<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20191228122017.1"><vh>@settings</vh>
<v t="leo.20191228122017.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20191228122017.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo.20191228122123.1"><vh>compile solvespace with msys2</vh></v>
<v t="leo.20191228122134.1"><vh>compile CDemo.c with msys2</vh></v>
<v t="leo.20191228122148.1"><vh>importer for cython directory</vh></v>
<v t="leo.20191228122441.1"><vh>imported files</vh>
<v t="leo.20191228122441.2"><vh>@path ./cython</vh>
<v t="leo.20191228122441.3"><vh>@clean setup.py</vh>
<v t="leo.20191228122441.4"><vh>Declarations</vh></v>
<v t="leo.20191228122441.5"><vh>write</vh></v>
<v t="leo.20191228122441.6"><vh>read</vh></v>
<v t="leo.20191228122441.7"><vh>find_version</vh></v>
<v t="leo.20191228122441.8"><vh>copy_source</vh></v>
<v t="leo.20191228122441.9"><vh>class Build(build_ext)</vh>
<v t="leo.20191228122441.10"><vh>Build.build_extensions</vh></v>
<v t="leo.20191228122441.11"><vh>Build.run</vh></v>
</v>
<v t="leo.20191228122441.12"><vh>class PackSource(sdist)</vh>
<v t="leo.20191228122441.13"><vh>PackSource.run</vh></v>
</v>
</v>
<v t="leo.20191228122441.14"><vh>@path build</vh>
<v t="leo.20191228122441.15"><vh>@path lib.win-amd64-3.8</vh>
<v t="leo.20191228122441.16"><vh>@path python_solvespace</vh>
<v t="leo.20191228122441.17"><vh>@clean slvs.pxd</vh></v>
<v t="leo.20191228122441.18"><vh>@clean slvs.pyi</vh>
<v t="leo.20191228122441.19"><vh>Declarations (slvs.pyi)</vh></v>
<v t="leo.20191228122441.20"><vh>quaternion_u (slvs.pyi)</vh></v>
<v t="leo.20191228122441.21"><vh>quaternion_v (slvs.pyi)</vh></v>
<v t="leo.20191228122441.22"><vh>quaternion_n (slvs.pyi)</vh></v>
<v t="leo.20191228122441.23"><vh>make_quaternion (slvs.pyi)</vh></v>
<v t="leo.20191228122441.24"><vh>class Params</vh>
<v t="leo.20191228122441.25"><vh>Params.__repr__</vh></v>
</v>
<v t="leo.20191228122441.26"><vh>class Entity</vh>
<v t="leo.20191228122441.27"><vh>Entity.is_3d</vh></v>
<v t="leo.20191228122441.28"><vh>Entity.is_none</vh></v>
<v t="leo.20191228122441.29"><vh>Entity.is_point_2d</vh></v>
<v t="leo.20191228122441.30"><vh>Entity.is_point_3d</vh></v>
<v t="leo.20191228122441.31"><vh>Entity.is_point</vh></v>
<v t="leo.20191228122441.32"><vh>Entity.is_normal_2d</vh></v>
<v t="leo.20191228122441.33"><vh>Entity.is_normal_3d</vh></v>
<v t="leo.20191228122441.34"><vh>Entity.is_normal</vh></v>
<v t="leo.20191228122441.35"><vh>Entity.is_distance</vh></v>
<v t="leo.20191228122441.36"><vh>Entity.is_work_plane</vh></v>
<v t="leo.20191228122441.37"><vh>Entity.is_line_2d</vh></v>
<v t="leo.20191228122441.38"><vh>Entity.is_line_3d</vh></v>
<v t="leo.20191228122441.39"><vh>Entity.is_line</vh></v>
<v t="leo.20191228122441.40"><vh>Entity.is_cubic</vh></v>
<v t="leo.20191228122441.41"><vh>Entity.is_circle</vh></v>
<v t="leo.20191228122441.42"><vh>Entity.is_arc</vh></v>
<v t="leo.20191228122441.43"><vh>Entity.__repr__</vh></v>
</v>
<v t="leo.20191228122441.44"><vh>class SolverSystem</vh>
<v t="leo.20191228122441.45"><vh>SolverSystem.__init__</vh></v>
<v t="leo.20191228122441.46"><vh>SolverSystem.clear</vh></v>
<v t="leo.20191228122441.47"><vh>SolverSystem.set_group</vh></v>
<v t="leo.20191228122441.48"><vh>SolverSystem.group</vh></v>
<v t="leo.20191228122441.49"><vh>SolverSystem.set_params</vh></v>
<v t="leo.20191228122441.50"><vh>SolverSystem.params</vh></v>
<v t="leo.20191228122441.51"><vh>SolverSystem.dof</vh></v>
<v t="leo.20191228122441.52"><vh>SolverSystem.constraints</vh></v>
<v t="leo.20191228122441.53"><vh>SolverSystem.faileds</vh></v>
<v t="leo.20191228122441.54"><vh>SolverSystem.solve</vh></v>
<v t="leo.20191228122441.55"><vh>SolverSystem.create_2d_base</vh></v>
<v t="leo.20191228122441.56"><vh>SolverSystem.add_point_2d</vh></v>
<v t="leo.20191228122441.57"><vh>SolverSystem.add_point_3d</vh></v>
<v t="leo.20191228122441.58"><vh>SolverSystem.add_normal_2d</vh></v>
<v t="leo.20191228122441.59"><vh>SolverSystem.add_normal_3d</vh></v>
<v t="leo.20191228122441.60"><vh>SolverSystem.add_distance</vh></v>
<v t="leo.20191228122441.61"><vh>SolverSystem.add_line_2d</vh></v>
<v t="leo.20191228122441.62"><vh>SolverSystem.add_line_3d</vh></v>
<v t="leo.20191228122441.63"><vh>SolverSystem.add_cubic</vh></v>
<v t="leo.20191228122441.64"><vh>SolverSystem.add_arc</vh></v>
<v t="leo.20191228122441.65"><vh>SolverSystem.add_circle</vh></v>
<v t="leo.20191228122441.66"><vh>SolverSystem.add_work_plane</vh></v>
<v t="leo.20191228122441.67"><vh>SolverSystem.add_constraint</vh></v>
<v t="leo.20191228122441.68"><vh>SolverSystem.coincident</vh></v>
<v t="leo.20191228122441.69"><vh>SolverSystem.distance</vh></v>
<v t="leo.20191228122441.70"><vh>SolverSystem.equal</vh></v>
<v t="leo.20191228122441.71"><vh>SolverSystem.equal_included_angle</vh></v>
<v t="leo.20191228122441.72"><vh>SolverSystem.equal_point_to_line</vh></v>
<v t="leo.20191228122441.73"><vh>SolverSystem.ratio</vh></v>
<v t="leo.20191228122441.74"><vh>SolverSystem.symmetric</vh></v>
<v t="leo.20191228122441.75"><vh>SolverSystem.symmetric_h</vh></v>
<v t="leo.20191228122441.76"><vh>SolverSystem.symmetric_v</vh></v>
<v t="leo.20191228122441.77"><vh>SolverSystem.midpoint</vh></v>
<v t="leo.20191228122441.78"><vh>SolverSystem.horizontal</vh></v>
<v t="leo.20191228122441.79"><vh>SolverSystem.vertical</vh></v>
<v t="leo.20191228122441.80"><vh>SolverSystem.diameter</vh></v>
<v t="leo.20191228122441.81"><vh>SolverSystem.same_orientation</vh></v>
<v t="leo.20191228122441.82"><vh>SolverSystem.angle</vh></v>
<v t="leo.20191228122441.83"><vh>SolverSystem.perpendicular</vh></v>
<v t="leo.20191228122441.84"><vh>SolverSystem.parallel</vh></v>
<v t="leo.20191228122441.85"><vh>SolverSystem.tangent</vh></v>
<v t="leo.20191228122441.86"><vh>SolverSystem.distance_proj</vh></v>
<v t="leo.20191228122441.87"><vh>SolverSystem.dragged</vh></v>
</v>
</v>
<v t="leo.20191228122441.88"><vh>@clean __init__.pxd</vh></v>
<v t="leo.20191228122441.89"><vh>@clean __init__.py</vh>
<v t="leo.20191228122441.90"><vh>Declarations</vh></v>
<v t="leo.20191228122441.91"><vh>class Constraint(IntEnum)</vh></v>
<v t="leo.20191228122441.92"><vh>class ResultFlag(IntEnum)</vh></v>
</v>
</v>
</v>
<v t="leo.20191228122441.93"><vh>@path temp.win-amd64-3.8</vh>
<v t="leo.20191228122441.94"><vh>@path Release</vh>
<v t="leo.20191228122441.95"><vh>@path python_solvespace</vh>
<v t="leo.20191228122441.96"><vh>@path src</vh></v>
</v>
</v>
</v>
</v>
<v t="leo.20191228122441.98"><vh>@path platform</vh>
<v t="leo.20191228122441.99"><vh>@clean cygwinccompiler.diff</vh></v>
<v t="leo.20191228122441.100"><vh>@clean pyconfig.diff</vh></v>
<v t="leo.20191228122442.1"><vh>@clean set_pycompiler.bat</vh></v>
</v>
<v t="leo.20191228122442.2"><vh>@path python_solvespace</vh>
<v t="leo.20191228122442.3"><vh>@clean slvs.pxd</vh></v>
<v t="leo.20191228122442.4"><vh>@clean slvs.pyi</vh>
<v t="leo.20191228122442.5"><vh>Declarations (slvs.pyi)</vh></v>
<v t="leo.20191228122442.6"><vh>quaternion_u (slvs.pyi)</vh></v>
<v t="leo.20191228122442.7"><vh>quaternion_v (slvs.pyi)</vh></v>
<v t="leo.20191228122442.8"><vh>quaternion_n (slvs.pyi)</vh></v>
<v t="leo.20191228122442.9"><vh>make_quaternion (slvs.pyi)</vh></v>
<v t="leo.20191228122442.10"><vh>class Params</vh>
<v t="leo.20191228122442.11"><vh>Params.__repr__</vh></v>
</v>
<v t="leo.20191228122442.12"><vh>class Entity</vh>
<v t="leo.20191228122442.13"><vh>Entity.is_3d</vh></v>
<v t="leo.20191228122442.14"><vh>Entity.is_none</vh></v>
<v t="leo.20191228122442.15"><vh>Entity.is_point_2d</vh></v>
<v t="leo.20191228122442.16"><vh>Entity.is_point_3d</vh></v>
<v t="leo.20191228122442.17"><vh>Entity.is_point</vh></v>
<v t="leo.20191228122442.18"><vh>Entity.is_normal_2d</vh></v>
<v t="leo.20191228122442.19"><vh>Entity.is_normal_3d</vh></v>
<v t="leo.20191228122442.20"><vh>Entity.is_normal</vh></v>
<v t="leo.20191228122442.21"><vh>Entity.is_distance</vh></v>
<v t="leo.20191228122442.22"><vh>Entity.is_work_plane</vh></v>
<v t="leo.20191228122442.23"><vh>Entity.is_line_2d</vh></v>
<v t="leo.20191228122442.24"><vh>Entity.is_line_3d</vh></v>
<v t="leo.20191228122442.25"><vh>Entity.is_line</vh></v>
<v t="leo.20191228122442.26"><vh>Entity.is_cubic</vh></v>
<v t="leo.20191228122442.27"><vh>Entity.is_circle</vh></v>
<v t="leo.20191228122442.28"><vh>Entity.is_arc</vh></v>
<v t="leo.20191228122442.29"><vh>Entity.__repr__</vh></v>
</v>
<v t="leo.20191228122442.30"><vh>class SolverSystem</vh>
<v t="leo.20191228122442.31"><vh>SolverSystem.__init__</vh></v>
<v t="leo.20191228122442.32"><vh>SolverSystem.clear</vh></v>
<v t="leo.20191228122442.33"><vh>SolverSystem.set_group</vh></v>
<v t="leo.20191228122442.34"><vh>SolverSystem.group</vh></v>
<v t="leo.20191228122442.35"><vh>SolverSystem.set_params</vh></v>
<v t="leo.20191228122442.36"><vh>SolverSystem.params</vh></v>
<v t="leo.20191228122442.37"><vh>SolverSystem.dof</vh></v>
<v t="leo.20191228122442.38"><vh>SolverSystem.constraints</vh></v>
<v t="leo.20191228122442.39"><vh>SolverSystem.faileds</vh></v>
<v t="leo.20191228122442.40"><vh>SolverSystem.solve</vh></v>
<v t="leo.20191228122442.41"><vh>SolverSystem.create_2d_base</vh></v>
<v t="leo.20191228122442.42"><vh>SolverSystem.add_point_2d</vh></v>
<v t="leo.20191228122442.43"><vh>SolverSystem.add_point_3d</vh></v>
<v t="leo.20191228122442.44"><vh>SolverSystem.add_normal_2d</vh></v>
<v t="leo.20191228122442.45"><vh>SolverSystem.add_normal_3d</vh></v>
<v t="leo.20191228122442.46"><vh>SolverSystem.add_distance</vh></v>
<v t="leo.20191228122442.47"><vh>SolverSystem.add_line_2d</vh></v>
<v t="leo.20191228122442.48"><vh>SolverSystem.add_line_3d</vh></v>
<v t="leo.20191228122442.49"><vh>SolverSystem.add_cubic</vh></v>
<v t="leo.20191228122442.50"><vh>SolverSystem.add_arc</vh></v>
<v t="leo.20191228122442.51"><vh>SolverSystem.add_circle</vh></v>
<v t="leo.20191228122442.52"><vh>SolverSystem.add_work_plane</vh></v>
<v t="leo.20191228122442.53"><vh>SolverSystem.add_constraint</vh></v>
<v t="leo.20191228122442.54"><vh>SolverSystem.coincident</vh></v>
<v t="leo.20191228122442.55"><vh>SolverSystem.distance</vh></v>
<v t="leo.20191228122442.56"><vh>SolverSystem.equal</vh></v>
<v t="leo.20191228122442.57"><vh>SolverSystem.equal_included_angle</vh></v>
<v t="leo.20191228122442.58"><vh>SolverSystem.equal_point_to_line</vh></v>
<v t="leo.20191228122442.59"><vh>SolverSystem.ratio</vh></v>
<v t="leo.20191228122442.60"><vh>SolverSystem.symmetric</vh></v>
<v t="leo.20191228122442.61"><vh>SolverSystem.symmetric_h</vh></v>
<v t="leo.20191228122442.62"><vh>SolverSystem.symmetric_v</vh></v>
<v t="leo.20191228122442.63"><vh>SolverSystem.midpoint</vh></v>
<v t="leo.20191228122442.64"><vh>SolverSystem.horizontal</vh></v>
<v t="leo.20191228122442.65"><vh>SolverSystem.vertical</vh></v>
<v t="leo.20191228122442.66"><vh>SolverSystem.diameter</vh></v>
<v t="leo.20191228122442.67"><vh>SolverSystem.same_orientation</vh></v>
<v t="leo.20191228122442.68"><vh>SolverSystem.angle</vh></v>
<v t="leo.20191228122442.69"><vh>SolverSystem.perpendicular</vh></v>
<v t="leo.20191228122442.70"><vh>SolverSystem.parallel</vh></v>
<v t="leo.20191228122442.71"><vh>SolverSystem.tangent</vh></v>
<v t="leo.20191228122442.72"><vh>SolverSystem.distance_proj</vh></v>
<v t="leo.20191228122442.73"><vh>SolverSystem.dragged</vh></v>
</v>
</v>
<v t="leo.20191228122442.74"><vh>@clean slvs.pyx</vh></v>
<v t="leo.20191228122442.75"><vh>@clean __init__.pxd</vh></v>
<v t="leo.20191228122442.76"><vh>@clean __init__.py</vh>
<v t="leo.20191228122442.77"><vh>Declarations</vh></v>
<v t="leo.20191228122442.78"><vh>class Constraint(IntEnum)</vh></v>
<v t="leo.20191228122442.79"><vh>class ResultFlag(IntEnum)</vh></v>
</v>
<v t="leo.20191228122442.81"><vh>@path src</vh></v>
</v>
<v t="leo.20191228122442.85"><vh>@path tests</vh>
<v t="leo.20191228122442.86"><vh>@clean __init__.py</vh></v>
<v t="leo.20191228122442.87"><vh>@clean __main__.py</vh>
<v t="leo.20191228122442.88"><vh>Declarations</vh></v>
<v t="leo.20191228122442.89"><vh>class CoreTest(TestCase)</vh>
<v t="leo.20191228122442.90"><vh>CoreTest.test_crank_rocker</vh></v>
<v t="leo.20191228122442.91"><vh>CoreTest.test_involute</vh></v>
<v t="leo.20191228122442.92"><vh>CoreTest.test_jansen_linkage</vh></v>
<v t="leo.20191228122442.93"><vh>CoreTest.test_nut_cracker</vh></v>
<v t="leo.20191228122442.94"><vh>CoreTest.test_pydemo</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="leo.20191228122504.1"><vh>importer for ./src directory</vh></v>
<v t="leo.20191228122642.1"><vh>imported files</vh>
<v t="leo.20191228122642.2"><vh>@path ./src</vh>
<v t="leo.20191228122642.3"><vh>@clean bsp.cpp</vh>
<v t="leo.20191228122642.4"><vh>void SBsp3::InsertInPlane (bsp.cpp)</vh></v>
<v t="leo.20191228122642.5"><vh>void SBsp3::InsertHow (bsp.cpp)</vh></v>
<v t="leo.20191228122642.6"><vh>class BspUtil</vh>
<v t="leo.20191228122642.7"><vh>BspUtil.static BspUtil</vh></v>
<v t="leo.20191228122642.8"><vh>BspUtil.void AllocOn</vh></v>
<v t="leo.20191228122642.9"><vh>BspUtil.void AllocTriangle</vh></v>
<v t="leo.20191228122642.10"><vh>BspUtil.void AllocTriangles</vh></v>
<v t="leo.20191228122642.11"><vh>BspUtil.void AllocQuad</vh></v>
<v t="leo.20191228122642.12"><vh>BspUtil.void AllocClassify</vh></v>
<v t="leo.20191228122642.13"><vh>BspUtil.void AllocVertices</vh></v>
<v t="leo.20191228122642.14"><vh>BspUtil.void ClassifyTriangle</vh></v>
<v t="leo.20191228122642.15"><vh>BspUtil.bool ClassifyConvex</vh></v>
<v t="leo.20191228122642.16"><vh>BspUtil.bool ClassifyConvexVertices</vh></v>
<v t="leo.20191228122642.17"><vh>BspUtil.void ProcessEdgeInsert</vh></v>
<v t="leo.20191228122642.18"><vh>BspUtil.bool SplitIntoTwoTriangles</vh></v>
<v t="leo.20191228122642.19"><vh>BspUtil.bool SplitIntoTwoPieces</vh></v>
<v t="leo.20191228122642.20"><vh>BspUtil.static SBsp3</vh></v>
</v>
<v t="leo.20191228122642.21"><vh>void SBsp3::InsertConvexHow (bsp.cpp)</vh></v>
<v t="leo.20191228122642.22"><vh>void SBsp3::Insert (bsp.cpp)</vh></v>
<v t="leo.20191228122642.23"><vh>void SBsp3::GenerateInPaintOrder (bsp.cpp)</vh></v>
<v t="leo.20191228122642.24"><vh>void SBsp2::InsertEdge (bsp.cpp)</vh></v>
<v t="leo.20191228122642.25"><vh>void SBsp2::InsertTriangleHow (bsp.cpp)</vh></v>
<v t="leo.20191228122642.26"><vh>void SBsp2::InsertTriangle (bsp.cpp)</vh></v>
</v>
<v t="leo.20191228122642.27"><vh>@clean clipboard.cpp</vh>
<v t="leo.20191228122642.28"><vh>void SolveSpaceUI::Clipboard::Clear (clipboard.cpp)</vh></v>
<v t="leo.20191228122642.29"><vh>bool SolveSpaceUI::Clipboard::ContainsEntity (clipboard.cpp)</vh></v>
<v t="leo.20191228122642.30"><vh>void GraphicsWindow::DeleteSelection (clipboard.cpp)</vh></v>
<v t="leo.20191228122642.31"><vh>void GraphicsWindow::CopySelection (clipboard.cpp)</vh></v>
<v t="leo.20191228122642.32"><vh>void GraphicsWindow::PasteClipboard (clipboard.cpp)</vh>
<v t="leo.20191228122642.33"><vh>auto mapPoint (clipboard.cpp)</vh></v>
</v>
<v t="leo.20191228122642.34"><vh>void GraphicsWindow::MenuClipboard (clipboard.cpp)</vh></v>
<v t="leo.20191228122642.35"><vh>bool TextWindow::EditControlDoneForPaste (clipboard.cpp)</vh></v>
<v t="leo.20191228122642.36"><vh>void TextWindow::ScreenChangePasteTransformed (clipboard.cpp)</vh></v>
<v t="leo.20191228122642.37"><vh>void TextWindow::ScreenPasteTransformed (clipboard.cpp)</vh></v>
<v t="leo.20191228122642.38"><vh>void TextWindow::ShowPasteTransformed (clipboard.cpp)</vh></v>
</v>
<v t="leo.20191228122642.39"><vh>@clean confscreen.cpp</vh>
<v t="leo.20191228122642.40"><vh>void TextWindow::ScreenChangeLightDirection (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.41"><vh>void TextWindow::ScreenChangeLightIntensity (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.42"><vh>void TextWindow::ScreenChangeColor (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.43"><vh>void TextWindow::ScreenChangeChordTolerance (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.44"><vh>void TextWindow::ScreenChangeMaxSegments (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.45"><vh>void TextWindow::ScreenChangeExportChordTolerance (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.46"><vh>void TextWindow::ScreenChangeExportMaxSegments (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.47"><vh>void TextWindow::ScreenChangeCameraTangent (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.48"><vh>void TextWindow::ScreenChangeGridSpacing (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.49"><vh>void TextWindow::ScreenChangeDigitsAfterDecimal (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.50"><vh>void TextWindow::ScreenChangeDigitsAfterDecimalDegree (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.51"><vh>void TextWindow::ScreenChangeUseSIPrefixes (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.52"><vh>void TextWindow::ScreenChangeExportScale (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.53"><vh>void TextWindow::ScreenChangeExportOffset (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.54"><vh>void TextWindow::ScreenChangeFixExportColors (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.55"><vh>void TextWindow::ScreenChangeBackFaces (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.56"><vh>void TextWindow::ScreenChangeTurntableNav (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.57"><vh>void TextWindow::ScreenChangeImmediatelyEditDimension (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.58"><vh>void TextWindow::ScreenChangeShowContourAreas (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.59"><vh>void TextWindow::ScreenChangeCheckClosedContour (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.60"><vh>void TextWindow::ScreenChangeAutomaticLineConstraints (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.61"><vh>void TextWindow::ScreenChangeShadedTriangles (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.62"><vh>void TextWindow::ScreenChangePwlCurves (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.63"><vh>void TextWindow::ScreenChangeCanvasSizeAuto (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.64"><vh>void TextWindow::ScreenChangeCanvasSize (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.65"><vh>void TextWindow::ScreenChangeGCodeParameter (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.66"><vh>void TextWindow::ScreenChangeAutosaveInterval (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.67"><vh>void TextWindow::ShowConfiguration (confscreen.cpp)</vh></v>
<v t="leo.20191228122642.68"><vh>bool TextWindow::EditControlDoneForConfiguration (confscreen.cpp)</vh></v>
</v>
<v t="leo.20191228122642.69"><vh>@clean constraint.cpp</vh>
<v t="leo.20191228122642.70"><vh>void Constraint::DeleteAllConstraintsFor (constraint.cpp)</vh></v>
<v t="leo.20191228122642.71"><vh>bool other (constraint.cpp)</vh></v>
<v t="leo.20191228122642.72"><vh>bool other (constraint.cpp)</vh></v>
<v t="leo.20191228122642.73"><vh>void Constraint::MenuConstrain (constraint.cpp)</vh>
<v t="leo.20191228122642.74"><vh>const raint (constraint.cpp)</vh></v>
</v>
</v>
<v t="leo.20191228122642.75"><vh>@clean constrainteq.cpp</vh>
<v t="leo.20191228122642.76"><vh>bool ConstraintBase::HasLabel (constrainteq.cpp)</vh></v>
<v t="leo.20191228122642.77"><vh>void ConstraintBase::ModifyToSatisfy (constrainteq.cpp)</vh></v>
<v t="leo.20191228122642.78"><vh>void ConstraintBase::AddEq (constrainteq.cpp)</vh></v>
<v t="leo.20191228122642.79"><vh>void ConstraintBase::AddEq (constrainteq.cpp)</vh></v>
<v t="leo.20191228122642.80"><vh>void ConstraintBase::Generate (constrainteq.cpp)</vh></v>
<v t="leo.20191228122642.81"><vh>void ConstraintBase::GenerateEquations (constrainteq.cpp)</vh></v>
</v>
<v t="leo.20191228122642.82"><vh>@clean describescreen.cpp</vh>
<v t="leo.20191228122642.83"><vh>void TextWindow::ScreenUnselectAll (describescreen.cpp)</vh></v>
<v t="leo.20191228122643.1"><vh>void TextWindow::ScreenEditTtfText (describescreen.cpp)</vh></v>
<v t="leo.20191228122643.2"><vh>void TextWindow::ScreenSetTtfFont (describescreen.cpp)</vh></v>
<v t="leo.20191228122643.3"><vh>void TextWindow::ScreenConstraintShowAsRadius (describescreen.cpp)</vh></v>
<v t="leo.20191228122643.4"><vh>void TextWindow::DescribeSelection (describescreen.cpp)</vh>
<v t="leo.20191228122643.5"><vh>auto it (describescreen.cpp)</vh></v>
</v>
<v t="leo.20191228122643.6"><vh>void TextWindow::GoToScreen (describescreen.cpp)</vh></v>
</v>
<v t="leo.20191228122643.7"><vh>@clean draw.cpp</vh>
<v t="leo.20191228122643.8"><vh>bool GraphicsWindow::Selection::Equals (draw.cpp)</vh></v>
<v t="leo.20191228122643.9"><vh>bool GraphicsWindow::Selection::IsEmpty (draw.cpp)</vh></v>
<v t="leo.20191228122643.10"><vh>bool GraphicsWindow::Selection::HasEndpoints (draw.cpp)</vh></v>
<v t="leo.20191228122643.11"><vh>void GraphicsWindow::Selection::Clear (draw.cpp)</vh></v>
<v t="leo.20191228122643.12"><vh>void GraphicsWindow::Selection::Draw (draw.cpp)</vh>
<v t="leo.20191228122643.13"><vh>auto it (draw.cpp)</vh></v>
</v>
<v t="leo.20191228122643.14"><vh>void GraphicsWindow::ClearSelection (draw.cpp)</vh></v>
<v t="leo.20191228122643.15"><vh>void GraphicsWindow::ClearNonexistentSelectionItems (draw.cpp)</vh></v>
<v t="leo.20191228122643.16"><vh>bool GraphicsWindow::IsSelected (draw.cpp)</vh></v>
<v t="leo.20191228122643.17"><vh>bool GraphicsWindow::IsSelected (draw.cpp)</vh></v>
<v t="leo.20191228122643.18"><vh>void GraphicsWindow::MakeUnselected (draw.cpp)</vh></v>
<v t="leo.20191228122643.19"><vh>void GraphicsWindow::MakeUnselected (draw.cpp)</vh></v>
<v t="leo.20191228122643.20"><vh>void GraphicsWindow::MakeSelected (draw.cpp)</vh></v>
<v t="leo.20191228122643.21"><vh>void GraphicsWindow::MakeSelected (draw.cpp)</vh></v>
<v t="leo.20191228122643.22"><vh>void GraphicsWindow::MakeSelected (draw.cpp)</vh></v>
<v t="leo.20191228122643.23"><vh>void GraphicsWindow::SelectByMarquee (draw.cpp)</vh></v>
<v t="leo.20191228122643.24"><vh>void GraphicsWindow::GroupSelection (draw.cpp)</vh></v>
<v t="leo.20191228122643.25"><vh>void GraphicsWindow::HitTestMakeSelection (draw.cpp)</vh></v>
<v t="leo.20191228122643.26"><vh>void GraphicsWindow::NormalizeProjectionVectors (draw.cpp)</vh></v>
<v t="leo.20191228122643.27"><vh>void GraphicsWindow::DrawSnapGrid (draw.cpp)</vh>
<v t="leo.20191228122643.28"><vh>double umin (draw.cpp)</vh></v>
</v>
<v t="leo.20191228122643.29"><vh>void GraphicsWindow::DrawEntities (draw.cpp)</vh></v>
<v t="leo.20191228122643.30"><vh>void GraphicsWindow::DrawPersistent (draw.cpp)</vh></v>
<v t="leo.20191228122643.31"><vh>void GraphicsWindow::Draw (draw.cpp)</vh></v>
<v t="leo.20191228122643.32"><vh>void GraphicsWindow::Paint (draw.cpp)</vh></v>
<v t="leo.20191228122643.33"><vh>void GraphicsWindow::Invalidate (draw.cpp)</vh></v>
</v>
<v t="leo.20191228122643.34"><vh>@clean drawconstraint.cpp</vh>
<v t="leo.20191228122643.35"><vh>void Constraint::DoLine (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.36"><vh>void Constraint::DoStippledLine (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.37"><vh>void Constraint::DoLabel (drawconstraint.cpp)</vh>
<v t="leo.20191228122643.38"><vh>double swidth (drawconstraint.cpp)</vh></v>
</v>
<v t="leo.20191228122643.39"><vh>void Constraint::DoProjectedPoint (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.40"><vh>void Constraint::DoProjectedPoint (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.41"><vh>int Constraint::DoLineTrimmedAgainstBox (drawconstraint.cpp)</vh>
<v t="leo.20191228122643.42"><vh>double swidth (drawconstraint.cpp)</vh></v>
</v>
<v t="leo.20191228122643.43"><vh>void Constraint::DoArrow (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.44"><vh>void Constraint::DoLineWithArrows (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.45"><vh>void Constraint::DoEqualLenTicks (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.46"><vh>void Constraint::DoEqualRadiusTicks (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.47"><vh>void Constraint::DoArcForAngle (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.48"><vh>bool Constraint::IsVisible (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.49"><vh>bool Constraint::DoLineExtend (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.50"><vh>void Constraint::DoLayout (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.51"><vh>void Constraint::Draw (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.52"><vh>void Constraint::GetReferencePoints (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.53"><vh>bool Constraint::IsStylable (drawconstraint.cpp)</vh></v>
<v t="leo.20191228122643.54"><vh>bool Constraint::HasLabel (drawconstraint.cpp)</vh></v>
</v>
<v t="leo.20191228122643.55"><vh>@clean drawentity.cpp</vh>
<v t="leo.20191228122643.56"><vh>void Entity::GenerateEdges (drawentity.cpp)</vh></v>
<v t="leo.20191228122643.57"><vh>void Entity::GetReferencePoints (drawentity.cpp)</vh></v>
<v t="leo.20191228122643.58"><vh>int Entity::GetPositionOfPoint (drawentity.cpp)</vh></v>
<v t="leo.20191228122643.59"><vh>bool Entity::IsStylable (drawentity.cpp)</vh></v>
<v t="leo.20191228122643.60"><vh>bool Entity::IsVisible (drawentity.cpp)</vh></v>
<v t="leo.20191228122643.61"><vh>void Entity::CalculateNumerical (drawentity.cpp)</vh></v>
<v t="leo.20191228122643.62"><vh>void Entity::ComputeInterpolatingSpline (drawentity.cpp)</vh></v>
<v t="leo.20191228122643.63"><vh>void Entity::GenerateBezierCurves (drawentity.cpp)</vh></v>
<v t="leo.20191228122643.64"><vh>void Entity::Draw (drawentity.cpp)</vh></v>
</v>
<v t="leo.20191228122643.65"><vh>@clean dsc.h</vh>
<v t="leo.20191228122643.66"><vh>static inline (dsc.h)</vh></v>
<v t="leo.20191228122643.67"><vh>static inline (dsc.h)</vh></v>
<v t="leo.20191228122643.68"><vh>static inline (dsc.h)</vh></v>
<v t="leo.20191228122643.69"><vh>class Quaternion</vh></v>
<v t="leo.20191228122643.70"><vh>class Vector</vh></v>
<v t="leo.20191228122643.71"><vh>class Vector4</vh></v>
<v t="leo.20191228122643.72"><vh>class Point2d</vh></v>
<v t="leo.20191228122643.73"><vh>class List</vh>
<v t="leo.20191228122643.74"><vh>List.void ReserveMore</vh></v>
<v t="leo.20191228122643.75"><vh>List.void AllocForOneMore</vh></v>
<v t="leo.20191228122643.76"><vh>List.void Add</vh></v>
<v t="leo.20191228122643.77"><vh>List.void AddToBeginning</vh></v>
<v t="leo.20191228122643.78"><vh>List.const T</vh></v>
<v t="leo.20191228122643.79"><vh>List.const T</vh></v>
<v t="leo.20191228122643.80"><vh>List.void ClearTags</vh></v>
<v t="leo.20191228122643.81"><vh>List.void Clear</vh></v>
<v t="leo.20191228122643.82"><vh>List.void RemoveTagged</vh>
<v t="leo.20191228122643.83"><vh>List.auto newEnd</vh></v>
</v>
<v t="leo.20191228122643.84"><vh>List.void RemoveLast</vh></v>
<v t="leo.20191228122643.85"><vh>List.void Reverse</vh></v>
</v>
<v t="leo.20191228122643.86"><vh>bool operator (dsc.h)</vh></v>
<v t="leo.20191228122643.87"><vh>bool operator (dsc.h)</vh></v>
<v t="leo.20191228122643.88"><vh>class IdList</vh>
<v t="leo.20191228122643.89"><vh>IdList.bool IsEmpty</vh></v>
<v t="leo.20191228122643.90"><vh>IdList.void AllocForOneMore</vh></v>
<v t="leo.20191228122643.91"><vh>IdList.int LowerBoundIndex</vh></v>
<v t="leo.20191228122643.92"><vh>IdList.void ReserveMore</vh></v>
<v t="leo.20191228122643.93"><vh>IdList.void Add</vh></v>
<v t="leo.20191228122643.94"><vh>IdList.int IndexOf</vh></v>
<v t="leo.20191228122643.95"><vh>IdList.void ClearTags</vh></v>
<v t="leo.20191228122643.96"><vh>IdList.void Tag</vh></v>
<v t="leo.20191228122643.97"><vh>IdList.void RemoveTagged</vh></v>
<v t="leo.20191228122643.98"><vh>IdList.void RemoveById</vh></v>
<v t="leo.20191228122643.99"><vh>IdList.void MoveSelfInto</vh></v>
<v t="leo.20191228122643.100"><vh>IdList.void DeepCopyInto</vh></v>
<v t="leo.20191228122643.101"><vh>IdList.void Clear</vh></v>
</v>
<v t="leo.20191228122643.102"><vh>class BandedMatrix</vh></v>
<v t="leo.20191228122643.103"><vh>class RgbaColor</vh>
<v t="leo.20191228122643.104"><vh>RgbaColor.bool Equals</vh></v>
<v t="leo.20191228122643.105"><vh>RgbaColor.static RgbaColor</vh></v>
<v t="leo.20191228122643.106"><vh>RgbaColor.static RgbaColor</vh></v>
<v t="leo.20191228122643.107"><vh>RgbaColor.static RgbaColor</vh></v>
<v t="leo.20191228122643.108"><vh>RgbaColor.static RgbaColor</vh></v>
</v>
<v t="leo.20191228122643.109"><vh>bool operator (dsc.h)</vh></v>
<v t="leo.20191228122643.110"><vh>class BBox</vh></v>
</v>
<v t="leo.20191228122643.111"><vh>@clean entity.cpp</vh>
<v t="leo.20191228122643.112"><vh>bool EntityBase::HasVector (entity.cpp)</vh></v>
<v t="leo.20191228122643.113"><vh>bool EntityBase::IsCircle (entity.cpp)</vh></v>
<v t="leo.20191228122643.114"><vh>void EntityBase::ArcGetAngles (entity.cpp)</vh></v>
<v t="leo.20191228122643.115"><vh>bool EntityBase::IsWorkplane (entity.cpp)</vh></v>
<v t="leo.20191228122643.116"><vh>void EntityBase::WorkplaneGetPlaneExprs (entity.cpp)</vh></v>
<v t="leo.20191228122643.117"><vh>bool EntityBase::IsDistance (entity.cpp)</vh></v>
<v t="leo.20191228122643.118"><vh>void EntityBase::DistanceForceTo (entity.cpp)</vh></v>
<v t="leo.20191228122643.119"><vh>bool EntityBase::IsPoint (entity.cpp)</vh></v>
<v t="leo.20191228122643.120"><vh>bool EntityBase::IsNormal (entity.cpp)</vh></v>
<v t="leo.20191228122643.121"><vh>void EntityBase::NormalForceTo (entity.cpp)</vh></v>
<v t="leo.20191228122643.122"><vh>void EntityBase::PointForceParamTo (entity.cpp)</vh></v>
<v t="leo.20191228122643.123"><vh>void EntityBase::PointForceTo (entity.cpp)</vh></v>
<v t="leo.20191228122643.124"><vh>void EntityBase::PointGetExprsInWorkplane (entity.cpp)</vh></v>
<v t="leo.20191228122643.125"><vh>void EntityBase::PointForceQuaternionTo (entity.cpp)</vh></v>
<v t="leo.20191228122643.126"><vh>bool EntityBase::IsFace (entity.cpp)</vh></v>
<v t="leo.20191228122643.127"><vh>bool EntityBase::HasEndpoints (entity.cpp)</vh></v>
<v t="leo.20191228122643.128"><vh>bool PointInPlane (entity.cpp)</vh></v>
<v t="leo.20191228122643.129"><vh>bool EntityBase::IsInPlane (entity.cpp)</vh></v>
<v t="leo.20191228122643.130"><vh>void EntityBase::RectGetPointsExprs (entity.cpp)</vh></v>
<v t="leo.20191228122643.131"><vh>void EntityBase::AddEq (entity.cpp)</vh></v>
<v t="leo.20191228122643.132"><vh>void EntityBase::GenerateEquations (entity.cpp)</vh>
<v t="leo.20191228122643.133"><vh>auto it (entity.cpp)</vh></v>
</v>
</v>
<v t="leo.20191228122643.134"><vh>@clean export.cpp</vh>
<v t="leo.20191228122643.135"><vh>void SolveSpaceUI::ExportSectionTo (export.cpp)</vh></v>
<v t="leo.20191228122643.136"><vh>class GetEdgesCanvas</vh>
<v t="leo.20191228122643.137"><vh>GetEdgesCanvas.const Camera</vh></v>
<v t="leo.20191228122643.138"><vh>GetEdgesCanvas.void DrawLine</vh></v>
<v t="leo.20191228122643.139"><vh>GetEdgesCanvas.void DrawEdges</vh></v>
<v t="leo.20191228122643.140"><vh>GetEdgesCanvas.void DrawVectorText</vh></v>
<v t="leo.20191228122643.141"><vh>GetEdgesCanvas.void DrawQuad</vh></v>
<v t="leo.20191228122643.142"><vh>GetEdgesCanvas.bool DrawBeziers</vh></v>
<v t="leo.20191228122643.143"><vh>GetEdgesCanvas.void DrawOutlines</vh></v>
<v t="leo.20191228122643.144"><vh>GetEdgesCanvas.void DrawPoint</vh></v>
<v t="leo.20191228122643.145"><vh>GetEdgesCanvas.void DrawPolygon</vh></v>
<v t="leo.20191228122643.146"><vh>GetEdgesCanvas.void DrawMesh</vh></v>
<v t="leo.20191228122643.147"><vh>GetEdgesCanvas.void DrawFaces</vh></v>
<v t="leo.20191228122643.148"><vh>GetEdgesCanvas.void DrawPixmap</vh></v>
<v t="leo.20191228122643.149"><vh>GetEdgesCanvas.void InvalidatePixmap</vh></v>
</v>
<v t="leo.20191228122643.150"><vh>void SolveSpaceUI::ExportViewOrWireframeTo (export.cpp)</vh></v>
<v t="leo.20191228122643.151"><vh>void SolveSpaceUI::ExportWireframeCurves (export.cpp)</vh></v>
<v t="leo.20191228122643.152"><vh>void SolveSpaceUI::ExportLinesAndMesh (export.cpp)</vh></v>
<v t="leo.20191228122644.1"><vh>void VectorFileWriter::SetModelviewProjection (export.cpp)</vh></v>
<v t="leo.20191228122644.2"><vh>void VectorFileWriter::OutputLinesAndMesh (export.cpp)</vh></v>
<v t="leo.20191228122644.3"><vh>void VectorFileWriter::BezierAsPwl (export.cpp)</vh></v>
<v t="leo.20191228122644.4"><vh>void VectorFileWriter::BezierAsNonrationalCubic (export.cpp)</vh></v>
<v t="leo.20191228122644.5"><vh>void SolveSpaceUI::ExportMeshTo (export.cpp)</vh></v>
<v t="leo.20191228122644.6"><vh>void SolveSpaceUI::ExportMeshAsStlTo (export.cpp)</vh></v>
<v t="leo.20191228122644.7"><vh>void SolveSpaceUI::ExportMeshAsQ3doTo (export.cpp)</vh></v>
<v t="leo.20191228122644.8"><vh>void SolveSpaceUI::ExportMeshAsObjTo (export.cpp)</vh></v>
<v t="leo.20191228122644.9"><vh>void SolveSpaceUI::ExportMeshAsThreeJsTo (export.cpp)</vh></v>
<v t="leo.20191228122644.10"><vh>void SolveSpaceUI::ExportMeshAsVrmlTo (export.cpp)</vh>
<v t="leo.20191228122644.11"><vh>auto colour_itr (export.cpp)</vh></v>
</v>
<v t="leo.20191228122644.12"><vh>void SolveSpaceUI::ExportAsPngTo (export.cpp)</vh></v>
</v>
<v t="leo.20191228122644.13"><vh>@clean exportstep.cpp</vh>
<v t="leo.20191228122644.14"><vh>void StepFileWriter::WriteHeader (exportstep.cpp)</vh></v>
<v t="leo.20191228122644.15"><vh>void StepFileWriter::WriteFooter (exportstep.cpp)</vh></v>
<v t="leo.20191228122644.16"><vh>void StepFileWriter::ExportSurfacesTo (exportstep.cpp)</vh></v>
<v t="leo.20191228122644.17"><vh>void StepFileWriter::WriteWireframe (exportstep.cpp)</vh></v>
</v>
<v t="leo.20191228122644.18"><vh>@clean exportvector.cpp</vh>
<v t="leo.20191228122644.19"><vh>class DxfWriteInterface</vh>
<v t="leo.20191228122644.20"><vh>DxfWriteInterface.static DRW_Coord</vh></v>
<v t="leo.20191228122644.21"><vh>DxfWriteInterface.void writeTextstyles</vh></v>
<v t="leo.20191228122644.22"><vh>DxfWriteInterface.void writeLayers</vh></v>
<v t="leo.20191228122644.23"><vh>DxfWriteInterface.void writeLTypes</vh></v>
<v t="leo.20191228122644.24"><vh>DxfWriteInterface.void writePolylines</vh>
<v t="leo.20191228122644.25"><vh>DxfWriteInterface.auto startFunc</vh></v>
<v t="leo.20191228122644.26"><vh>DxfWriteInterface.auto nextFunc</vh></v>
<v t="leo.20191228122644.27"><vh>DxfWriteInterface.auto endFunc</vh></v>
<v t="leo.20191228122644.28"><vh>DxfWriteInterface.auto aloneFunc</vh></v>
</v>
<v t="leo.20191228122644.29"><vh>DxfWriteInterface.void writeEntities</vh></v>
<v t="leo.20191228122644.30"><vh>DxfWriteInterface.int findDxfColor</vh></v>
<v t="leo.20191228122644.31"><vh>DxfWriteInterface.void assignEntityDefaults</vh></v>
<v t="leo.20191228122644.32"><vh>DxfWriteInterface.void assignDimensionDefaults</vh></v>
<v t="leo.20191228122644.33"><vh>DxfWriteInterface.void writeLine</vh></v>
<v t="leo.20191228122644.34"><vh>DxfWriteInterface.void writeArc</vh></v>
<v t="leo.20191228122644.35"><vh>DxfWriteInterface.void writeBezierAsPwl</vh></v>
<v t="leo.20191228122644.36"><vh>DxfWriteInterface.void makeKnotsFor</vh></v>
<v t="leo.20191228122644.37"><vh>DxfWriteInterface.void writeSpline</vh></v>
<v t="leo.20191228122644.38"><vh>DxfWriteInterface.void writeBezier</vh></v>
<v t="leo.20191228122644.39"><vh>DxfWriteInterface.void writeAlignedDimension</vh></v>
<v t="leo.20191228122644.40"><vh>DxfWriteInterface.void writeLinearDimension</vh></v>
<v t="leo.20191228122644.41"><vh>DxfWriteInterface.void writeRadialDimension</vh></v>
<v t="leo.20191228122644.42"><vh>DxfWriteInterface.void writeDiametricDimension</vh></v>
<v t="leo.20191228122644.43"><vh>DxfWriteInterface.void writeAngularDimension</vh></v>
<v t="leo.20191228122644.44"><vh>DxfWriteInterface.void writeText</vh></v>
</v>
<v t="leo.20191228122644.45"><vh>bool DxfFileWriter::OutputConstraints (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.46"><vh>void DxfFileWriter::StartFile (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.47"><vh>void DxfFileWriter::StartPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.48"><vh>void DxfFileWriter::FinishPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.49"><vh>void DxfFileWriter::Triangle (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.50"><vh>void DxfFileWriter::Bezier (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.51"><vh>void DxfFileWriter::FinishAndCloseFile (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.52"><vh>bool DxfFileWriter::NeedToOutput (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.53"><vh>const char *DxfFileWriter::lineTypeName(StipplePattern stippleType) { (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.54"><vh>static std::string (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.55"><vh>void EpsFileWriter::StartFile (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.56"><vh>void EpsFileWriter::StartPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.57"><vh>void EpsFileWriter::FinishPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.58"><vh>void EpsFileWriter::MaybeMoveTo (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.59"><vh>void EpsFileWriter::Triangle (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.60"><vh>void EpsFileWriter::Bezier (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.61"><vh>void EpsFileWriter::FinishAndCloseFile (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.62"><vh>void PdfFileWriter::StartFile (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.63"><vh>void PdfFileWriter::FinishAndCloseFile (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.64"><vh>void PdfFileWriter::StartPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.65"><vh>void PdfFileWriter::FinishPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.66"><vh>void PdfFileWriter::MaybeMoveTo (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.67"><vh>void PdfFileWriter::Triangle (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.68"><vh>void PdfFileWriter::Bezier (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.69"><vh>void SvgFileWriter::StartFile (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.70"><vh>void SvgFileWriter::StartPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.71"><vh>void SvgFileWriter::FinishPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.72"><vh>void SvgFileWriter::MaybeMoveTo (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.73"><vh>void SvgFileWriter::Triangle (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.74"><vh>void SvgFileWriter::Bezier (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.75"><vh>void SvgFileWriter::FinishAndCloseFile (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.76"><vh>void HpglFileWriter::StartFile (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.77"><vh>void HpglFileWriter::StartPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.78"><vh>void HpglFileWriter::FinishPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.79"><vh>void HpglFileWriter::Triangle (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.80"><vh>void HpglFileWriter::Bezier (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.81"><vh>void HpglFileWriter::FinishAndCloseFile (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.82"><vh>void GCodeFileWriter::StartFile (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.83"><vh>void GCodeFileWriter::StartPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.84"><vh>void GCodeFileWriter::FinishPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.85"><vh>void GCodeFileWriter::Triangle (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.86"><vh>void GCodeFileWriter::Bezier (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.87"><vh>void GCodeFileWriter::FinishAndCloseFile (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.88"><vh>void Step2dFileWriter::StartFile (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.89"><vh>void Step2dFileWriter::Triangle (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.90"><vh>void Step2dFileWriter::StartPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.91"><vh>void Step2dFileWriter::FinishPath (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.92"><vh>void Step2dFileWriter::Bezier (exportvector.cpp)</vh></v>
<v t="leo.20191228122644.93"><vh>void Step2dFileWriter::FinishAndCloseFile (exportvector.cpp)</vh></v>
</v>
<v t="leo.20191228122644.94"><vh>@clean expr.cpp</vh>
<v t="leo.20191228122644.95"><vh>int Expr::Children (expr.cpp)</vh></v>
<v t="leo.20191228122644.96"><vh>int Expr::Nodes (expr.cpp)</vh></v>
<v t="leo.20191228122644.97"><vh>bool Expr::DependsOn (expr.cpp)</vh></v>
<v t="leo.20191228122644.98"><vh>bool Expr::Tol (expr.cpp)</vh></v>
<v t="leo.20191228122644.99"><vh>void Expr::Substitute (expr.cpp)</vh></v>
<v t="leo.20191228122644.100"><vh>class ExprParser</vh>
<v t="leo.20191228122644.101"><vh>class Token</vh></v>
</v>
<v t="leo.20191228122644.102"><vh>char ExprParser::ReadChar (expr.cpp)</vh></v>
<v t="leo.20191228122644.103"><vh>char ExprParser::PeekChar (expr.cpp)</vh></v>
<v t="leo.20191228122644.104"><vh>void ExprParser::SkipSpace (expr.cpp)</vh></v>
<v t="leo.20191228122644.105"><vh>int ExprParser::Precedence (expr.cpp)</vh></v>
<v t="leo.20191228122644.106"><vh>bool ExprParser::Reduce (expr.cpp)</vh></v>
<v t="leo.20191228122644.107"><vh>bool ExprParser::Parse (expr.cpp)</vh></v>
</v>
<v t="leo.20191228122644.108"><vh>@clean expr.h</vh>
<v t="leo.20191228122644.109"><vh>class Expr</vh></v>
<v t="leo.20191228122644.110"><vh>class ExprVector</vh></v>
<v t="leo.20191228122644.111"><vh>class ExprQuaternion</vh></v>
</v>
<v t="leo.20191228122644.112"><vh>@clean file.cpp</vh>
<v t="leo.20191228122644.113"><vh>int StrStartsWith (file.cpp)</vh></v>
<v t="leo.20191228122644.114"><vh>void SolveSpaceUI::ClearExisting (file.cpp)</vh></v>
<v t="leo.20191228122644.115"><vh>void SolveSpaceUI::NewFile (file.cpp)</vh></v>
<v t="leo.20191228122644.116"><vh>const SolveSpaceUI::SaveTable (file.cpp)</vh></v>
<v t="leo.20191228122644.117"><vh>void SolveSpaceUI::SaveUsingTable (file.cpp)</vh></v>
<v t="leo.20191228122644.118"><vh>bool SolveSpaceUI::SaveToFile (file.cpp)</vh></v>
<v t="leo.20191228122644.119"><vh>void SolveSpaceUI::LoadUsingTable (file.cpp)</vh></v>
<v t="leo.20191228122644.120"><vh>bool SolveSpaceUI::LoadFromFile (file.cpp)</vh></v>
<v t="leo.20191228122644.121"><vh>void SolveSpaceUI::UpgradeLegacyData (file.cpp)</vh>
<v t="leo.20191228122644.122"><vh>auto AllParamsExistFor (file.cpp)</vh></v>
</v>
<v t="leo.20191228122644.123"><vh>bool SolveSpaceUI::LoadEntitiesFromFile (file.cpp)</vh></v>
<v t="leo.20191228122644.124"><vh>static Platform::MessageDialog::Response (file.cpp)</vh></v>
<v t="leo.20191228122644.125"><vh>bool SolveSpaceUI::ReloadAllLinked (file.cpp)</vh></v>
<v t="leo.20191228122644.126"><vh>bool SolveSpaceUI::ReloadLinkedImage (file.cpp)</vh></v>
</v>
<v t="leo.20191228122644.127"><vh>@clean generate.cpp</vh>
<v t="leo.20191228122644.128"><vh>void SolveSpaceUI::MarkGroupDirtyByEntity (generate.cpp)</vh></v>
<v t="leo.20191228122644.129"><vh>void SolveSpaceUI::MarkGroupDirty (generate.cpp)</vh></v>
<v t="leo.20191228122644.130"><vh>bool SolveSpaceUI::PruneOrphans (generate.cpp)</vh>
<v t="leo.20191228122644.131"><vh>auto r (generate.cpp)</vh></v>
<v t="leo.20191228122644.132"><vh>auto c (generate.cpp)</vh></v>
</v>
<v t="leo.20191228122644.133"><vh>bool SolveSpaceUI::GroupsInOrder (generate.cpp)</vh></v>
<v t="leo.20191228122644.134"><vh>bool SolveSpaceUI::GroupExists (generate.cpp)</vh></v>
<v t="leo.20191228122644.135"><vh>bool SolveSpaceUI::EntityExists (generate.cpp)</vh></v>
<v t="leo.20191228122644.136"><vh>bool SolveSpaceUI::PruneGroups (generate.cpp)</vh></v>
<v t="leo.20191228122644.137"><vh>bool SolveSpaceUI::PruneRequests (generate.cpp)</vh>
<v t="leo.20191228122644.138"><vh>auto e (generate.cpp)</vh></v>
</v>
<v t="leo.20191228122644.139"><vh>bool SolveSpaceUI::PruneConstraints (generate.cpp)</vh>
<v t="leo.20191228122644.140"><vh>auto c (generate.cpp)</vh></v>
</v>
<v t="leo.20191228122644.141"><vh>void SolveSpaceUI::GenerateAll (generate.cpp)</vh></v>
<v t="leo.20191228122644.142"><vh>void SolveSpaceUI::ForceReferences (generate.cpp)</vh>
<v t="leo.20191228122644.143"><vh>const struct (generate.cpp)</vh></v>
</v>
<v t="leo.20191228122644.144"><vh>void SolveSpaceUI::UpdateCenterOfMass (generate.cpp)</vh></v>
<v t="leo.20191228122644.145"><vh>void SolveSpaceUI::MarkDraggedParams (generate.cpp)</vh></v>
<v t="leo.20191228122644.146"><vh>void SolveSpaceUI::SolveGroupAndReport (generate.cpp)</vh>
<v t="leo.20191228122644.147"><vh>bool isOkay (generate.cpp)</vh></v>
</v>
<v t="leo.20191228122644.148"><vh>void SolveSpaceUI::WriteEqSystemForGroup (generate.cpp)</vh></v>
<v t="leo.20191228122644.149"><vh>void SolveSpaceUI::SolveGroup (generate.cpp)</vh></v>
<v t="leo.20191228122644.150"><vh>bool SolveSpaceUI::ActiveGroupsOkay (generate.cpp)</vh></v>
</v>
<v t="leo.20191228122645.1"><vh>@clean graphicswin.cpp</vh>
<v t="leo.20191228122645.2"><vh>const MenuEntry (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.3"><vh>void GraphicsWindow::ActivateCommand (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.4"><vh>bool GraphicsWindow::KeyboardEvent (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.5"><vh>void GraphicsWindow::PopulateMainMenu (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.6"><vh>void PopulateMenuWithPathnames (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.7"><vh>void GraphicsWindow::PopulateRecentFiles (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.8"><vh>void GraphicsWindow::Init (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.9"><vh>void GraphicsWindow::AnimateOntoWorkplane (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.10"><vh>void GraphicsWindow::AnimateOnto (graphicswin.cpp)</vh>
<v t="leo.20191228122645.11"><vh>int 32_t (graphicswin.cpp)</vh></v>
</v>
<v t="leo.20191228122645.12"><vh>void GraphicsWindow::HandlePointForZoomToFit (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.13"><vh>void GraphicsWindow::LoopOverPoints (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.14"><vh>void GraphicsWindow::ZoomToFit (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.15"><vh>bool includingInvisibles (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.16"><vh>void GraphicsWindow::MenuView (graphicswin.cpp)</vh>
<v t="leo.20191228122645.17"><vh>const Vector (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.18"><vh>double d (graphicswin.cpp)</vh></v>
</v>
<v t="leo.20191228122645.19"><vh>void GraphicsWindow::EnsureValidActives (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.20"><vh>void GraphicsWindow::SetWorkplaneFreeIn3d (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.21"><vh>bool GraphicsWindow::LockedInWorkplane (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.22"><vh>void GraphicsWindow::ForceTextWindowShown (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.23"><vh>void GraphicsWindow::DeleteTaggedRequests (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.24"><vh>void GraphicsWindow::MenuEdit (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.25"><vh>void GraphicsWindow::MenuRequest (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.26"><vh>void GraphicsWindow::ClearSuper (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.27"><vh>void GraphicsWindow::ToggleBool (graphicswin.cpp)</vh></v>
<v t="leo.20191228122645.28"><vh>bool GraphicsWindow::SuggestLineConstraint (graphicswin.cpp)</vh></v>
</v>
<v t="leo.20191228122645.29"><vh>@clean group.cpp</vh>
<v t="leo.20191228122645.30"><vh>void Group::Clear (group.cpp)</vh></v>
<v t="leo.20191228122645.31"><vh>void Group::AddParam (group.cpp)</vh></v>
<v t="leo.20191228122645.32"><vh>bool Group::IsVisible (group.cpp)</vh></v>
<v t="leo.20191228122645.33"><vh>void Group::ExtrusionForceVectorTo (group.cpp)</vh></v>
<v t="leo.20191228122645.34"><vh>void Group::MenuGroup (group.cpp)</vh></v>
<v t="leo.20191228122645.35"><vh>void Group::MenuGroup (group.cpp)</vh></v>
<v t="leo.20191228122645.36"><vh>void Group::TransformImportedBy (group.cpp)</vh></v>
<v t="leo.20191228122645.37"><vh>bool Group::IsForcedToMeshBySource (group.cpp)</vh></v>
<v t="leo.20191228122645.38"><vh>bool Group::IsForcedToMesh (group.cpp)</vh></v>
<v t="leo.20191228122645.39"><vh>void Group::Activate (group.cpp)</vh></v>
<v t="leo.20191228122645.40"><vh>void Group::Generate (group.cpp)</vh></v>
<v t="leo.20191228122645.41"><vh>bool Group::IsSolvedOkay (group.cpp)</vh></v>
<v t="leo.20191228122645.42"><vh>void Group::AddEq (group.cpp)</vh></v>
<v t="leo.20191228122645.43"><vh>void Group::GenerateEquations (group.cpp)</vh></v>
<v t="leo.20191228122645.44"><vh>void Group::MakeExtrusionLines (group.cpp)</vh></v>
<v t="leo.20191228122645.45"><vh>void Group::MakeLatheCircles (group.cpp)</vh></v>
<v t="leo.20191228122645.46"><vh>void Group::MakeLatheSurfacesSelectable (group.cpp)</vh></v>
<v t="leo.20191228122645.47"><vh>void Group::MakeExtrusionTopBottomFaces (group.cpp)</vh></v>
<v t="leo.20191228122645.48"><vh>void Group::CopyEntity (group.cpp)</vh></v>
</v>
<v t="leo.20191228122645.49"><vh>@clean groupmesh.cpp</vh>
<v t="leo.20191228122645.50"><vh>void Group::AssembleLoops (groupmesh.cpp)</vh></v>
<v t="leo.20191228122645.51"><vh>void Group::GenerateLoops (groupmesh.cpp)</vh></v>
<v t="leo.20191228122645.52"><vh>void SShell::RemapFaces (groupmesh.cpp)</vh></v>
<v t="leo.20191228122645.53"><vh>void SMesh::RemapFaces (groupmesh.cpp)</vh></v>
<v t="leo.20191228122645.54"><vh>void Group::GenerateForStepAndRepeat (groupmesh.cpp)</vh></v>
<v t="leo.20191228122645.55"><vh>void Group::GenerateForBoolean (groupmesh.cpp)</vh></v>
<v t="leo.20191228122645.56"><vh>void Group::GenerateShellAndMesh (groupmesh.cpp)</vh></v>
<v t="leo.20191228122645.57"><vh>void Group::GenerateDisplayItems (groupmesh.cpp)</vh></v>
<v t="leo.20191228122645.58"><vh>bool Group::IsMeshGroup (groupmesh.cpp)</vh></v>
<v t="leo.20191228122645.59"><vh>void Group::DrawMesh (groupmesh.cpp)</vh></v>
<v t="leo.20191228122645.60"><vh>void Group::Draw (groupmesh.cpp)</vh></v>
<v t="leo.20191228122645.61"><vh>void Group::DrawPolyError (groupmesh.cpp)</vh></v>
<v t="leo.20191228122645.62"><vh>void Group::DrawFilledPaths (groupmesh.cpp)</vh></v>
<v t="leo.20191228122645.63"><vh>void Group::DrawContourAreaLabels (groupmesh.cpp)</vh></v>
</v>
<v t="leo.20191228122645.64"><vh>@clean importdxf.cpp</vh>
<v t="leo.20191228122645.65"><vh>static std::string (importdxf.cpp)</vh></v>
<v t="leo.20191228122645.66"><vh>class DxfImport</vh>
<v t="leo.20191228122645.67"><vh>DxfImport.void invertXTransform</vh></v>
<v t="leo.20191228122645.68"><vh>DxfImport.void multBlockTransform</vh></v>
<v t="leo.20191228122645.69"><vh>DxfImport.void clearBlockTransform</vh></v>
<v t="leo.20191228122645.70"><vh>DxfImport.void blockTransformArc</vh></v>
<v t="leo.20191228122645.71"><vh>DxfImport.double angleTo</vh></v>
<v t="leo.20191228122645.72"><vh>DxfImport.bool addPendingBlockEntity</vh></v>
<v t="leo.20191228122645.73"><vh>DxfImport.void addEntity</vh></v>
<v t="leo.20191228122645.74"><vh>DxfImport.int getColor</vh></v>
<v t="leo.20191228122645.75"><vh>DxfImport.void configureRequest</vh></v>
<v t="leo.20191228122645.76"><vh>DxfImport.bool operator</vh></v>
<v t="leo.20191228122645.77"><vh>DxfImport.void processPoint</vh></v>
<v t="leo.20191228122645.78"><vh>DxfImport.void addLayer</vh></v>
<v t="leo.20191228122645.79"><vh>DxfImport.void addBlock</vh></v>
<v t="leo.20191228122645.80"><vh>DxfImport.void endBlock</vh></v>
<v t="leo.20191228122645.81"><vh>DxfImport.void addPoint</vh></v>
<v t="leo.20191228122645.82"><vh>DxfImport.void addLine</vh></v>
<v t="leo.20191228122645.83"><vh>DxfImport.void addArc</vh></v>
<v t="leo.20191228122645.84"><vh>DxfImport.void addCircle</vh></v>
<v t="leo.20191228122645.85"><vh>DxfImport.void addLWPolyline</vh></v>
<v t="leo.20191228122645.86"><vh>DxfImport.void addPolyline</vh></v>
<v t="leo.20191228122645.87"><vh>DxfImport.void addSpline</vh></v>
<v t="leo.20191228122645.88"><vh>DxfImport.void addInsert</vh></v>
<v t="leo.20191228122645.89"><vh>DxfImport.void addMText</vh></v>
<v t="leo.20191228122645.90"><vh>DxfImport.void addText</vh></v>
<v t="leo.20191228122645.91"><vh>DxfImport.void addDimAlign</vh></v>
<v t="leo.20191228122645.92"><vh>DxfImport.void addDimLinear</vh></v>
<v t="leo.20191228122645.93"><vh>DxfImport.void addDimAngular</vh></v>
<v t="leo.20191228122645.94"><vh>DxfImport.bool asRadius</vh></v>
<v t="leo.20191228122645.95"><vh>DxfImport.void addDimRadial</vh></v>
<v t="leo.20191228122645.96"><vh>DxfImport.void addDimDiametric</vh></v>
<v t="leo.20191228122645.97"><vh>DxfImport.void addDimAngular3P</vh></v>
</v>
<v t="leo.20191228122645.98"><vh>class DxfCheck3D</vh>
<v t="leo.20191228122645.99"><vh>DxfCheck3D.void addEntity</vh></v>
<v t="leo.20191228122645.100"><vh>DxfCheck3D.void addPoint</vh></v>
<v t="leo.20191228122645.101"><vh>DxfCheck3D.void addLine</vh></v>
<v t="leo.20191228122645.102"><vh>DxfCheck3D.void addArc</vh></v>
<v t="leo.20191228122645.103"><vh>DxfCheck3D.void addCircle</vh></v>
<v t="leo.20191228122645.104"><vh>DxfCheck3D.void addPolyline</vh></v>
<v t="leo.20191228122645.105"><vh>DxfCheck3D.void addSpline</vh></v>
<v t="leo.20191228122645.106"><vh>DxfCheck3D.void addInsert</vh></v>
<v t="leo.20191228122645.107"><vh>DxfCheck3D.void addMText</vh></v>
<v t="leo.20191228122645.108"><vh>DxfCheck3D.void addText</vh></v>
<v t="leo.20191228122645.109"><vh>DxfCheck3D.void addDimAlign</vh></v>
<v t="leo.20191228122645.110"><vh>DxfCheck3D.void addDimLinear</vh></v>
<v t="leo.20191228122645.111"><vh>DxfCheck3D.void addDimAngular</vh></v>
<v t="leo.20191228122645.112"><vh>DxfCheck3D.void addDimRadial</vh></v>
<v t="leo.20191228122645.113"><vh>DxfCheck3D.void addDimDiametric</vh></v>
<v t="leo.20191228122645.114"><vh>DxfCheck3D.void addDimAngular3P</vh></v>
<v t="leo.20191228122645.115"><vh>DxfCheck3D.void checkCoord</vh></v>
</v>
<v t="leo.20191228122645.116"><vh>static void ImportDwgDxf (importdxf.cpp)</vh></v>
<v t="leo.20191228122645.117"><vh>void ImportDxf (importdxf.cpp)</vh></v>
<v t="leo.20191228122645.118"><vh>void ImportDwg (importdxf.cpp)</vh></v>
</v>
<v t="leo.20191228122645.119"><vh>@clean lib.cpp</vh>
<v t="leo.20191228122645.120"><vh>void SolveSpace::Platform::FatalError (lib.cpp)</vh></v>
<v t="leo.20191228122645.121"><vh>void Group::GenerateEquations (lib.cpp)</vh></v>
<v t="leo.20191228122645.122"><vh>extern "C" { (lib.cpp)</vh>
<v t="leo.20191228122645.123"><vh>void Slvs_QuaternionU (lib.cpp)</vh></v>
<v t="leo.20191228122645.124"><vh>void Slvs_QuaternionV (lib.cpp)</vh></v>
<v t="leo.20191228122645.125"><vh>void Slvs_QuaternionN (lib.cpp)</vh></v>
<v t="leo.20191228122645.126"><vh>void Slvs_MakeQuaternion (lib.cpp)</vh></v>
<v t="leo.20191228122645.127"><vh>void Slvs_Solve (lib.cpp)</vh></v>
</v>
</v>
<v t="leo.20191228122645.128"><vh>@clean mesh.cpp</vh>
<v t="leo.20191228122645.129"><vh>void SMesh::Clear (mesh.cpp)</vh></v>
<v t="leo.20191228122645.130"><vh>void SMesh::AddTriangle (mesh.cpp)</vh></v>
<v t="leo.20191228122645.131"><vh>void SMesh::AddTriangle (mesh.cpp)</vh></v>
<v t="leo.20191228122645.132"><vh>void SMesh::AddTriangle (mesh.cpp)</vh></v>
<v t="leo.20191228122645.133"><vh>void SMesh::DoBounding (mesh.cpp)</vh></v>
<v t="leo.20191228122645.134"><vh>void SMesh::GetBounding (mesh.cpp)</vh></v>
<v t="leo.20191228122645.135"><vh>void SMesh::MakeEdgesInPlaneInto (mesh.cpp)</vh></v>
<v t="leo.20191228122645.136"><vh>void SMesh::MakeOutlinesInto (mesh.cpp)</vh></v>
<v t="leo.20191228122645.137"><vh>void SMesh::Simplify (mesh.cpp)</vh></v>
<v t="leo.20191228122645.138"><vh>void SMesh::AddAgainstBsp (mesh.cpp)</vh></v>
<v t="leo.20191228122645.139"><vh>void SMesh::MakeFromUnionOf (mesh.cpp)</vh></v>
<v t="leo.20191228122645.140"><vh>void SMesh::MakeFromDifferenceOf (mesh.cpp)</vh></v>
<v t="leo.20191228122645.141"><vh>void SMesh::MakeFromCopyOf (mesh.cpp)</vh></v>
<v t="leo.20191228122645.142"><vh>void SMesh::MakeFromAssemblyOf (mesh.cpp)</vh></v>
<v t="leo.20191228122645.143"><vh>void SMesh::MakeFromTransformationOf (mesh.cpp)</vh></v>
<v t="leo.20191228122645.144"><vh>double a (mesh.cpp)</vh></v>
<v t="leo.20191228122645.145"><vh>double a (mesh.cpp)</vh></v>
<v t="leo.20191228122645.146"><vh>void SKdNode::ClearTags (mesh.cpp)</vh></v>
<v t="leo.20191228122645.147"><vh>void SKdNode::AddTriangle (mesh.cpp)</vh>
<v t="leo.20191228122645.148"><vh>double ta (mesh.cpp)</vh></v>
</v>
<v t="leo.20191228122645.149"><vh>void SKdNode::MakeMeshInto (mesh.cpp)</vh></v>
<v t="leo.20191228122645.150"><vh>void SKdNode::ListTrianglesInto (mesh.cpp)</vh></v>
<v t="leo.20191228122645.151"><vh>void SKdNode::SnapToVertex (mesh.cpp)</vh></v>
<v t="leo.20191228122645.152"><vh>void SKdNode::SnapToMesh (mesh.cpp)</vh></v>
<v t="leo.20191228122645.153"><vh>void SKdNode::SplitLinesAgainstTriangle (mesh.cpp)</vh>
<v t="leo.20191228122645.154"><vh>double da (mesh.cpp)</vh></v>
<v t="leo.20191228122645.155"><vh>double d (mesh.cpp)</vh></v>
<v t="leo.20191228122645.156"><vh>double da (mesh.cpp)</vh></v>
</v>
<v t="leo.20191228122645.157"><vh>void SKdNode::OcclusionTestLine (mesh.cpp)</vh>
<v t="leo.20191228122645.158"><vh>double ac (mesh.cpp)</vh></v>
</v>
<v t="leo.20191228122645.159"><vh>void SKdNode::FindEdgeOn (mesh.cpp)</vh>
<v t="leo.20191228122645.160"><vh>double ac (mesh.cpp)</vh></v>
</v>
<v t="leo.20191228122645.161"><vh>bool CheckAndAddTrianglePair (mesh.cpp)</vh></v>
<v t="leo.20191228122645.162"><vh>void SKdNode::MakeCertainEdgesInto (mesh.cpp)</vh></v>
<v t="leo.20191228122645.163"><vh>void SKdNode::MakeOutlinesInto (mesh.cpp)</vh></v>
<v t="leo.20191228122645.164"><vh>bool SOutline::IsVisible (mesh.cpp)</vh></v>
<v t="leo.20191228122645.165"><vh>void SOutlineList::Clear (mesh.cpp)</vh></v>
<v t="leo.20191228122645.166"><vh>void SOutlineList::AddEdge (mesh.cpp)</vh></v>
<v t="leo.20191228122645.167"><vh>void SOutlineList::ListTaggedInto (mesh.cpp)</vh></v>
<v t="leo.20191228122645.168"><vh>void SOutlineList::MakeFromCopyOf (mesh.cpp)</vh></v>
<v t="leo.20191228122645.169"><vh>void SMesh::PrecomputeTransparency (mesh.cpp)</vh>
<v t="leo.20191228122645.170"><vh>bool opaquea (mesh.cpp)</vh></v>
</v>
</v>
<v t="leo.20191228122646.1"><vh>@clean modify.cpp</vh>
<v t="leo.20191228122646.2"><vh>void GraphicsWindow::ReplacePointInConstraints (modify.cpp)</vh></v>
<v t="leo.20191228122646.3"><vh>void GraphicsWindow::RemoveConstraintsForPointBeingDeleted (modify.cpp)</vh></v>
<v t="leo.20191228122646.4"><vh>void GraphicsWindow::FixConstraintsForRequestBeingDeleted (modify.cpp)</vh></v>
<v t="leo.20191228122646.5"><vh>void GraphicsWindow::FixConstraintsForPointBeingDeleted (modify.cpp)</vh></v>
<v t="leo.20191228122646.6"><vh>void GraphicsWindow::ParametricCurve::MakeFromEntity (modify.cpp)</vh></v>
<v t="leo.20191228122646.7"><vh>void GraphicsWindow::ParametricCurve::CreateRequestTrimmedTo (modify.cpp)</vh></v>
<v t="leo.20191228122646.8"><vh>void GraphicsWindow::ParametricCurve::ConstrainPointIfCoincident (modify.cpp)</vh></v>
<v t="leo.20191228122646.9"><vh>void GraphicsWindow::MakeTangentArc (modify.cpp)</vh></v>
<v t="leo.20191228122646.10"><vh>void GraphicsWindow::SplitLinesOrCurves (modify.cpp)</vh></v>
</v>
<v t="leo.20191228122646.11"><vh>@clean mouse.cpp</vh>
<v t="leo.20191228122646.12"><vh>void GraphicsWindow::UpdateDraggedPoint (mouse.cpp)</vh></v>
<v t="leo.20191228122646.13"><vh>void GraphicsWindow::UpdateDraggedNum (mouse.cpp)</vh></v>
<v t="leo.20191228122646.14"><vh>void GraphicsWindow::AddPointToDraggedList (mouse.cpp)</vh></v>
<v t="leo.20191228122646.15"><vh>void GraphicsWindow::StartDraggingByEntity (mouse.cpp)</vh></v>
<v t="leo.20191228122646.16"><vh>void GraphicsWindow::StartDraggingBySelection (mouse.cpp)</vh></v>
<v t="leo.20191228122646.17"><vh>void GraphicsWindow::MouseMoved (mouse.cpp)</vh></v>
<v t="leo.20191228122646.18"><vh>void GraphicsWindow::ClearPending (mouse.cpp)</vh></v>
<v t="leo.20191228122646.19"><vh>bool GraphicsWindow::IsFromPending (mouse.cpp)</vh></v>
<v t="leo.20191228122646.20"><vh>void GraphicsWindow::AddToPending (mouse.cpp)</vh></v>
<v t="leo.20191228122646.21"><vh>void GraphicsWindow::ReplacePending (mouse.cpp)</vh></v>
<v t="leo.20191228122646.22"><vh>void GraphicsWindow::MouseMiddleOrRightDown (mouse.cpp)</vh></v>
<v t="leo.20191228122646.23"><vh>void GraphicsWindow::MouseRightUp (mouse.cpp)</vh>
<v t="leo.20191228122646.24"><vh>int pointCount (mouse.cpp)</vh></v>
</v>
<v t="leo.20191228122646.25"><vh>bool GraphicsWindow::ConstrainPointByHovered (mouse.cpp)</vh></v>
<v t="leo.20191228122646.26"><vh>bool GraphicsWindow::MouseEvent (mouse.cpp)</vh></v>
<v t="leo.20191228122646.27"><vh>void GraphicsWindow::MouseLeftDown (mouse.cpp)</vh></v>
<v t="leo.20191228122646.28"><vh>void GraphicsWindow::MouseLeftUp (mouse.cpp)</vh></v>
<v t="leo.20191228122646.29"><vh>void GraphicsWindow::EditConstraint (mouse.cpp)</vh></v>
<v t="leo.20191228122646.30"><vh>void GraphicsWindow::MouseLeftDoubleClick (mouse.cpp)</vh></v>
<v t="leo.20191228122646.31"><vh>void GraphicsWindow::EditControlDone (mouse.cpp)</vh></v>
<v t="leo.20191228122646.32"><vh>void GraphicsWindow::MouseScroll (mouse.cpp)</vh></v>
<v t="leo.20191228122646.33"><vh>void GraphicsWindow::MouseLeave (mouse.cpp)</vh></v>
<v t="leo.20191228122646.34"><vh>void GraphicsWindow::SixDofEvent (mouse.cpp)</vh></v>
</v>
<v t="leo.20191228122646.35"><vh>@clean polygon.cpp</vh>
<v t="leo.20191228122646.36"><vh>double altA (polygon.cpp)</vh></v>
<v t="leo.20191228122646.37"><vh>bool STriangle::ContainsPointProjd (polygon.cpp)</vh></v>
<v t="leo.20191228122646.38"><vh>bool STriangle::Raytrace (polygon.cpp)</vh></v>
<v t="leo.20191228122646.39"><vh>bool STriangle::IsDegenerate (polygon.cpp)</vh></v>
<v t="leo.20191228122646.40"><vh>void STriangle::FlipNormal (polygon.cpp)</vh></v>
<v t="leo.20191228122646.41"><vh>bool SEdge::EdgeCrosses (polygon.cpp)</vh></v>
<v t="leo.20191228122646.42"><vh>void SEdgeList::Clear (polygon.cpp)</vh></v>
<v t="leo.20191228122646.43"><vh>void SEdgeList::AddEdge (polygon.cpp)</vh></v>
<v t="leo.20191228122646.44"><vh>bool SEdgeList::AssembleContour (polygon.cpp)</vh></v>
<v t="leo.20191228122646.45"><vh>bool SEdgeList::AssemblePolygon (polygon.cpp)</vh></v>
<v t="leo.20191228122646.46"><vh>int SEdgeList::AnyEdgeCrossings (polygon.cpp)</vh>
<v t="leo.20191228122646.47"><vh>auto cnt (polygon.cpp)</vh></v>
</v>
<v t="leo.20191228122646.48"><vh>bool SEdgeList::ContainsEdge (polygon.cpp)</vh></v>
<v t="leo.20191228122646.49"><vh>void SEdgeList::CullExtraneousEdges (polygon.cpp)</vh></v>
<v t="leo.20191228122646.50"><vh>int SKdNodeEdges::AnyEdgeCrossings (polygon.cpp)</vh></v>
<v t="leo.20191228122646.51"><vh>void SEdgeList::MergeCollinearSegments (polygon.cpp)</vh></v>
<v t="leo.20191228122646.52"><vh>void SPointList::Clear (polygon.cpp)</vh></v>
<v t="leo.20191228122646.53"><vh>bool SPointList::ContainsPoint (polygon.cpp)</vh></v>
<v t="leo.20191228122646.54"><vh>int SPointList::IndexForPoint (polygon.cpp)</vh></v>
<v t="leo.20191228122646.55"><vh>void SPointList::IncrementTagFor (polygon.cpp)</vh></v>
<v t="leo.20191228122646.56"><vh>void SPointList::Add (polygon.cpp)</vh></v>
<v t="leo.20191228122646.57"><vh>void SContour::AddPoint (polygon.cpp)</vh></v>
<v t="leo.20191228122646.58"><vh>void SContour::MakeEdgesInto (polygon.cpp)</vh></v>
<v t="leo.20191228122646.59"><vh>void SContour::CopyInto (polygon.cpp)</vh></v>
<v t="leo.20191228122646.60"><vh>void SContour::FindPointWithMinX (polygon.cpp)</vh></v>
<v t="leo.20191228122646.61"><vh>bool SContour::IsClockwiseProjdToNormal (polygon.cpp)</vh></v>
<v t="leo.20191228122646.62"><vh>bool SContour::ContainsPointProjdToNormal (polygon.cpp)</vh></v>
<v t="leo.20191228122646.63"><vh>void SContour::Reverse (polygon.cpp)</vh></v>
<v t="leo.20191228122646.64"><vh>void SPolygon::Clear (polygon.cpp)</vh></v>
<v t="leo.20191228122646.65"><vh>void SPolygon::AddEmptyContour (polygon.cpp)</vh></v>
<v t="leo.20191228122646.66"><vh>void SPolygon::MakeEdgesInto (polygon.cpp)</vh></v>
<v t="leo.20191228122646.67"><vh>bool SPolygon::ContainsPoint (polygon.cpp)</vh></v>
<v t="leo.20191228122646.68"><vh>auto winding (polygon.cpp)</vh></v>
<v t="leo.20191228122646.69"><vh>void SPolygon::FixContourDirections (polygon.cpp)</vh></v>
<v t="leo.20191228122646.70"><vh>bool SPolygon::IsEmpty (polygon.cpp)</vh></v>
<v t="leo.20191228122646.71"><vh>bool SPolygon::SelfIntersecting (polygon.cpp)</vh></v>
<v t="leo.20191228122646.72"><vh>void SPolygon::InverseTransformInto (polygon.cpp)</vh></v>
<v t="leo.20191228122646.73"><vh>void SPolygon::OffsetInto (polygon.cpp)</vh></v>
<v t="leo.20191228122646.74"><vh>bool IntersectionOfLines (polygon.cpp)</vh></v>
<v t="leo.20191228122646.75"><vh>void SContour::OffsetInto (polygon.cpp)</vh></v>
</v>
<v t="leo.20191228122646.76"><vh>@clean polygon.h</vh>
<v t="leo.20191228122646.77"><vh>class SEdge</vh></v>
<v t="leo.20191228122646.78"><vh>class SEdgeList</vh></v>
<v t="leo.20191228122646.79"><vh>class SEdgeLl</vh></v>
<v t="leo.20191228122646.80"><vh>class SKdNodeEdges</vh>
<v t="leo.20191228122646.81"><vh>SKdNodeEdges.int AnyEdgeCrossings</vh></v>
</v>
<v t="leo.20191228122646.82"><vh>class SPointList</vh></v>
<v t="leo.20191228122646.83"><vh>class SContour</vh></v>
<v t="leo.20191228122646.84"><vh>typedef struct (polygon.h)</vh></v>
<v t="leo.20191228122646.85"><vh>class SPolygon</vh></v>
<v t="leo.20191228122646.86"><vh>class STriangle</vh>
<v t="leo.20191228122646.87"><vh>STriangle.bool Raytrace</vh></v>
<v t="leo.20191228122646.88"><vh>STriangle.static SBsp2</vh></v>
<v t="leo.20191228122646.89"><vh>STriangle.void InsertConvexHow</vh></v>
</v>
<v t="leo.20191228122646.90"><vh>class STriangleLl</vh></v>
<v t="leo.20191228122646.91"><vh>class SOutline</vh></v>
<v t="leo.20191228122646.92"><vh>class SOutlineList</vh></v>
<v t="leo.20191228122646.93"><vh>class SKdNode</vh>
<v t="leo.20191228122646.94"><vh>class PolylineBuilder</vh></v>
</v>
</v>
<v t="leo.20191228122646.95"><vh>@clean polyline.cpp</vh>
<v t="leo.20191228122646.96"><vh>bool PolylineBuilder::Vertex::GetNext (polyline.cpp)</vh>
<v t="leo.20191228122646.97"><vh>auto it (polyline.cpp)</vh></v>
</v>
<v t="leo.20191228122646.98"><vh>bool PolylineBuilder::Vertex::GetNext (polyline.cpp)</vh></v>
<v t="leo.20191228122646.99"><vh>bool PolylineBuilder::Edge::GetStartAndNext (polyline.cpp)</vh></v>
<v t="leo.20191228122646.100"><vh>void PolylineBuilder::Clear (polyline.cpp)</vh></v>
<v t="leo.20191228122646.101"><vh>void PolylineBuilder::Generate (polyline.cpp)</vh></v>
<v t="leo.20191228122646.102"><vh>void PolylineBuilder::MakeFromEdges (polyline.cpp)</vh></v>
<v t="leo.20191228122646.103"><vh>void PolylineBuilder::MakeFromOutlines (polyline.cpp)</vh></v>
<v t="leo.20191228122646.104"><vh>void PolylineBuilder::GenerateEdges (polyline.cpp)</vh>
<v t="leo.20191228122646.105"><vh>auto startFunc (polyline.cpp)</vh></v>
<v t="leo.20191228122646.106"><vh>auto nextFunc (polyline.cpp)</vh></v>
<v t="leo.20191228122646.107"><vh>auto aloneFunc (polyline.cpp)</vh></v>
</v>
<v t="leo.20191228122646.108"><vh>void PolylineBuilder::GenerateOutlines (polyline.cpp)</vh>
<v t="leo.20191228122646.109"><vh>auto startFunc (polyline.cpp)</vh></v>
<v t="leo.20191228122646.110"><vh>auto nextFunc (polyline.cpp)</vh></v>
<v t="leo.20191228122646.111"><vh>auto aloneFunc (polyline.cpp)</vh></v>
</v>
</v>
<v t="leo.20191228122646.112"><vh>@clean request.cpp</vh>
<v t="leo.20191228122646.113"><vh>const EntReqMapping (request.cpp)</vh></v>
<v t="leo.20191228122646.114"><vh>void CopyEntityInfo (request.cpp)</vh></v>
<v t="leo.20191228122646.115"><vh>bool EntReqTable::GetRequestInfo (request.cpp)</vh></v>
<v t="leo.20191228122646.116"><vh>bool EntReqTable::GetEntityInfo (request.cpp)</vh></v>
<v t="leo.20191228122646.117"><vh>void Request::Generate (request.cpp)</vh></v>
<v t="leo.20191228122646.118"><vh>int Request::IndexOfPoint (request.cpp)</vh></v>
</v>
<v t="leo.20191228122646.119"><vh>@clean resource.cpp</vh>
<v t="leo.20191228122646.120"><vh>void Pixmap::SetPixel (resource.cpp)</vh></v>
<v t="leo.20191228122646.121"><vh>void Pixmap::ConvertTo (resource.cpp)</vh></v>
<v t="leo.20191228122646.122"><vh>static std::shared_ptr (resource.cpp)</vh></v>
<v t="leo.20191228122646.123"><vh>bool Pixmap::WritePng (resource.cpp)</vh></v>
<v t="leo.20191228122646.124"><vh>bool Pixmap::WritePng (resource.cpp)</vh></v>
<v t="leo.20191228122646.125"><vh>bool Pixmap::Equals (resource.cpp)</vh></v>
<v t="leo.20191228122646.126"><vh>class ASCIIReader</vh>
<v t="leo.20191228122646.127"><vh>ASCIIReader.static ASCIIReader</vh></v>
<v t="leo.20191228122646.128"><vh>ASCIIReader.bool AtEnd</vh></v>
<v t="leo.20191228122646.129"><vh>ASCIIReader.bool SkipSpace</vh></v>
<v t="leo.20191228122646.130"><vh>ASCIIReader.char PeekChar</vh></v>
<v t="leo.20191228122646.131"><vh>ASCIIReader.char ReadChar</vh></v>
<v t="leo.20191228122646.132"><vh>ASCIIReader.bool TryChar</vh></v>
<v t="leo.20191228122646.133"><vh>ASCIIReader.void ExpectChar</vh></v>
<v t="leo.20191228122646.134"><vh>ASCIIReader.bool TryString</vh></v>
<v t="leo.20191228122646.135"><vh>ASCIIReader.void ExpectString</vh></v>
<v t="leo.20191228122646.136"><vh>ASCIIReader.void SkipUntilEol</vh></v>
<v t="leo.20191228122646.137"><vh>ASCIIReader.double ReadFloatDecimal</vh></v>
<v t="leo.20191228122646.138"><vh>ASCIIReader.bool TryRegex</vh></v>
<v t="leo.20191228122646.139"><vh>ASCIIReader.void ExpectRegex</vh></v>
</v>
<v t="leo.20191228122646.140"><vh>static uint8_t (resource.cpp)</vh></v>
<v t="leo.20191228122646.141"><vh>void BitmapFont::AddGlyph (resource.cpp)</vh></v>
<v t="leo.20191228122646.142"><vh>const BitmapFont::Glyph (resource.cpp)</vh>
<v t="leo.20191228122646.143"><vh>auto first (resource.cpp)</vh></v>
</v>
<v t="leo.20191228122646.144"><vh>void BitmapFont::LocateGlyph (resource.cpp)</vh></v>
<v t="leo.20191228122646.145"><vh>void MakePwlArc (resource.cpp)</vh></v>
<v t="leo.20191228122646.146"><vh>void MakePwlBulge (resource.cpp)</vh></v>
<v t="leo.20191228122646.147"><vh>void GetGlyphBBox (resource.cpp)</vh></v>
<v t="leo.20191228122646.148"><vh>const VectorFont::Glyph (resource.cpp)</vh>
<v t="leo.20191228122646.149"><vh>auto first (resource.cpp)</vh></v>
</v>
<v t="leo.20191228122646.150"><vh>void VectorFont::Trace (resource.cpp)</vh></v>
<v t="leo.20191228122646.151"><vh>void VectorFont::Trace (resource.cpp)</vh></v>
<v t="leo.20191228122646.152"><vh>class PluralExpr</vh>
<v t="leo.20191228122646.153"><vh>class Token</vh></v>
</v>
<v t="leo.20191228122646.154"><vh>int PluralExpr::Token::Precedence (resource.cpp)</vh></v>
<v t="leo.20191228122646.155"><vh>void PluralExpr::Reduce (resource.cpp)</vh></v>
<v t="leo.20191228122646.156"><vh>void PluralExpr::Eval (resource.cpp)</vh></v>
<v t="leo.20191228122646.157"><vh>unsigned PluralExpr::Eval (resource.cpp)</vh></v>
<v t="leo.20191228122646.158"><vh>class TranslationKey</vh></v>
<v t="leo.20191228122646.159"><vh>bool operator (resource.cpp)</vh></v>
<v t="leo.20191228122646.160"><vh>class GettextParser</vh></v>
<v t="leo.20191228122646.161"><vh>void GettextParser::SkipSpace (resource.cpp)</vh></v>
<v t="leo.20191228122646.162"><vh>void GettextParser::ParseHeader (resource.cpp)</vh></v>
<v t="leo.20191228122646.163"><vh>void GettextParser::Parse (resource.cpp)</vh></v>
<v t="leo.20191228122646.164"><vh>class Translation</vh></v>
<v t="leo.20191228122646.165"><vh>const std::string (resource.cpp)</vh></v>
<v t="leo.20191228122646.166"><vh>const std::string (resource.cpp)</vh></v>
<v t="leo.20191228122646.167"><vh>const std::set (resource.cpp)</vh></v>
<v t="leo.20191228122646.168"><vh>bool SetLocale (resource.cpp)</vh></v>
<v t="leo.20191228122646.169"><vh>bool SetLocale (resource.cpp)</vh></v>
<v t="leo.20191228122646.170"><vh>bool SetLocale (resource.cpp)</vh></v>
<v t="leo.20191228122646.171"><vh>const std::string (resource.cpp)</vh></v>
<v t="leo.20191228122646.172"><vh>const std::string (resource.cpp)</vh></v>
<v t="leo.20191228122646.173"><vh>const std::string (resource.cpp)</vh></v>
<v t="leo.20191228122646.174"><vh>const std::string (resource.cpp)</vh></v>
</v>
<v t="leo.20191228122647.1"><vh>@clean resource.h</vh>
<v t="leo.20191228122647.2"><vh>class Pixmap</vh></v>
<v t="leo.20191228122647.3"><vh>class BitmapFont</vh>
<v t="leo.20191228122647.4"><vh>BitmapFont.void LocateGlyph</vh></v>
</v>
</v>
<v t="leo.20191228122647.5"><vh>@clean sketch.h</vh>
<v t="leo.20191228122647.6"><vh>class hGroup</vh></v>
<v t="leo.20191228122647.7"><vh>class hRequest</vh></v>
<v t="leo.20191228122647.8"><vh>class hEntity</vh></v>
<v t="leo.20191228122647.9"><vh>class hParam</vh></v>
<v t="leo.20191228122647.10"><vh>class hStyle</vh></v>
<v t="leo.20191228122647.11"><vh>bool operator (sketch.h)</vh></v>
<v t="leo.20191228122647.12"><vh>class Group</vh></v>
<v t="leo.20191228122647.13"><vh>class Request</vh>
<v t="leo.20191228122647.14"><vh>Request.void Clear</vh></v>
<v t="leo.20191228122647.15"><vh>Request.void Clear</vh></v>
<v t="leo.20191228122647.16"><vh>Request.void Clear</vh></v>
</v>
<v t="leo.20191228122647.17"><vh>class EntReqTable</vh>
<v t="leo.20191228122647.18"><vh>EntReqTable.bool GetRequestInfo</vh></v>
<v t="leo.20191228122647.19"><vh>EntReqTable.void Clear</vh></v>
</v>
<v t="leo.20191228122647.20"><vh>class ConstraintBase</vh>
<v t="leo.20191228122647.21"><vh>ConstraintBase.bool Equals</vh></v>
<v t="leo.20191228122647.22"><vh>ConstraintBase.void Clear</vh></v>
<v t="leo.20191228122647.23"><vh>ConstraintBase.static hConstraint</vh></v>
</v>
<v t="leo.20191228122647.24"><vh>class Equation</vh>
<v t="leo.20191228122647.25"><vh>Equation.void Clear</vh></v>
<v t="leo.20191228122647.26"><vh>Equation.typedef struct</vh></v>
</v>
<v t="leo.20191228122647.27"><vh>class ClipboardRequest</vh></v>
</v>
<v t="leo.20191228122647.28"><vh>@clean solvespace.cpp</vh>
<v t="leo.20191228122647.29"><vh>void SolveSpaceUI::Init (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.30"><vh>bool SolveSpaceUI::LoadAutosaveFor (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.31"><vh>bool SolveSpaceUI::Load (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.32"><vh>void SolveSpaceUI::Exit (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.33"><vh>void SolveSpaceUI::ScheduleGenerateAll (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.34"><vh>void SolveSpaceUI::ScheduleShowTW (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.35"><vh>void SolveSpaceUI::ScheduleAutosave (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.36"><vh>const char *SolveSpaceUI::UnitName() { (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.37"><vh>static const char *DimToString(int dim) { (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.38"><vh>static std::pair (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.39"><vh>static std::pair (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.40"><vh>int SolveSpaceUI::GetMaxSegments (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.41"><vh>int SolveSpaceUI::UnitDigitsAfterDecimal (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.42"><vh>void SolveSpaceUI::SetUnitDigitsAfterDecimal (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.43"><vh>void SolveSpaceUI::AfterNewFile (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.44"><vh>void SolveSpaceUI::AddToRecentList (solvespace.cpp)</vh>
<v t="leo.20191228122647.45"><vh>auto it (solvespace.cpp)</vh></v>
</v>
<v t="leo.20191228122647.46"><vh>bool SolveSpaceUI::GetFilenameAndSave (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.47"><vh>void SolveSpaceUI::Autosave (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.48"><vh>void SolveSpaceUI::RemoveAutosave (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.49"><vh>bool SolveSpaceUI::OkayToStartNewFile (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.50"><vh>void SolveSpaceUI::UpdateWindowTitles (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.51"><vh>void SolveSpaceUI::MenuFile (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.52"><vh>void SolveSpaceUI::MenuAnalyze (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.53"><vh>void SolveSpaceUI::ShowNakedEdges (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.54"><vh>void SolveSpaceUI::MenuHelp (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.55"><vh>void SolveSpaceUI::Clear (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.56"><vh>void Sketch::Clear (solvespace.cpp)</vh></v>
<v t="leo.20191228122647.57"><vh>auto includePoint (solvespace.cpp)</vh></v>
</v>
<v t="leo.20191228122647.58"><vh>@clean solvespace.h</vh>
<v t="leo.20191228122647.59"><vh>void AssertFailure (solvespace.h)</vh></v>
<v t="leo.20191228122647.60"><vh>class utf8_iterator</vh></v>
<v t="leo.20191228122647.61"><vh>class ReadUTF8</vh></v>
<v t="leo.20191228122647.62"><vh>class System</vh>
<v t="leo.20191228122647.63"><vh>class StepFileWriter</vh></v>
</v>
<v t="leo.20191228122647.64"><vh>class VectorFileWriter</vh></v>
<v t="leo.20191228122647.65"><vh>class DxfFileWriter</vh></v>
<v t="leo.20191228122647.66"><vh>class EpsFileWriter</vh>
<v t="leo.20191228122647.67"><vh>class PdfFileWriter</vh>
<v t="leo.20191228122647.68"><vh>class SvgFileWriter</vh>
<v t="leo.20191228122647.69"><vh>class HpglFileWriter</vh>
<v t="leo.20191228122647.70"><vh>class Step2dFileWriter</vh>
<v t="leo.20191228122647.71"><vh>class GCodeFileWriter</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="leo.20191228122647.72"><vh>class Sketch</vh></v>
<v t="leo.20191228122647.73"><vh>class SolveSpaceUI</vh>
<v t="leo.20191228122647.74"><vh>SolveSpaceUI.typedef struct</vh>
<v t="leo.20191228122647.75"><vh>SolveSpaceUI.void Clear</vh></v>
</v>
<v t="leo.20191228122647.76"><vh>SolveSpaceUI.typedef struct</vh></v>
<v t="leo.20191228122647.77"><vh>SolveSpaceUI.typedef struct</vh></v>
<v t="leo.20191228122647.78"><vh>class Clipboard</vh></v>
</v>
</v>
<v t="leo.20191228122647.79"><vh>@clean style.cpp</vh>
<v t="leo.20191228122647.80"><vh>const Style::Default (style.cpp)</vh></v>
<v t="leo.20191228122647.81"><vh>void Style::CreateAllDefaultStyles (style.cpp)</vh></v>
<v t="leo.20191228122647.82"><vh>void Style::CreateDefaultStyle (style.cpp)</vh></v>
<v t="leo.20191228122647.83"><vh>void Style::FillDefaultStyle (style.cpp)</vh></v>
<v t="leo.20191228122647.84"><vh>void Style::LoadFactoryDefaults (style.cpp)</vh></v>
<v t="leo.20191228122647.85"><vh>void Style::FreezeDefaultStyles (style.cpp)</vh></v>
<v t="leo.20191228122647.86"><vh>void Style::AssignSelectionToStyle (style.cpp)</vh></v>
<v t="leo.20191228122647.87"><vh>bool Style::Exportable (style.cpp)</vh></v>
<v t="leo.20191228122647.88"><vh>void TextWindow::ScreenShowListOfStyles (style.cpp)</vh></v>
<v t="leo.20191228122647.89"><vh>void TextWindow::ScreenShowStyleInfo (style.cpp)</vh></v>
<v t="leo.20191228122647.90"><vh>void TextWindow::ScreenLoadFactoryDefaultStyles (style.cpp)</vh></v>
<v t="leo.20191228122647.91"><vh>void TextWindow::ScreenCreateCustomStyle (style.cpp)</vh></v>
<v t="leo.20191228122647.92"><vh>void TextWindow::ScreenChangeBackgroundColor (style.cpp)</vh></v>
<v t="leo.20191228122647.93"><vh>void TextWindow::ShowListOfStyles (style.cpp)</vh></v>
<v t="leo.20191228122647.94"><vh>void TextWindow::ScreenChangeStyleName (style.cpp)</vh></v>
<v t="leo.20191228122647.95"><vh>void TextWindow::ScreenDeleteStyle (style.cpp)</vh></v>
<v t="leo.20191228122647.96"><vh>void TextWindow::ScreenChangeStylePatternType (style.cpp)</vh></v>
<v t="leo.20191228122647.97"><vh>void TextWindow::ScreenChangeStyleMetric (style.cpp)</vh></v>
<v t="leo.20191228122647.98"><vh>void TextWindow::ScreenChangeStyleTextAngle (style.cpp)</vh></v>
<v t="leo.20191228122647.99"><vh>void TextWindow::ScreenChangeStyleColor (style.cpp)</vh></v>
<v t="leo.20191228122647.100"><vh>void TextWindow::ScreenChangeStyleYesNo (style.cpp)</vh></v>
<v t="leo.20191228122647.101"><vh>bool TextWindow::EditControlDoneForStyles (style.cpp)</vh></v>
<v t="leo.20191228122647.102"><vh>void TextWindow::ShowStyleInfo (style.cpp)</vh>
<v t="leo.20191228122647.103"><vh>const char *patternsSource[patternCount] = { (style.cpp)</vh></v>
</v>
<v t="leo.20191228122647.104"><vh>void TextWindow::ScreenAssignSelectionToStyle (style.cpp)</vh></v>
</v>
<v t="leo.20191228122647.105"><vh>@clean system.cpp</vh>
<v t="leo.20191228122647.106"><vh>bool System::WriteJacobian (system.cpp)</vh></v>
<v t="leo.20191228122647.107"><vh>void System::EvalJacobian (system.cpp)</vh></v>
<v t="leo.20191228122647.108"><vh>bool System::IsDragged (system.cpp)</vh></v>
<v t="leo.20191228122647.109"><vh>void System::SolveBySubstitution (system.cpp)</vh></v>
<v t="leo.20191228122647.110"><vh>int System::CalculateRank (system.cpp)</vh></v>
<v t="leo.20191228122647.111"><vh>bool System::TestRank (system.cpp)</vh></v>
<v t="leo.20191228122647.112"><vh>bool System::SolveLinearSystem (system.cpp)</vh></v>
<v t="leo.20191228122647.113"><vh>bool System::SolveLeastSquares (system.cpp)</vh></v>
<v t="leo.20191228122647.114"><vh>bool System::NewtonSolve (system.cpp)</vh></v>
<v t="leo.20191228122647.115"><vh>void System::WriteEquationsExceptFor (system.cpp)</vh></v>
<v t="leo.20191228122647.116"><vh>void System::FindWhichToRemoveToFixJacobian (system.cpp)</vh></v>
<v t="leo.20191228122647.117"><vh>bool andFindBad (system.cpp)</vh></v>
<v t="leo.20191228122647.118"><vh>bool andFindBad (system.cpp)</vh></v>
<v t="leo.20191228122647.119"><vh>void System::Clear (system.cpp)</vh></v>
<v t="leo.20191228122647.120"><vh>void System::MarkParamsFree (system.cpp)</vh></v>
<v t="leo.20191228122647.121"><vh>int System::CalculateDof (system.cpp)</vh></v>
</v>
<v t="leo.20191228122647.122"><vh>@clean textscreens.cpp</vh>
<v t="leo.20191228122647.123"><vh>void TextWindow::ScreenHome (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.124"><vh>void TextWindow::ShowHeader (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.125"><vh>void TextWindow::ScreenSelectGroup (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.126"><vh>void TextWindow::ScreenToggleGroupShown (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.127"><vh>void TextWindow::ScreenShowGroupsSpecial (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.128"><vh>void TextWindow::ScreenActivateGroup (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.129"><vh>void TextWindow::ReportHowGroupSolved (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.130"><vh>void TextWindow::ScreenHowGroupSolved (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.131"><vh>void TextWindow::ScreenShowConfiguration (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.132"><vh>void TextWindow::ScreenShowEditView (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.133"><vh>void TextWindow::ScreenGoToWebsite (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.134"><vh>void TextWindow::ShowListOfGroups (textscreens.cpp)</vh>
<v t="leo.20191228122647.135"><vh>const char *radioTrue  = " " RADIO_TRUE  " ", Printf (textscreens.cpp)</vh>
<v t="leo.20191228122647.136"><vh>bool warn (textscreens.cpp)</vh></v>
</v>
</v>
<v t="leo.20191228122647.137"><vh>void TextWindow::ScreenHoverConstraint (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.138"><vh>void TextWindow::ScreenHoverRequest (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.139"><vh>void TextWindow::ScreenSelectConstraint (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.140"><vh>void TextWindow::ScreenSelectRequest (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.141"><vh>void TextWindow::ScreenChangeGroupOption (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.142"><vh>void TextWindow::ScreenColor (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.143"><vh>void TextWindow::ScreenOpacity (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.144"><vh>void TextWindow::ScreenChangeExprA (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.145"><vh>void TextWindow::ScreenChangeGroupName (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.146"><vh>void TextWindow::ScreenChangeGroupScale (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.147"><vh>void TextWindow::ScreenDeleteGroup (textscreens.cpp)</vh></v>
<v t="leo.20191228122647.148"><vh>void TextWindow::ShowGroupInfo (textscreens.cpp)</vh></v>
<v t="leo.20191228122648.1"><vh>void TextWindow::ScreenAllowRedundant (textscreens.cpp)</vh></v>
<v t="leo.20191228122648.2"><vh>void TextWindow::ShowGroupSolveInfo (textscreens.cpp)</vh></v>
<v t="leo.20191228122648.3"><vh>void TextWindow::ScreenStepDimFinish (textscreens.cpp)</vh></v>
<v t="leo.20191228122648.4"><vh>void TextWindow::ScreenStepDimSteps (textscreens.cpp)</vh></v>
<v t="leo.20191228122648.5"><vh>void TextWindow::ScreenStepDimGo (textscreens.cpp)</vh></v>
<v t="leo.20191228122648.6"><vh>void TextWindow::ShowStepDimension (textscreens.cpp)</vh></v>
<v t="leo.20191228122648.7"><vh>void TextWindow::ScreenChangeTangentArc (textscreens.cpp)</vh></v>
<v t="leo.20191228122648.8"><vh>void TextWindow::ShowTangentArc (textscreens.cpp)</vh></v>
<v t="leo.20191228122648.9"><vh>void TextWindow::EditControlDone (textscreens.cpp)</vh></v>
</v>
<v t="leo.20191228122648.10"><vh>@clean textwin.cpp</vh>
<v t="leo.20191228122648.11"><vh>class Button</vh></v>
<v t="leo.20191228122648.12"><vh>class SpacerButton</vh>
<v t="leo.20191228122648.13"><vh>SpacerButton.void Draw</vh></v>
<v t="leo.20191228122648.14"><vh>SpacerButton.void Click</vh></v>
<v t="leo.20191228122648.15"><vh>SpacerButton.void Draw</vh></v>
</v>
<v t="leo.20191228122648.16"><vh>class FacesButton</vh></v>
<v t="leo.20191228122648.17"><vh>class OccludedLinesButton</vh>
<v t="leo.20191228122648.18"><vh>OccludedLinesButton.void Draw</vh></v>
<v t="leo.20191228122648.19"><vh>OccludedLinesButton.void Click</vh></v>
</v>
<v t="leo.20191228122648.20"><vh>const TextWindow::Color (textwin.cpp)</vh></v>
<v t="leo.20191228122648.21"><vh>const TextWindow::Color (textwin.cpp)</vh></v>
<v t="leo.20191228122648.22"><vh>void TextWindow::MakeColorTable (textwin.cpp)</vh></v>
<v t="leo.20191228122648.23"><vh>void TextWindow::Init (textwin.cpp)</vh></v>
<v t="leo.20191228122648.24"><vh>void TextWindow::ClearSuper (textwin.cpp)</vh></v>
<v t="leo.20191228122648.25"><vh>void TextWindow::HideEditControl (textwin.cpp)</vh></v>
<v t="leo.20191228122648.26"><vh>void TextWindow::ShowEditControl (textwin.cpp)</vh></v>
<v t="leo.20191228122648.27"><vh>void TextWindow::ShowEditControlWithColorPicker (textwin.cpp)</vh></v>
<v t="leo.20191228122648.28"><vh>void TextWindow::ClearScreen (textwin.cpp)</vh></v>
<v t="leo.20191228122648.29"><vh>void TextWindow::Printf (textwin.cpp)</vh></v>
<v t="leo.20191228122648.30"><vh>void TextWindow::Show (textwin.cpp)</vh></v>
<v t="leo.20191228122648.31"><vh>void TextWindow::Resize (textwin.cpp)</vh></v>
<v t="leo.20191228122648.32"><vh>void TextWindow::DrawOrHitTestIcons (textwin.cpp)</vh></v>
<v t="leo.20191228122648.33"><vh>void TextWindow::ColorPickerDone (textwin.cpp)</vh></v>
<v t="leo.20191228122648.34"><vh>bool TextWindow::DrawOrHitTestColorPicker (textwin.cpp)</vh>
<v t="leo.20191228122648.35"><vh>const RgbaColor (textwin.cpp)</vh></v>
<v t="leo.20191228122648.36"><vh>int pxm (textwin.cpp)</vh></v>
</v>
<v t="leo.20191228122648.37"><vh>void TextWindow::Paint (textwin.cpp)</vh></v>
<v t="leo.20191228122648.38"><vh>void TextWindow::MouseEvent (textwin.cpp)</vh></v>
<v t="leo.20191228122648.39"><vh>void TextWindow::MouseLeave (textwin.cpp)</vh></v>
<v t="leo.20191228122648.40"><vh>void TextWindow::ScrollbarEvent (textwin.cpp)</vh></v>
</v>
<v t="leo.20191228122648.41"><vh>@clean toolbar.cpp</vh>
<v t="leo.20191228122648.42"><vh>static ToolIcon (toolbar.cpp)</vh></v>
<v t="leo.20191228122648.43"><vh>void GraphicsWindow::ToolbarDraw (toolbar.cpp)</vh></v>
<v t="leo.20191228122648.44"><vh>bool GraphicsWindow::ToolbarMouseMoved (toolbar.cpp)</vh></v>
<v t="leo.20191228122648.45"><vh>bool GraphicsWindow::ToolbarMouseDown (toolbar.cpp)</vh></v>
<v t="leo.20191228122648.46"><vh>bool GraphicsWindow::ToolbarDrawOrHitTest (toolbar.cpp)</vh>
<v t="leo.20191228122648.47"><vh>bool withinToolbar (toolbar.cpp)</vh></v>
</v>
</v>
<v t="leo.20191228122648.48"><vh>@clean ttf.cpp</vh>
<v t="leo.20191228122648.49"><vh>const struct (ttf.cpp)</vh></v>
<v t="leo.20191228122648.50"><vh>extern "C" const char *ft_error_string(int err) { (ttf.cpp)</vh></v>
<v t="leo.20191228122648.51"><vh>void TtfFontList::LoadAll (ttf.cpp)</vh></v>
<v t="leo.20191228122648.52"><vh>void TtfFontList::PlotString (ttf.cpp)</vh></v>
<v t="leo.20191228122648.53"><vh>void TtfFont::SetResourceID (ttf.cpp)</vh></v>
<v t="leo.20191228122648.54"><vh>bool TtfFont::IsResource (ttf.cpp)</vh></v>
<v t="leo.20191228122648.55"><vh>bool TtfFont::LoadFromFile (ttf.cpp)</vh></v>
<v t="leo.20191228122648.56"><vh>bool TtfFont::LoadFromResource (ttf.cpp)</vh>
<v t="leo.20191228122648.57"><vh>const void *_buffer = Platform::LoadResource(fontFile.raw.substr(6, fontFile.raw.size()), FT_Long (ttf.cpp)</vh></v>
</v>
<v t="leo.20191228122648.58"><vh>bool TtfFont::ExtractTTFData (ttf.cpp)</vh></v>
<v t="leo.20191228122648.59"><vh>typedef struct (ttf.cpp)</vh></v>
<v t="leo.20191228122648.60"><vh>static Vector (ttf.cpp)</vh></v>
<v t="leo.20191228122648.61"><vh>int MoveTo (ttf.cpp)</vh></v>
<v t="leo.20191228122648.62"><vh>int LineTo (ttf.cpp)</vh></v>
<v t="leo.20191228122648.63"><vh>int ConicTo (ttf.cpp)</vh></v>
<v t="leo.20191228122648.64"><vh>int CubicTo (ttf.cpp)</vh></v>
<v t="leo.20191228122648.65"><vh>void TtfFont::PlotString (ttf.cpp)</vh></v>
</v>
<v t="leo.20191228122648.66"><vh>@clean ttf.h</vh>
<v t="leo.20191228122648.67"><vh>class TtfFont</vh>
<v t="leo.20191228122648.68"><vh>TtfFont.void PlotString</vh></v>
</v>
</v>
<v t="leo.20191228122648.69"><vh>@clean ui.h</vh>
<v t="leo.20191228122648.70"><vh>class Locale</vh></v>
<v t="leo.20191228122648.71"><vh>bool operator (ui.h)</vh></v>
<v t="leo.20191228122648.72"><vh>class TextWindow</vh>
<v t="leo.20191228122648.73"><vh>TextWindow.typedef struct</vh></v>
<v t="leo.20191228122648.74"><vh>TextWindow.typedef struct</vh></v>
</v>
<v t="leo.20191228122648.75"><vh>class GraphicsWindow</vh>
<v t="leo.20191228122648.76"><vh>class ParametricCurve</vh></v>
<v t="leo.20191228122648.77"><vh>class Selection</vh></v>
<v t="leo.20191228122648.78"><vh>class Hover</vh></v>
</v>
</v>
<v t="leo.20191228122648.79"><vh>@clean undoredo.cpp</vh>
<v t="leo.20191228122648.80"><vh>void SolveSpaceUI::UndoRemember (undoredo.cpp)</vh></v>
<v t="leo.20191228122648.81"><vh>void SolveSpaceUI::UndoUndo (undoredo.cpp)</vh></v>
<v t="leo.20191228122648.82"><vh>void SolveSpaceUI::UndoRedo (undoredo.cpp)</vh></v>
<v t="leo.20191228122648.83"><vh>void SolveSpaceUI::UndoEnableMenus (undoredo.cpp)</vh></v>
<v t="leo.20191228122648.84"><vh>void SolveSpaceUI::PushFromCurrentOnto (undoredo.cpp)</vh></v>
<v t="leo.20191228122648.85"><vh>void SolveSpaceUI::PopOntoCurrentFrom (undoredo.cpp)</vh></v>
<v t="leo.20191228122648.86"><vh>void SolveSpaceUI::UndoClearStack (undoredo.cpp)</vh></v>
<v t="leo.20191228122648.87"><vh>void SolveSpaceUI::UndoClearState (undoredo.cpp)</vh></v>
</v>
<v t="leo.20191228122648.88"><vh>@clean util.cpp</vh>
<v t="leo.20191228122648.89"><vh>void SolveSpace::AssertFailure (util.cpp)</vh></v>
<v t="leo.20191228122648.90"><vh>char 32_t (util.cpp)</vh></v>
<v t="leo.20191228122648.91"><vh>int 64_t (util.cpp)</vh></v>
<v t="leo.20191228122648.92"><vh>void SolveSpace::MakeMatrix (util.cpp)</vh></v>
<v t="leo.20191228122648.93"><vh>void SolveSpace::MultMatrix (util.cpp)</vh></v>
<v t="leo.20191228122648.94"><vh>void MessageBox (util.cpp)</vh></v>
<v t="leo.20191228122648.95"><vh>void SolveSpace::Error (util.cpp)</vh></v>
<v t="leo.20191228122648.96"><vh>void SolveSpace::Message (util.cpp)</vh></v>
<v t="leo.20191228122648.97"><vh>void SolveSpace::MessageAndRun (util.cpp)</vh></v>
<v t="leo.20191228122648.98"><vh>void BandedMatrix::Solve (util.cpp)</vh></v>
<v t="leo.20191228122648.99"><vh>bool Vector::EqualsExactly (util.cpp)</vh></v>
<v t="leo.20191228122648.100"><vh>bool Vector::OnLineSegment (util.cpp)</vh></v>
<v t="leo.20191228122648.101"><vh>void Vector::MakeMaxMin (util.cpp)</vh></v>
<v t="leo.20191228122648.102"><vh>bool Vector::OutsideAndNotOn (util.cpp)</vh></v>
<v t="leo.20191228122648.103"><vh>bool Vector::BoundingBoxesDisjoint (util.cpp)</vh></v>
<v t="leo.20191228122648.104"><vh>bool Vector::BoundingBoxIntersectsLine (util.cpp)</vh></v>
<v t="leo.20191228122648.105"><vh>double det2 (util.cpp)</vh></v>
<v t="leo.20191228122648.106"><vh>double det3 (util.cpp)</vh></v>
<v t="leo.20191228122648.107"><vh>double det (util.cpp)</vh></v>
<v t="leo.20191228122648.108"><vh>bool VectorPred::operator (util.cpp)</vh></v>
<v t="leo.20191228122648.109"><vh>bool Point2d::Equals (util.cpp)</vh></v>
<v t="leo.20191228122648.110"><vh>void BBox::Include (util.cpp)</vh></v>
<v t="leo.20191228122648.111"><vh>bool BBox::Overlaps (util.cpp)</vh></v>
<v t="leo.20191228122648.112"><vh>bool BBox::Contains (util.cpp)</vh></v>
<v t="leo.20191228122648.113"><vh>const std::vector (util.cpp)</vh></v>
</v>
<v t="leo.20191228122648.114"><vh>@clean view.cpp</vh>
<v t="leo.20191228122648.115"><vh>void TextWindow::ShowEditView (view.cpp)</vh></v>
<v t="leo.20191228122648.116"><vh>void TextWindow::ScreenChangeViewScale (view.cpp)</vh></v>
<v t="leo.20191228122648.117"><vh>void TextWindow::ScreenChangeViewToFullScale (view.cpp)</vh></v>
<v t="leo.20191228122648.118"><vh>void TextWindow::ScreenChangeViewOrigin (view.cpp)</vh></v>
<v t="leo.20191228122648.119"><vh>void TextWindow::ScreenChangeViewProjection (view.cpp)</vh></v>
<v t="leo.20191228122648.120"><vh>bool TextWindow::EditControlDoneForView (view.cpp)</vh></v>
</v>
<v t="leo.20191228122648.121"><vh>@path platform</vh>
<v t="leo.20191228122648.122"><vh>@clean entrycli.cpp</vh>
<v t="leo.20191228122648.123"><vh>void ShowUsage (entrycli.cpp)</vh>
<v t="leo.20191228122648.124"><vh>auto FormatListFromFileFilters (entrycli.cpp)</vh></v>
</v>
<v t="leo.20191228122648.125"><vh>bool RunCommand (entrycli.cpp)</vh>
<v t="leo.20191228122648.126"><vh>auto ParseInputFile (entrycli.cpp)</vh></v>
<v t="leo.20191228122648.127"><vh>auto ParseOutputPattern (entrycli.cpp)</vh></v>
<v t="leo.20191228122648.128"><vh>auto ParseViewDirection (entrycli.cpp)</vh></v>
<v t="leo.20191228122648.129"><vh>auto ParseChordTolerance (entrycli.cpp)</vh></v>
<v t="leo.20191228122648.130"><vh>auto ParseSize (entrycli.cpp)</vh></v>
</v>
<v t="leo.20191228122648.131"><vh>int main (entrycli.cpp)</vh></v>
</v>
<v t="leo.20191228122649.1"><vh>@clean entrygui.cpp</vh>
<v t="leo.20191228122649.2"><vh>int main (entrygui.cpp)</vh></v>
<v t="leo.20191228122649.3"><vh>int WINAPI (entrygui.cpp)</vh></v>
</v>
<v t="leo.20191228122649.4"><vh>@clean gui.cpp</vh>
<v t="leo.20191228122649.5"><vh>void Settings::FreezeBool (gui.cpp)</vh></v>
<v t="leo.20191228122649.6"><vh>bool Settings::ThawBool (gui.cpp)</vh></v>
<v t="leo.20191228122649.7"><vh>void Settings::FreezeColor (gui.cpp)</vh></v>
<v t="leo.20191228122649.8"><vh>void FileDialog::AddFilter (gui.cpp)</vh></v>
<v t="leo.20191228122649.9"><vh>void FileDialog::AddFilters (gui.cpp)</vh></v>
</v>
<v t="leo.20191228122649.10"><vh>@clean gui.h</vh>
<v t="leo.20191228122649.11"><vh>class MouseEvent</vh></v>
<v t="leo.20191228122649.12"><vh>bool Equals (gui.h)</vh></v>
<v t="leo.20191228122649.13"><vh>class Settings</vh></v>
<v t="leo.20191228122649.14"><vh>class Timer</vh></v>
<v t="leo.20191228122649.15"><vh>class MenuItem</vh></v>
<v t="leo.20191228122649.16"><vh>class Menu</vh>
<v t="leo.20191228122649.17"><vh>class MenuBar</vh></v>
</v>
<v t="leo.20191228122649.18"><vh>class Window</vh></v>
<v t="leo.20191228122649.19"><vh>class MessageDialog</vh></v>
<v t="leo.20191228122649.20"><vh>class FileDialog</vh></v>
</v>
<v t="leo.20191228122649.21"><vh>@clean guigtk.cpp</vh>
<v t="leo.20191228122649.22"><vh>static std::string (guigtk.cpp)</vh></v>
<v t="leo.20191228122649.23"><vh>static std::string (guigtk.cpp)</vh></v>
<v t="leo.20191228122649.24"><vh>void FatalError (guigtk.cpp)</vh></v>
<v t="leo.20191228122649.25"><vh>class SettingsImplGtk</vh>
<v t="leo.20191228122649.26"><vh>SettingsImplGtk.static Path</vh></v>
<v t="leo.20191228122649.27"><vh>SettingsImplGtk.void FreezeInt</vh></v>
<v t="leo.20191228122649.28"><vh>SettingsImplGtk.void FreezeBool</vh></v>
<v t="leo.20191228122649.29"><vh>SettingsImplGtk.bool ThawBool</vh></v>
<v t="leo.20191228122649.30"><vh>SettingsImplGtk.void FreezeFloat</vh></v>
<v t="leo.20191228122649.31"><vh>SettingsImplGtk.double ThawFloat</vh></v>
<v t="leo.20191228122649.32"><vh>SettingsImplGtk.void FreezeString</vh></v>
<v t="leo.20191228122649.33"><vh>SettingsImplGtk.const std::string</vh></v>
</v>
<v t="leo.20191228122649.34"><vh>class TimerImplGtk</vh>
<v t="leo.20191228122649.35"><vh>TimerImplGtk.void RunAfter</vh>
<v t="leo.20191228122649.36"><vh>TimerImplGtk.auto handler</vh></v>
</v>
</v>
<v t="leo.20191228122649.37"><vh>class GtkMenuItem</vh>
<v t="leo.20191228122649.38"><vh>GtkMenuItem.void set_accel_key</vh></v>
<v t="leo.20191228122649.39"><vh>GtkMenuItem.bool has_indicator</vh></v>
<v t="leo.20191228122649.40"><vh>GtkMenuItem.void set_has_indicator</vh></v>
<v t="leo.20191228122649.41"><vh>GtkMenuItem.void set_active</vh></v>
<v t="leo.20191228122649.42"><vh>GtkMenuItem.void on_activate</vh></v>
<v t="leo.20191228122649.43"><vh>GtkMenuItem.void draw_indicator_vfunc</vh></v>
</v>
<v t="leo.20191228122649.44"><vh>class MenuItemImplGtk</vh>
<v t="leo.20191228122649.45"><vh>MenuItemImplGtk.void SetAccelerator</vh></v>
<v t="leo.20191228122649.46"><vh>MenuItemImplGtk.void SetIndicator</vh></v>
<v t="leo.20191228122649.47"><vh>MenuItemImplGtk.void SetActive</vh></v>
<v t="leo.20191228122649.48"><vh>MenuItemImplGtk.void SetEnabled</vh></v>
</v>
<v t="leo.20191228122649.49"><vh>class MenuImplGtk</vh>
<v t="leo.20191228122649.50"><vh>MenuImplGtk.bool mnemonics</vh></v>
<v t="leo.20191228122649.51"><vh>MenuImplGtk.void AddSeparator</vh></v>
<v t="leo.20191228122649.52"><vh>MenuImplGtk.void PopUp</vh></v>
<v t="leo.20191228122649.53"><vh>MenuImplGtk.void Clear</vh></v>
</v>
<v t="leo.20191228122649.54"><vh>class MenuBarImplGtk</vh>
<v t="leo.20191228122649.55"><vh>MenuBarImplGtk.void Clear</vh></v>
</v>
<v t="leo.20191228122649.56"><vh>class GtkGLWidget</vh>
<v t="leo.20191228122649.57"><vh>GtkGLWidget.bool on_render</vh></v>
<v t="leo.20191228122649.58"><vh>GtkGLWidget.bool process_pointer_event</vh></v>
<v t="leo.20191228122649.59"><vh>GtkGLWidget.bool on_motion_notify_event</vh></v>
<v t="leo.20191228122649.60"><vh>GtkGLWidget.bool on_button_press_event</vh></v>
<v t="leo.20191228122649.61"><vh>GtkGLWidget.bool on_button_release_event</vh></v>
<v t="leo.20191228122649.62"><vh>GtkGLWidget.bool on_scroll_event</vh></v>
<v t="leo.20191228122649.63"><vh>GtkGLWidget.bool on_leave_notify_event</vh></v>
<v t="leo.20191228122649.64"><vh>GtkGLWidget.bool process_key_event</vh></v>
<v t="leo.20191228122649.65"><vh>GtkGLWidget.bool on_key_press_event</vh></v>
<v t="leo.20191228122649.66"><vh>GtkGLWidget.bool on_key_release_event</vh></v>
</v>
<v t="leo.20191228122649.67"><vh>class GtkEditorOverlay</vh>
<v t="leo.20191228122649.68"><vh>GtkEditorOverlay.bool is_editing</vh></v>
<v t="leo.20191228122649.69"><vh>GtkEditorOverlay.void start_editing</vh></v>
<v t="leo.20191228122649.70"><vh>GtkEditorOverlay.void stop_editing</vh></v>
<v t="leo.20191228122649.71"><vh>GtkEditorOverlay.bool on_key_press_event</vh></v>
<v t="leo.20191228122649.72"><vh>GtkEditorOverlay.bool on_key_release_event</vh></v>
<v t="leo.20191228122649.73"><vh>GtkEditorOverlay.void on_size_allocate</vh></v>
<v t="leo.20191228122649.74"><vh>GtkEditorOverlay.void on_activate</vh></v>
</v>
<v t="leo.20191228122649.75"><vh>class GtkWindow</vh>
<v t="leo.20191228122649.76"><vh>GtkWindow.bool is_full_screen</vh></v>
<v t="leo.20191228122649.77"><vh>GtkWindow.void set_menu_bar</vh></v>
<v t="leo.20191228122649.78"><vh>GtkWindow.void set_tooltip</vh></v>
<v t="leo.20191228122649.79"><vh>GtkWindow.bool on_query_tooltip</vh></v>
<v t="leo.20191228122649.80"><vh>GtkWindow.bool on_enter_notify_event</vh></v>
<v t="leo.20191228122649.81"><vh>GtkWindow.bool on_leave_notify_event</vh></v>
<v t="leo.20191228122649.82"><vh>GtkWindow.bool on_delete_event</vh></v>
<v t="leo.20191228122649.83"><vh>GtkWindow.bool on_window_state_event</vh></v>
<v t="leo.20191228122649.84"><vh>GtkWindow.void on_scrollbar_value_changed</vh></v>
</v>
<v t="leo.20191228122649.85"><vh>class WindowImplGtk</vh>
<v t="leo.20191228122649.86"><vh>WindowImplGtk.auto gdkIcon</vh></v>
<v t="leo.20191228122649.87"><vh>WindowImplGtk.int GetDevicePixelRatio</vh></v>
<v t="leo.20191228122649.88"><vh>WindowImplGtk.bool IsVisible</vh></v>
<v t="leo.20191228122649.89"><vh>WindowImplGtk.void SetVisible</vh></v>
<v t="leo.20191228122649.90"><vh>WindowImplGtk.void Focus</vh></v>
<v t="leo.20191228122649.91"><vh>WindowImplGtk.bool IsFullScreen</vh></v>
<v t="leo.20191228122649.92"><vh>WindowImplGtk.void SetFullScreen</vh></v>
<v t="leo.20191228122649.93"><vh>WindowImplGtk.void SetTitle</vh></v>
<v t="leo.20191228122649.94"><vh>WindowImplGtk.void SetMenuBar</vh></v>
<v t="leo.20191228122649.95"><vh>WindowImplGtk.void GetContentSize</vh></v>
<v t="leo.20191228122649.96"><vh>WindowImplGtk.void SetMinContentSize</vh></v>
<v t="leo.20191228122649.97"><vh>WindowImplGtk.void FreezePosition</vh></v>
<v t="leo.20191228122649.98"><vh>WindowImplGtk.void ThawPosition</vh></v>
<v t="leo.20191228122649.99"><vh>WindowImplGtk.void SetCursor</vh></v>
<v t="leo.20191228122649.100"><vh>WindowImplGtk.void SetTooltip</vh></v>
<v t="leo.20191228122649.101"><vh>WindowImplGtk.bool IsEditorVisible</vh></v>
<v t="leo.20191228122649.102"><vh>WindowImplGtk.void ShowEditor</vh></v>
<v t="leo.20191228122649.103"><vh>WindowImplGtk.void HideEditor</vh></v>
<v t="leo.20191228122649.104"><vh>WindowImplGtk.void SetScrollbarVisible</vh></v>
<v t="leo.20191228122649.105"><vh>WindowImplGtk.void ConfigureScrollbar</vh></v>
<v t="leo.20191228122649.106"><vh>WindowImplGtk.double GetScrollbarPosition</vh></v>
<v t="leo.20191228122649.107"><vh>WindowImplGtk.void SetScrollbarPosition</vh></v>
<v t="leo.20191228122649.108"><vh>WindowImplGtk.void Invalidate</vh></v>
</v>
<v t="leo.20191228122649.109"><vh>void Open3DConnexion (guigtk.cpp)</vh></v>
<v t="leo.20191228122649.110"><vh>void Request3DConnexionEventsForWindow (guigtk.cpp)</vh></v>
<v t="leo.20191228122649.111"><vh>class MessageDialogImplGtk</vh>
<v t="leo.20191228122649.112"><vh>MessageDialogImplGtk.void SetType</vh></v>
<v t="leo.20191228122649.113"><vh>MessageDialogImplGtk.void SetTitle</vh></v>
<v t="leo.20191228122649.114"><vh>MessageDialogImplGtk.void SetMessage</vh></v>
<v t="leo.20191228122649.115"><vh>MessageDialogImplGtk.void SetDescription</vh></v>
<v t="leo.20191228122649.116"><vh>MessageDialogImplGtk.void AddButton</vh></v>
<v t="leo.20191228122649.117"><vh>MessageDialogImplGtk.void ShowModal</vh>
<v t="leo.20191228122649.118"><vh>MessageDialogImplGtk.auto it</vh></v>
</v>
</v>
<v t="leo.20191228122649.119"><vh>class FileDialogImplGtk</vh>
<v t="leo.20191228122649.120"><vh>FileDialogImplGtk.void InitFileChooser</vh></v>
<v t="leo.20191228122649.121"><vh>FileDialogImplGtk.void SetCurrentName</vh></v>
<v t="leo.20191228122649.122"><vh>FileDialogImplGtk.void SetFilename</vh></v>
<v t="leo.20191228122649.123"><vh>FileDialogImplGtk.void AddFilter</vh></v>
<v t="leo.20191228122649.124"><vh>FileDialogImplGtk.void SetExtension</vh></v>
<v t="leo.20191228122649.125"><vh>FileDialogImplGtk.void FilterChanged</vh></v>
<v t="leo.20191228122649.126"><vh>FileDialogImplGtk.void FreezeChoices</vh></v>
<v t="leo.20191228122649.127"><vh>FileDialogImplGtk.void ThawChoices</vh></v>
<v t="leo.20191228122649.128"><vh>FileDialogImplGtk.void CheckForUntitledFile</vh></v>
</v>
<v t="leo.20191228122649.129"><vh>class FileDialogGtkImplGtk</vh>
<v t="leo.20191228122649.130"><vh>FileDialogGtkImplGtk.void SetTitle</vh></v>
<v t="leo.20191228122649.131"><vh>FileDialogGtkImplGtk.bool RunModal</vh></v>
</v>
<v t="leo.20191228122649.132"><vh>class FileDialogNativeImplGtk</vh>
<v t="leo.20191228122649.133"><vh>FileDialogNativeImplGtk.void SetTitle</vh></v>
<v t="leo.20191228122649.134"><vh>FileDialogNativeImplGtk.bool RunModal</vh></v>
</v>
<v t="leo.20191228122649.135"><vh>void OpenInBrowser (guigtk.cpp)</vh></v>
<v t="leo.20191228122649.136"><vh>void InitGui (guigtk.cpp)</vh></v>
<v t="leo.20191228122649.137"><vh>void RunGui (guigtk.cpp)</vh></v>
<v t="leo.20191228122649.138"><vh>void ExitGui (guigtk.cpp)</vh></v>
<v t="leo.20191228122649.139"><vh>void ClearGui (guigtk.cpp)</vh></v>
</v>
<v t="leo.20191228122649.140"><vh>@clean guinone.cpp</vh>
<v t="leo.20191228122649.141"><vh>void FatalError (guinone.cpp)</vh></v>
<v t="leo.20191228122649.142"><vh>class SettingsImplDummy</vh>
<v t="leo.20191228122649.143"><vh>SettingsImplDummy.void FreezeInt</vh></v>
<v t="leo.20191228122649.144"><vh>SettingsImplDummy.void FreezeFloat</vh></v>
<v t="leo.20191228122649.145"><vh>SettingsImplDummy.double ThawFloat</vh></v>
<v t="leo.20191228122649.146"><vh>SettingsImplDummy.void FreezeString</vh></v>
</v>
<v t="leo.20191228122649.147"><vh>static std::shared_ptr (guinone.cpp)</vh></v>
<v t="leo.20191228122649.148"><vh>void RunAfter (guinone.cpp)</vh></v>
<v t="leo.20191228122649.149"><vh>void Request3DConnexionEventsForWindow (guinone.cpp)</vh></v>
<v t="leo.20191228122649.150"><vh>void OpenInBrowser (guinone.cpp)</vh></v>
</v>
<v t="leo.20191228122649.151"><vh>@clean guiwin.cpp</vh>
<v t="leo.20191228122649.152"><vh>void CheckLastError (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.153"><vh>static std::wstring (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.154"><vh>static std::string (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.155"><vh>int Clamp (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.156"><vh>void FatalError (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.157"><vh>class SettingsImplWin32</vh>
<v t="leo.20191228122649.158"><vh>SettingsImplWin32.void FreezeInt</vh></v>
<v t="leo.20191228122649.159"><vh>SettingsImplWin32.void FreezeFloat</vh></v>
<v t="leo.20191228122649.160"><vh>SettingsImplWin32.double ThawFloat</vh></v>
<v t="leo.20191228122649.161"><vh>SettingsImplWin32.void FreezeString</vh></v>
</v>
<v t="leo.20191228122649.162"><vh>class TimerImplWin32</vh>
<v t="leo.20191228122649.163"><vh>TimerImplWin32.static HWND</vh></v>
<v t="leo.20191228122649.164"><vh>TimerImplWin32.void CALLBACK</vh></v>
<v t="leo.20191228122649.165"><vh>TimerImplWin32.void RunAfter</vh></v>
</v>
<v t="leo.20191228122649.166"><vh>class MenuItemImplWin32</vh>
<v t="leo.20191228122649.167"><vh>MenuItemImplWin32.void SetAccelerator</vh></v>
<v t="leo.20191228122649.168"><vh>MenuItemImplWin32.void SetIndicator</vh></v>
<v t="leo.20191228122649.169"><vh>MenuItemImplWin32.void SetActive</vh></v>
<v t="leo.20191228122649.170"><vh>MenuItemImplWin32.void SetEnabled</vh></v>
</v>
<v t="leo.20191228122649.171"><vh>class MenuImplWin32</vh>
<v t="leo.20191228122649.172"><vh>MenuImplWin32.bool mnemonics</vh></v>
<v t="leo.20191228122649.173"><vh>MenuImplWin32.void AddSeparator</vh></v>
<v t="leo.20191228122649.174"><vh>MenuImplWin32.void PopUp</vh></v>
<v t="leo.20191228122649.175"><vh>MenuImplWin32.void Clear</vh></v>
</v>
<v t="leo.20191228122649.176"><vh>class MenuBarImplWin32</vh>
<v t="leo.20191228122649.177"><vh>MenuBarImplWin32.void Clear</vh></v>
</v>
<v t="leo.20191228122649.178"><vh>class WindowImplWin32</vh>
<v t="leo.20191228122649.179"><vh>WindowImplWin32.void RegisterWindowClass</vh></v>
<v t="leo.20191228122649.180"><vh>WindowImplWin32.static LRESULT</vh></v>
<v t="leo.20191228122649.181"><vh>WindowImplWin32.static LRESULT</vh></v>
<v t="leo.20191228122649.182"><vh>WindowImplWin32.double GetPixelDensity</vh></v>
<v t="leo.20191228122649.183"><vh>WindowImplWin32.int GetDevicePixelRatio</vh></v>
<v t="leo.20191228122649.184"><vh>WindowImplWin32.bool IsVisible</vh></v>
<v t="leo.20191228122649.185"><vh>WindowImplWin32.void SetVisible</vh></v>
<v t="leo.20191228122649.186"><vh>WindowImplWin32.void Focus</vh></v>
<v t="leo.20191228122649.187"><vh>WindowImplWin32.bool IsFullScreen</vh></v>
<v t="leo.20191228122649.188"><vh>WindowImplWin32.void SetFullScreen</vh></v>
<v t="leo.20191228122649.189"><vh>WindowImplWin32.void SetTitle</vh></v>
<v t="leo.20191228122649.190"><vh>WindowImplWin32.void SetMenuBar</vh></v>
<v t="leo.20191228122649.191"><vh>WindowImplWin32.void GetContentSize</vh></v>
<v t="leo.20191228122649.192"><vh>WindowImplWin32.void SetMinContentSize</vh></v>
<v t="leo.20191228122649.193"><vh>WindowImplWin32.void FreezePosition</vh></v>
<v t="leo.20191228122649.194"><vh>WindowImplWin32.void ThawPosition</vh></v>
<v t="leo.20191228122649.195"><vh>WindowImplWin32.void SetCursor</vh></v>
<v t="leo.20191228122649.196"><vh>WindowImplWin32.void SetTooltip</vh></v>
<v t="leo.20191228122649.197"><vh>WindowImplWin32.bool IsEditorVisible</vh></v>
<v t="leo.20191228122649.198"><vh>WindowImplWin32.void ShowEditor</vh></v>
<v t="leo.20191228122649.199"><vh>WindowImplWin32.void HideEditor</vh></v>
<v t="leo.20191228122649.200"><vh>WindowImplWin32.void SetScrollbarVisible</vh></v>
<v t="leo.20191228122649.201"><vh>WindowImplWin32.void ConfigureScrollbar</vh></v>
<v t="leo.20191228122649.202"><vh>WindowImplWin32.double GetScrollbarPosition</vh></v>
<v t="leo.20191228122649.203"><vh>WindowImplWin32.void SetScrollbarPosition</vh></v>
<v t="leo.20191228122649.204"><vh>WindowImplWin32.void Invalidate</vh></v>
</v>
<v t="leo.20191228122649.205"><vh>void Open3DConnexion (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.206"><vh>void Close3DConnexion (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.207"><vh>void Request3DConnexionEventsForWindow (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.208"><vh>void Open3DConnexion (guiwin.cpp)</vh>
<v t="leo.20191228122649.209"><vh>void SetType (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.210"><vh>void SetTitle (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.211"><vh>void SetMessage (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.212"><vh>void SetDescription (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.213"><vh>void UpdateText (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.214"><vh>void AddButton (guiwin.cpp)</vh></v>
</v>
<v t="leo.20191228122649.215"><vh>class FileDialogImplWin32</vh>
<v t="leo.20191228122649.216"><vh>FileDialogImplWin32.void SetTitle</vh></v>
<v t="leo.20191228122649.217"><vh>FileDialogImplWin32.void SetCurrentName</vh></v>
<v t="leo.20191228122649.218"><vh>FileDialogImplWin32.void SetFilename</vh></v>
<v t="leo.20191228122649.219"><vh>FileDialogImplWin32.void AddFilter</vh></v>
<v t="leo.20191228122649.220"><vh>FileDialogImplWin32.void FreezeChoices</vh></v>
<v t="leo.20191228122649.221"><vh>FileDialogImplWin32.void ThawChoices</vh></v>
<v t="leo.20191228122649.222"><vh>FileDialogImplWin32.bool RunModal</vh></v>
</v>
<v t="leo.20191228122649.223"><vh>void OpenInBrowser (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.224"><vh>void InitGui (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.225"><vh>void RunGui (guiwin.cpp)</vh></v>
<v t="leo.20191228122649.226"><vh>void ExitGui (guiwin.cpp)</vh></v>
</v>
<v t="leo.20191228122649.227"><vh>@clean platform.cpp</vh>
<v t="leo.20191228122649.228"><vh>static std::vector (platform.cpp)</vh></v>
<v t="leo.20191228122649.229"><vh>static std::string (platform.cpp)</vh></v>
<v t="leo.20191228122649.230"><vh>bool Path::HasExtension (platform.cpp)</vh></v>
<v t="leo.20191228122649.231"><vh>void FindPrefix (platform.cpp)</vh></v>
<v t="leo.20191228122649.232"><vh>bool Path::IsAbsolute (platform.cpp)</vh></v>
<v t="leo.20191228122649.233"><vh>static std::string (platform.cpp)</vh></v>
<v t="leo.20191228122649.234"><vh>bool Path::Equals (platform.cpp)</vh></v>
<v t="leo.20191228122649.235"><vh>bool FileExists (platform.cpp)</vh></v>
<v t="leo.20191228122649.236"><vh>void RemoveFile (platform.cpp)</vh></v>
<v t="leo.20191228122649.237"><vh>bool ReadFile (platform.cpp)</vh></v>
<v t="leo.20191228122649.238"><vh>bool WriteFile (platform.cpp)</vh></v>
<v t="leo.20191228122649.239"><vh>const void *LoadResource(const std::string &amp;name, size_t *size) { (platform.cpp)</vh></v>
<v t="leo.20191228122649.240"><vh>static Platform::Path (platform.cpp)</vh></v>
<v t="leo.20191228122649.241"><vh>static Platform::Path (platform.cpp)</vh></v>
<v t="leo.20191228122649.242"><vh>static Platform::Path (platform.cpp)</vh></v>
<v t="leo.20191228122649.243"><vh>static Platform::Path (platform.cpp)</vh></v>
<v t="leo.20191228122649.244"><vh>const void *LoadResource(const std::string &amp;name, size_t *size) { (platform.cpp)</vh></v>
</v>
<v t="leo.20191228122649.245"><vh>@clean platform.h</vh>
<v t="leo.20191228122649.246"><vh>class Path</vh></v>
</v>
<v t="leo.20191228122649.247"><vh>@clean utilunix.cpp</vh>
<v t="leo.20191228122649.248"><vh>void dbp (utilunix.cpp)</vh></v>
<v t="leo.20191228122650.1"><vh>typedef struct (utilunix.cpp)</vh></v>
<v t="leo.20191228122650.2"><vh>void *AllocTemporary(size_t n) (utilunix.cpp)</vh></v>
<v t="leo.20191228122650.3"><vh>void FreeAllTemporary (utilunix.cpp)</vh></v>
<v t="leo.20191228122650.4"><vh>void *MemAlloc(size_t n) { (utilunix.cpp)</vh></v>
<v t="leo.20191228122650.5"><vh>void MemFree (utilunix.cpp)</vh></v>
</v>
<v t="leo.20191228122650.6"><vh>@clean utilwin.cpp</vh>
<v t="leo.20191228122650.7"><vh>void dbp (utilwin.cpp)</vh></v>
<v t="leo.20191228122650.8"><vh>void *AllocTemporary(size_t n) (utilwin.cpp)</vh></v>
<v t="leo.20191228122650.9"><vh>void FreeAllTemporary (utilwin.cpp)</vh></v>
<v t="leo.20191228122650.10"><vh>void *MemAlloc(size_t n) { (utilwin.cpp)</vh></v>
<v t="leo.20191228122650.11"><vh>void MemFree (utilwin.cpp)</vh></v>
<v t="leo.20191228122650.12"><vh>void vl (utilwin.cpp)</vh></v>
</v>
</v>
<v t="leo.20191228122650.13"><vh>@path render</vh>
<v t="leo.20191228122650.14"><vh>@clean gl3shader.cpp</vh>
<v t="leo.20191228122650.15"><vh>static GLuint (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.16"><vh>void Shader::Init (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.17"><vh>void Shader::Clear (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.18"><vh>void Shader::SetUniformMatrix (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.19"><vh>void Shader::SetUniformVector (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.20"><vh>void Shader::SetUniformVector (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.21"><vh>void Shader::SetUniformColor (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.22"><vh>void Shader::SetUniformFloat (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.23"><vh>void Shader::SetUniformInt (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.24"><vh>void Shader::SetUniformTextureUnit (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.25"><vh>void Shader::Enable (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.26"><vh>void Shader::Disable (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.27"><vh>void MeshRenderer::Init (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.28"><vh>void MeshRenderer::Clear (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.29"><vh>void MeshRenderer::Remove (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.30"><vh>void MeshRenderer::Draw (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.31"><vh>void MeshRenderer::Draw (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.32"><vh>void MeshRenderer::SetModelview (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.33"><vh>void MeshRenderer::SetProjection (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.34"><vh>void MeshRenderer::UseShaded (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.35"><vh>void MeshRenderer::UseFilled (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.36"><vh>double Frac (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.37"><vh>static RgbaColor (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.38"><vh>void StippleAtlas::Init (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.39"><vh>void StippleAtlas::Clear (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.40"><vh>void EdgeRenderer::Init (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.41"><vh>void EdgeRenderer::Clear (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.42"><vh>void EdgeRenderer::Remove (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.43"><vh>void EdgeRenderer::Draw (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.44"><vh>void EdgeRenderer::Draw (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.45"><vh>void EdgeRenderer::SetModelview (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.46"><vh>void EdgeRenderer::SetProjection (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.47"><vh>void EdgeRenderer::SetStroke (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.48"><vh>void OutlineRenderer::Init (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.49"><vh>void OutlineRenderer::Clear (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.50"><vh>void OutlineRenderer::Remove (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.51"><vh>void OutlineRenderer::Draw (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.52"><vh>void OutlineRenderer::Draw (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.53"><vh>void OutlineRenderer::SetModelview (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.54"><vh>void OutlineRenderer::SetProjection (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.55"><vh>void OutlineRenderer::SetStroke (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.56"><vh>void SIndexedMesh::AddPoint (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.57"><vh>void SIndexedMesh::AddQuad (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.58"><vh>void SIndexedMesh::AddPixmap (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.59"><vh>void SIndexedMesh::Clear (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.60"><vh>void IndexedMeshRenderer::Init (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.61"><vh>void IndexedMeshRenderer::Clear (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.62"><vh>void IndexedMeshRenderer::Remove (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.63"><vh>void IndexedMeshRenderer::Draw (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.64"><vh>void IndexedMeshRenderer::Draw (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.65"><vh>bool IndexedMeshRenderer::NeedsTexture (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.66"><vh>void IndexedMeshRenderer::SetModelview (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.67"><vh>void IndexedMeshRenderer::SetProjection (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.68"><vh>void IndexedMeshRenderer::UseFilled (gl3shader.cpp)</vh></v>
<v t="leo.20191228122650.69"><vh>void IndexedMeshRenderer::UsePoint (gl3shader.cpp)</vh></v>
</v>
<v t="leo.20191228122650.70"><vh>@clean gl3shader.h</vh>
<v t="leo.20191228122650.71"><vh>class Vector2f</vh></v>
<v t="leo.20191228122650.72"><vh>class Vector3f</vh></v>
<v t="leo.20191228122650.73"><vh>class Vector4f</vh></v>
<v t="leo.20191228122650.74"><vh>class Shader</vh></v>
<v t="leo.20191228122650.75"><vh>class MeshRenderer</vh></v>
<v t="leo.20191228122650.76"><vh>class StippleAtlas</vh></v>
<v t="leo.20191228122650.77"><vh>class EdgeRenderer</vh></v>
<v t="leo.20191228122650.78"><vh>class OutlineRenderer</vh></v>
<v t="leo.20191228122650.79"><vh>class SIndexedMesh</vh>
<v t="leo.20191228122650.80"><vh>SIndexedMesh.void AddPixmap</vh></v>
</v>
</v>
<v t="leo.20191228122650.81"><vh>@clean render.cpp</vh>
<v t="leo.20191228122650.82"><vh>void Camera::LoadIdentity (render.cpp)</vh></v>
<v t="leo.20191228122650.83"><vh>void Camera::NormalizeProjectionVectors (render.cpp)</vh></v>
<v t="leo.20191228122650.84"><vh>bool Canvas::Stroke::Equals (render.cpp)</vh></v>
<v t="leo.20191228122650.85"><vh>bool Canvas::Fill::Equals (render.cpp)</vh></v>
<v t="leo.20191228122650.86"><vh>void Canvas::Clear (render.cpp)</vh></v>
<v t="leo.20191228122650.87"><vh>const Camera (render.cpp)</vh></v>
<v t="leo.20191228122650.88"><vh>void UiCanvas::DrawLine (render.cpp)</vh></v>
<v t="leo.20191228122650.89"><vh>void UiCanvas::DrawRect (render.cpp)</vh></v>
<v t="leo.20191228122650.90"><vh>void UiCanvas::DrawPixmap (render.cpp)</vh></v>
<v t="leo.20191228122650.91"><vh>void UiCanvas::DrawBitmapChar (render.cpp)</vh></v>
<v t="leo.20191228122650.92"><vh>void UiCanvas::DrawBitmapText (render.cpp)</vh></v>
<v t="leo.20191228122650.93"><vh>void ObjectPicker::DoCompare (render.cpp)</vh></v>
<v t="leo.20191228122650.94"><vh>void ObjectPicker::DoQuad (render.cpp)</vh>
<v t="leo.20191228122650.95"><vh>double minNegative (render.cpp)</vh></v>
</v>
<v t="leo.20191228122650.96"><vh>void ObjectPicker::DrawLine (render.cpp)</vh></v>
<v t="leo.20191228122650.97"><vh>void ObjectPicker::DrawEdges (render.cpp)</vh></v>
<v t="leo.20191228122650.98"><vh>void ObjectPicker::DrawOutlines (render.cpp)</vh></v>
<v t="leo.20191228122650.99"><vh>void ObjectPicker::DrawVectorText (render.cpp)</vh></v>
<v t="leo.20191228122650.100"><vh>void ObjectPicker::DrawPoint (render.cpp)</vh></v>
<v t="leo.20191228122650.101"><vh>void ObjectPicker::DrawPolygon (render.cpp)</vh></v>
<v t="leo.20191228122650.102"><vh>void ObjectPicker::DrawMesh (render.cpp)</vh></v>
<v t="leo.20191228122650.103"><vh>void ObjectPicker::DrawFaces (render.cpp)</vh></v>
<v t="leo.20191228122650.104"><vh>void ObjectPicker::DrawPixmap (render.cpp)</vh></v>
<v t="leo.20191228122650.105"><vh>bool ObjectPicker::Pick (render.cpp)</vh></v>
</v>
<v t="leo.20191228122650.106"><vh>@clean render.h</vh>
<v t="leo.20191228122650.107"><vh>class Camera</vh></v>
<v t="leo.20191228122650.108"><vh>class Lighting</vh></v>
<v t="leo.20191228122650.109"><vh>class Canvas</vh>
<v t="leo.20191228122650.110"><vh>class hStroke</vh></v>
<v t="leo.20191228122650.111"><vh>class hFill</vh></v>
<v t="leo.20191228122650.112"><vh>class Stroke</vh></v>
<v t="leo.20191228122650.113"><vh>class Fill</vh></v>
</v>
<v t="leo.20191228122650.114"><vh>class ViewportCanvas</vh></v>
<v t="leo.20191228122650.115"><vh>class BatchCanvas</vh></v>
<v t="leo.20191228122650.116"><vh>class UiCanvas</vh></v>
<v t="leo.20191228122650.117"><vh>class ObjectPicker</vh>
<v t="leo.20191228122650.118"><vh>class SurfaceRenderer</vh></v>
</v>
<v t="leo.20191228122650.119"><vh>class CairoRenderer</vh></v>
<v t="leo.20191228122650.120"><vh>class CairoPixmapRenderer</vh></v>
</v>
<v t="leo.20191228122650.121"><vh>@clean render2d.cpp</vh>
<v t="leo.20191228122650.122"><vh>static Vector (render2d.cpp)</vh></v>
<v t="leo.20191228122650.123"><vh>void SurfaceRenderer::DrawLine (render2d.cpp)</vh></v>
<v t="leo.20191228122650.124"><vh>void SurfaceRenderer::DrawEdges (render2d.cpp)</vh></v>
<v t="leo.20191228122650.125"><vh>bool SurfaceRenderer::DrawBeziers (render2d.cpp)</vh></v>
<v t="leo.20191228122650.126"><vh>void SurfaceRenderer::DrawOutlines (render2d.cpp)</vh></v>
<v t="leo.20191228122650.127"><vh>void SurfaceRenderer::DrawVectorText (render2d.cpp)</vh>
<v t="leo.20191228122650.128"><vh>auto traceEdge (render2d.cpp)</vh></v>
</v>
<v t="leo.20191228122650.129"><vh>void SurfaceRenderer::DrawQuad (render2d.cpp)</vh></v>
<v t="leo.20191228122650.130"><vh>void SurfaceRenderer::DrawPoint (render2d.cpp)</vh></v>
<v t="leo.20191228122650.131"><vh>void SurfaceRenderer::DrawPolygon (render2d.cpp)</vh></v>
<v t="leo.20191228122650.132"><vh>void SurfaceRenderer::DrawMesh (render2d.cpp)</vh></v>
<v t="leo.20191228122650.133"><vh>void SurfaceRenderer::DrawFaces (render2d.cpp)</vh></v>
<v t="leo.20191228122650.134"><vh>void SurfaceRenderer::DrawPixmap (render2d.cpp)</vh></v>
<v t="leo.20191228122650.135"><vh>void SurfaceRenderer::InvalidatePixmap (render2d.cpp)</vh></v>
<v t="leo.20191228122650.136"><vh>void SurfaceRenderer::CalculateBBox (render2d.cpp)</vh></v>
<v t="leo.20191228122650.137"><vh>void SurfaceRenderer::ConvertBeziersToEdges (render2d.cpp)</vh></v>
<v t="leo.20191228122650.138"><vh>void SurfaceRenderer::CullOccludedStrokes (render2d.cpp)</vh></v>
<v t="leo.20191228122650.139"><vh>void SurfaceRenderer::OutputInPaintOrder (render2d.cpp)</vh>
<v t="leo.20191228122650.140"><vh>const Layer (render2d.cpp)</vh></v>
<v t="leo.20191228122650.141"><vh>int aZIndex (render2d.cpp)</vh></v>
</v>
<v t="leo.20191228122650.142"><vh>void SurfaceRenderer::Clear (render2d.cpp)</vh></v>
<v t="leo.20191228122650.143"><vh>void SurfaceRenderer::OutputBezierAsNonrationalCubic (render2d.cpp)</vh></v>
</v>
<v t="leo.20191228122650.144"><vh>@clean rendercairo.cpp</vh>
<v t="leo.20191228122650.145"><vh>void CairoRenderer::Clear (rendercairo.cpp)</vh></v>
<v t="leo.20191228122650.146"><vh>void CairoRenderer::GetIdent (rendercairo.cpp)</vh></v>
<v t="leo.20191228122650.147"><vh>void CairoRenderer::FlushFrame (rendercairo.cpp)</vh></v>
<v t="leo.20191228122650.148"><vh>void CairoRenderer::OutputStart (rendercairo.cpp)</vh></v>
<v t="leo.20191228122650.149"><vh>void CairoRenderer::OutputEnd (rendercairo.cpp)</vh></v>
<v t="leo.20191228122650.150"><vh>void CairoRenderer::SelectStroke (rendercairo.cpp)</vh></v>
<v t="leo.20191228122650.151"><vh>void CairoRenderer::MoveTo (rendercairo.cpp)</vh></v>
<v t="leo.20191228122650.152"><vh>void CairoRenderer::FinishPath (rendercairo.cpp)</vh></v>
<v t="leo.20191228122650.153"><vh>void CairoRenderer::OutputBezier (rendercairo.cpp)</vh>
<v t="leo.20191228122650.154"><vh>double theta0 (rendercairo.cpp)</vh></v>
</v>
<v t="leo.20191228122650.155"><vh>void CairoRenderer::OutputTriangle (rendercairo.cpp)</vh></v>
<v t="leo.20191228122650.156"><vh>void CairoPixmapRenderer::Init (rendercairo.cpp)</vh></v>
<v t="leo.20191228122650.157"><vh>void CairoPixmapRenderer::Clear (rendercairo.cpp)</vh></v>
</v>
<v t="leo.20191228122650.158"><vh>@clean rendergl1.cpp</vh>
<v t="leo.20191228122650.159"><vh>bool HasIntelThinLineQuirk (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.160"><vh>bool HasGl1V1Quirk (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.161"><vh>static inline (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.162"><vh>static inline (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.163"><vh>void ssglLineWidth (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.164"><vh>static inline (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.165"><vh>static inline (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.166"><vh>void ssglDepthRange (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.167"><vh>void ssglFillPattern (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.168"><vh>class OpenGl1Renderer</vh></v>
<v t="leo.20191228122650.169"><vh>void OpenGl1Renderer::SelectPrimitive (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.170"><vh>void OpenGl1Renderer::UnSelectPrimitive (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.171"><vh>int RoundUpToPowerOfTwo (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.172"><vh>void OpenGl1Renderer::SelectTexture (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.173"><vh>void OpenGl1Renderer::DoFatLineEndcap (rendergl1.cpp)</vh>
<v t="leo.20191228122650.174"><vh>double Circle (rendergl1.cpp)</vh></v>
</v>
<v t="leo.20191228122650.175"><vh>void OpenGl1Renderer::DoFatLine (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.176"><vh>void OpenGl1Renderer::DoLine (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.177"><vh>void OpenGl1Renderer::DoPoint (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.178"><vh>void OpenGl1Renderer::DoStippledLine (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.179"><vh>void OpenGl1Renderer::DrawLine (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.180"><vh>void OpenGl1Renderer::DrawEdges (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.181"><vh>void OpenGl1Renderer::DrawOutlines (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.182"><vh>void OpenGl1Renderer::DrawVectorText (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.183"><vh>void OpenGl1Renderer::DrawQuad (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.184"><vh>void OpenGl1Renderer::DrawPoint (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.185"><vh>void SSGL_CALLBACK (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.186"><vh>void SSGL_CALLBACK (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.187"><vh>void OpenGl1Renderer::DrawPolygon (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.188"><vh>void OpenGl1Renderer::DrawMesh (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.189"><vh>void OpenGl1Renderer::DrawFaces (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.190"><vh>void OpenGl1Renderer::DrawPixmap (rendergl1.cpp)</vh>
<v t="leo.20191228122650.191"><vh>double xfactor (rendergl1.cpp)</vh></v>
</v>
<v t="leo.20191228122650.192"><vh>void OpenGl1Renderer::InvalidatePixmap (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.193"><vh>void OpenGl1Renderer::UpdateProjection (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.194"><vh>void OpenGl1Renderer::StartFrame (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.195"><vh>void OpenGl1Renderer::FlushFrame (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.196"><vh>void OpenGl1Renderer::FinishFrame (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.197"><vh>void OpenGl1Renderer::GetIdent (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.198"><vh>void OpenGl1Renderer::SetCamera (rendergl1.cpp)</vh></v>
<v t="leo.20191228122650.199"><vh>void OpenGl1Renderer::SetLighting (rendergl1.cpp)</vh></v>
</v>
<v t="leo.20191228122650.200"><vh>@clean rendergl3.cpp</vh>
<v t="leo.20191228122650.201"><vh>class TextureCache</vh>
<v t="leo.20191228122650.202"><vh>TextureCache.bool Lookup</vh></v>
<v t="leo.20191228122650.203"><vh>TextureCache.void CleanupUnused</vh></v>
</v>
<v t="leo.20191228122650.204"><vh>class OpenGl3Renderer</vh></v>
<v t="leo.20191228122650.205"><vh>void ssglDepthRange (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.206"><vh>void OpenGl3Renderer::SelectMask (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.207"><vh>bool IsPowerOfTwo (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.208"><vh>void OpenGl3Renderer::InvalidatePixmap (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.209"><vh>void OpenGl3Renderer::SelectTexture (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.210"><vh>void OpenGl3Renderer::DoLine (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.211"><vh>void OpenGl3Renderer::DoPoint (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.212"><vh>void OpenGl3Renderer::DoStippledLine (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.213"><vh>void OpenGl3Renderer::Init (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.214"><vh>void OpenGl3Renderer::DrawLine (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.215"><vh>void OpenGl3Renderer::DrawEdges (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.216"><vh>void OpenGl3Renderer::DrawOutlines (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.217"><vh>void OpenGl3Renderer::DrawVectorText (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.218"><vh>void OpenGl3Renderer::DrawQuad (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.219"><vh>void OpenGl3Renderer::DrawPoint (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.220"><vh>void OpenGl3Renderer::DrawPolygon (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.221"><vh>void OpenGl3Renderer::DrawMesh (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.222"><vh>void OpenGl3Renderer::DrawFaces (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.223"><vh>void OpenGl3Renderer::DrawPixmap (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.224"><vh>void OpenGl3Renderer::UpdateProjection (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.225"><vh>void OpenGl3Renderer::StartFrame (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.226"><vh>void OpenGl3Renderer::FlushFrame (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.227"><vh>void OpenGl3Renderer::FinishFrame (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.228"><vh>void OpenGl3Renderer::Clear (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.229"><vh>void OpenGl3Renderer::GetIdent (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.230"><vh>void OpenGl3Renderer::SetCamera (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.231"><vh>void OpenGl3Renderer::SetLighting (rendergl3.cpp)</vh></v>
<v t="leo.20191228122650.232"><vh>class DrawCall</vh></v>
<v t="leo.20191228122650.233"><vh>class EdgeDrawCall</vh>
<v t="leo.20191228122650.234"><vh>EdgeDrawCall.static std::shared_ptr</vh></v>
<v t="leo.20191228122650.235"><vh>EdgeDrawCall.void Draw</vh></v>
<v t="leo.20191228122650.236"><vh>EdgeDrawCall.void Remove</vh></v>
</v>
<v t="leo.20191228122650.237"><vh>class OutlineDrawCall</vh>
<v t="leo.20191228122650.238"><vh>OutlineDrawCall.static std::shared_ptr</vh></v>
<v t="leo.20191228122650.239"><vh>OutlineDrawCall.void Draw</vh></v>
<v t="leo.20191228122650.240"><vh>OutlineDrawCall.void Remove</vh></v>
</v>
<v t="leo.20191228122650.241"><vh>class PointDrawCall</vh>
<v t="leo.20191228122650.242"><vh>PointDrawCall.static std::shared_ptr</vh></v>
<v t="leo.20191228122650.243"><vh>PointDrawCall.void Draw</vh></v>
<v t="leo.20191228122650.244"><vh>PointDrawCall.void Remove</vh></v>
</v>
<v t="leo.20191228122650.245"><vh>class PixmapDrawCall</vh>
<v t="leo.20191228122650.246"><vh>PixmapDrawCall.static std::shared_ptr</vh></v>
<v t="leo.20191228122650.247"><vh>PixmapDrawCall.void Draw</vh></v>
<v t="leo.20191228122650.248"><vh>PixmapDrawCall.void Remove</vh></v>
</v>
<v t="leo.20191228122650.249"><vh>class MeshDrawCall</vh>
<v t="leo.20191228122650.250"><vh>MeshDrawCall.static std::shared_ptr</vh></v>
<v t="leo.20191228122650.251"><vh>MeshDrawCall.void DrawFace</vh></v>
<v t="leo.20191228122651.1"><vh>MeshDrawCall.void Draw</vh></v>
<v t="leo.20191228122651.2"><vh>MeshDrawCall.void Remove</vh></v>
</v>
<v t="leo.20191228122651.3"><vh>bool operator (rendergl3.cpp)</vh>
<v t="leo.20191228122651.4"><vh>const Canvas::Layer (rendergl3.cpp)</vh></v>
<v t="leo.20191228122651.5"><vh>int aLayerIndex (rendergl3.cpp)</vh></v>
</v>
<v t="leo.20191228122651.6"><vh>class OpenGl3RendererBatch</vh>
<v t="leo.20191228122651.7"><vh>OpenGl3RendererBatch.void Clear</vh></v>
<v t="leo.20191228122651.8"><vh>OpenGl3RendererBatch.void Clear</vh></v>
<v t="leo.20191228122651.9"><vh>OpenGl3RendererBatch.void DrawLine</vh></v>
<v t="leo.20191228122651.10"><vh>OpenGl3RendererBatch.void DrawEdges</vh></v>
<v t="leo.20191228122651.11"><vh>OpenGl3RendererBatch.bool DrawBeziers</vh></v>
<v t="leo.20191228122651.12"><vh>OpenGl3RendererBatch.void DrawOutlines</vh></v>
<v t="leo.20191228122651.13"><vh>OpenGl3RendererBatch.void DrawVectorText</vh></v>
<v t="leo.20191228122651.14"><vh>OpenGl3RendererBatch.void DrawQuad</vh></v>
<v t="leo.20191228122651.15"><vh>OpenGl3RendererBatch.void DrawPoint</vh></v>
<v t="leo.20191228122651.16"><vh>OpenGl3RendererBatch.void DrawPolygon</vh></v>
<v t="leo.20191228122651.17"><vh>OpenGl3RendererBatch.void DrawMesh</vh></v>
<v t="leo.20191228122651.18"><vh>OpenGl3RendererBatch.void DrawFaces</vh></v>
<v t="leo.20191228122651.19"><vh>OpenGl3RendererBatch.void DrawPixmap</vh></v>
<v t="leo.20191228122651.20"><vh>OpenGl3RendererBatch.void InvalidatePixmap</vh></v>
<v t="leo.20191228122651.21"><vh>OpenGl3RendererBatch.void Finalize</vh></v>
<v t="leo.20191228122651.22"><vh>OpenGl3RendererBatch.void Draw</vh></v>
<v t="leo.20191228122651.23"><vh>OpenGl3RendererBatch.void Clear</vh></v>
</v>
</v>
</v>
<v t="leo.20191228122651.24"><vh>@path srf</vh>
<v t="leo.20191228122651.25"><vh>@clean boolean.cpp</vh>
<v t="leo.20191228122651.26"><vh>void SShell::MakeFromUnionOf (boolean.cpp)</vh></v>
<v t="leo.20191228122651.27"><vh>void SShell::MakeFromDifferenceOf (boolean.cpp)</vh></v>
<v t="leo.20191228122651.28"><vh>void SShell::CopyCurvesSplitAgainst (boolean.cpp)</vh></v>
<v t="leo.20191228122651.29"><vh>void SSurface::TrimFromEdgeList (boolean.cpp)</vh></v>
<v t="leo.20191228122651.30"><vh>bool KeepRegion (boolean.cpp)</vh>
<v t="leo.20191228122651.31"><vh>bool inShell (boolean.cpp)</vh></v>
</v>
<v t="leo.20191228122651.32"><vh>bool KeepEdge (boolean.cpp)</vh></v>
<v t="leo.20191228122651.33"><vh>void DEBUGEDGELIST (boolean.cpp)</vh></v>
<v t="leo.20191228122651.34"><vh>void SSurface::FindChainAvoiding (boolean.cpp)</vh>
<v t="leo.20191228122651.35"><vh>bool startOkay (boolean.cpp)</vh></v>
</v>
<v t="leo.20191228122651.36"><vh>void SSurface::EdgeNormalsWithinSurface (boolean.cpp)</vh></v>
<v t="leo.20191228122651.37"><vh>void SShell::CopySurfacesTrimAgainst (boolean.cpp)</vh></v>
<v t="leo.20191228122651.38"><vh>void SShell::MakeIntersectionCurvesAgainst (boolean.cpp)</vh></v>
<v t="leo.20191228122651.39"><vh>void SShell::CleanupAfterBoolean (boolean.cpp)</vh></v>
<v t="leo.20191228122651.40"><vh>void SShell::RewriteSurfaceHandlesForCurves (boolean.cpp)</vh></v>
<v t="leo.20191228122651.41"><vh>void SShell::MakeFromAssemblyOf (boolean.cpp)</vh></v>
<v t="leo.20191228122651.42"><vh>void SShell::MakeFromBoolean (boolean.cpp)</vh></v>
<v t="leo.20191228122651.43"><vh>void SShell::MakeClassifyingBsps (boolean.cpp)</vh></v>
<v t="leo.20191228122651.44"><vh>void SSurface::MakeClassifyingBsp (boolean.cpp)</vh></v>
<v t="leo.20191228122651.45"><vh>void SBspUv::ScalePoints (boolean.cpp)</vh></v>
<v t="leo.20191228122651.46"><vh>void SBspUv::InsertEdge (boolean.cpp)</vh>
<v t="leo.20191228122651.47"><vh>double dea (boolean.cpp)</vh></v>
</v>
</v>
<v t="leo.20191228122651.48"><vh>@clean curve.cpp</vh>
<v t="leo.20191228122651.49"><vh>void SBezier::Reverse (curve.cpp)</vh></v>
<v t="leo.20191228122651.50"><vh>void SBezier::ScaleSelfBy (curve.cpp)</vh></v>
<v t="leo.20191228122651.51"><vh>void SBezier::GetBoundingProjd (curve.cpp)</vh></v>
<v t="leo.20191228122651.52"><vh>bool SBezier::IsInPlane (curve.cpp)</vh></v>
<v t="leo.20191228122651.53"><vh>bool SBezier::IsCircle (curve.cpp)</vh>
<v t="leo.20191228122651.54"><vh>double rd0 (curve.cpp)</vh></v>
<v t="leo.20191228122651.55"><vh>double thetaa (curve.cpp)</vh></v>
</v>
<v t="leo.20191228122651.56"><vh>bool SBezier::IsRational (curve.cpp)</vh></v>
<v t="leo.20191228122651.57"><vh>bool SBezier::Equals (curve.cpp)</vh></v>
<v t="leo.20191228122651.58"><vh>void SBezierList::Clear (curve.cpp)</vh></v>
<v t="leo.20191228122651.59"><vh>void SBezierList::ScaleSelfBy (curve.cpp)</vh></v>
<v t="leo.20191228122651.60"><vh>void SBezierList::CullIdenticalBeziers (curve.cpp)</vh></v>
<v t="leo.20191228122651.61"><vh>void SBezierList::AllIntersectionsWith (curve.cpp)</vh></v>
<v t="leo.20191228122651.62"><vh>void SBezier::AllIntersectionsWith (curve.cpp)</vh></v>
<v t="leo.20191228122651.63"><vh>bool SBezierList::GetPlaneContainingBeziers (curve.cpp)</vh></v>
<v t="leo.20191228122651.64"><vh>void SBezierLoop::Reverse (curve.cpp)</vh></v>
<v t="leo.20191228122651.65"><vh>void SBezierLoop::GetBoundingProjd (curve.cpp)</vh></v>
<v t="leo.20191228122651.66"><vh>void SBezierLoop::MakePwlInto (curve.cpp)</vh></v>
<v t="leo.20191228122651.67"><vh>bool SBezierLoop::IsClosed (curve.cpp)</vh></v>
<v t="leo.20191228122651.68"><vh>double chordTol (curve.cpp)</vh></v>
<v t="leo.20191228122651.69"><vh>void SBezierLoopSet::GetBoundingProjd (curve.cpp)</vh></v>
<v t="leo.20191228122651.70"><vh>void SBezierLoopSet::MakePwlInto (curve.cpp)</vh></v>
<v t="leo.20191228122651.71"><vh>void SBezierLoopSet::Clear (curve.cpp)</vh></v>
<v t="leo.20191228122651.72"><vh>void SBezierLoopSetSet::FindOuterFacesFrom (curve.cpp)</vh></v>
<v t="leo.20191228122651.73"><vh>void SBezierLoopSetSet::AddOpenPath (curve.cpp)</vh></v>
<v t="leo.20191228122651.74"><vh>void SBezierLoopSetSet::Clear (curve.cpp)</vh></v>
<v t="leo.20191228122651.75"><vh>void SCurve::Clear (curve.cpp)</vh></v>
<v t="leo.20191228122651.76"><vh>void SCurve::RemoveShortSegments (curve.cpp)</vh></v>
</v>
<v t="leo.20191228122651.77"><vh>@clean merge.cpp</vh>
<v t="leo.20191228122651.78"><vh>void SShell::MergeCoincidentSurfaces (merge.cpp)</vh>
<v t="leo.20191228122651.79"><vh>double umax (merge.cpp)</vh></v>
</v>
</v>
<v t="leo.20191228122651.80"><vh>@clean ratpoly.cpp</vh>
<v t="leo.20191228122651.81"><vh>void SBezier::ClosestPointTo (ratpoly.cpp)</vh></v>
<v t="leo.20191228122651.82"><vh>bool SBezier::PointOnThisAndCurve (ratpoly.cpp)</vh></v>
<v t="leo.20191228122651.83"><vh>void SBezier::SplitAt (ratpoly.cpp)</vh></v>
<v t="leo.20191228122651.84"><vh>void SBezier::MakePwlInto (ratpoly.cpp)</vh></v>
<v t="leo.20191228122651.85"><vh>void SBezier::MakePwlInto (ratpoly.cpp)</vh></v>
<v t="leo.20191228122651.86"><vh>void SBezier::MakePwlInto (ratpoly.cpp)</vh></v>
<v t="leo.20191228122651.87"><vh>void SBezier::MakePwlInto (ratpoly.cpp)</vh></v>
<v t="leo.20191228122651.88"><vh>void SBezier::MakePwlWorker (ratpoly.cpp)</vh></v>
<v t="leo.20191228122651.89"><vh>void SBezier::MakePwlInitialWorker (ratpoly.cpp)</vh>
<v t="leo.20191228122651.90"><vh>double d (ratpoly.cpp)</vh></v>
</v>
<v t="leo.20191228122651.91"><vh>void SBezier::MakeNonrationalCubicInto (ratpoly.cpp)</vh></v>
<v t="leo.20191228122651.92"><vh>void SSurface::TangentsAt (ratpoly.cpp)</vh>
<v t="leo.20191228122651.93"><vh>double den (ratpoly.cpp)</vh></v>
</v>
<v t="leo.20191228122651.94"><vh>void SSurface::ClosestPointTo (ratpoly.cpp)</vh></v>
<v t="leo.20191228122651.95"><vh>void SSurface::ClosestPointTo (ratpoly.cpp)</vh></v>
<v t="leo.20191228122651.96"><vh>bool SSurface::ClosestPointNewton (ratpoly.cpp)</vh></v>
<v t="leo.20191228122651.97"><vh>bool SSurface::PointIntersectingLine (ratpoly.cpp)</vh></v>
<v t="leo.20191228122651.98"><vh>void SSurface::PointOnSurfaces (ratpoly.cpp)</vh></v>
</v>
<v t="leo.20191228122651.99"><vh>@clean raycast.cpp</vh>
<v t="leo.20191228122651.100"><vh>double mag (raycast.cpp)</vh></v>
<v t="leo.20191228122651.101"><vh>void SSurface::WeightControlPoints (raycast.cpp)</vh></v>
<v t="leo.20191228122651.102"><vh>void SSurface::UnWeightControlPoints (raycast.cpp)</vh></v>
<v t="leo.20191228122651.103"><vh>void SSurface::CopyRowOrCol (raycast.cpp)</vh></v>
<v t="leo.20191228122651.104"><vh>void SSurface::BlendRowOrCol (raycast.cpp)</vh></v>
<v t="leo.20191228122651.105"><vh>void SSurface::SplitInHalf (raycast.cpp)</vh></v>
<v t="leo.20191228122651.106"><vh>void SSurface::AllPointsIntersectingUntrimmed (raycast.cpp)</vh></v>
<v t="leo.20191228122651.107"><vh>void SSurface::AllPointsIntersecting (raycast.cpp)</vh>
<v t="leo.20191228122651.108"><vh>double dp (raycast.cpp)</vh></v>
</v>
<v t="leo.20191228122651.109"><vh>void SShell::AllPointsIntersecting (raycast.cpp)</vh></v>
<v t="leo.20191228122651.110"><vh>bool SShell::ClassifyEdge (raycast.cpp)</vh>
<v t="leo.20191228122651.111"><vh>int er_edge_n (raycast.cpp)</vh></v>
</v>
</v>
<v t="leo.20191228122651.112"><vh>@clean surface.cpp</vh>
<v t="leo.20191228122651.113"><vh>bool SSurface::IsExtrusion (surface.cpp)</vh></v>
<v t="leo.20191228122651.114"><vh>bool SSurface::IsCylinder (surface.cpp)</vh></v>
<v t="leo.20191228122651.115"><vh>double thetaf (surface.cpp)</vh></v>
<v t="leo.20191228122651.116"><vh>bool includingTrims (surface.cpp)</vh></v>
<v t="leo.20191228122651.117"><vh>void SSurface::GetAxisAlignedBounding (surface.cpp)</vh></v>
<v t="leo.20191228122651.118"><vh>bool SSurface::LineEntirelyOutsideBbox (surface.cpp)</vh></v>
<v t="leo.20191228122651.119"><vh>void SSurface::MakeTrimEdgesInto (surface.cpp)</vh></v>
<v t="leo.20191228122651.120"><vh>void SSurface::MakeEdgesInto (surface.cpp)</vh></v>
<v t="leo.20191228122651.121"><vh>void SSurface::MakeSectionEdgesInto (surface.cpp)</vh></v>
<v t="leo.20191228122651.122"><vh>void SSurface::TriangulateInto (surface.cpp)</vh></v>
<v t="leo.20191228122651.123"><vh>void SSurface::Reverse (surface.cpp)</vh></v>
<v t="leo.20191228122651.124"><vh>void SSurface::ScaleSelfBy (surface.cpp)</vh></v>
<v t="leo.20191228122651.125"><vh>void SSurface::Clear (surface.cpp)</vh></v>
<v t="leo.20191228122651.126"><vh>typedef struct (surface.cpp)</vh></v>
<v t="leo.20191228122651.127"><vh>void SShell::MakeFromExtrusionOf (surface.cpp)</vh></v>
<v t="leo.20191228122651.128"><vh>bool SShell::CheckNormalAxisRelationship (surface.cpp)</vh></v>
<v t="leo.20191228122651.129"><vh>void SShell::MakeFromHelicalRevolutionOf (surface.cpp)</vh></v>
<v t="leo.20191228122651.130"><vh>void SShell::MakeFromRevolutionOf (surface.cpp)</vh></v>
<v t="leo.20191228122651.131"><vh>void SShell::MakeFirstOrderRevolvedSurfaces (surface.cpp)</vh></v>
<v t="leo.20191228122651.132"><vh>void SShell::MakeFromCopyOf (surface.cpp)</vh></v>
<v t="leo.20191228122651.133"><vh>void SShell::MakeFromTransformationOf (surface.cpp)</vh></v>
<v t="leo.20191228122651.134"><vh>void SShell::MakeEdgesInto (surface.cpp)</vh></v>
<v t="leo.20191228122651.135"><vh>void SShell::MakeSectionEdgesInto (surface.cpp)</vh></v>
<v t="leo.20191228122651.136"><vh>void SShell::TriangulateInto (surface.cpp)</vh></v>
<v t="leo.20191228122651.137"><vh>bool SShell::IsEmpty (surface.cpp)</vh></v>
<v t="leo.20191228122651.138"><vh>void SShell::Clear (surface.cpp)</vh></v>
</v>
<v t="leo.20191228122651.139"><vh>@clean surface.h</vh>
<v t="leo.20191228122651.140"><vh>class SBspUv</vh></v>
<v t="leo.20191228122651.141"><vh>class hSSurface</vh></v>
<v t="leo.20191228122651.142"><vh>class hSCurve</vh></v>
<v t="leo.20191228122651.143"><vh>class SBezier</vh></v>
<v t="leo.20191228122651.144"><vh>class SBezierList</vh>
<v t="leo.20191228122651.145"><vh>SBezierList.bool GetPlaneContainingBeziers</vh></v>
<v t="leo.20191228122651.146"><vh>SBezierList.static SBezierLoop</vh></v>
<v t="leo.20191228122651.147"><vh>class SBezierLoopSetSet</vh></v>
</v>
<v t="leo.20191228122651.148"><vh>class SCurve</vh>
<v t="leo.20191228122651.149"><vh>class STrimBy</vh></v>
</v>
<v t="leo.20191228122651.150"><vh>class SInter</vh></v>
<v t="leo.20191228122651.151"><vh>class SSurface</vh>
<v t="leo.20191228122651.152"><vh>SSurface.void IntersectAgainst</vh></v>
<v t="leo.20191228122651.153"><vh>SSurface.bool IsCylinder</vh></v>
</v>
<v t="leo.20191228122651.154"><vh>class SShell</vh></v>
</v>
<v t="leo.20191228122652.1"><vh>@clean surfinter.cpp</vh>
<v t="leo.20191228122652.2"><vh>void SSurface::AddExactIntersectionCurve (surfinter.cpp)</vh></v>
<v t="leo.20191228122652.3"><vh>void SSurface::IntersectAgainst (surfinter.cpp)</vh>
<v t="leo.20191228122652.4"><vh>bool isExtdt (surfinter.cpp)</vh></v>
</v>
<v t="leo.20191228122652.5"><vh>bool SSurface::CoincidentWith (surfinter.cpp)</vh></v>
<v t="leo.20191228122652.6"><vh>bool SSurface::CoincidentWithPlane (surfinter.cpp)</vh></v>
<v t="leo.20191228122652.7"><vh>void SShell::MakeCoincidentEdgesInto (surfinter.cpp)</vh></v>
</v>
<v t="leo.20191228122652.8"><vh>@clean triangulate.cpp</vh>
<v t="leo.20191228122652.9"><vh>void SPolygon::UvTriangulateInto (triangulate.cpp)</vh></v>
<v t="leo.20191228122652.10"><vh>bool SContour::BridgeToContour (triangulate.cpp)</vh></v>
<v t="leo.20191228122652.11"><vh>bool SContour::IsEar (triangulate.cpp)</vh>
<v t="leo.20191228122652.12"><vh>int ap (triangulate.cpp)</vh></v>
</v>
<v t="leo.20191228122652.13"><vh>void SContour::ClipEarInto (triangulate.cpp)</vh>
<v t="leo.20191228122652.14"><vh>int ap (triangulate.cpp)</vh></v>
</v>
<v t="leo.20191228122652.15"><vh>void SContour::UvTriangulateInto (triangulate.cpp)</vh></v>
<v t="leo.20191228122652.16"><vh>void SSurface::MakeTriangulationGridInto (triangulate.cpp)</vh></v>
<v t="leo.20191228122652.17"><vh>void SPolygon::UvGridTriangulateInto (triangulate.cpp)</vh></v>
<v t="leo.20191228122652.18"><vh>void SPolygon::TriangulateInto (triangulate.cpp)</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20191228122017.1"></t>
<t tx="leo.20191228122017.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20191228122017.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20191228122123.1">編譯步驟:
先將 Y:\portablegit\bin\sh.exe 改名為 sh_rename_for_solvespace.exe (透過 MSYS2 執行 shell 指令, 而非 portablegit 中的 sh.exe), 另外 webots 中可能也會自帶 msys2, 若路徑指向 sh.exe 也須暫時改名, 否則無法編譯 solvespace.

git version 查驗 git 版本

git 2.13 版本以上, 可以使用下列 git clone --recurse-submodules 取得所有子模組資料

git clone --recurse-submodules https://github.com/solvespace/solvespace.git solvespace

上述指令同:

git clone https://github.com/solvespace/solvespace.git 

cd solvespace

git submodule init

git submodule update

edit Y:\tmp\solvespace\extlib\angle\CMakeLists.txt comment out line 713 and 714

#list(APPEND ANGLE_DEFINITIONS
#"-DANGLE_PRELOADED_D3DCOMPILER_MODULE_NAMES={ \"d3dcompiler_47.dll\", \"d3dcompiler_46.dll\", \"d3dcompiler_43.dll\" }")
endif()

接著需要手動進行 libpng.dll.a 的編譯, 並改名為 libpng_static.a, 並放到編譯系統的 lib 目錄中 (即隨身系統的 msys64\mingw64\lib 目錄):

cd solvespace

cd extlib

cd libpng

mkdir build

cd build

cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release
mingw32-make

(mingw32-make -Wl,-static)

rename libpng.dll.a to libpng_static.a and copy to Y:\msys64\mingw64\lib

接著回到 solvespace 原始碼目錄, 建立 build 目錄後進入 build 目錄, 執行:

cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release
mingw32-make

編譯完成後, 可以在 build\bin 目錄中建立 solvespace.exe, 配合相關 dll 檔案後, 即可執行.</t>
<t tx="leo.20191228122134.1">編譯 CDemo.c 流程:

首先將 solvespace/include/slvs.h 複製到 Y:\msys64\mingw64\include

接著將先前 build 目錄中的 libslvs.dll 複製到 Y:\msys64\mingw64\lib

然後在 solvespace\exposed\ 目錄中建立 build 目錄, 然後以指令模式進入此一 build 目錄後, 執行:

cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release
mingw32-make

就可以完成 CDemo.exe 的編譯, 必須配合 libslvs.dll 與 libwinpthread-1.dll 執行.</t>
<t tx="leo.20191228122148.1">c.recursiveImport(
    dir_ = r'./cython',
    kind = '@clean',
    safe_at_file = False,
    theTypes = ['.py', '.pyx', '.pyi', '.pxd', '.diff', '.bat']
)
</t>
<t tx="leo.20191228122441.1"></t>
<t tx="leo.20191228122441.10">def build_extensions(self):
    compiler = self.compiler.compiler_type
    if compiler in {'mingw32', 'unix'}:
        for e in self.extensions:
            e.define_macros = macros
            e.extra_compile_args = compile_args
    elif compiler == 'msvc':
        for e in self.extensions:
            e.define_macros = macros[1:]
            e.libraries = ['shell32']
    super(Build, self).build_extensions()

</t>
<t tx="leo.20191228122441.100">@path ./cython/platform/
@language unknown_language
--- pyconfig.h	2016-01-27 10:54:56.000000000 +0300
+++ pyconfig.h	2016-03-28 11:46:48.000000000 +0300
@@ -100,6 +100,12 @@
 
 /* Compiler specific defines */
 
+#ifdef __MINGW32__
+#ifdef _WIN64
+#define MS_WIN64
+#endif
+#endif
+
 /* ------------------------------------------------------------------------*/
 /* Microsoft C defines _MSC_VER */
 #ifdef _MSC_VER
</t>
<t tx="leo.20191228122441.11">def run(self):
    has_src = isdir(include_path) and isdir(src_path)
    if not has_src:
        copy_source(self.dry_run)
    super(Build, self).run()
    if not has_src:
        dir_util.remove_tree(include_path, dry_run=self.dry_run)
        dir_util.remove_tree(src_path, dry_run=self.dry_run)


</t>
<t tx="leo.20191228122441.12">class PackSource(sdist):
    @others
setup(
    name="python_solvespace",
    version=find_version('python_solvespace', '__init__.py'),
    author=__author__,
    author_email=__email__,
    description="Python library of Solvespace.",
    long_description=read("README.md"),
    long_description_content_type='text/markdown',
    url="https://github.com/KmolYuan/solvespace",
    packages=find_packages(exclude=('tests',)),
    package_data={'': ["*.pyi", "*.pxd"], 'python_solvespace': ['py.typed']},
    ext_modules=[Extension(
        "python_solvespace.slvs",
        sources,
        language="c++",
        include_dirs=[include_path, src_path, platform_path]
    )],
    cmdclass={'build_ext': Build, 'sdist': PackSource},
    zip_safe=False,
    python_requires="&gt;=3.6",
    install_requires=read('requirements.txt').splitlines(),
    test_suite='tests',
    classifiers=[
        "Programming Language :: Python :: 3.6",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Cython",
        "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)",
        "Operating System :: OS Independent",
    ]
)
</t>
<t tx="leo.20191228122441.13">def run(self):
    copy_source(self.dry_run)
    super(PackSource, self).run()
    if not self.keep_temp:
        dir_util.remove_tree(include_path, dry_run=self.dry_run)
        dir_util.remove_tree(src_path, dry_run=self.dry_run)


</t>
<t tx="leo.20191228122441.14"></t>
<t tx="leo.20191228122441.15"></t>
<t tx="leo.20191228122441.16"></t>
<t tx="leo.20191228122441.17">@path ./cython/build/lib.win-amd64-3.8/python_solvespace/
@language unknown_language
# -*- coding: utf-8 -*-
# cython: language_level=3

"""Wrapper header of Solvespace.

author: Yuan Chang
copyright: Copyright (C) 2016-2019
license: GPLv3+
email: pyslvs@gmail.com
"""

from libc.stdint cimport uint32_t
from libcpp.vector cimport vector
from libcpp.map cimport map as cmap

cdef extern from "slvs.h" nogil:

    ctypedef uint32_t Slvs_hParam
    ctypedef uint32_t Slvs_hEntity
    ctypedef uint32_t Slvs_hConstraint
    ctypedef uint32_t Slvs_hGroup

    # Virtual work plane entity
    Slvs_hEntity SLVS_FREE_IN_3D

    ctypedef struct Slvs_Param:
        Slvs_hParam h
        Slvs_hGroup group
        double val

    # Entity type
    int SLVS_E_POINT_IN_3D
    int SLVS_E_POINT_IN_2D
    int SLVS_E_NORMAL_IN_2D
    int SLVS_E_NORMAL_IN_3D
    int SLVS_E_DISTANCE
    int SLVS_E_WORKPLANE
    int SLVS_E_LINE_SEGMENT
    int SLVS_E_CUBIC
    int SLVS_E_CIRCLE
    int SLVS_E_ARC_OF_CIRCLE

    ctypedef struct Slvs_Entity:
        Slvs_hEntity h
        Slvs_hGroup group
        int type
        Slvs_hEntity wrkpl
        Slvs_hEntity point[4]
        Slvs_hEntity normal
        Slvs_hEntity distance
        Slvs_hParam param[4]

    int SLVS_C_POINTS_COINCIDENT
    int SLVS_C_PT_PT_DISTANCE
    int SLVS_C_PT_PLANE_DISTANCE
    int SLVS_C_PT_LINE_DISTANCE
    int SLVS_C_PT_FACE_DISTANCE
    int SLVS_C_PT_IN_PLANE
    int SLVS_C_PT_ON_LINE
    int SLVS_C_PT_ON_FACE
    int SLVS_C_EQUAL_LENGTH_LINES
    int SLVS_C_LENGTH_RATIO
    int SLVS_C_EQ_LEN_PT_LINE_D
    int SLVS_C_EQ_PT_LN_DISTANCES
    int SLVS_C_EQUAL_ANGLE
    int SLVS_C_EQUAL_LINE_ARC_LEN
    int SLVS_C_SYMMETRIC
    int SLVS_C_SYMMETRIC_HORIZ
    int SLVS_C_SYMMETRIC_VERT
    int SLVS_C_SYMMETRIC_LINE
    int SLVS_C_AT_MIDPOINT
    int SLVS_C_HORIZONTAL
    int SLVS_C_VERTICAL
    int SLVS_C_DIAMETER
    int SLVS_C_PT_ON_CIRCLE
    int SLVS_C_SAME_ORIENTATION
    int SLVS_C_ANGLE
    int SLVS_C_PARALLEL
    int SLVS_C_PERPENDICULAR
    int SLVS_C_ARC_LINE_TANGENT
    int SLVS_C_CUBIC_LINE_TANGENT
    int SLVS_C_EQUAL_RADIUS
    int SLVS_C_PROJ_PT_DISTANCE
    int SLVS_C_WHERE_DRAGGED
    int SLVS_C_CURVE_CURVE_TANGENT
    int SLVS_C_LENGTH_DIFFERENCE

    ctypedef struct Slvs_Constraint:
        Slvs_hConstraint h
        Slvs_hGroup group
        int type
        Slvs_hEntity wrkpl
        double valA
        Slvs_hEntity ptA
        Slvs_hEntity ptB
        Slvs_hEntity entityA
        Slvs_hEntity entityB
        Slvs_hEntity entityC
        Slvs_hEntity entityD
        int other
        int other2

    ctypedef struct Slvs_System:
        Slvs_Param *param
        int params
        Slvs_Entity *entity
        int entities
        Slvs_Constraint *constraint
        int constraints
        Slvs_hParam dragged[4]
        int calculateFaileds
        Slvs_hConstraint *failed
        int faileds
        int dof
        int result

    void Slvs_Solve(Slvs_System *sys, Slvs_hGroup hg)
    void Slvs_QuaternionU(
        double qw, double qx, double qy, double qz,
        double *x, double *y, double *z
    )
    void Slvs_QuaternionV(
        double qw, double qx, double qy, double qz,
        double *x, double *y, double *z
    )
    void Slvs_QuaternionN(
        double qw, double qx, double qy, double qz,
        double *x, double *y, double *z
    )
    void Slvs_MakeQuaternion(
        double ux, double uy, double uz,
        double vx, double vy, double vz,
        double *qw, double *qx, double *qy, double *qz
    )
    Slvs_Param Slvs_MakeParam(Slvs_hParam h, Slvs_hGroup group, double val)
    Slvs_Entity Slvs_MakePoint2d(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl,
        Slvs_hParam u, Slvs_hParam v
    )
    Slvs_Entity Slvs_MakePoint3d(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hParam x, Slvs_hParam y, Slvs_hParam z
    )
    Slvs_Entity Slvs_MakeNormal3d(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hParam qw, Slvs_hParam qx,
        Slvs_hParam qy, Slvs_hParam qz
    )
    Slvs_Entity Slvs_MakeNormal2d(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl
    )
    Slvs_Entity Slvs_MakeDistance(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl, Slvs_hParam d
    )
    Slvs_Entity Slvs_MakeLineSegment(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl,
        Slvs_hEntity ptA, Slvs_hEntity ptB
    )
    Slvs_Entity Slvs_MakeCubic(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl,
        Slvs_hEntity pt0, Slvs_hEntity pt1,
        Slvs_hEntity pt2, Slvs_hEntity pt3
    )
    Slvs_Entity Slvs_MakeArcOfCircle(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl,
        Slvs_hEntity normal,
        Slvs_hEntity center,
        Slvs_hEntity start, Slvs_hEntity end
    )
    Slvs_Entity Slvs_MakeCircle(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl,
        Slvs_hEntity center,
        Slvs_hEntity normal, Slvs_hEntity radius
    )
    Slvs_Entity Slvs_MakeWorkplane(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity origin, Slvs_hEntity normal
    )
    Slvs_Constraint Slvs_MakeConstraint(
        Slvs_hConstraint h,
        Slvs_hGroup group,
        int type,
        Slvs_hEntity wrkpl,
        double valA,
        Slvs_hEntity ptA,
        Slvs_hEntity ptB,
        Slvs_hEntity entityA,
        Slvs_hEntity entityB
    )

cpdef tuple quaternion_u(double qw, double qx, double qy, double qz)
cpdef tuple quaternion_v(double qw, double qx, double qy, double qz)
cpdef tuple quaternion_n(double qw, double qx, double qy, double qz)
cpdef tuple make_quaternion(double ux, double uy, double uz, double vx, double vy, double vz)

cdef class Params:

    cdef vector[Slvs_hParam] param_list

    @staticmethod
    cdef Params create(Slvs_hParam *p, size_t count)

cdef class Entity:

    cdef int t
    cdef Slvs_hEntity h, wp
    cdef Slvs_hGroup g
    cdef readonly Params params

    @staticmethod
    cdef Entity create(Slvs_Entity *e, size_t p_size)

    cpdef bint is_3d(self)
    cpdef bint is_none(self)
    cpdef bint is_point_2d(self)
    cpdef bint is_point_3d(self)
    cpdef bint is_point(self)
    cpdef bint is_normal_2d(self)
    cpdef bint is_normal_3d(self)
    cpdef bint is_normal(self)
    cpdef bint is_distance(self)
    cpdef bint is_work_plane(self)
    cpdef bint is_line_2d(self)
    cpdef bint is_line_3d(self)
    cpdef bint is_line(self)
    cpdef bint is_cubic(self)
    cpdef bint is_circle(self)
    cpdef bint is_arc(self)


cdef class SolverSystem:

    cdef Slvs_hGroup g
    cdef Slvs_System sys
    cdef cmap[Slvs_hParam, Slvs_Param] param_list
    cdef vector[Slvs_Entity] entity_list
    cdef vector[Slvs_Constraint] cons_list
    cdef vector[Slvs_hConstraint] failed_list

    cdef void copy_to_sys(self) nogil
    cdef void copy_from_sys(self) nogil
    cpdef void clear(self)
    cdef void failed_collecting(self) nogil
    cdef void free(self)
    cpdef void set_group(self, size_t g)
    cpdef int group(self)
    cpdef void set_params(self, Params p, object params)
    cpdef tuple params(self, Params p)
    cpdef int dof(self)
    cpdef object constraints(self)
    cpdef list faileds(self)
    cpdef int solve(self)
    cpdef Entity create_2d_base(self)
    cdef Slvs_hParam new_param(self, double val) nogil
    cdef Slvs_hEntity eh(self) nogil

    cpdef Entity add_point_2d(self, double u, double v, Entity wp)
    cpdef Entity add_point_3d(self, double x, double y, double z)
    cpdef Entity add_normal_2d(self, Entity wp)
    cpdef Entity add_normal_3d(self, double qw, double qx, double qy, double qz)
    cpdef Entity add_distance(self, double d, Entity wp)
    cpdef Entity add_line_2d(self, Entity p1, Entity p2, Entity wp)
    cpdef Entity add_line_3d(self, Entity p1, Entity p2)
    cpdef Entity add_cubic(self, Entity p1, Entity p2, Entity p3, Entity p4, Entity wp)
    cpdef Entity add_arc(self, Entity nm, Entity ct, Entity start, Entity end, Entity wp)
    cpdef Entity add_circle(self, Entity nm, Entity ct, Entity radius, Entity wp)
    cpdef Entity add_work_plane(self, Entity origin, Entity nm)
    cpdef void add_constraint(
        self,
        int c_type,
        Entity wp,
        double v,
        Entity p1,
        Entity p2,
        Entity e1,
        Entity e2,
        Entity e3 = *,
        Entity e4 = *,
        int other = *,
        int other2 = *
    )

    cpdef void coincident(self, Entity e1, Entity e2, Entity wp = *)
    cpdef void distance(self, Entity e1, Entity e2, double value, Entity wp = *)
    cpdef void equal(self, Entity e1, Entity e2, Entity wp = *)
    cpdef void equal_included_angle(self, Entity e1, Entity e2, Entity e3, Entity e4, Entity wp)
    cpdef void equal_point_to_line(self, Entity e1, Entity e2, Entity e3, Entity e4, Entity wp)
    cpdef void ratio(self, Entity e1, Entity e2, double value, Entity wp)
    cpdef void symmetric(self, Entity e1, Entity e2, Entity e3 = *, Entity wp = *)
    cpdef void symmetric_h(self, Entity e1, Entity e2, Entity wp)
    cpdef void symmetric_v(self, Entity e1, Entity e2, Entity wp)
    cpdef void midpoint(self, Entity e1, Entity e2, Entity wp = *)
    cpdef void horizontal(self, Entity e1, Entity wp)
    cpdef void vertical(self, Entity e1, Entity wp)
    cpdef void diameter(self, Entity e1, double value, Entity wp)
    cpdef void same_orientation(self, Entity e1, Entity e2)
    cpdef void angle(self, Entity e1, Entity e2, double value, Entity wp, bint inverse = *)
    cpdef void perpendicular(self, Entity e1, Entity e2, Entity wp, bint inverse = *)
    cpdef void parallel(self, Entity e1, Entity e2, Entity wp = *)
    cpdef void tangent(self, Entity e1, Entity e2, Entity wp = *)
    cpdef void distance_proj(self, Entity e1, Entity e2, double value)
    cpdef void dragged(self, Entity e1, Entity wp = *)
</t>
<t tx="leo.20191228122441.18">@path ./cython/build/lib.win-amd64-3.8/python_solvespace/
# -*- coding: utf-8 -*-

@others
@language python
@tabwidth -4
</t>
<t tx="leo.20191228122441.19">from typing import Tuple, List, Sequence, Counter, ClassVar

</t>
<t tx="leo.20191228122441.2"></t>
<t tx="leo.20191228122441.20">def quaternion_u(
    qw: float,
    qx: float,
    qy: float,
    qz: float
) -&gt; Tuple[float, float, float]:
    ...

</t>
<t tx="leo.20191228122441.21">def quaternion_v(
    qw: float,
    qx: float,
    qy: float,
    qz: float
) -&gt; Tuple[float, float, float]:
    ...

</t>
<t tx="leo.20191228122441.22">def quaternion_n(
    qw: float,
    qx: float,
    qy: float,
    qz: float
) -&gt; Tuple[float, float, float]:
    ...

</t>
<t tx="leo.20191228122441.23">def make_quaternion(
    ux: float,
    uy: float,
    uz: float,
    vx: float,
    vy: float,
    vz: float
) -&gt; Tuple[float, float, float, float]:
    ...


</t>
<t tx="leo.20191228122441.24">class Params:

    @others
</t>
<t tx="leo.20191228122441.25">def __repr__(self) -&gt; str:
    ...


</t>
<t tx="leo.20191228122441.26">class Entity:

    FREE_IN_3D: ClassVar[Entity]
    NONE: ClassVar[Entity]
    params: Params

    @others
</t>
<t tx="leo.20191228122441.27">def is_3d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.28">def is_none(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.29">def is_point_2d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.3">@path ./cython/
# -*- coding: utf-8 -*-

@others
@language python
@tabwidth -4
</t>
<t tx="leo.20191228122441.30">def is_point_3d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.31">def is_point(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.32">def is_normal_2d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.33">def is_normal_3d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.34">def is_normal(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.35">def is_distance(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.36">def is_work_plane(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.37">def is_line_2d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.38">def is_line_3d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.39">def is_line(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.4">"""Compile the Cython libraries of Python-Solvespace."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2019"
__license__ = "GPLv3+"
__email__ = "pyslvs@gmail.com"

import sys
from os import walk
from os.path import dirname, isdir, join as pth_join
import re
import codecs
from setuptools import setup, Extension, find_packages
from setuptools.command.build_ext import build_ext
from setuptools.command.sdist import sdist
from distutils import file_util, dir_util
from platform import system

include_path = pth_join('python_solvespace', 'include')
src_path = pth_join('python_solvespace', 'src')
platform_path = pth_join(src_path, 'platform')


</t>
<t tx="leo.20191228122441.40">def is_cubic(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.41">def is_circle(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.42">def is_arc(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122441.43">def __repr__(self) -&gt; str:
    ...


</t>
<t tx="leo.20191228122441.44">class SolverSystem:

    @others
</t>
<t tx="leo.20191228122441.45">def __init__(self) -&gt; None:
    ...

</t>
<t tx="leo.20191228122441.46">def clear(self) -&gt; None:
    ...

</t>
<t tx="leo.20191228122441.47">def set_group(self, g: int) -&gt; None:
    ...

</t>
<t tx="leo.20191228122441.48">def group(self) -&gt; int:
    ...

</t>
<t tx="leo.20191228122441.49">def set_params(self, p: Params, params: Sequence[float]) -&gt; None:
    ...

</t>
<t tx="leo.20191228122441.5">def write(doc, *parts):
    with codecs.open(pth_join(*parts), 'w') as f:
        f.write(doc)


</t>
<t tx="leo.20191228122441.50">def params(self, p: Params) -&gt; Tuple[float, ...]:
    ...

</t>
<t tx="leo.20191228122441.51">def dof(self) -&gt; int:
    ...

</t>
<t tx="leo.20191228122441.52">def constraints(self) -&gt; Counter[str]:
    ...

</t>
<t tx="leo.20191228122441.53">def faileds(self) -&gt; List[int]:
    ...

</t>
<t tx="leo.20191228122441.54">def solve(self) -&gt; int:
    ...

</t>
<t tx="leo.20191228122441.55">def create_2d_base(self) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122441.56">def add_point_2d(self, u: float, v: float, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122441.57">def add_point_3d(self, x: float, y: float, z: float) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122441.58">def add_normal_2d(self, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122441.59">def add_normal_3d(self, qw: float, qx: float, qy: float, qz: float) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122441.6">def read(*parts):
    with codecs.open(pth_join(*parts), 'r') as f:
        return f.read()


</t>
<t tx="leo.20191228122441.60">def add_distance(self, d: float, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122441.61">def add_line_2d(self, p1: Entity, p2: Entity, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122441.62">def add_line_3d(self, p1: Entity, p2: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122441.63">def add_cubic(self, p1: Entity, p2: Entity, p3: Entity, p4: Entity, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122441.64">def add_arc(self, nm: Entity, ct: Entity, start: Entity, end: Entity, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122441.65">def add_circle(self, nm: Entity, ct: Entity, radius: Entity, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122441.66">def add_work_plane(self, origin: Entity, nm: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122441.67">def add_constraint(
    self,
    c_type: int,
    wp: Entity,
    v: float,
    p1: Entity,
    p2: Entity,
    e1: Entity,
    e2: Entity,
    e3: Entity = Entity.NONE,
    e4: Entity = Entity.NONE,
    other: int = 0,
    other2: int = 0
) -&gt; None:
    ...

</t>
<t tx="leo.20191228122441.68">def coincident(self, e1: Entity, e2: Entity, wp: Entity = Entity.FREE_IN_3D) -&gt; None:
    """Coincident two entities."""
    ...

</t>
<t tx="leo.20191228122441.69">def distance(
    self,
    e1: Entity,
    e2: Entity,
    value: float,
    wp: Entity = Entity.FREE_IN_3D
) -&gt; None:
    """Distance constraint between two entities."""
    ...

</t>
<t tx="leo.20191228122441.7">def find_version(*file_paths):
    m = re.search(r"^__version__ = ['\"]([^'\"]*)['\"]", read(*file_paths), re.M)
    if m:
        return m.group(1)
    raise RuntimeError("Unable to find version string.")


macros = [
    ('M_PI', 'PI'),
    ('_USE_MATH_DEFINES', None),
    ('ISOLATION_AWARE_ENABLED', None),
    ('LIBRARY', None),
    ('EXPORT_DLL', None),
    ('_CRT_SECURE_NO_WARNINGS', None),
]
compile_args = [
    '-O3',
    '-Wno-cpp',
    '-g',
    '-Wno-write-strings',
    '-fpermissive',
    '-fPIC',
    '-std=c++17',
    '-DMS_WIN64',
]
sources = [
    pth_join('python_solvespace', 'slvs.pyx'),
    pth_join(src_path, 'util.cpp'),
    pth_join(src_path, 'entity.cpp'),
    pth_join(src_path, 'expr.cpp'),
    pth_join(src_path, 'constrainteq.cpp'),
    pth_join(src_path, 'constraint.cpp'),
    pth_join(src_path, 'system.cpp'),
    pth_join(src_path, 'lib.cpp'),
]
if {'sdist', 'bdist'} &amp; set(sys.argv):
    for s in ('utilwin', 'utilunix', 'platform'):
        sources.append(pth_join(platform_path, f'{s}.cpp'))
elif system() == 'Windows':
    # Disable format warning
    compile_args.append('-Wno-format')
    # Solvespace arguments
    macros.append(('WIN32', None))
    # Platform sources
    sources.append(pth_join(platform_path, 'utilwin.cpp'))
    sources.append(pth_join(platform_path, 'platform.cpp'))
    if sys.version_info &lt; (3, 7):
        macros.append(('_hypot', 'hypot'))
else:
    sources.append(pth_join(platform_path, 'utilunix.cpp'))


</t>
<t tx="leo.20191228122441.70">def equal(self, e1: Entity, e2: Entity, wp: Entity = Entity.FREE_IN_3D) -&gt; None:
    """Equal constraint between two entities."""
    ...

</t>
<t tx="leo.20191228122441.71">def equal_included_angle(
    self,
    e1: Entity,
    e2: Entity,
    e3: Entity,
    e4: Entity,
    wp: Entity
) -&gt; None:
    """Constraint that point 1 and line 1, point 2 and line 2
    must have same distance.
    """
    ...

</t>
<t tx="leo.20191228122441.72">def equal_point_to_line(
    self,
    e1: Entity,
    e2: Entity,
    e3: Entity,
    e4: Entity,
    wp: Entity
) -&gt; None:
    """Constraint that line 1 and line 2, line 3 and line 4
    must have same included angle.
    """
    ...

</t>
<t tx="leo.20191228122441.73">def ratio(self, e1: Entity, e2: Entity, value: float, wp: Entity) -&gt; None:
    """The ratio constraint between two lines."""
    ...

</t>
<t tx="leo.20191228122441.74">def symmetric(
    self,
    e1: Entity,
    e2: Entity,
    e3: Entity = Entity.NONE,
    wp: Entity = Entity.FREE_IN_3D
) -&gt; None:
    """Symmetric constraint between two points."""
    ...

</t>
<t tx="leo.20191228122441.75">def symmetric_h(self, e1: Entity, e2: Entity, wp: Entity) -&gt; None:
    """Symmetric constraint between two points with horizontal line."""
    ...

</t>
<t tx="leo.20191228122441.76">def symmetric_v(self, e1: Entity, e2: Entity, wp: Entity) -&gt; None:
    """Symmetric constraint between two points with vertical line."""
    ...

</t>
<t tx="leo.20191228122441.77">def midpoint(
    self,
    e1: Entity,
    e2: Entity,
    wp: Entity = Entity.FREE_IN_3D
) -&gt; None:
    """Midpoint constraint between a point and a line."""
    ...

</t>
<t tx="leo.20191228122441.78">def horizontal(self, e1: Entity, wp: Entity) -&gt; None:
    """Horizontal constraint of a 2d point."""
    ...

</t>
<t tx="leo.20191228122441.79">def vertical(self, e1: Entity, wp: Entity) -&gt; None:
    """Vertical constraint of a 2d point."""
    ...

</t>
<t tx="leo.20191228122441.8">def copy_source(dry_run):
    dir_util.copy_tree(pth_join('..', 'include'), include_path, dry_run=dry_run)
    dir_util.mkpath(src_path)
    for root, _, files in walk(pth_join('..', 'src')):
        for f in files:
            if not f.endswith('.h'):
                continue
            f = pth_join(root, f)
            f_new = f.replace('..', 'python_solvespace')
            if not isdir(dirname(f_new)):
                dir_util.mkpath(dirname(f_new))
            file_util.copy_file(f, f_new, dry_run=dry_run)
    for f in sources[1:]:
        file_util.copy_file(f.replace('python_solvespace', '..'), f, dry_run=dry_run)
    open(pth_join(platform_path, 'config.h'), 'a').close()


</t>
<t tx="leo.20191228122441.80">def diameter(self, e1: Entity, value: float, wp: Entity) -&gt; None:
    """Diameter constraint of a circular entities."""
    ...

</t>
<t tx="leo.20191228122441.81">def same_orientation(self, e1: Entity, e2: Entity) -&gt; None:
    """Equal orientation constraint between two 3d normals."""
    ...

</t>
<t tx="leo.20191228122441.82">def angle(self, e1: Entity, e2: Entity, value: float, wp: Entity, inverse: bool = False) -&gt; None:
    """Degrees angle constraint between two 2d lines."""
    ...

</t>
<t tx="leo.20191228122441.83">def perpendicular(self, e1: Entity, e2: Entity, wp: Entity, inverse: bool = False) -&gt; None:
    """Perpendicular constraint between two 2d lines."""
    ...

</t>
<t tx="leo.20191228122441.84">def parallel(self, e1: Entity, e2: Entity, wp: Entity = Entity.FREE_IN_3D) -&gt; None:
    """Parallel constraint between two lines."""
    ...

</t>
<t tx="leo.20191228122441.85">def tangent(self, e1: Entity, e2: Entity, wp: Entity = Entity.FREE_IN_3D) -&gt; None:
    """Parallel constraint between two entities."""
    ...

</t>
<t tx="leo.20191228122441.86">def distance_proj(self, e1: Entity, e2: Entity, value: float) -&gt; None:
    """Projected distance constraint between two 3d points."""
    ...

</t>
<t tx="leo.20191228122441.87">def dragged(self, e1: Entity, wp: Entity = Entity.FREE_IN_3D) -&gt; None:
    """Dragged constraint of a point."""
    ...
</t>
<t tx="leo.20191228122441.88">@path ./cython/build/lib.win-amd64-3.8/python_solvespace/
@language unknown_language
 
</t>
<t tx="leo.20191228122441.89">@path ./cython/build/lib.win-amd64-3.8/python_solvespace/
# -*- coding: utf-8 -*-

@others
@language python
@tabwidth -4
</t>
<t tx="leo.20191228122441.9">class Build(build_ext):
    @others
</t>
<t tx="leo.20191228122441.90">"""'python_solvespace' module is a wrapper of
Python binding Solvespace solver libraries.
"""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2019"
__license__ = "GPLv3+"
__email__ = "pyslvs@gmail.com"
__version__ = "3.0.1.post0"

from enum import IntEnum, auto
from .slvs import (
    quaternion_u,
    quaternion_v,
    quaternion_n,
    make_quaternion,
    Params,
    Entity,
    SolverSystem,
)

__all__ = [
    'quaternion_u',
    'quaternion_v',
    'quaternion_n',
    'make_quaternion',
    'Constraint',
    'ResultFlag',
    'Params',
    'Entity',
    'SolverSystem',
]


</t>
<t tx="leo.20191228122441.91">class Constraint(IntEnum):
    # Expose macro of constraint types
    POINTS_COINCIDENT = 100000
    PT_PT_DISTANCE = auto()
    PT_PLANE_DISTANCE = auto()
    PT_LINE_DISTANCE = auto()
    PT_FACE_DISTANCE = auto()
    PT_IN_PLANE = auto()
    PT_ON_LINE = auto()
    PT_ON_FACE = auto()
    EQUAL_LENGTH_LINES = auto()
    LENGTH_RATIO = auto()
    EQ_LEN_PT_LINE_D = auto()
    EQ_PT_LN_DISTANCES = auto()
    EQUAL_ANGLE = auto()
    EQUAL_LINE_ARC_LEN = auto()
    SYMMETRIC = auto()
    SYMMETRIC_HORIZ = auto()
    SYMMETRIC_VERT = auto()
    SYMMETRIC_LINE = auto()
    AT_MIDPOINT = auto()
    HORIZONTAL = auto()
    VERTICAL = auto()
    DIAMETER = auto()
    PT_ON_CIRCLE = auto()
    SAME_ORIENTATION = auto()
    ANGLE = auto()
    PARALLEL = auto()
    PERPENDICULAR = auto()
    ARC_LINE_TANGENT = auto()
    CUBIC_LINE_TANGENT = auto()
    EQUAL_RADIUS = auto()
    PROJ_PT_DISTANCE = auto()
    WHERE_DRAGGED = auto()
    CURVE_CURVE_TANGENT = auto()
    LENGTH_DIFFERENCE = auto()


</t>
<t tx="leo.20191228122441.92">class ResultFlag(IntEnum):
    # Expose macro of result flags
    OKAY = 0
    INCONSISTENT = auto()
    DIDNT_CONVERGE = auto()
    TOO_MANY_UNKNOWNS = auto()
</t>
<t tx="leo.20191228122441.93"></t>
<t tx="leo.20191228122441.94"></t>
<t tx="leo.20191228122441.95"></t>
<t tx="leo.20191228122441.96"></t>
<t tx="leo.20191228122441.98"></t>
<t tx="leo.20191228122441.99">@path ./cython/platform/
@language unknown_language
--- cygwinccompiler.py
+++ cygwinccompiler.py
@@ -82,7 +82,25 @@ def get_msvcr():
         elif msc_ver == '1600':
             # VS2010 / MSVC 10.0
             return ['msvcr100']
+        elif msc_ver == '1700':
+            # Visual Studio 2012 / Visual C++ 11.0
+            return ['msvcr110']
+        elif msc_ver == '1800':
+            # Visual Studio 2013 / Visual C++ 12.0
+            return ['msvcr120']
+        elif msc_ver == '1900':
+            # Visual Studio 2015 / Visual C++ 14.0
+            # "msvcr140.dll no longer exists" http://blogs.msdn.com/b/vcblog/archive/2014/06/03/visual-studio-14-ctp.aspx
+            return ['vcruntime140']
+        elif msc_ver == '1910':
+            return ['vcruntime140']
+        elif msc_ver == '1914':
+            return ['vcruntime140']
+        elif msc_ver == '1915':
+            return ['vcruntime140']
+        elif msc_ver == '1916':
+            return ['vcruntime140']
         else:
             raise ValueError("Unknown MS Compiler version %s " % msc_ver)
</t>
<t tx="leo.20191228122442.1">@path ./cython/platform/
@language batch
echo off

REM Usage: set_pycompiler C:\Python37 mingw32
REM Where %PYTHON_DIR% is the directory of your Python installation.
REM Compiler option can be "mingw32" or "msvc".
REM In Pyslvs project.
set HERE=%~dp0
set PYTHON_DIR=%1
set COMPILER=%2

REM Create "distutils.cfg"
set DISTUTILS=%PYTHON_DIR%\Lib\distutils\distutils.cfg
if exist "%DISTUTILS%" del "%DISTUTILS%" /Q /S
echo [build]&gt;&gt; "%DISTUTILS%"
echo compiler=%COMPILER%&gt;&gt; "%DISTUTILS%"
echo patched file "%DISTUTILS%"
REM Apply the patch of "cygwinccompiler.py".
REM Unix "patch" command of Msys.
patch -N "%PYTHON_DIR%\lib\distutils\cygwinccompiler.py" "%HERE%\cygwinccompiler.diff"
patch -N "%PYTHON_DIR%\include\pyconfig.h" "%HERE%\pyconfig.diff"

REM Copy "vcruntime140.dll" to "libs".
copy "%PYTHON_DIR%\vcruntime140.dll" "%PYTHON_DIR%\libs"
echo copied "vcruntime140.dll".
</t>
<t tx="leo.20191228122442.10">class Params:

    @others
</t>
<t tx="leo.20191228122442.11">def __repr__(self) -&gt; str:
    ...


</t>
<t tx="leo.20191228122442.12">class Entity:

    FREE_IN_3D: ClassVar[Entity]
    NONE: ClassVar[Entity]
    params: Params

    @others
</t>
<t tx="leo.20191228122442.13">def is_3d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.14">def is_none(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.15">def is_point_2d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.16">def is_point_3d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.17">def is_point(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.18">def is_normal_2d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.19">def is_normal_3d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.2"></t>
<t tx="leo.20191228122442.20">def is_normal(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.21">def is_distance(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.22">def is_work_plane(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.23">def is_line_2d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.24">def is_line_3d(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.25">def is_line(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.26">def is_cubic(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.27">def is_circle(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.28">def is_arc(self) -&gt; bool:
    ...

</t>
<t tx="leo.20191228122442.29">def __repr__(self) -&gt; str:
    ...


</t>
<t tx="leo.20191228122442.3">@path ./cython/python_solvespace/
@language unknown_language
# -*- coding: utf-8 -*-
# cython: language_level=3

"""Wrapper header of Solvespace.

author: Yuan Chang
copyright: Copyright (C) 2016-2019
license: GPLv3+
email: pyslvs@gmail.com
"""

from libc.stdint cimport uint32_t
from libcpp.vector cimport vector
from libcpp.map cimport map as cmap

cdef extern from "slvs.h" nogil:

    ctypedef uint32_t Slvs_hParam
    ctypedef uint32_t Slvs_hEntity
    ctypedef uint32_t Slvs_hConstraint
    ctypedef uint32_t Slvs_hGroup

    # Virtual work plane entity
    Slvs_hEntity SLVS_FREE_IN_3D

    ctypedef struct Slvs_Param:
        Slvs_hParam h
        Slvs_hGroup group
        double val

    # Entity type
    int SLVS_E_POINT_IN_3D
    int SLVS_E_POINT_IN_2D
    int SLVS_E_NORMAL_IN_2D
    int SLVS_E_NORMAL_IN_3D
    int SLVS_E_DISTANCE
    int SLVS_E_WORKPLANE
    int SLVS_E_LINE_SEGMENT
    int SLVS_E_CUBIC
    int SLVS_E_CIRCLE
    int SLVS_E_ARC_OF_CIRCLE

    ctypedef struct Slvs_Entity:
        Slvs_hEntity h
        Slvs_hGroup group
        int type
        Slvs_hEntity wrkpl
        Slvs_hEntity point[4]
        Slvs_hEntity normal
        Slvs_hEntity distance
        Slvs_hParam param[4]

    int SLVS_C_POINTS_COINCIDENT
    int SLVS_C_PT_PT_DISTANCE
    int SLVS_C_PT_PLANE_DISTANCE
    int SLVS_C_PT_LINE_DISTANCE
    int SLVS_C_PT_FACE_DISTANCE
    int SLVS_C_PT_IN_PLANE
    int SLVS_C_PT_ON_LINE
    int SLVS_C_PT_ON_FACE
    int SLVS_C_EQUAL_LENGTH_LINES
    int SLVS_C_LENGTH_RATIO
    int SLVS_C_EQ_LEN_PT_LINE_D
    int SLVS_C_EQ_PT_LN_DISTANCES
    int SLVS_C_EQUAL_ANGLE
    int SLVS_C_EQUAL_LINE_ARC_LEN
    int SLVS_C_SYMMETRIC
    int SLVS_C_SYMMETRIC_HORIZ
    int SLVS_C_SYMMETRIC_VERT
    int SLVS_C_SYMMETRIC_LINE
    int SLVS_C_AT_MIDPOINT
    int SLVS_C_HORIZONTAL
    int SLVS_C_VERTICAL
    int SLVS_C_DIAMETER
    int SLVS_C_PT_ON_CIRCLE
    int SLVS_C_SAME_ORIENTATION
    int SLVS_C_ANGLE
    int SLVS_C_PARALLEL
    int SLVS_C_PERPENDICULAR
    int SLVS_C_ARC_LINE_TANGENT
    int SLVS_C_CUBIC_LINE_TANGENT
    int SLVS_C_EQUAL_RADIUS
    int SLVS_C_PROJ_PT_DISTANCE
    int SLVS_C_WHERE_DRAGGED
    int SLVS_C_CURVE_CURVE_TANGENT
    int SLVS_C_LENGTH_DIFFERENCE

    ctypedef struct Slvs_Constraint:
        Slvs_hConstraint h
        Slvs_hGroup group
        int type
        Slvs_hEntity wrkpl
        double valA
        Slvs_hEntity ptA
        Slvs_hEntity ptB
        Slvs_hEntity entityA
        Slvs_hEntity entityB
        Slvs_hEntity entityC
        Slvs_hEntity entityD
        int other
        int other2

    ctypedef struct Slvs_System:
        Slvs_Param *param
        int params
        Slvs_Entity *entity
        int entities
        Slvs_Constraint *constraint
        int constraints
        Slvs_hParam dragged[4]
        int calculateFaileds
        Slvs_hConstraint *failed
        int faileds
        int dof
        int result

    void Slvs_Solve(Slvs_System *sys, Slvs_hGroup hg)
    void Slvs_QuaternionU(
        double qw, double qx, double qy, double qz,
        double *x, double *y, double *z
    )
    void Slvs_QuaternionV(
        double qw, double qx, double qy, double qz,
        double *x, double *y, double *z
    )
    void Slvs_QuaternionN(
        double qw, double qx, double qy, double qz,
        double *x, double *y, double *z
    )
    void Slvs_MakeQuaternion(
        double ux, double uy, double uz,
        double vx, double vy, double vz,
        double *qw, double *qx, double *qy, double *qz
    )
    Slvs_Param Slvs_MakeParam(Slvs_hParam h, Slvs_hGroup group, double val)
    Slvs_Entity Slvs_MakePoint2d(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl,
        Slvs_hParam u, Slvs_hParam v
    )
    Slvs_Entity Slvs_MakePoint3d(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hParam x, Slvs_hParam y, Slvs_hParam z
    )
    Slvs_Entity Slvs_MakeNormal3d(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hParam qw, Slvs_hParam qx,
        Slvs_hParam qy, Slvs_hParam qz
    )
    Slvs_Entity Slvs_MakeNormal2d(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl
    )
    Slvs_Entity Slvs_MakeDistance(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl, Slvs_hParam d
    )
    Slvs_Entity Slvs_MakeLineSegment(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl,
        Slvs_hEntity ptA, Slvs_hEntity ptB
    )
    Slvs_Entity Slvs_MakeCubic(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl,
        Slvs_hEntity pt0, Slvs_hEntity pt1,
        Slvs_hEntity pt2, Slvs_hEntity pt3
    )
    Slvs_Entity Slvs_MakeArcOfCircle(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl,
        Slvs_hEntity normal,
        Slvs_hEntity center,
        Slvs_hEntity start, Slvs_hEntity end
    )
    Slvs_Entity Slvs_MakeCircle(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity wrkpl,
        Slvs_hEntity center,
        Slvs_hEntity normal, Slvs_hEntity radius
    )
    Slvs_Entity Slvs_MakeWorkplane(
        Slvs_hEntity h, Slvs_hGroup group,
        Slvs_hEntity origin, Slvs_hEntity normal
    )
    Slvs_Constraint Slvs_MakeConstraint(
        Slvs_hConstraint h,
        Slvs_hGroup group,
        int type,
        Slvs_hEntity wrkpl,
        double valA,
        Slvs_hEntity ptA,
        Slvs_hEntity ptB,
        Slvs_hEntity entityA,
        Slvs_hEntity entityB
    )

cpdef tuple quaternion_u(double qw, double qx, double qy, double qz)
cpdef tuple quaternion_v(double qw, double qx, double qy, double qz)
cpdef tuple quaternion_n(double qw, double qx, double qy, double qz)
cpdef tuple make_quaternion(double ux, double uy, double uz, double vx, double vy, double vz)

cdef class Params:

    cdef vector[Slvs_hParam] param_list

    @staticmethod
    cdef Params create(Slvs_hParam *p, size_t count)

cdef class Entity:

    cdef int t
    cdef Slvs_hEntity h, wp
    cdef Slvs_hGroup g
    cdef readonly Params params

    @staticmethod
    cdef Entity create(Slvs_Entity *e, size_t p_size)

    cpdef bint is_3d(self)
    cpdef bint is_none(self)
    cpdef bint is_point_2d(self)
    cpdef bint is_point_3d(self)
    cpdef bint is_point(self)
    cpdef bint is_normal_2d(self)
    cpdef bint is_normal_3d(self)
    cpdef bint is_normal(self)
    cpdef bint is_distance(self)
    cpdef bint is_work_plane(self)
    cpdef bint is_line_2d(self)
    cpdef bint is_line_3d(self)
    cpdef bint is_line(self)
    cpdef bint is_cubic(self)
    cpdef bint is_circle(self)
    cpdef bint is_arc(self)


cdef class SolverSystem:

    cdef Slvs_hGroup g
    cdef Slvs_System sys
    cdef cmap[Slvs_hParam, Slvs_Param] param_list
    cdef vector[Slvs_Entity] entity_list
    cdef vector[Slvs_Constraint] cons_list
    cdef vector[Slvs_hConstraint] failed_list

    cdef void copy_to_sys(self) nogil
    cdef void copy_from_sys(self) nogil
    cpdef void clear(self)
    cdef void failed_collecting(self) nogil
    cdef void free(self)
    cpdef void set_group(self, size_t g)
    cpdef int group(self)
    cpdef void set_params(self, Params p, object params)
    cpdef tuple params(self, Params p)
    cpdef int dof(self)
    cpdef object constraints(self)
    cpdef list faileds(self)
    cpdef int solve(self)
    cpdef Entity create_2d_base(self)
    cdef Slvs_hParam new_param(self, double val) nogil
    cdef Slvs_hEntity eh(self) nogil

    cpdef Entity add_point_2d(self, double u, double v, Entity wp)
    cpdef Entity add_point_3d(self, double x, double y, double z)
    cpdef Entity add_normal_2d(self, Entity wp)
    cpdef Entity add_normal_3d(self, double qw, double qx, double qy, double qz)
    cpdef Entity add_distance(self, double d, Entity wp)
    cpdef Entity add_line_2d(self, Entity p1, Entity p2, Entity wp)
    cpdef Entity add_line_3d(self, Entity p1, Entity p2)
    cpdef Entity add_cubic(self, Entity p1, Entity p2, Entity p3, Entity p4, Entity wp)
    cpdef Entity add_arc(self, Entity nm, Entity ct, Entity start, Entity end, Entity wp)
    cpdef Entity add_circle(self, Entity nm, Entity ct, Entity radius, Entity wp)
    cpdef Entity add_work_plane(self, Entity origin, Entity nm)
    cpdef void add_constraint(
        self,
        int c_type,
        Entity wp,
        double v,
        Entity p1,
        Entity p2,
        Entity e1,
        Entity e2,
        Entity e3 = *,
        Entity e4 = *,
        int other = *,
        int other2 = *
    )

    cpdef void coincident(self, Entity e1, Entity e2, Entity wp = *)
    cpdef void distance(self, Entity e1, Entity e2, double value, Entity wp = *)
    cpdef void equal(self, Entity e1, Entity e2, Entity wp = *)
    cpdef void equal_included_angle(self, Entity e1, Entity e2, Entity e3, Entity e4, Entity wp)
    cpdef void equal_point_to_line(self, Entity e1, Entity e2, Entity e3, Entity e4, Entity wp)
    cpdef void ratio(self, Entity e1, Entity e2, double value, Entity wp)
    cpdef void symmetric(self, Entity e1, Entity e2, Entity e3 = *, Entity wp = *)
    cpdef void symmetric_h(self, Entity e1, Entity e2, Entity wp)
    cpdef void symmetric_v(self, Entity e1, Entity e2, Entity wp)
    cpdef void midpoint(self, Entity e1, Entity e2, Entity wp = *)
    cpdef void horizontal(self, Entity e1, Entity wp)
    cpdef void vertical(self, Entity e1, Entity wp)
    cpdef void diameter(self, Entity e1, double value, Entity wp)
    cpdef void same_orientation(self, Entity e1, Entity e2)
    cpdef void angle(self, Entity e1, Entity e2, double value, Entity wp, bint inverse = *)
    cpdef void perpendicular(self, Entity e1, Entity e2, Entity wp, bint inverse = *)
    cpdef void parallel(self, Entity e1, Entity e2, Entity wp = *)
    cpdef void tangent(self, Entity e1, Entity e2, Entity wp = *)
    cpdef void distance_proj(self, Entity e1, Entity e2, double value)
    cpdef void dragged(self, Entity e1, Entity wp = *)
</t>
<t tx="leo.20191228122442.30">class SolverSystem:

    @others
</t>
<t tx="leo.20191228122442.31">def __init__(self) -&gt; None:
    ...

</t>
<t tx="leo.20191228122442.32">def clear(self) -&gt; None:
    ...

</t>
<t tx="leo.20191228122442.33">def set_group(self, g: int) -&gt; None:
    ...

</t>
<t tx="leo.20191228122442.34">def group(self) -&gt; int:
    ...

</t>
<t tx="leo.20191228122442.35">def set_params(self, p: Params, params: Sequence[float]) -&gt; None:
    ...

</t>
<t tx="leo.20191228122442.36">def params(self, p: Params) -&gt; Tuple[float, ...]:
    ...

</t>
<t tx="leo.20191228122442.37">def dof(self) -&gt; int:
    ...

</t>
<t tx="leo.20191228122442.38">def constraints(self) -&gt; Counter[str]:
    ...

</t>
<t tx="leo.20191228122442.39">def faileds(self) -&gt; List[int]:
    ...

</t>
<t tx="leo.20191228122442.4">@path ./cython/python_solvespace/
# -*- coding: utf-8 -*-

@others
@language python
@tabwidth -4
</t>
<t tx="leo.20191228122442.40">def solve(self) -&gt; int:
    ...

</t>
<t tx="leo.20191228122442.41">def create_2d_base(self) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122442.42">def add_point_2d(self, u: float, v: float, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122442.43">def add_point_3d(self, x: float, y: float, z: float) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122442.44">def add_normal_2d(self, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122442.45">def add_normal_3d(self, qw: float, qx: float, qy: float, qz: float) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122442.46">def add_distance(self, d: float, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122442.47">def add_line_2d(self, p1: Entity, p2: Entity, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122442.48">def add_line_3d(self, p1: Entity, p2: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122442.49">def add_cubic(self, p1: Entity, p2: Entity, p3: Entity, p4: Entity, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122442.5">from typing import Tuple, List, Sequence, Counter, ClassVar

</t>
<t tx="leo.20191228122442.50">def add_arc(self, nm: Entity, ct: Entity, start: Entity, end: Entity, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122442.51">def add_circle(self, nm: Entity, ct: Entity, radius: Entity, wp: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122442.52">def add_work_plane(self, origin: Entity, nm: Entity) -&gt; Entity:
    ...

</t>
<t tx="leo.20191228122442.53">def add_constraint(
    self,
    c_type: int,
    wp: Entity,
    v: float,
    p1: Entity,
    p2: Entity,
    e1: Entity,
    e2: Entity,
    e3: Entity = Entity.NONE,
    e4: Entity = Entity.NONE,
    other: int = 0,
    other2: int = 0
) -&gt; None:
    ...

</t>
<t tx="leo.20191228122442.54">def coincident(self, e1: Entity, e2: Entity, wp: Entity = Entity.FREE_IN_3D) -&gt; None:
    """Coincident two entities."""
    ...

</t>
<t tx="leo.20191228122442.55">def distance(
    self,
    e1: Entity,
    e2: Entity,
    value: float,
    wp: Entity = Entity.FREE_IN_3D
) -&gt; None:
    """Distance constraint between two entities."""
    ...

</t>
<t tx="leo.20191228122442.56">def equal(self, e1: Entity, e2: Entity, wp: Entity = Entity.FREE_IN_3D) -&gt; None:
    """Equal constraint between two entities."""
    ...

</t>
<t tx="leo.20191228122442.57">def equal_included_angle(
    self,
    e1: Entity,
    e2: Entity,
    e3: Entity,
    e4: Entity,
    wp: Entity
) -&gt; None:
    """Constraint that point 1 and line 1, point 2 and line 2
    must have same distance.
    """
    ...

</t>
<t tx="leo.20191228122442.58">def equal_point_to_line(
    self,
    e1: Entity,
    e2: Entity,
    e3: Entity,
    e4: Entity,
    wp: Entity
) -&gt; None:
    """Constraint that line 1 and line 2, line 3 and line 4
    must have same included angle.
    """
    ...

</t>
<t tx="leo.20191228122442.59">def ratio(self, e1: Entity, e2: Entity, value: float, wp: Entity) -&gt; None:
    """The ratio constraint between two lines."""
    ...

</t>
<t tx="leo.20191228122442.6">def quaternion_u(
    qw: float,
    qx: float,
    qy: float,
    qz: float
) -&gt; Tuple[float, float, float]:
    ...

</t>
<t tx="leo.20191228122442.60">def symmetric(
    self,
    e1: Entity,
    e2: Entity,
    e3: Entity = Entity.NONE,
    wp: Entity = Entity.FREE_IN_3D
) -&gt; None:
    """Symmetric constraint between two points."""
    ...

</t>
<t tx="leo.20191228122442.61">def symmetric_h(self, e1: Entity, e2: Entity, wp: Entity) -&gt; None:
    """Symmetric constraint between two points with horizontal line."""
    ...

</t>
<t tx="leo.20191228122442.62">def symmetric_v(self, e1: Entity, e2: Entity, wp: Entity) -&gt; None:
    """Symmetric constraint between two points with vertical line."""
    ...

</t>
<t tx="leo.20191228122442.63">def midpoint(
    self,
    e1: Entity,
    e2: Entity,
    wp: Entity = Entity.FREE_IN_3D
) -&gt; None:
    """Midpoint constraint between a point and a line."""
    ...

</t>
<t tx="leo.20191228122442.64">def horizontal(self, e1: Entity, wp: Entity) -&gt; None:
    """Horizontal constraint of a 2d point."""
    ...

</t>
<t tx="leo.20191228122442.65">def vertical(self, e1: Entity, wp: Entity) -&gt; None:
    """Vertical constraint of a 2d point."""
    ...

</t>
<t tx="leo.20191228122442.66">def diameter(self, e1: Entity, value: float, wp: Entity) -&gt; None:
    """Diameter constraint of a circular entities."""
    ...

</t>
<t tx="leo.20191228122442.67">def same_orientation(self, e1: Entity, e2: Entity) -&gt; None:
    """Equal orientation constraint between two 3d normals."""
    ...

</t>
<t tx="leo.20191228122442.68">def angle(self, e1: Entity, e2: Entity, value: float, wp: Entity, inverse: bool = False) -&gt; None:
    """Degrees angle constraint between two 2d lines."""
    ...

</t>
<t tx="leo.20191228122442.69">def perpendicular(self, e1: Entity, e2: Entity, wp: Entity, inverse: bool = False) -&gt; None:
    """Perpendicular constraint between two 2d lines."""
    ...

</t>
<t tx="leo.20191228122442.7">def quaternion_v(
    qw: float,
    qx: float,
    qy: float,
    qz: float
) -&gt; Tuple[float, float, float]:
    ...

</t>
<t tx="leo.20191228122442.70">def parallel(self, e1: Entity, e2: Entity, wp: Entity = Entity.FREE_IN_3D) -&gt; None:
    """Parallel constraint between two lines."""
    ...

</t>
<t tx="leo.20191228122442.71">def tangent(self, e1: Entity, e2: Entity, wp: Entity = Entity.FREE_IN_3D) -&gt; None:
    """Parallel constraint between two entities."""
    ...

</t>
<t tx="leo.20191228122442.72">def distance_proj(self, e1: Entity, e2: Entity, value: float) -&gt; None:
    """Projected distance constraint between two 3d points."""
    ...

</t>
<t tx="leo.20191228122442.73">def dragged(self, e1: Entity, wp: Entity = Entity.FREE_IN_3D) -&gt; None:
    """Dragged constraint of a point."""
    ...
</t>
<t tx="leo.20191228122442.74">@path ./cython/python_solvespace/
@language cython
# -*- coding: utf-8 -*-
# cython: language_level=3, embedsignature=True, cdivision=True

"""Wrapper source code of Solvespace.

author: Yuan Chang
copyright: Copyright (C) 2016-2019
license: GPLv3+
email: pyslvs@gmail.com
"""

from cpython.mem cimport PyMem_Malloc, PyMem_Free
from cpython.object cimport Py_EQ, Py_NE
from libcpp.pair cimport pair
from collections import Counter


cpdef tuple quaternion_u(double qw, double qx, double qy, double qz):
    cdef double x, y, z
    Slvs_QuaternionU(qw, qx, qy, qz, &amp;x, &amp;y, &amp;z)
    return x, y, z


cpdef tuple quaternion_v(double qw, double qx, double qy, double qz):
    cdef double x, y, z
    Slvs_QuaternionV(qw, qx, qy, qz, &amp;x, &amp;y, &amp;z)
    return x, y, z


cpdef tuple quaternion_n(double qw, double qx, double qy, double qz):
    cdef double x, y, z
    Slvs_QuaternionN(qw, qx, qy, qz, &amp;x, &amp;y, &amp;z)
    return x, y, z


cpdef tuple make_quaternion(double ux, double uy, double uz, double vx, double vy, double vz):
    cdef double qw, qx, qy, qz
    Slvs_MakeQuaternion(ux, uy, uz, vx, vy, vz, &amp;qw, &amp;qx, &amp;qy, &amp;qz)
    return qw, qx, qy, qz


cdef class Params:

    """Python object to handle multiple parameter handles."""

    @staticmethod
    cdef Params create(Slvs_hParam *p, size_t count):
        """Constructor."""
        cdef Params params = Params.__new__(Params)
        cdef size_t i
        for i in range(count):
            params.param_list.push_back(p[i])
        return params

    def __richcmp__(self, Params other, int op) -&gt; bint:
        """Compare the parameters."""
        if op == Py_EQ:
            return self.param_list == other.param_list
        elif op == Py_NE:
            return self.param_list != other.param_list
        else:
            raise TypeError(
                f"'{op}' not support between instances of "
                f"{type(self)} and {type(other)}"
            )

    def __repr__(self) -&gt; str:
        m = f"{type(self).__name__}(["
        cdef size_t i
        cdef size_t s = self.param_list.size()
        for i in range(s):
            m += str(&lt;int&gt;self.param_list[i])
            if i != s - 1:
                m += ", "
        m += "])"
        return m

# A virtual work plane that present 3D entity or constraint.
cdef Entity _E_FREE_IN_3D = Entity.__new__(Entity)
_E_FREE_IN_3D.t = SLVS_E_WORKPLANE
_E_FREE_IN_3D.h = SLVS_FREE_IN_3D
_E_FREE_IN_3D.g = 0
_E_FREE_IN_3D.params = Params.create(NULL, 0)

# A "None" entity used to fill in constraint option.
cdef Entity _E_NONE = Entity.__new__(Entity)
_E_NONE.t = 0
_E_NONE.h = 0
_E_NONE.g = 0
_E_NONE.params = Params.create(NULL, 0)

# Entity names
_NAME_OF_ENTITIES = {
    SLVS_E_POINT_IN_3D: "point 3d",
    SLVS_E_POINT_IN_2D: "point 2d",
    SLVS_E_NORMAL_IN_2D: "normal 2d",
    SLVS_E_NORMAL_IN_3D: "normal 3d",
    SLVS_E_DISTANCE: "distance",
    SLVS_E_WORKPLANE: "work plane",
    SLVS_E_LINE_SEGMENT: "line segment",
    SLVS_E_CUBIC: "cubic",
    SLVS_E_CIRCLE: "circle",
    SLVS_E_ARC_OF_CIRCLE: "arc",
}

# Constraint names
_NAME_OF_CONSTRAINTS = {
    SLVS_C_POINTS_COINCIDENT: "points coincident",
    SLVS_C_PT_PT_DISTANCE: "point point distance",
    SLVS_C_PT_PLANE_DISTANCE: "point plane distance",
    SLVS_C_PT_LINE_DISTANCE: "point line distance",
    SLVS_C_PT_FACE_DISTANCE: "point face distance",
    SLVS_C_PT_IN_PLANE: "point in plane",
    SLVS_C_PT_ON_LINE: "point on line",
    SLVS_C_PT_ON_FACE: "point on face",
    SLVS_C_EQUAL_LENGTH_LINES: "equal length lines",
    SLVS_C_LENGTH_RATIO: "length ratio",
    SLVS_C_EQ_LEN_PT_LINE_D: "equal length point line distance",
    SLVS_C_EQ_PT_LN_DISTANCES: "equal point line distance",
    SLVS_C_EQUAL_ANGLE: "equal angle",
    SLVS_C_EQUAL_LINE_ARC_LEN: "equal line arc length",
    SLVS_C_SYMMETRIC: "symmetric",
    SLVS_C_SYMMETRIC_HORIZ: "symmetric horizontal",
    SLVS_C_SYMMETRIC_VERT: "symmetric vertical",
    SLVS_C_SYMMETRIC_LINE: "symmetric line",
    SLVS_C_AT_MIDPOINT: "at midpoint",
    SLVS_C_HORIZONTAL: "horizontal",
    SLVS_C_VERTICAL: "vertical",
    SLVS_C_DIAMETER: "diameter",
    SLVS_C_PT_ON_CIRCLE: "point on circle",
    SLVS_C_SAME_ORIENTATION: "same orientation",
    SLVS_C_ANGLE: "angle",
    SLVS_C_PARALLEL: "parallel",
    SLVS_C_PERPENDICULAR: "perpendicular",
    SLVS_C_ARC_LINE_TANGENT: "arc line tangent",
    SLVS_C_CUBIC_LINE_TANGENT: "cubic line tangent",
    SLVS_C_EQUAL_RADIUS: "equal radius",
    SLVS_C_PROJ_PT_DISTANCE: "project point distance",
    SLVS_C_WHERE_DRAGGED: "where dragged",
    SLVS_C_CURVE_CURVE_TANGENT: "curve curve tangent",
    SLVS_C_LENGTH_DIFFERENCE: "length difference",
}


cdef class Entity:

    """Python object to handle a pointer of 'Slvs_hEntity'."""

    FREE_IN_3D = _E_FREE_IN_3D
    NONE = _E_NONE

    @staticmethod
    cdef Entity create(Slvs_Entity *e, size_t p_size):
        """Constructor."""
        cdef Entity entity = Entity.__new__(Entity)
        with nogil:
            entity.t = e.type
            entity.h = e.h
            entity.wp = e.wrkpl
            entity.g = e.group
        entity.params = Params.create(e.param, p_size)
        return entity

    def __richcmp__(self, Entity other, int op) -&gt; bint:
        """Compare the entities."""
        if op == Py_EQ:
            return (
                self.t == other.t and
                self.h == other.h and
                self.wp == other.wp and
                self.g == other.g and
                self.params == other.params
            )
        elif op == Py_NE:
            return not (self == other)
        else:
            raise TypeError(
                f"'{op}' not support between instances of "
                f"{type(self)} and {type(other)}"
            )

    cpdef bint is_3d(self):
        return self.wp == SLVS_FREE_IN_3D

    cpdef bint is_none(self):
        return self.h == 0

    cpdef bint is_point_2d(self):
        return self.t == SLVS_E_POINT_IN_2D

    cpdef bint is_point_3d(self):
        return self.t == SLVS_E_POINT_IN_3D

    cpdef bint is_point(self):
        return self.is_point_2d() or self.is_point_3d()

    cpdef bint is_normal_2d(self):
        return self.t == SLVS_E_NORMAL_IN_2D

    cpdef bint is_normal_3d(self):
        return self.t == SLVS_E_NORMAL_IN_3D

    cpdef bint is_normal(self):
        return self.is_normal_2d() or self.is_normal_3d()

    cpdef bint is_distance(self):
        return self.t == SLVS_E_DISTANCE

    cpdef bint is_work_plane(self):
        return self.t == SLVS_E_WORKPLANE

    cpdef bint is_line_2d(self):
        return self.is_line() and not self.is_3d()

    cpdef bint is_line_3d(self):
        return self.is_line() and self.is_3d()

    cpdef bint is_line(self):
        return self.t == SLVS_E_LINE_SEGMENT

    cpdef bint is_cubic(self):
        return self.t == SLVS_E_CUBIC

    cpdef bint is_circle(self):
        return self.t == SLVS_E_CIRCLE

    cpdef bint is_arc(self):
        return self.t == SLVS_E_ARC_OF_CIRCLE

    def __repr__(self) -&gt; str:
        cdef int h = &lt;int&gt;self.h
        cdef int g = &lt;int&gt;self.g
        cdef str t = _NAME_OF_ENTITIES[&lt;int&gt;self.t]
        return (
            f"{type(self).__name__}"
            f"(handle={h}, group={g}, type=&lt;{t}&gt;, is_3d={self.is_3d()}, params={self.params})"
        )


cdef class SolverSystem:

    """Python object of 'Slvs_System'."""

    def __cinit__(self):
        self.g = 0
        self.sys.params = self.sys.entities = self.sys.constraints = 0

    def __dealloc__(self):
        self.free()

    cdef inline void copy_to_sys(self) nogil:
        """Copy data from stack into system."""
        cdef int i = 0
        cdef pair[Slvs_hParam, Slvs_Param] param
        for param in self.param_list:
            self.sys.param[i] = param.second
            i += 1

        i = 0
        cdef Slvs_Entity entity
        for entity in self.entity_list:
            self.sys.entity[i] = entity
            i += 1

        i = 0
        cdef Slvs_Constraint con
        for con in self.cons_list:
            self.sys.constraint[i] = con
            i += 1

    cdef inline void copy_from_sys(self) nogil:
        """Copy data from system into stack."""
        self.param_list.clear()
        self.entity_list.clear()
        self.cons_list.clear()
        cdef int i
        for i in range(self.sys.params):
            self.param_list[self.sys.param[i].h] = self.sys.param[i]
        for i in range(self.sys.entities):
            self.entity_list.push_back(self.sys.entity[i])
        for i in range(self.sys.constraints):
            self.cons_list.push_back(self.sys.constraint[i])

    cpdef void clear(self):
        self.g = 0
        self.param_list.clear()
        self.entity_list.clear()
        self.cons_list.clear()
        self.failed_list.clear()
        self.free()

    cdef inline void failed_collecting(self) nogil:
        """Collecting the failed constraints."""
        cdef int i
        for i in range(self.sys.faileds):
            self.failed_list.push_back(self.sys.failed[i])

    cdef inline void free(self):
        PyMem_Free(self.sys.param)
        PyMem_Free(self.sys.entity)
        PyMem_Free(self.sys.constraint)
        PyMem_Free(self.sys.failed)
        self.sys.param = NULL
        self.sys.entity = NULL
        self.sys.constraint = NULL
        self.sys.failed = NULL
        self.sys.params = self.sys.entities = self.sys.constraints = 0

    cpdef void set_group(self, size_t g):
        """Set the current group by integer."""
        self.g = &lt;Slvs_hGroup&gt;g

    cpdef int group(self):
        """Return the current group by integer."""
        return &lt;int&gt;self.g

    cpdef void set_params(self, Params p, object params):
        """Set the parameters by Params object and sequence object."""
        params = tuple(params)
        cdef int i = p.param_list.size()
        if i != len(params):
            raise ValueError(f"number of parameters {len(params)} are not match {i}")

        i = 0
        cdef Slvs_hParam h
        for h in p.param_list:
            self.param_list[h].val = params[i]
            i += 1

    cpdef tuple params(self, Params p):
        """Get the parameters by Params object."""
        param_list = []
        cdef Slvs_hParam h
        for h in p.param_list:
            param_list.append(self.param_list[h].val)
        return tuple(param_list)

    cpdef int dof(self):
        """Return the DOF of system."""
        return self.sys.dof

    cpdef object constraints(self):
        """Return the list of all constraints."""
        cons_list = []
        cdef Slvs_Constraint con
        for con in self.cons_list:
            cons_list.append(_NAME_OF_CONSTRAINTS[con.type])
        return Counter(cons_list)

    cpdef list faileds(self):
        """Return the count of failed constraint."""
        failed_list = []
        cdef Slvs_hConstraint error
        for error in self.failed_list:
            failed_list.append(&lt;int&gt;error)
        return failed_list

    cpdef int solve(self):
        """Solve the system."""
        # Parameters
        self.sys.param = &lt;Slvs_Param *&gt;PyMem_Malloc(self.param_list.size() * sizeof(Slvs_Param))
        # Entities
        self.sys.entity = &lt;Slvs_Entity *&gt;PyMem_Malloc(self.entity_list.size() * sizeof(Slvs_Entity))
        # Constraints
        cdef size_t cons_size = self.cons_list.size()
        self.sys.constraint = &lt;Slvs_Constraint *&gt;PyMem_Malloc(cons_size * sizeof(Slvs_Constraint))
        self.sys.failed = &lt;Slvs_hConstraint *&gt;PyMem_Malloc(cons_size * sizeof(Slvs_hConstraint))
        self.sys.faileds = cons_size

        # Copy to system
        self.copy_to_sys()
        # Solve
        Slvs_Solve(&amp;self.sys, self.g)
        # Failed constraints and free memory.
        self.copy_from_sys()
        self.failed_collecting()
        self.free()
        return self.sys.result

    cpdef Entity create_2d_base(self):
        """Create a basic 2D system and return the work plane."""
        cdef double qw, qx, qy, qz
        qw, qx, qy, qz = make_quaternion(1, 0, 0, 0, 1, 0)
        cdef Entity nm = self.add_normal_3d(qw, qx, qy, qz)
        return self.add_work_plane(self.add_point_3d(0, 0, 0), nm)

    cdef inline Slvs_hParam new_param(self, double val) nogil:
        """Add a parameter."""
        self.sys.params += 1
        cdef Slvs_hParam h = &lt;Slvs_hParam&gt;self.sys.params
        self.param_list[h] = Slvs_MakeParam(h, self.g, val)
        return h

    cdef inline Slvs_hEntity eh(self) nogil:
        """Return new entity handle."""
        self.sys.entities += 1
        return &lt;Slvs_hEntity&gt;self.sys.entities

    cpdef Entity add_point_2d(self, double u, double v, Entity wp):
        """Add 2D point."""
        if wp is None or not wp.is_work_plane():
            raise TypeError(f"{wp} is not a work plane")

        cdef Slvs_hParam u_p = self.new_param(u)
        cdef Slvs_hParam v_p = self.new_param(v)
        cdef Slvs_Entity e = Slvs_MakePoint2d(self.eh(), self.g, wp.h, u_p, v_p)
        self.entity_list.push_back(e)

        return Entity.create(&amp;e, 2)

    cpdef Entity add_point_3d(self, double x, double y, double z):
        """Add 3D point."""
        cdef Slvs_hParam x_p = self.new_param(x)
        cdef Slvs_hParam y_p = self.new_param(y)
        cdef Slvs_hParam z_p = self.new_param(z)
        cdef Slvs_Entity e = Slvs_MakePoint3d(self.eh(), self.g, x_p, y_p, z_p)
        self.entity_list.push_back(e)

        return Entity.create(&amp;e, 3)

    cpdef Entity add_normal_2d(self, Entity wp):
        """Add a 2D normal."""
        if wp is None or not wp.is_work_plane():
            raise TypeError(f"{wp} is not a work plane")
        cdef Slvs_Entity e = Slvs_MakeNormal2d(self.eh(), self.g, wp.h)
        self.entity_list.push_back(e)
        return Entity.create(&amp;e, 0)

    cpdef Entity add_normal_3d(self, double qw, double qx, double qy, double qz):
        """Add a 3D normal."""
        cdef Slvs_hParam w_p = self.new_param(qw)
        cdef Slvs_hParam x_p = self.new_param(qx)
        cdef Slvs_hParam y_p = self.new_param(qy)
        cdef Slvs_hParam z_p = self.new_param(qz)
        self.entity_list.push_back(Slvs_MakeNormal3d(
            self.eh(), self.g, w_p, x_p, y_p, z_p))
        return Entity.create(&amp;self.entity_list.back(), 4)

    cpdef Entity add_distance(self, double d, Entity wp):
        """Add a 2D distance."""
        if wp is None or not wp.is_work_plane():
            raise TypeError(f"{wp} is not a work plane")

        cdef Slvs_hParam d_p = self.new_param(d)
        self.entity_list.push_back(Slvs_MakeDistance(
            self.eh(), self.g, wp.h, d_p))
        return Entity.create(&amp;self.entity_list.back(), 1)

    cpdef Entity add_line_2d(self, Entity p1, Entity p2, Entity wp):
        """Add a 2D line."""
        if wp is None or not wp.is_work_plane():
            raise TypeError(f"{wp} is not a work plane")
        if p1 is None or not p1.is_point_2d():
            raise TypeError(f"{p1} is not a 2d point")
        if p2 is None or not p2.is_point_2d():
            raise TypeError(f"{p2} is not a 2d point")

        self.entity_list.push_back(Slvs_MakeLineSegment(
            self.eh(), self.g, wp.h, p1.h, p2.h))
        return Entity.create(&amp;self.entity_list.back(), 0)

    cpdef Entity add_line_3d(self, Entity p1, Entity p2):
        """Add a 3D line."""
        if p1 is None or not p1.is_point_3d():
            raise TypeError(f"{p1} is not a 3d point")
        if p2 is None or not p2.is_point_3d():
            raise TypeError(f"{p2} is not a 3d point")

        self.entity_list.push_back(Slvs_MakeLineSegment(
            self.eh(), self.g, SLVS_FREE_IN_3D, p1.h, p2.h))
        return Entity.create(&amp;self.entity_list.back(), 0)

    cpdef Entity add_cubic(self, Entity p1, Entity p2, Entity p3, Entity p4, Entity wp):
        """Add a 2D cubic."""
        if wp is None or not wp.is_work_plane():
            raise TypeError(f"{wp} is not a work plane")
        if p1 is None or not p1.is_point_2d():
            raise TypeError(f"{p1} is not a 2d point")
        if p2 is None or not p2.is_point_2d():
            raise TypeError(f"{p2} is not a 2d point")
        if p3 is None or not p3.is_point_2d():
            raise TypeError(f"{p3} is not a 2d point")
        if p4 is None or not p4.is_point_2d():
            raise TypeError(f"{p4} is not a 2d point")

        self.entity_list.push_back(Slvs_MakeCubic(
            self.eh(), self.g, wp.h, p1.h, p2.h, p3.h, p4.h))
        return Entity.create(&amp;self.entity_list.back(), 0)

    cpdef Entity add_arc(self, Entity nm, Entity ct, Entity start, Entity end, Entity wp):
        """Add an 2D arc."""
        if wp is None or not wp.is_work_plane():
            raise TypeError(f"{wp} is not a work plane")
        if nm is None or not nm.is_normal_3d():
            raise TypeError(f"{nm} is not a 3d normal")
        if ct is None or not ct.is_point_2d():
            raise TypeError(f"{ct} is not a 2d point")
        if start is None or not start.is_point_2d():
            raise TypeError(f"{start} is not a 2d point")
        if end is None or not end.is_point_2d():
            raise TypeError(f"{end} is not a 2d point")
        self.entity_list.push_back(Slvs_MakeArcOfCircle(
            self.eh(), self.g, wp.h, nm.h, ct.h, start.h, end.h))
        return Entity.create(&amp;self.entity_list.back(), 0)

    cpdef Entity add_circle(self, Entity nm, Entity ct, Entity radius, Entity wp):
        """Add a 2D circle."""
        if wp is None or not wp.is_work_plane():
            raise TypeError(f"{wp} is not a work plane")
        if nm is None or not nm.is_normal_3d():
            raise TypeError(f"{nm} is not a 3d normal")
        if ct is None or not ct.is_point_2d():
            raise TypeError(f"{ct} is not a 2d point")
        if radius is None or not radius.is_distance():
            raise TypeError(f"{radius} is not a distance")

        self.entity_list.push_back(Slvs_MakeCircle(self.eh(), self.g, wp.h,
                                                   ct.h, nm.h, radius.h))
        return Entity.create(&amp;self.entity_list.back(), 0)

    cpdef Entity add_work_plane(self, Entity origin, Entity nm):
        """Add a 3D work plane."""
        if origin is None or origin.t != SLVS_E_POINT_IN_3D:
            raise TypeError(f"{origin} is not a 3d point")
        if nm is None or nm.t != SLVS_E_NORMAL_IN_3D:
            raise TypeError(f"{nm} is not a 3d normal")

        self.entity_list.push_back(Slvs_MakeWorkplane(self.eh(), self.g, origin.h, nm.h))
        return Entity.create(&amp;self.entity_list.back(), 0)

    cpdef void add_constraint(
        self,
        int c_type,
        Entity wp,
        double v,
        Entity p1,
        Entity p2,
        Entity e1,
        Entity e2,
        Entity e3 = _E_NONE,
        Entity e4 = _E_NONE,
        int other = 0,
        int other2 = 0
    ):
        """Add customized constraint."""
        if wp is None or not wp.is_work_plane():
            raise TypeError(f"{wp} is not a work plane")

        cdef Entity e
        for e in (p1, p2):
            if e is None or not (e.is_none() or e.is_point()):
                raise TypeError(f"{e} is not a point")
        for e in (e1, e2, e3, e4):
            if e is None:
                raise TypeError(f"{e} is not a entity")

        self.sys.constraints += 1
        cdef Slvs_Constraint c
        c.h = &lt;Slvs_hConstraint&gt;self.sys.constraints
        c.group = self.g
        c.type = c_type
        c.wrkpl = wp.h
        c.valA = v
        c.ptA = p1.h
        c.ptB = p2.h
        c.entityA = e1.h
        c.entityB = e2.h
        c.entityC = e3.h
        c.entityD = e4.h
        c.other = other
        c.other2 = other2
        self.cons_list.push_back(c)

    #####
    # Constraint methods.
    #####

    cpdef void coincident(self, Entity e1, Entity e2, Entity wp = _E_FREE_IN_3D):
        """Coincident two entities."""
        cdef int t
        if e1.is_point() and e2.is_point():
            self.add_constraint(SLVS_C_POINTS_COINCIDENT, wp, 0., e1, e2,
                                _E_NONE, _E_NONE)
        elif e1.is_point() and e2.is_work_plane() and wp is _E_FREE_IN_3D:
            self.add_constraint(SLVS_C_PT_IN_PLANE, e2, 0., e1, _E_NONE, e2,
                                _E_NONE)
        elif e1.is_point() and (e2.is_line() or e2.is_circle()):
            if e2.is_line():
                t = SLVS_C_PT_ON_LINE
            else:
                t = SLVS_C_PT_ON_CIRCLE
            self.add_constraint(t, wp, 0., e1, _E_NONE, e2, _E_NONE)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

    cpdef void distance(
        self,
        Entity e1,
        Entity e2,
        double value,
        Entity wp = _E_FREE_IN_3D
    ):
        """Distance constraint between two entities."""
        if value == 0.:
            self.coincident(e1, e2, wp)
            return
        if e1.is_point() and e2.is_point():
            self.add_constraint(SLVS_C_PT_PT_DISTANCE, wp, value, e1, e2,
                                _E_NONE, _E_NONE)
        elif e1.is_point() and e2.is_work_plane() and wp is _E_FREE_IN_3D:
            self.add_constraint(SLVS_C_PT_PLANE_DISTANCE, e2, value, e1,
                                _E_NONE, e2, _E_NONE)
        elif e1.is_point() and e2.is_line():
            self.add_constraint(SLVS_C_PT_LINE_DISTANCE, wp, value, e1,
                                _E_NONE, e2, _E_NONE)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

    cpdef void equal(self, Entity e1, Entity e2, Entity wp = _E_FREE_IN_3D):
        """Equal constraint between two entities."""
        if e1.is_line() and e2.is_line():
            self.add_constraint(SLVS_C_EQUAL_LENGTH_LINES, wp, 0., _E_NONE,
                                _E_NONE, e1, e2)
        elif e1.is_line() and (e2.is_arc() or e2.is_circle()):
            self.add_constraint(SLVS_C_EQUAL_LINE_ARC_LEN, wp, 0., _E_NONE,
                                _E_NONE, e1, e2)
        elif (e1.is_arc() or e1.is_circle()) and (e2.is_arc() or e2.is_circle()):
            self.add_constraint(SLVS_C_EQUAL_RADIUS, wp, 0., _E_NONE, _E_NONE, e1, e2)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

    cpdef void equal_included_angle(
        self,
        Entity e1,
        Entity e2,
        Entity e3,
        Entity e4,
        Entity wp
    ):
        """Constraint that line 1 and line 2, line 3 and line 4
        must have same included angle.
        """
        if wp is _E_FREE_IN_3D:
            raise ValueError("this is a 2d constraint")
        if e1.is_line_2d() and e2.is_line_2d() and e3.is_line_2d() and e4.is_line_2d():
            self.add_constraint(SLVS_C_EQUAL_ANGLE, wp, 0., _E_NONE, _E_NONE,
                                e1, e2, e3, e4)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {e3}, {e4}, {wp}")

    cpdef void equal_point_to_line(
        self,
        Entity e1,
        Entity e2,
        Entity e3,
        Entity e4,
        Entity wp
    ):
        """Constraint that point 1 and line 1, point 2 and line 2
        must have same distance.
        """
        if wp is _E_FREE_IN_3D:
            raise ValueError("this is a 2d constraint")
        if e1.is_point_2d() and e2.is_line_2d() and e3.is_point_2d() and e4.is_line_2d():
            self.add_constraint(SLVS_C_EQ_PT_LN_DISTANCES, wp, 0., e1, e3, e2, e4)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {e3}, {e4}, {wp}")

    cpdef void ratio(self, Entity e1, Entity e2, double value, Entity wp):
        """The ratio constraint between two lines."""
        if wp is _E_FREE_IN_3D:
            raise ValueError("this is a 2d constraint")
        if e1.is_line_2d() and e2.is_line_2d():
            self.add_constraint(SLVS_C_EQ_PT_LN_DISTANCES, wp, value, _E_NONE,
                                _E_NONE, e1, e2)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

    cpdef void symmetric(
        self,
        Entity e1,
        Entity e2,
        Entity e3 = _E_NONE,
        Entity wp = _E_FREE_IN_3D
    ):
        """Symmetric constraint between two points."""
        if e1.is_point_3d() and e2.is_point_3d() and e3.is_work_plane() and wp is _E_FREE_IN_3D:
            self.add_constraint(SLVS_C_SYMMETRIC, wp, 0., e1, e2, e3, _E_NONE)
        elif e1.is_point_2d() and e2.is_point_2d() and e3.is_work_plane() and wp is _E_FREE_IN_3D:
            self.add_constraint(SLVS_C_SYMMETRIC, e3, 0., e1, e2, e3, _E_NONE)
        elif e1.is_point_2d() and e2.is_point_2d() and e3.is_line_2d():
            if wp is _E_FREE_IN_3D:
                raise ValueError("this is a 2d constraint")
            self.add_constraint(SLVS_C_SYMMETRIC_LINE, wp, 0., e1, e2, e3, _E_NONE)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {e3}, {wp}")

    cpdef void symmetric_h(self, Entity e1, Entity e2, Entity wp):
        """Symmetric constraint between two points with horizontal line."""
        if wp is _E_FREE_IN_3D:
            raise ValueError("this is a 2d constraint")
        if e1.is_point_2d() and e2.is_point_2d():
            self.add_constraint(SLVS_C_SYMMETRIC_HORIZ, wp, 0., e1, e2, _E_NONE, _E_NONE)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

    cpdef void symmetric_v(self, Entity e1, Entity e2, Entity wp):
        """Symmetric constraint between two points with vertical line."""
        if wp is _E_FREE_IN_3D:
            raise ValueError("this is a 2d constraint")
        if e1.is_point_2d() and e2.is_point_2d():
            self.add_constraint(SLVS_C_SYMMETRIC_VERT, wp, 0., e1, e2, _E_NONE, _E_NONE)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

    cpdef void midpoint(
        self,
        Entity e1,
        Entity e2,
        Entity wp = _E_FREE_IN_3D
    ):
        """Midpoint constraint between a point and a line."""
        if e1.is_point() and e2.is_line():
            self.add_constraint(SLVS_C_AT_MIDPOINT, wp, 0., e1, _E_NONE, e2, _E_NONE)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

    cpdef void horizontal(self, Entity e1, Entity wp):
        """Horizontal constraint of a 2d point."""
        if wp is _E_FREE_IN_3D:
            raise ValueError("this is a 2d constraint")
        if e1.is_line_2d():
            self.add_constraint(SLVS_C_HORIZONTAL, wp, 0., _E_NONE, _E_NONE, e1, _E_NONE)
        else:
            raise TypeError(f"unsupported entities: {e1}, {wp}")

    cpdef void vertical(self, Entity e1, Entity wp):
        """Vertical constraint of a 2d point."""
        if wp is _E_FREE_IN_3D:
            raise ValueError("this is a 2d constraint")
        if e1.is_line_2d():
            self.add_constraint(SLVS_C_VERTICAL, wp, 0., _E_NONE, _E_NONE, e1, _E_NONE)
        else:
            raise TypeError(f"unsupported entities: {e1}, {wp}")

    cpdef void diameter(self, Entity e1, double value, Entity wp):
        """Diameter constraint of a circular entities."""
        if wp is _E_FREE_IN_3D:
            raise ValueError("this is a 2d constraint")
        if e1.is_arc() or e1.is_circle():
            self.add_constraint(SLVS_C_DIAMETER, wp, value, _E_NONE, _E_NONE,
                                e1, _E_NONE)
        else:
            raise TypeError(f"unsupported entities: {e1}, {wp}")

    cpdef void same_orientation(self, Entity e1, Entity e2):
        """Equal orientation constraint between two 3d normals."""
        if e1.is_normal_3d() and e2.is_normal_3d():
            self.add_constraint(SLVS_C_SAME_ORIENTATION, _E_FREE_IN_3D, 0.,
                                _E_NONE, _E_NONE, e1, e2)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}")

    cpdef void angle(self, Entity e1, Entity e2, double value, Entity wp, bint inverse = False):
        """Degrees angle constraint between two 2d lines."""
        if wp is _E_FREE_IN_3D:
            raise ValueError("this is a 2d constraint")
        if e1.is_line_2d() and e2.is_line_2d():
            self.add_constraint(SLVS_C_ANGLE, wp, value, _E_NONE, _E_NONE,
                                e1, e2, _E_NONE, _E_NONE, inverse)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

    cpdef void perpendicular(self, Entity e1, Entity e2, Entity wp, bint inverse = False):
        """Perpendicular constraint between two 2d lines."""
        if wp is _E_FREE_IN_3D:
            raise ValueError("this is a 2d constraint")
        if e1.is_line_2d() and e2.is_line_2d():
            self.add_constraint(SLVS_C_PERPENDICULAR, wp, 0., _E_NONE, _E_NONE,
                                e1, e2, _E_NONE, _E_NONE, inverse)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

    cpdef void parallel(self, Entity e1, Entity e2, Entity wp = _E_FREE_IN_3D):
        """Parallel constraint between two lines."""
        if e1.is_line() and e2.is_line():
            self.add_constraint(SLVS_C_PARALLEL, wp, 0., _E_NONE, _E_NONE, e1, e2)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

    cpdef void tangent(self, Entity e1, Entity e2, Entity wp = _E_FREE_IN_3D):
        """Parallel constraint between two entities."""
        if e1.is_arc() and e2.is_line_2d():
            if wp is _E_FREE_IN_3D:
                raise ValueError("this is a 2d constraint")
            self.add_constraint(SLVS_C_ARC_LINE_TANGENT, wp, 0., _E_NONE, _E_NONE, e1, e2)
        elif e1.is_cubic() and e2.is_line_3d() and wp is _E_FREE_IN_3D:
            self.add_constraint(SLVS_C_CUBIC_LINE_TANGENT, wp, 0., _E_NONE, _E_NONE, e1, e2)
        elif (e1.is_arc() or e1.is_cubic()) and (e2.is_arc() or e2.is_cubic()):
            if (e1.is_arc() or e2.is_arc()) and wp is _E_FREE_IN_3D:
                raise ValueError("this is a 2d constraint")
            self.add_constraint(SLVS_C_CURVE_CURVE_TANGENT, wp, 0., _E_NONE, _E_NONE, e1, e2)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}, {wp}")

    cpdef void distance_proj(self, Entity e1, Entity e2, double value):
        """Projected distance constraint between two 3d points."""
        if e1.is_point_3d() and e2.is_point_3d():
            self.add_constraint(SLVS_C_CURVE_CURVE_TANGENT, _E_FREE_IN_3D,
                                value, e1, e2, _E_NONE, _E_NONE)
        else:
            raise TypeError(f"unsupported entities: {e1}, {e2}")

    cpdef void dragged(self, Entity e1, Entity wp = _E_FREE_IN_3D):
        """Dragged constraint of a point."""
        if e1.is_point():
            self.add_constraint(SLVS_C_WHERE_DRAGGED, wp, 0., e1, _E_NONE, _E_NONE, _E_NONE)
        else:
            raise TypeError(f"unsupported entities: {e1}, {wp}")
</t>
<t tx="leo.20191228122442.75">@path ./cython/python_solvespace/
@language unknown_language
 
</t>
<t tx="leo.20191228122442.76">@path ./cython/python_solvespace/
# -*- coding: utf-8 -*-

@others
@language python
@tabwidth -4
</t>
<t tx="leo.20191228122442.77">"""'python_solvespace' module is a wrapper of
Python binding Solvespace solver libraries.
"""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2019"
__license__ = "GPLv3+"
__email__ = "pyslvs@gmail.com"
__version__ = "3.0.1.post0"

from enum import IntEnum, auto
from .slvs import (
    quaternion_u,
    quaternion_v,
    quaternion_n,
    make_quaternion,
    Params,
    Entity,
    SolverSystem,
)

__all__ = [
    'quaternion_u',
    'quaternion_v',
    'quaternion_n',
    'make_quaternion',
    'Constraint',
    'ResultFlag',
    'Params',
    'Entity',
    'SolverSystem',
]


</t>
<t tx="leo.20191228122442.78">class Constraint(IntEnum):
    # Expose macro of constraint types
    POINTS_COINCIDENT = 100000
    PT_PT_DISTANCE = auto()
    PT_PLANE_DISTANCE = auto()
    PT_LINE_DISTANCE = auto()
    PT_FACE_DISTANCE = auto()
    PT_IN_PLANE = auto()
    PT_ON_LINE = auto()
    PT_ON_FACE = auto()
    EQUAL_LENGTH_LINES = auto()
    LENGTH_RATIO = auto()
    EQ_LEN_PT_LINE_D = auto()
    EQ_PT_LN_DISTANCES = auto()
    EQUAL_ANGLE = auto()
    EQUAL_LINE_ARC_LEN = auto()
    SYMMETRIC = auto()
    SYMMETRIC_HORIZ = auto()
    SYMMETRIC_VERT = auto()
    SYMMETRIC_LINE = auto()
    AT_MIDPOINT = auto()
    HORIZONTAL = auto()
    VERTICAL = auto()
    DIAMETER = auto()
    PT_ON_CIRCLE = auto()
    SAME_ORIENTATION = auto()
    ANGLE = auto()
    PARALLEL = auto()
    PERPENDICULAR = auto()
    ARC_LINE_TANGENT = auto()
    CUBIC_LINE_TANGENT = auto()
    EQUAL_RADIUS = auto()
    PROJ_PT_DISTANCE = auto()
    WHERE_DRAGGED = auto()
    CURVE_CURVE_TANGENT = auto()
    LENGTH_DIFFERENCE = auto()


</t>
<t tx="leo.20191228122442.79">class ResultFlag(IntEnum):
    # Expose macro of result flags
    OKAY = 0
    INCONSISTENT = auto()
    DIDNT_CONVERGE = auto()
    TOO_MANY_UNKNOWNS = auto()
</t>
<t tx="leo.20191228122442.8">def quaternion_n(
    qw: float,
    qx: float,
    qy: float,
    qz: float
) -&gt; Tuple[float, float, float]:
    ...

</t>
<t tx="leo.20191228122442.81"></t>
<t tx="leo.20191228122442.85"></t>
<t tx="leo.20191228122442.86">@path ./cython/tests/

@language python
@tabwidth -4
</t>
<t tx="leo.20191228122442.87">@path ./cython/tests/
# -*- coding: utf-8 -*-

@others
@language python
@tabwidth -4
</t>
<t tx="leo.20191228122442.88">"""This module will test the functions of Python-Solvespace."""

__author__ = "Yuan Chang"
__copyright__ = "Copyright (C) 2016-2019"
__license__ = "GPLv3+"
__email__ = "pyslvs@gmail.com"

import unittest
from unittest import TestCase
from math import radians
from python_solvespace import ResultFlag, SolverSystem, make_quaternion


</t>
<t tx="leo.20191228122442.89">class CoreTest(TestCase):

    @others
if __name__ == '__main__':
    unittest.main()
</t>
<t tx="leo.20191228122442.9">def make_quaternion(
    ux: float,
    uy: float,
    uz: float,
    vx: float,
    vy: float,
    vz: float
) -&gt; Tuple[float, float, float, float]:
    ...


</t>
<t tx="leo.20191228122442.90">def test_crank_rocker(self):
    """Crank rocker example."""
    sys = SolverSystem()
    wp = sys.create_2d_base()
    p0 = sys.add_point_2d(0, 0, wp)
    sys.dragged(p0, wp)
    p1 = sys.add_point_2d(90, 0, wp)
    sys.dragged(p1, wp)
    line0 = sys.add_line_2d(p0, p1, wp)
    p2 = sys.add_point_2d(20, 20, wp)
    p3 = sys.add_point_2d(0, 10, wp)
    p4 = sys.add_point_2d(30, 20, wp)
    sys.distance(p2, p3, 40, wp)
    sys.distance(p2, p4, 40, wp)
    sys.distance(p3, p4, 70, wp)

    sys.distance(p0, p3, 35, wp)
    sys.distance(p1, p4, 70, wp)
    line1 = sys.add_line_2d(p0, p3, wp)
    sys.angle(line0, line1, 45, wp)

    result_flag = sys.solve()
    self.assertEqual(result_flag, ResultFlag.OKAY)
    x, y = sys.params(p2.params)
    self.assertAlmostEqual(39.54852, x, 4)
    self.assertAlmostEqual(61.91009, y, 4)

</t>
<t tx="leo.20191228122442.91">def test_involute(self):
    """Involute example."""
    r = 10
    angle = 45

    sys = SolverSystem()
    wp = sys.create_2d_base()
    p0 = sys.add_point_2d(0, 0, wp)
    sys.dragged(p0, wp)

    p1 = sys.add_point_2d(0, 10, wp)
    sys.distance(p0, p1, r, wp)
    line0 = sys.add_line_2d(p0, p1, wp)

    p2 = sys.add_point_2d(10, 10, wp)
    line1 = sys.add_line_2d(p1, p2, wp)
    sys.distance(p1, p2, r * radians(angle), wp)
    sys.perpendicular(line0, line1, wp, False)

    p3 = sys.add_point_2d(10, 0, wp)
    sys.dragged(p3, wp)
    line_base = sys.add_line_2d(p0, p3, wp)
    sys.angle(line0, line_base, angle, wp)

    result_flag = sys.solve()
    self.assertEqual(result_flag, ResultFlag.OKAY)
    x, y = sys.params(p2.params)
    self.assertAlmostEqual(12.62467, x, 4)
    self.assertAlmostEqual(1.51746, y, 4)

</t>
<t tx="leo.20191228122442.92">def test_jansen_linkage(self):
    """Jansen's linkage example."""
    sys = SolverSystem()
    wp = sys.create_2d_base()
    p0 = sys.add_point_2d(0, 0, wp)
    sys.dragged(p0, wp)

    p1 = sys.add_point_2d(0, 20, wp)
    sys.distance(p0, p1, 15, wp)
    line0 = sys.add_line_2d(p0, p1, wp)

    p2 = sys.add_point_2d(-38, -7.8, wp)
    sys.dragged(p2, wp)
    p3 = sys.add_point_2d(-50, 30, wp)
    p4 = sys.add_point_2d(-70, -15, wp)
    sys.distance(p2, p3, 41.5, wp)
    sys.distance(p3, p4, 55.8, wp)
    sys.distance(p2, p4, 40.1, wp)

    p5 = sys.add_point_2d(-50, -50, wp)
    p6 = sys.add_point_2d(-10, -90, wp)
    p7 = sys.add_point_2d(-20, -40, wp)
    sys.distance(p5, p6, 65.7, wp)
    sys.distance(p6, p7, 49.0, wp)
    sys.distance(p5, p7, 36.7, wp)

    sys.distance(p1, p3, 50, wp)
    sys.distance(p1, p7, 61.9, wp)

    p8 = sys.add_point_2d(20, 0, wp)
    line_base = sys.add_line_2d(p0, p8, wp)
    sys.angle(line0, line_base, 45, wp)

    result_flag = sys.solve()
    self.assertEqual(result_flag, ResultFlag.OKAY)
    x, y = sys.params(p8.params)
    self.assertAlmostEqual(18.93036, x, 4)
    self.assertAlmostEqual(13.63778, y, 4)

</t>
<t tx="leo.20191228122442.93">def test_nut_cracker(self):
    """Nut cracker example."""
    h0 = 0.5
    b0 = 0.75
    r0 = 0.25
    n1 = 1.5
    n2 = 2.3
    l0 = 3.25

    sys = SolverSystem()
    wp = sys.create_2d_base()
    p0 = sys.add_point_2d(0, 0, wp)
    sys.dragged(p0, wp)

    p1 = sys.add_point_2d(2, 2, wp)
    p2 = sys.add_point_2d(2, 0, wp)
    line0 = sys.add_line_2d(p0, p2, wp)
    sys.horizontal(line0, wp)

    line1 = sys.add_line_2d(p1, p2, wp)
    p3 = sys.add_point_2d(b0 / 2, h0, wp)
    sys.dragged(p3, wp)
    sys.distance(p3, line1, r0, wp)
    sys.distance(p0, p1, n1, wp)
    sys.distance(p1, p2, n2, wp)

    result_flag = sys.solve()
    self.assertEqual(result_flag, ResultFlag.OKAY)
    x, _ = sys.params(p2.params)
    ans_min = x - b0 / 2
    ans_max = l0 - r0 - b0 / 2
    self.assertAlmostEqual(1.01576, ans_min, 4)
    self.assertAlmostEqual(2.625, ans_max, 4)

</t>
<t tx="leo.20191228122442.94">def test_pydemo(self):
    """
    Some sample code for slvs.dll. We draw some geometric entities, provide
    initial guesses for their positions, and then constrain them. The solver
    calculates their new positions, in order to satisfy the constraints.

    Copyright 2008-2013 Jonathan Westhues.
    Copyright 2016-2017 Yuan Chang [pyslvs@gmail.com] Python-Solvespace bundled.

    An example of a constraint in 2d. In our first group, we create a workplane
    along the reference frame's xy plane. In a second group, we create some
    entities in that group and dimension them.
    """
    sys = SolverSystem()
    sys.set_group(1)

    # First, we create our workplane. Its origin corresponds to the origin
    # of our base frame (x y z) = (0 0 0)
    p101 = sys.add_point_3d(0, 0, 0)
    # and it is parallel to the xy plane, so it has basis vectors (1 0 0)
    # and (0 1 0).
    qw, qx, qy, qz = make_quaternion(1, 0, 0, 0, 1, 0)
    n102 = sys.add_normal_3d(qw, qx, qy, qz)
    wp200 = sys.add_work_plane(p101, n102)

    # Now create a second group. We'll solve group 2, while leaving group 1
    # constant; so the workplane that we've created will be locked down,
    # and the solver can't move it.
    sys.set_group(2)
    p301 = sys.add_point_2d(10, 20, wp200)
    p302 = sys.add_point_2d(20, 10, wp200)

    # And we create a line segment with those endpoints.
    l400 = sys.add_line_2d(p301, p302, wp200)

    # Now three more points.
    p303 = sys.add_point_2d(100, 120, wp200)
    p304 = sys.add_point_2d(120, 110, wp200)
    p305 = sys.add_point_2d(115, 115, wp200)

    # And arc, centered at point 303, starting at point 304, ending at
    # point 305.
    a401 = sys.add_arc(n102, p303, p304, p305, wp200)

    # Now one more point, and a distance
    p306 = sys.add_point_2d(200, 200, wp200)
    d307 = sys.add_distance(30, wp200)

    # And a complete circle, centered at point 306 with radius equal to
    # distance 307. The normal is 102, the same as our workplane.
    c402 = sys.add_circle(n102, p306, d307, wp200)

    # The length of our line segment is 30.0 units.
    sys.distance(p301, p302, 30, wp200)

    # And the distance from our line segment to the origin is 10.0 units.
    sys.distance(p101, l400, 10, wp200)

    # And the line segment is vertical.
    sys.vertical(l400, wp200)

    # And the distance from one endpoint to the origin is 15.0 units.
    sys.distance(p301, p101, 15, wp200)

    # The arc and the circle have equal radius.
    sys.equal(a401, c402, wp200)

    # The arc has radius 17.0 units.
    sys.diameter(a401, 17 * 2, wp200)

    # If the solver fails, then ask it to report which constraints caused
    # the problem.

    # And solve.
    result_flag = sys.solve()
    self.assertEqual(result_flag, ResultFlag.OKAY)
    x, y = sys.params(p301.params)
    self.assertAlmostEqual(10, x, 4)
    self.assertAlmostEqual(11.18030, y, 4)
    x, y = sys.params(p302.params)
    self.assertAlmostEqual(10, x, 4)
    self.assertAlmostEqual(-18.81966, y, 4)
    x, y = sys.params(p303.params)
    self.assertAlmostEqual(101.11418, x, 4)
    self.assertAlmostEqual(119.04153, y, 4)
    x, y = sys.params(p304.params)
    self.assertAlmostEqual(116.47661, x, 4)
    self.assertAlmostEqual(111.76171, y, 4)
    x, y = sys.params(p305.params)
    self.assertAlmostEqual(117.40922, x, 4)
    self.assertAlmostEqual(114.19676, y, 4)
    x, y = sys.params(p306.params)
    self.assertAlmostEqual(200, x, 4)
    self.assertAlmostEqual(200, y, 4)
    x, = sys.params(d307.params)
    self.assertAlmostEqual(17, x, 4)
    self.assertEqual(6, sys.dof())


</t>
<t tx="leo.20191228122504.1">c.recursiveImport(
    dir_ = r'./src',
    kind = '@clean',
    safe_at_file = False,
    theTypes = ['.cpp', '.h']
)
</t>
<t tx="leo.20191228122642.1"></t>
<t tx="leo.20191228122642.10">void AllocTriangles() {
    btri = (STriangle *)AllocTemporary(sizeof(STriangle) * 2);
    ctri = &amp;btri[1];
}

</t>
<t tx="leo.20191228122642.11">void AllocQuad() {
    vpos = (Vector *)AllocTemporary(sizeof(Vector) * 4);
}

</t>
<t tx="leo.20191228122642.12">void AllocClassify(size_t size) {
    // Allocate a one big piece is faster than a small ones.
    isPos = (bool *)AllocTemporary(sizeof(bool) * size * 3);
    isNeg = &amp;isPos[size];
    isOn  = &amp;isNeg[size];
}

</t>
<t tx="leo.20191228122642.13">void AllocVertices(size_t size) {
    vpos = (Vector *)AllocTemporary(sizeof(Vector) * size * 2);
    vneg = &amp;vpos[size];
}

</t>
<t tx="leo.20191228122642.14">void ClassifyTriangle(STriangle *tri, SBsp3 *node) {
    tr   = tri;
    bsp  = node;
    onc  = 0;
    posc = 0;
    negc = 0;

    AllocClassify(3);

    double dt[3] = { (tr-&gt;a).Dot(bsp-&gt;n), (tr-&gt;b).Dot(bsp-&gt;n), (tr-&gt;c).Dot(bsp-&gt;n) };
    double d = bsp-&gt;d;
    // Count vertices in the plane
    for(int i = 0; i &lt; 3; i++) {
        if(dt[i] &gt; d + LENGTH_EPS) {
            posc++;
            isPos[i] = true;
        } else if(dt[i] &lt; d - LENGTH_EPS) {
            negc++;
            isNeg[i] = true;
        } else {
            onc++;
            isOn[i] = true;
        }
    }
}

</t>
<t tx="leo.20191228122642.15">bool ClassifyConvex(Vector *vertex, size_t cnt, SBsp3 *node, bool insertEdge) {
    bsp  = node;
    onc  = 0;
    posc = 0;
    negc = 0;

    AllocClassify(cnt);
    AllocOn();

    for(size_t i = 0; i &lt; cnt; i++) {
        double dt = bsp-&gt;n.Dot(vertex[i]);
        isPos[i] = isNeg[i] = isOn[i] = false;
        if(fabs(dt - bsp-&gt;d) &lt; LENGTH_EPS) {
            isOn[i] = true;
            if(onc &lt; 2) {
                on[onc] = vertex[i];
            }
            onc++;
        } else if(dt &gt; bsp-&gt;d) {
            isPos[i] = true;
            posc++;
        } else {
            isNeg[i] = true;
            negc++;
        }
    }

    if(onc != 2 &amp;&amp; onc != 1 &amp;&amp; onc != 0) return false;
    if(onc == 2) {
        if(insertEdge) {
            Vector e01 = (vertex[1]).Minus(vertex[0]);
            Vector e12 = (vertex[2]).Minus(vertex[1]);
            Vector out = e01.Cross(e12);
            SEdge se = SEdge::From(on[0], on[1]);
            bsp-&gt;edges = SBsp2::InsertOrCreateEdge(bsp-&gt;edges, &amp;se, bsp-&gt;n, out);
        }
    }
    return true;
}

</t>
<t tx="leo.20191228122642.16">bool ClassifyConvexVertices(Vector *vertex, size_t cnt, bool insertEdges) {
    Vector inter[2];
    int inters = 0;

    npos = 0;
    nneg = 0;

    // Enlarge vertices list to consider two intersections
    AllocVertices(cnt + 4);

    for(size_t i = 0; i &lt; cnt; i++) {
        size_t ip = WRAP((i + 1), cnt);

        if(isPos[i]) {
            vpos[npos++] = vertex[i];
        }
        if(isNeg[i]) {
            vneg[nneg++] = vertex[i];
        }
        if(isOn[i]) {
            vneg[nneg++] = vertex[i];
            vpos[npos++] = vertex[i];
        }
        if((isPos[i] &amp;&amp; isNeg[ip]) || (isNeg[i] &amp;&amp; isPos[ip])) {
            Vector vi = bsp-&gt;IntersectionWith(vertex[i], vertex[ip]);
            vpos[npos++] = vi;
            vneg[nneg++] = vi;

            if(inters &gt;= 2) return false; // triangulate: XXX shouldn't happen but does
            inter[inters++] = vi;
        }
    }
    ssassert(npos &lt;= cnt + 1 &amp;&amp; nneg &lt;= cnt + 1, "Impossible");

    if(insertEdges) {
        Vector e01 = (vertex[1]).Minus(vertex[0]);
        Vector e12 = (vertex[2]).Minus(vertex[1]);
        Vector out = e01.Cross(e12);
        if(inters == 2) {
            SEdge se = SEdge::From(inter[0], inter[1]);
            bsp-&gt;edges = SBsp2::InsertOrCreateEdge(bsp-&gt;edges, &amp;se, bsp-&gt;n, out);
        } else if(inters == 1 &amp;&amp; onc == 1) {
            SEdge se = SEdge::From(inter[0], on[0]);
            bsp-&gt;edges = SBsp2::InsertOrCreateEdge(bsp-&gt;edges, &amp;se, bsp-&gt;n, out);
        } else if(inters == 0 &amp;&amp; onc == 2) {
            // We already handled this on-plane existing edge
        } else {
            return false; //triangulate;
        }
    }
    if(nneg &lt; 3 || npos &lt; 3) return false; // triangulate; // XXX

    return true;
}

</t>
<t tx="leo.20191228122642.17">void ProcessEdgeInsert() {
    ssassert(onc == 2, "Impossible");

    Vector a, b;
    if     (!isOn[0]) { a = tr-&gt;b; b = tr-&gt;c; }
    else if(!isOn[1]) { a = tr-&gt;c; b = tr-&gt;a; }
    else if(!isOn[2]) { a = tr-&gt;a; b = tr-&gt;b; }
    else ssassert(false, "Impossible");

    SEdge se = SEdge::From(a, b);
    bsp-&gt;edges = SBsp2::InsertOrCreateEdge(bsp-&gt;edges, &amp;se, bsp-&gt;n, tr-&gt;Normal());
}

</t>
<t tx="leo.20191228122642.18">bool SplitIntoTwoTriangles(bool insertEdge) {
    ssassert(posc == 1 &amp;&amp; negc == 1 &amp;&amp; onc == 1, "Impossible");

    bool bpos;
    Vector a, b, c;

    // Standardize so that a is on the plane
    if       (isOn[0]) { a = tr-&gt;a; b = tr-&gt;b; c = tr-&gt;c; bpos = isPos[1];
    } else if(isOn[1]) { a = tr-&gt;b; b = tr-&gt;c; c = tr-&gt;a; bpos = isPos[2];
    } else if(isOn[2]) { a = tr-&gt;c; b = tr-&gt;a; c = tr-&gt;b; bpos = isPos[0];
    } else ssassert(false, "Impossible");

    AllocTriangles();
    Vector bPc = bsp-&gt;IntersectionWith(b, c);
    *btri = STriangle::From(tr-&gt;meta, a, b, bPc);
    *ctri = STriangle::From(tr-&gt;meta, c, a, bPc);

    if(insertEdge) {
        SEdge se = SEdge::From(a, bPc);
        bsp-&gt;edges = SBsp2::InsertOrCreateEdge(bsp-&gt;edges, &amp;se, bsp-&gt;n, tr-&gt;Normal());
    }

    return bpos;
}

</t>
<t tx="leo.20191228122642.19">bool SplitIntoTwoPieces(bool insertEdge) {
    Vector a, b, c;
    if(posc == 2 &amp;&amp; negc == 1) {
        // Standardize so that a is on one side, and b and c are on the other.
        if       (isNeg[0]) {   a = tr-&gt;a; b = tr-&gt;b; c = tr-&gt;c;
        } else if(isNeg[1]) {   a = tr-&gt;b; b = tr-&gt;c; c = tr-&gt;a;
        } else if(isNeg[2]) {   a = tr-&gt;c; b = tr-&gt;a; c = tr-&gt;b;
        } else ssassert(false, "Impossible");
    } else if(posc == 1 &amp;&amp; negc == 2) {
        if       (isPos[0]) {   a = tr-&gt;a; b = tr-&gt;b; c = tr-&gt;c;
        } else if(isPos[1]) {   a = tr-&gt;b; b = tr-&gt;c; c = tr-&gt;a;
        } else if(isPos[2]) {   a = tr-&gt;c; b = tr-&gt;a; c = tr-&gt;b;
        } else ssassert(false, "Impossible");
    } else ssassert(false, "Impossible");

    Vector aPb = bsp-&gt;IntersectionWith(a, b);
    Vector cPa = bsp-&gt;IntersectionWith(c, a);
    AllocTriangle();
    AllocQuad();

    *btri = STriangle::From(tr-&gt;meta, a, aPb, cPa);

    vpos[0] = aPb;
    vpos[1] = b;
    vpos[2] = c;
    vpos[3] = cPa;

    if(insertEdge) {
        SEdge se = SEdge::From(aPb, cPa);
        bsp-&gt;edges = SBsp2::InsertOrCreateEdge(bsp-&gt;edges, &amp;se, bsp-&gt;n, btri-&gt;Normal());
    }

    return posc == 2 &amp;&amp; negc == 1;
}

</t>
<t tx="leo.20191228122642.2"></t>
<t tx="leo.20191228122642.20">static SBsp3 *Triangulate(SBsp3 *bsp, const STriMeta &amp;meta, Vector *vertex,
                          size_t cnt, SMesh *instead) {
    for(size_t i = 0; i &lt; cnt - 2; i++) {
        STriangle tr = STriangle::From(meta, vertex[0], vertex[i + 1], vertex[i + 2]);
        bsp = SBsp3::InsertOrCreate(bsp, &amp;tr, instead);
    }
    return bsp;
}
</t>
<t tx="leo.20191228122642.21">void SBsp3::InsertConvexHow(BspClass how, STriMeta meta, Vector *vertex, size_t n,
                            SMesh *instead) {
    switch(how) {
        case BspClass::POS:
            if(pos) {
                pos = pos-&gt;InsertConvex(meta, vertex, n, instead);
                return;
            }
            break;

        case BspClass::NEG:
            if(neg) {
                neg = neg-&gt;InsertConvex(meta, vertex, n, instead);
                return;
            }
            break;

        default: ssassert(false, "Unexpected BSP insert type");
    }

    for(size_t i = 0; i &lt; n - 2; i++) {
        STriangle tr = STriangle::From(meta,
                                       vertex[0], vertex[i+1], vertex[i+2]);
        InsertHow(how, &amp;tr, instead);
    }
}

SBsp3 *SBsp3::InsertConvex(STriMeta meta, Vector *vertex, size_t cnt, SMesh *instead) {
    BspUtil *u = BspUtil::Alloc();
    if(u-&gt;ClassifyConvex(vertex, cnt, this, !instead)) {
        if(u-&gt;posc == 0) {
            InsertConvexHow(BspClass::NEG, meta, vertex, cnt, instead);
            return this;
        }
        if(u-&gt;negc == 0) {
            InsertConvexHow(BspClass::POS, meta, vertex, cnt, instead);
            return this;
        }

        if(u-&gt;ClassifyConvexVertices(vertex, cnt, !instead)) {
            InsertConvexHow(BspClass::NEG, meta, u-&gt;vneg, u-&gt;nneg, instead);
            InsertConvexHow(BspClass::POS, meta, u-&gt;vpos, u-&gt;npos, instead);
            return this;
        }
    }

    // We don't handle the special case for this; do it as triangles
    return BspUtil::Triangulate(this, meta, vertex, cnt, instead);
}

SBsp3 *SBsp3::InsertOrCreate(SBsp3 *where, STriangle *tr, SMesh *instead) {
    if(where == NULL) {
        if(instead) {
            if(instead-&gt;flipNormal) {
                instead-&gt;atLeastOneDiscarded = true;
            } else {
                instead-&gt;AddTriangle(tr-&gt;meta, tr-&gt;a, tr-&gt;b, tr-&gt;c);
            }
            return NULL;
        }

        // Brand new node; so allocate for it, and fill us in.
        SBsp3 *r = Alloc();
        r-&gt;n = (tr-&gt;Normal()).WithMagnitude(1);
        r-&gt;d = (tr-&gt;a).Dot(r-&gt;n);
        r-&gt;tri = *tr;
        return r;
    }
    where-&gt;Insert(tr, instead);
    return where;
}

</t>
<t tx="leo.20191228122642.22">void SBsp3::Insert(STriangle *tr, SMesh *instead) {
    BspUtil *u = BspUtil::Alloc();
    u-&gt;ClassifyTriangle(tr, this);

    // All vertices in-plane
    if(u-&gt;onc == 3) {
        InsertHow(BspClass::COPLANAR, tr, instead);
        return;
    }

    // No split required
    if(u-&gt;posc == 0 || u-&gt;negc == 0) {
        if(!instead &amp;&amp; u-&gt;onc == 2) {
            u-&gt;ProcessEdgeInsert();
        }

        if(u-&gt;posc &gt; 0) {
            InsertHow(BspClass::POS, tr, instead);
        } else {
            InsertHow(BspClass::NEG, tr, instead);
        }
        return;
    }

    // The polygon must be split into two triangles, one above, one below.
    if(u-&gt;posc == 1 &amp;&amp; u-&gt;negc == 1 &amp;&amp; u-&gt;onc == 1) {
        if(u-&gt;SplitIntoTwoTriangles(!instead)) {
            InsertHow(BspClass::POS, u-&gt;btri, instead);
            InsertHow(BspClass::NEG, u-&gt;ctri, instead);
        } else {
            InsertHow(BspClass::POS, u-&gt;ctri, instead);
            InsertHow(BspClass::NEG, u-&gt;btri, instead);
        }
        return;
    }

    // The polygon must be split into two pieces: a triangle and a quad.
    if(u-&gt;SplitIntoTwoPieces(!instead)) {
        InsertConvexHow(BspClass::POS, tr-&gt;meta, u-&gt;vpos, 4, instead);
        InsertHow(BspClass::NEG, u-&gt;btri, instead);
    } else {
        InsertConvexHow(BspClass::NEG, tr-&gt;meta, u-&gt;vpos, 4, instead);
        InsertHow(BspClass::POS, u-&gt;btri, instead);
    }
}

</t>
<t tx="leo.20191228122642.23">void SBsp3::GenerateInPaintOrder(SMesh *m) const {
    // Doesn't matter which branch we take if the normal has zero z
    // component, so don't need a separate case for that.
    if(n.z &lt; 0) {
        if(pos) pos-&gt;GenerateInPaintOrder(m);
    } else {
        if(neg) neg-&gt;GenerateInPaintOrder(m);
    }

    const SBsp3 *flip = this;
    while(flip) {
        m-&gt;AddTriangle(&amp;(flip-&gt;tri));
        flip = flip-&gt;more;
    }

    if(n.z &lt; 0) {
        if(neg) neg-&gt;GenerateInPaintOrder(m);
    } else {
        if(pos) pos-&gt;GenerateInPaintOrder(m);
    }
}

/////////////////////////////////

Vector SBsp2::IntersectionWith(Vector a, Vector b) const {
    double da = a.Dot(no) - d;
    double db = b.Dot(no) - d;
    ssassert(da*db &lt; 0, "Expected segment to intersect BSP node");

    double dab = (db - da);
    return (a.ScaledBy(db/dab)).Plus(b.ScaledBy(-da/dab));
}

SBsp2 *SBsp2::InsertOrCreateEdge(SBsp2 *where, SEdge *nedge, Vector nnp, Vector out) {
    if(where == NULL) {
        // Brand new node; so allocate for it, and fill us in.
        SBsp2 *r = Alloc();
        r-&gt;np = nnp;
        r-&gt;no = ((r-&gt;np).Cross((nedge-&gt;b).Minus(nedge-&gt;a))).WithMagnitude(1);
        if(out.Dot(r-&gt;no) &lt; 0) {
            r-&gt;no = (r-&gt;no).ScaledBy(-1);
        }
        r-&gt;d = (nedge-&gt;a).Dot(r-&gt;no);
        r-&gt;edge = *nedge;
        return r;
    }
    where-&gt;InsertEdge(nedge, nnp, out);
    return where;
}

</t>
<t tx="leo.20191228122642.24">void SBsp2::InsertEdge(SEdge *nedge, Vector nnp, Vector out) {

    double dt[2] = { (nedge-&gt;a).Dot(no), (nedge-&gt;b).Dot(no) };

    bool isPos[2] = {}, isNeg[2] = {}, isOn[2] = {};
    for(int i = 0; i &lt; 2; i++) {
        if(fabs(dt[i] - d) &lt; LENGTH_EPS) {
            isOn[i] = true;
        } else if(dt[i] &gt; d) {
            isPos[i] = true;
        } else {
            isNeg[i] = true;
        }
    }

    if((isPos[0] &amp;&amp; isPos[1])||(isPos[0] &amp;&amp; isOn[1])||(isOn[0] &amp;&amp; isPos[1])) {
        pos = InsertOrCreateEdge(pos, nedge, nnp, out);
        return;
    }
    if((isNeg[0] &amp;&amp; isNeg[1])||(isNeg[0] &amp;&amp; isOn[1])||(isOn[0] &amp;&amp; isNeg[1])) {
        neg = InsertOrCreateEdge(neg, nedge, nnp, out);
        return;
    }
    if(isOn[0] &amp;&amp; isOn[1]) {
        SBsp2 *m = Alloc();

        m-&gt;np = nnp;
        m-&gt;no = ((m-&gt;np).Cross((nedge-&gt;b).Minus(nedge-&gt;a))).WithMagnitude(1);
        if(out.Dot(m-&gt;no) &lt; 0) {
            m-&gt;no = (m-&gt;no).ScaledBy(-1);
        }
        m-&gt;d = (nedge-&gt;a).Dot(m-&gt;no);
        m-&gt;edge = *nedge;

        m-&gt;more = more;
        more = m;
        return;
    }
    if((isPos[0] &amp;&amp; isNeg[1]) || (isNeg[0] &amp;&amp; isPos[1])) {
        Vector aPb = IntersectionWith(nedge-&gt;a, nedge-&gt;b);

        SEdge ea = SEdge::From(nedge-&gt;a, aPb);
        SEdge eb = SEdge::From(aPb, nedge-&gt;b);

        if(isPos[0]) {
            pos = InsertOrCreateEdge(pos, &amp;ea, nnp, out);
            neg = InsertOrCreateEdge(neg, &amp;eb, nnp, out);
        } else {
            neg = InsertOrCreateEdge(neg, &amp;ea, nnp, out);
            pos = InsertOrCreateEdge(pos, &amp;eb, nnp, out);
        }
        return;
    }
    ssassert(false, "Impossible");
}

</t>
<t tx="leo.20191228122642.25">void SBsp2::InsertTriangleHow(BspClass how, STriangle *tr, SMesh *m, SBsp3 *bsp3) {
    switch(how) {
        case BspClass::POS:
            if(pos) {
                pos-&gt;InsertTriangle(tr, m, bsp3);
            } else {
                bsp3-&gt;InsertInPlane(/*pos2=*/true, tr, m);
            }
            break;

        case BspClass::NEG:
            if(neg) {
                neg-&gt;InsertTriangle(tr, m, bsp3);
            } else {
                bsp3-&gt;InsertInPlane(/*pos2=*/false, tr, m);
            }
            break;

        default: ssassert(false, "Unexpected BSP insert type");
    }
}

</t>
<t tx="leo.20191228122642.26">void SBsp2::InsertTriangle(STriangle *tr, SMesh *m, SBsp3 *bsp3) {
    double dt[3] = { (tr-&gt;a).Dot(no), (tr-&gt;b).Dot(no), (tr-&gt;c).Dot(no) };

    bool isPos[3] = {}, isNeg[3] = {}, isOn[3] = {};
    int inc = 0, posc = 0, negc = 0;
    for(int i = 0; i &lt; 3; i++) {
        if(fabs(dt[i] - d) &lt; LENGTH_EPS) {
            isOn[i] = true;
            inc++;
        } else if(dt[i] &gt; d) {
            isPos[i] = true;
            posc++;
        } else {
            isNeg[i] = true;
            negc++;
        }
    }

    if(inc == 3) {
        // All vertices on-line; so it's a degenerate triangle, to ignore.
        return;
    }

    // No split required
    if(posc == 0 || negc == 0) {
        if(posc &gt; 0) {
            InsertTriangleHow(BspClass::POS, tr, m, bsp3);
        } else {
            InsertTriangleHow(BspClass::NEG, tr, m, bsp3);
        }
        return;
    }

    // The polygon must be split into two pieces, one above, one below.
    Vector a, b, c;

    if(posc == 1 &amp;&amp; negc == 1 &amp;&amp; inc == 1) {
        bool bpos;
        // Standardize so that a is on the plane
        if       (isOn[0]) { a = tr-&gt;a; b = tr-&gt;b; c = tr-&gt;c; bpos = isPos[1];
        } else if(isOn[1]) { a = tr-&gt;b; b = tr-&gt;c; c = tr-&gt;a; bpos = isPos[2];
        } else if(isOn[2]) { a = tr-&gt;c; b = tr-&gt;a; c = tr-&gt;b; bpos = isPos[0];
        } else ssassert(false, "Impossible");

        Vector bPc = IntersectionWith(b, c);
        STriangle btri = STriangle::From(tr-&gt;meta, a, b, bPc);
        STriangle ctri = STriangle::From(tr-&gt;meta, c, a, bPc);

        if(bpos) {
            InsertTriangleHow(BspClass::POS, &amp;btri, m, bsp3);
            InsertTriangleHow(BspClass::NEG, &amp;ctri, m, bsp3);
        } else {
            InsertTriangleHow(BspClass::POS, &amp;ctri, m, bsp3);
            InsertTriangleHow(BspClass::NEG, &amp;btri, m, bsp3);
        }

        return;
    }

    if(posc == 2 &amp;&amp; negc == 1) {
        // Standardize so that a is on one side, and b and c are on the other.
        if       (isNeg[0]) {   a = tr-&gt;a; b = tr-&gt;b; c = tr-&gt;c;
        } else if(isNeg[1]) {   a = tr-&gt;b; b = tr-&gt;c; c = tr-&gt;a;
        } else if(isNeg[2]) {   a = tr-&gt;c; b = tr-&gt;a; c = tr-&gt;b;
        } else ssassert(false, "Impossible");

    } else if(posc == 1 &amp;&amp; negc == 2) {
        if       (isPos[0]) {   a = tr-&gt;a; b = tr-&gt;b; c = tr-&gt;c;
        } else if(isPos[1]) {   a = tr-&gt;b; b = tr-&gt;c; c = tr-&gt;a;
        } else if(isPos[2]) {   a = tr-&gt;c; b = tr-&gt;a; c = tr-&gt;b;
        } else ssassert(false, "Impossible");
    } else ssassert(false, "Impossible");

    Vector aPb = IntersectionWith(a, b);
    Vector cPa = IntersectionWith(c, a);

    STriangle alone = STriangle::From(tr-&gt;meta, a,   aPb, cPa);
    STriangle quad1 = STriangle::From(tr-&gt;meta, aPb, b,   c  );
    STriangle quad2 = STriangle::From(tr-&gt;meta, aPb, c,   cPa);

    if(posc == 2 &amp;&amp; negc == 1) {
        InsertTriangleHow(BspClass::POS, &amp;quad1, m, bsp3);
        InsertTriangleHow(BspClass::POS, &amp;quad2, m, bsp3);
        InsertTriangleHow(BspClass::NEG, &amp;alone, m, bsp3);
    } else {
        InsertTriangleHow(BspClass::NEG, &amp;quad1, m, bsp3);
        InsertTriangleHow(BspClass::NEG, &amp;quad2, m, bsp3);
        InsertTriangleHow(BspClass::POS, &amp;alone, m, bsp3);
    }

    return;
}
</t>
<t tx="leo.20191228122642.27">@path ./src/
//-----------------------------------------------------------------------------
// The clipboard that gets manipulated when the user selects Edit -&gt; Cut,
// Copy, Paste, etc.; may contain entities only, not constraints.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122642.28">void SolveSpaceUI::Clipboard::Clear() {
    c.Clear();
    r.Clear();
}

</t>
<t tx="leo.20191228122642.29">bool SolveSpaceUI::Clipboard::ContainsEntity(hEntity he) {
    if(he == Entity::NO_ENTITY)
        return true;

    ClipboardRequest *cr;
    for(cr = r.First(); cr; cr = r.NextAfter(cr)) {
        if(cr-&gt;oldEnt == he)
            return true;

        for(int i = 0; i &lt; MAX_POINTS_IN_ENTITY; i++) {
            if(cr-&gt;oldPointEnt[i] == he)
                return true;
        }
    }
    return false;
}

hEntity SolveSpaceUI::Clipboard::NewEntityFor(hEntity he) {
    if(he == Entity::NO_ENTITY)
        return Entity::NO_ENTITY;

    ClipboardRequest *cr;
    for(cr = r.First(); cr; cr = r.NextAfter(cr)) {
        if(cr-&gt;oldEnt == he)
            return cr-&gt;newReq.entity(0);

        for(int i = 0; i &lt; MAX_POINTS_IN_ENTITY; i++) {
            if(cr-&gt;oldPointEnt[i] == he)
                return cr-&gt;newReq.entity(1+i);
        }
    }

    ssassert(false, "Expected to find entity in some clipboard request");
}

</t>
<t tx="leo.20191228122642.3">@path ./src/
//-----------------------------------------------------------------------------
// Binary space partitioning tree, used to represent a volume in 3-space
// bounded by a triangle mesh. These are used to compute Boolean operations
// on meshes. These aren't used for anything relating to an SShell of
// ratpoly surfaces.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

SBsp2 *SBsp2::Alloc() { return (SBsp2 *)AllocTemporary(sizeof(SBsp2)); }
SBsp3 *SBsp3::Alloc() { return (SBsp3 *)AllocTemporary(sizeof(SBsp3)); }

SBsp3 *SBsp3::FromMesh(const SMesh *m) {
    SMesh mc = {};
    for(auto const &amp;elt : m-&gt;l) { mc.AddTriangle(&amp;elt); }

    srand(0); // Let's be deterministic, at least!
    int n = mc.l.n;
    while(n &gt; 1) {
        int k = rand() % n;
        n--;
        swap(mc.l[k], mc.l[n]);
    }

    SBsp3 *bsp3 = NULL;
    for(auto &amp;elt : mc.l) { bsp3 = InsertOrCreate(bsp3, &amp;elt, NULL); }
    mc.Clear();
    return bsp3;
}

Vector SBsp3::IntersectionWith(Vector a, Vector b) const {
    double da = a.Dot(n) - d;
    double db = b.Dot(n) - d;
    ssassert(da*db &lt; 0, "Expected segment to intersect BSP node");

    double dab = (db - da);
    return (a.ScaledBy(db/dab)).Plus(b.ScaledBy(-da/dab));
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122642.30">void GraphicsWindow::DeleteSelection() {
    SK.request.ClearTags();
    SK.constraint.ClearTags();
    List&lt;Selection&gt; *ls = &amp;(selection);
    for(Selection *s = ls-&gt;First(); s; s = ls-&gt;NextAfter(s)) {
        hRequest r = { 0 };
        if(s-&gt;entity.v &amp;&amp; s-&gt;entity.isFromRequest()) {
            r = s-&gt;entity.request();
        }
        if(r.v &amp;&amp; !r.IsFromReferences()) {
            SK.request.Tag(r, 1);
        }
        if(s-&gt;constraint.v) {
            SK.constraint.Tag(s-&gt;constraint, 1);
        }
    }

    SK.constraint.RemoveTagged();
    // Note that this regenerates and clears the selection, to avoid
    // lingering references to the just-deleted items.
    DeleteTaggedRequests();
}

</t>
<t tx="leo.20191228122642.31">void GraphicsWindow::CopySelection() {
    SS.clipboard.Clear();

    Entity *wrkpl  = SK.GetEntity(ActiveWorkplane());
    Entity *wrkpln = SK.GetEntity(wrkpl-&gt;normal);
    Vector u = wrkpln-&gt;NormalU(),
           v = wrkpln-&gt;NormalV(),
           n = wrkpln-&gt;NormalN(),
           p = SK.GetEntity(wrkpl-&gt;point[0])-&gt;PointGetNum();

    List&lt;Selection&gt; *ls = &amp;(selection);
    for(Selection *s = ls-&gt;First(); s; s = ls-&gt;NextAfter(s)) {
        if(!s-&gt;entity.v) continue;
        // Work only on entities that have requests that will generate them.
        Entity *e = SK.GetEntity(s-&gt;entity);
        bool hasDistance;
        Request::Type req;
        int pts;
        if(!EntReqTable::GetEntityInfo(e-&gt;type, e-&gt;extraPoints,
                &amp;req, &amp;pts, NULL, &amp;hasDistance))
        {
            if(!e-&gt;h.isFromRequest()) continue;
            Request *r = SK.GetRequest(e-&gt;h.request());
            if(r-&gt;type != Request::Type::DATUM_POINT) continue;
            EntReqTable::GetEntityInfo((Entity::Type)0, e-&gt;extraPoints,
                &amp;req, &amp;pts, NULL, &amp;hasDistance);
        }
        if(req == Request::Type::WORKPLANE) continue;

        ClipboardRequest cr = {};
        cr.type         = req;
        cr.extraPoints  = e-&gt;extraPoints;
        cr.style        = e-&gt;style;
        cr.str          = e-&gt;str;
        cr.font         = e-&gt;font;
        cr.file         = e-&gt;file;
        cr.construction = e-&gt;construction;
        {for(int i = 0; i &lt; pts; i++) {
            Vector pt;
            if(req == Request::Type::DATUM_POINT) {
                pt = e-&gt;PointGetNum();
            } else {
                pt = SK.GetEntity(e-&gt;point[i])-&gt;PointGetNum();
            }
            pt = pt.Minus(p);
            pt = pt.DotInToCsys(u, v, n);
            cr.point[i] = pt;
        }}
        if(hasDistance) {
            cr.distance = SK.GetEntity(e-&gt;distance)-&gt;DistanceGetNum();
        }

        cr.oldEnt = e-&gt;h;
        for(int i = 0; i &lt; pts; i++) {
            cr.oldPointEnt[i] = e-&gt;point[i];
        }

        SS.clipboard.r.Add(&amp;cr);
    }

    for(Selection *s = ls-&gt;First(); s; s = ls-&gt;NextAfter(s)) {
        if(!s-&gt;constraint.v) continue;

        Constraint *c = SK.GetConstraint(s-&gt;constraint);
        if(c-&gt;type == Constraint::Type::COMMENT) {
            SS.clipboard.c.Add(c);
        }
    }

    Constraint *c;
    for(c = SK.constraint.First(); c; c = SK.constraint.NextAfter(c)) {
        if(!SS.clipboard.ContainsEntity(c-&gt;ptA) ||
           !SS.clipboard.ContainsEntity(c-&gt;ptB) ||
           !SS.clipboard.ContainsEntity(c-&gt;entityA) ||
           !SS.clipboard.ContainsEntity(c-&gt;entityB) ||
           !SS.clipboard.ContainsEntity(c-&gt;entityC) ||
           !SS.clipboard.ContainsEntity(c-&gt;entityD) ||
           c-&gt;type == Constraint::Type::COMMENT) {
            continue;
        }
        SS.clipboard.c.Add(c);
    }
}

</t>
<t tx="leo.20191228122642.32">void GraphicsWindow::PasteClipboard(Vector trans, double theta, double scale) {
    Entity *wrkpl  = SK.GetEntity(ActiveWorkplane());
    Entity *wrkpln = SK.GetEntity(wrkpl-&gt;normal);
    Vector u = wrkpln-&gt;NormalU(),
           v = wrkpln-&gt;NormalV(),
           n = wrkpln-&gt;NormalN(),
           p = SK.GetEntity(wrkpl-&gt;point[0])-&gt;PointGetNum();

    // For arcs, reflection involves swapping the endpoints, or otherwise
    // the arc gets inverted.
    @others
}

</t>
<t tx="leo.20191228122642.33">auto mapPoint = [scale](hEntity he) {
    if(he.v == 0) return he;

    if(scale &lt; 0) {
        hRequest hr = he.request();
        Request *r = SK.GetRequest(hr);
        if(r-&gt;type == Request::Type::ARC_OF_CIRCLE) {
            if(he == hr.entity(2)) {
                return hr.entity(3);
            } else if(he == hr.entity(3)) {
                return hr.entity(2);
            }
        }
    }
    return he;
};

ClipboardRequest *cr;
for(cr = SS.clipboard.r.First(); cr; cr = SS.clipboard.r.NextAfter(cr)) {
    hRequest hr = AddRequest(cr-&gt;type, /*rememberForUndo=*/false);
    Request *r = SK.GetRequest(hr);
    r-&gt;extraPoints  = cr-&gt;extraPoints;
    r-&gt;style        = cr-&gt;style;
    r-&gt;str          = cr-&gt;str;
    r-&gt;font         = cr-&gt;font;
    r-&gt;file         = cr-&gt;file;
    r-&gt;construction = cr-&gt;construction;
    // Need to regen to get the right number of points, if extraPoints
    // changed.
    SS.GenerateAll(SolveSpaceUI::Generate::REGEN);
    SS.MarkGroupDirty(r-&gt;group);
    bool hasDistance;
    int i, pts;
    EntReqTable::GetRequestInfo(r-&gt;type, r-&gt;extraPoints,
        NULL, &amp;pts, NULL, &amp;hasDistance);
    for(i = 0; i &lt; pts; i++) {
        Vector pt = cr-&gt;point[i];
        // We need the reflection to occur within the workplane; it may
        // otherwise correspond to just a rotation as projected.
        if(scale &lt; 0) {
            pt.x *= -1;
        }
        // Likewise the scale, which could otherwise take us out of the
        // workplane.
        pt = pt.ScaledBy(fabs(scale));
        pt = pt.ScaleOutOfCsys(u, v, Vector::From(0, 0, 0));
        pt = pt.Plus(p);
        pt = pt.RotatedAbout(n, theta);
        pt = pt.Plus(trans);
        int j = (r-&gt;type == Request::Type::DATUM_POINT) ? i : i + 1;
        SK.GetEntity(mapPoint(hr.entity(j)))-&gt;PointForceTo(pt);
    }
    if(hasDistance) {
        SK.GetEntity(hr.entity(64))-&gt;DistanceForceTo(
                                        cr-&gt;distance*fabs(scale));
    }

    cr-&gt;newReq = hr;
    MakeSelected(hr.entity(0));
    for(i = 0; i &lt; pts; i++) {
        int j = (r-&gt;type == Request::Type::DATUM_POINT) ? i : i + 1;
        MakeSelected(hr.entity(j));
    }
}

Constraint *cc;
for(cc = SS.clipboard.c.First(); cc; cc = SS.clipboard.c.NextAfter(cc)) {
    Constraint c = {};
    c.group = SS.GW.activeGroup;
    c.workplane = SS.GW.ActiveWorkplane();
    c.type = cc-&gt;type;
    c.valA = cc-&gt;valA;
    c.ptA = SS.clipboard.NewEntityFor(mapPoint(cc-&gt;ptA));
    c.ptB = SS.clipboard.NewEntityFor(mapPoint(cc-&gt;ptB));
    c.entityA = SS.clipboard.NewEntityFor(cc-&gt;entityA);
    c.entityB = SS.clipboard.NewEntityFor(cc-&gt;entityB);
    c.entityC = SS.clipboard.NewEntityFor(cc-&gt;entityC);
    c.entityD = SS.clipboard.NewEntityFor(cc-&gt;entityD);
    c.other = cc-&gt;other;
    c.other2 = cc-&gt;other2;
    c.reference = cc-&gt;reference;
    c.disp = cc-&gt;disp;
    c.comment = cc-&gt;comment;
    switch(c.type) {
        case Constraint::Type::COMMENT:
            c.disp.offset = c.disp.offset.Plus(trans);
            break;

        case Constraint::Type::PT_PT_DISTANCE:
        case Constraint::Type::PT_LINE_DISTANCE:
        case Constraint::Type::PROJ_PT_DISTANCE:
        case Constraint::Type::DIAMETER:
            c.valA *= fabs(scale);
            break;

        default:
            break;
    }

    hConstraint hc = Constraint::AddConstraint(&amp;c, /*rememberForUndo=*/false);
    if(c.type == Constraint::Type::COMMENT) {
        MakeSelected(hc);
    }
}
</t>
<t tx="leo.20191228122642.34">void GraphicsWindow::MenuClipboard(Command id) {
    if(id != Command::DELETE &amp;&amp; !SS.GW.LockedInWorkplane()) {
        Error(_("Cut, paste, and copy work only in a workplane.\n\n"
                "Activate one with Sketch -&gt; In Workplane."));
        return;
    }

    switch(id) {
        case Command::PASTE: {
            SS.UndoRemember();
            Vector trans = SS.GW.projRight.ScaledBy(80/SS.GW.scale).Plus(
                           SS.GW.projUp   .ScaledBy(40/SS.GW.scale));
            SS.GW.ClearSelection();
            SS.GW.PasteClipboard(trans, 0, 1);
            break;
        }

        case Command::PASTE_TRANSFORM: {
            if(SS.clipboard.r.IsEmpty()) {
                Error(_("Clipboard is empty; nothing to paste."));
                break;
            }

            Entity *wrkpl  = SK.GetEntity(SS.GW.ActiveWorkplane());
            Vector p = SK.GetEntity(wrkpl-&gt;point[0])-&gt;PointGetNum();
            SS.TW.shown.paste.times  = 1;
            SS.TW.shown.paste.trans  = Vector::From(0, 0, 0);
            SS.TW.shown.paste.theta  = 0;
            SS.TW.shown.paste.origin = p;
            SS.TW.shown.paste.scale  = 1;
            SS.TW.GoToScreen(TextWindow::Screen::PASTE_TRANSFORMED);
            SS.GW.ForceTextWindowShown();
            SS.ScheduleShowTW();
            break;
        }

        case Command::COPY:
            SS.GW.CopySelection();
            SS.GW.ClearSelection();
            break;

        case Command::CUT:
            SS.UndoRemember();
            SS.GW.CopySelection();
            SS.GW.DeleteSelection();
            break;

        case Command::DELETE:
            SS.UndoRemember();
            SS.GW.DeleteSelection();
            break;

        default: ssassert(false, "Unexpected menu ID");
    }
}

</t>
<t tx="leo.20191228122642.35">bool TextWindow::EditControlDoneForPaste(const std::string &amp;s) {
    Expr *e;
    switch(edit.meaning) {
        case Edit::PASTE_TIMES_REPEATED: {
            e = Expr::From(s, /*popUpError=*/true);
            if(!e) break;
            int v = (int)e-&gt;Eval();
            if(v &gt; 0) {
                shown.paste.times = v;
            } else {
                Error(_("Number of copies to paste must be at least one."));
            }
            break;
        }
        case Edit::PASTE_ANGLE:
            e = Expr::From(s, /*popUpError=*/true);
            if(!e) break;
            shown.paste.theta = WRAP_SYMMETRIC((e-&gt;Eval())*PI/180, 2*PI);
            break;

        case Edit::PASTE_SCALE: {
            e = Expr::From(s, /*popUpError=*/true);
            double v = e-&gt;Eval();
            if(fabs(v) &gt; 1e-6) {
                shown.paste.scale = shown.paste.scale &lt; 0 ? -v : v;
            } else {
                Error(_("Scale cannot be zero."));
            }
            break;
        }

        default:
            return false;
    }
    return true;
}

</t>
<t tx="leo.20191228122642.36">void TextWindow::ScreenChangePasteTransformed(int link, uint32_t v) {
    switch(link) {
        case 't':
            SS.TW.ShowEditControl(13, ssprintf("%d", SS.TW.shown.paste.times));
            SS.TW.edit.meaning = Edit::PASTE_TIMES_REPEATED;
            break;

        case 'r':
            SS.TW.ShowEditControl(13, ssprintf("%.3f", SS.TW.shown.paste.theta*180/PI));
            SS.TW.edit.meaning = Edit::PASTE_ANGLE;
            break;

        case 's':
            SS.TW.ShowEditControl(13, ssprintf("%.3f", fabs(SS.TW.shown.paste.scale)));
            SS.TW.edit.meaning = Edit::PASTE_SCALE;
            break;

        case 'f':
            SS.TW.shown.paste.scale *= -1;
            break;
    }
}

</t>
<t tx="leo.20191228122642.37">void TextWindow::ScreenPasteTransformed(int link, uint32_t v) {
    SS.GW.GroupSelection();
    switch(link) {
        case 'o':
            if(SS.GW.gs.points == 1 &amp;&amp; SS.GW.gs.n == 1) {
                Entity *e = SK.GetEntity(SS.GW.gs.point[0]);
                SS.TW.shown.paste.origin = e-&gt;PointGetNum();
            } else {
                Error(_("Select one point to define origin of rotation."));
            }
            SS.GW.ClearSelection();
            break;

        case 't':
            if(SS.GW.gs.points == 2 &amp;&amp; SS.GW.gs.n == 2) {
                Entity *pa = SK.GetEntity(SS.GW.gs.point[0]),
                       *pb = SK.GetEntity(SS.GW.gs.point[1]);
                SS.TW.shown.paste.trans =
                    (pb-&gt;PointGetNum()).Minus(pa-&gt;PointGetNum());
            } else {
                Error(_("Select two points to define translation vector."));
            }
            SS.GW.ClearSelection();
            break;

        case 'g': {
            if(fabs(SS.TW.shown.paste.theta) &lt; LENGTH_EPS &amp;&amp;
               SS.TW.shown.paste.trans.Magnitude() &lt; LENGTH_EPS &amp;&amp;
               SS.TW.shown.paste.times != 1)
            {
                Message(_("Transformation is identity. So all copies will be "
                          "exactly on top of each other."));
            }
            if(SS.TW.shown.paste.times*SS.clipboard.r.n &gt; 100) {
                Error(_("Too many items to paste; split this into smaller "
                        "pastes."));
                break;
            }
            if(!SS.GW.LockedInWorkplane()) {
                Error(_("No workplane active."));
                break;
            }
            Entity *wrkpl  = SK.GetEntity(SS.GW.ActiveWorkplane());
            Entity *wrkpln = SK.GetEntity(wrkpl-&gt;normal);
            Vector wn = wrkpln-&gt;NormalN();
            SS.UndoRemember();
            SS.GW.ClearSelection();
            for(int i = 0; i &lt; SS.TW.shown.paste.times; i++) {
                Vector trans  = SS.TW.shown.paste.trans.ScaledBy(i+1),
                       origin = SS.TW.shown.paste.origin;
                double theta = SS.TW.shown.paste.theta*(i+1);
                // desired transformation is Q*(p - o) + o + t =
                // Q*p - Q*o + o + t = Q*p + (t + o - Q*o)
                Vector t = trans.Plus(
                           origin).Minus(
                           origin.RotatedAbout(wn, theta));

                SS.GW.PasteClipboard(t, theta, SS.TW.shown.paste.scale);
            }
            SS.TW.GoToScreen(Screen::LIST_OF_GROUPS);
            SS.ScheduleShowTW();
            break;
        }
    }
}

</t>
<t tx="leo.20191228122642.38">void TextWindow::ShowPasteTransformed() {
    Printf(true, "%FtPASTE TRANSFORMED%E");
    Printf(true,  "%Ba   %Ftrepeat%E    %d time%s %Fl%Lt%f[change]%E",
        shown.paste.times, (shown.paste.times == 1) ? "" : "s",
        &amp;ScreenChangePasteTransformed);
    Printf(false, "%Bd   %Ftrotate%E    %@ degrees %Fl%Lr%f[change]%E",
        shown.paste.theta*180/PI,
        &amp;ScreenChangePasteTransformed);
    Printf(false, "%Ba   %Ftabout pt%E  (%s, %s, %s) %Fl%Lo%f[use selected]%E",
            SS.MmToString(shown.paste.origin.x).c_str(),
            SS.MmToString(shown.paste.origin.y).c_str(),
            SS.MmToString(shown.paste.origin.z).c_str(),
        &amp;ScreenPasteTransformed);
    Printf(false, "%Bd   %Fttranslate%E (%s, %s, %s) %Fl%Lt%f[use selected]%E",
            SS.MmToString(shown.paste.trans.x).c_str(),
            SS.MmToString(shown.paste.trans.y).c_str(),
            SS.MmToString(shown.paste.trans.z).c_str(),
        &amp;ScreenPasteTransformed);
    Printf(false, "%Ba   %Ftscale%E     %@ %Fl%Ls%f[change]%E",
        fabs(shown.paste.scale),
        &amp;ScreenChangePasteTransformed);
    Printf(false, "%Ba   %Ftmirror%E    %Fd%Lf%f%s  flip%E",
        &amp;ScreenChangePasteTransformed,
        shown.paste.scale &lt; 0 ? CHECK_TRUE : CHECK_FALSE);

    Printf(true, " %Fl%Lg%fpaste transformed now%E", &amp;ScreenPasteTransformed);

    Printf(true, "(or %Fl%Ll%fcancel operation%E)", &amp;ScreenHome);
}

</t>
<t tx="leo.20191228122642.39">@path ./src/
//-----------------------------------------------------------------------------
// For the configuration screen, setup items that are not specific to the
// file being edited right now.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122642.4">void SBsp3::InsertInPlane(bool pos2, STriangle *tr, SMesh *m) {
    Vector tc = ((tr-&gt;a).Plus(tr-&gt;b).Plus(tr-&gt;c)).ScaledBy(1.0/3);

    bool onFace = false;
    bool sameNormal = false;
    double maxNormalMag = -1;

    Vector lln, trn = tr-&gt;Normal();

    SBsp3 *ll = this;
    while(ll) {
        if((ll-&gt;tri).ContainsPoint(tc)) {
            onFace = true;
            // If the mesh contains almost-zero-area triangles, and we're
            // just on the edge of one of those, then don't trust its normal.
            lln = (ll-&gt;tri).Normal();
            if(lln.Magnitude() &gt; maxNormalMag) {
                sameNormal = trn.Dot(lln) &gt; 0;
                maxNormalMag = lln.Magnitude();
            }
        }
        ll = ll-&gt;more;
    }

    if(m-&gt;flipNormal &amp;&amp; ((!pos2 &amp;&amp; !onFace) ||
                                   (onFace &amp;&amp; !sameNormal &amp;&amp; m-&gt;keepCoplanar)))
    {
        m-&gt;AddTriangle(tr-&gt;meta, tr-&gt;c, tr-&gt;b, tr-&gt;a);
    } else if(!(m-&gt;flipNormal) &amp;&amp; ((pos2 &amp;&amp; !onFace) ||
                                   (onFace &amp;&amp; sameNormal &amp;&amp; m-&gt;keepCoplanar)))
    {
        m-&gt;AddTriangle(tr-&gt;meta, tr-&gt;a, tr-&gt;b, tr-&gt;c);
    } else {
        m-&gt;atLeastOneDiscarded = true;
    }
}

</t>
<t tx="leo.20191228122642.40">void TextWindow::ScreenChangeLightDirection(int link, uint32_t v) {
    SS.TW.ShowEditControl(8, ssprintf("%.2f, %.2f, %.2f", CO(SS.lightDir[v])));
    SS.TW.edit.meaning = Edit::LIGHT_DIRECTION;
    SS.TW.edit.i = v;
}

</t>
<t tx="leo.20191228122642.41">void TextWindow::ScreenChangeLightIntensity(int link, uint32_t v) {
    SS.TW.ShowEditControl(31, ssprintf("%.2f", SS.lightIntensity[v]));
    SS.TW.edit.meaning = Edit::LIGHT_INTENSITY;
    SS.TW.edit.i = v;
}

</t>
<t tx="leo.20191228122642.42">void TextWindow::ScreenChangeColor(int link, uint32_t v) {
    SS.TW.ShowEditControlWithColorPicker(13, SS.modelColor[v]);

    SS.TW.edit.meaning = Edit::COLOR;
    SS.TW.edit.i = v;
}

</t>
<t tx="leo.20191228122642.43">void TextWindow::ScreenChangeChordTolerance(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, ssprintf("%lg", SS.chordTol));
    SS.TW.edit.meaning = Edit::CHORD_TOLERANCE;
    SS.TW.edit.i = 0;
}

</t>
<t tx="leo.20191228122642.44">void TextWindow::ScreenChangeMaxSegments(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, ssprintf("%d", SS.maxSegments));
    SS.TW.edit.meaning = Edit::MAX_SEGMENTS;
    SS.TW.edit.i = 0;
}

</t>
<t tx="leo.20191228122642.45">void TextWindow::ScreenChangeExportChordTolerance(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, ssprintf("%lg", SS.exportChordTol));
    SS.TW.edit.meaning = Edit::CHORD_TOLERANCE;
    SS.TW.edit.i = 1;
}

</t>
<t tx="leo.20191228122642.46">void TextWindow::ScreenChangeExportMaxSegments(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, ssprintf("%d", SS.exportMaxSegments));
    SS.TW.edit.meaning = Edit::MAX_SEGMENTS;
    SS.TW.edit.i = 1;
}

</t>
<t tx="leo.20191228122642.47">void TextWindow::ScreenChangeCameraTangent(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, ssprintf("%.3f", 1000*SS.cameraTangent));
    SS.TW.edit.meaning = Edit::CAMERA_TANGENT;
}

</t>
<t tx="leo.20191228122642.48">void TextWindow::ScreenChangeGridSpacing(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, SS.MmToString(SS.gridSpacing));
    SS.TW.edit.meaning = Edit::GRID_SPACING;
}

</t>
<t tx="leo.20191228122642.49">void TextWindow::ScreenChangeDigitsAfterDecimal(int link, uint32_t v) {
    SS.TW.ShowEditControl(14, ssprintf("%d", SS.UnitDigitsAfterDecimal()));
    SS.TW.edit.meaning = Edit::DIGITS_AFTER_DECIMAL;
}

</t>
<t tx="leo.20191228122642.5">void SBsp3::InsertHow(BspClass how, STriangle *tr, SMesh *instead) {
    switch(how) {
        case BspClass::POS:
            if(instead &amp;&amp; !pos) goto alt;
            pos = InsertOrCreate(pos, tr, instead);
            break;

        case BspClass::NEG:
            if(instead &amp;&amp; !neg) goto alt;
            neg = InsertOrCreate(neg, tr, instead);
            break;

        case BspClass::COPLANAR: {
            if(instead) goto alt;
            SBsp3 *m = Alloc();
            m-&gt;n = n;
            m-&gt;d = d;
            m-&gt;tri = *tr;
            m-&gt;more = more;
            more = m;
            break;
        }
    }
    return;

alt:
    if(how == BspClass::POS &amp;&amp; !(instead-&gt;flipNormal)) {
        instead-&gt;AddTriangle(tr-&gt;meta, tr-&gt;a, tr-&gt;b, tr-&gt;c);
    } else if(how == BspClass::NEG &amp;&amp; instead-&gt;flipNormal) {
        instead-&gt;AddTriangle(tr-&gt;meta, tr-&gt;c, tr-&gt;b, tr-&gt;a);
    } else if(how == BspClass::COPLANAR) {
        if(edges) {
            edges-&gt;InsertTriangle(tr, instead, this);
        } else {
            // I suppose this actually is allowed to happen, if the coplanar
            // face is the leaf, and all of its neighbors are earlier in tree?
            InsertInPlane(/*pos2=*/false, tr, instead);
        }
    } else {
        instead-&gt;atLeastOneDiscarded = true;
    }
}

</t>
<t tx="leo.20191228122642.50">void TextWindow::ScreenChangeDigitsAfterDecimalDegree(int link, uint32_t v) {
    SS.TW.ShowEditControl(14, ssprintf("%d", SS.afterDecimalDegree));
    SS.TW.edit.meaning = Edit::DIGITS_AFTER_DECIMAL_DEGREE;
}

</t>
<t tx="leo.20191228122642.51">void TextWindow::ScreenChangeUseSIPrefixes(int link, uint32_t v) {
    SS.useSIPrefixes = !SS.useSIPrefixes;
    SS.GW.Invalidate();
}

</t>
<t tx="leo.20191228122642.52">void TextWindow::ScreenChangeExportScale(int link, uint32_t v) {
    SS.TW.ShowEditControl(5, ssprintf("%.3f", (double)SS.exportScale));
    SS.TW.edit.meaning = Edit::EXPORT_SCALE;
}

</t>
<t tx="leo.20191228122642.53">void TextWindow::ScreenChangeExportOffset(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, SS.MmToString(SS.exportOffset));
    SS.TW.edit.meaning = Edit::EXPORT_OFFSET;
}

</t>
<t tx="leo.20191228122642.54">void TextWindow::ScreenChangeFixExportColors(int link, uint32_t v) {
    SS.fixExportColors = !SS.fixExportColors;
}

</t>
<t tx="leo.20191228122642.55">void TextWindow::ScreenChangeBackFaces(int link, uint32_t v) {
    SS.drawBackFaces = !SS.drawBackFaces;
    SS.GW.Invalidate(/*clearPersistent=*/true);
}

</t>
<t tx="leo.20191228122642.56">void TextWindow::ScreenChangeTurntableNav(int link, uint32_t v) {
    SS.turntableNav = !SS.turntableNav;
    if(SS.turntableNav) {
        // If turntable nav is being turned on, align view so Z is vertical
        SS.GW.AnimateOnto(Quaternion::From(Vector::From(-1, 0, 0), Vector::From(0, 0, 1)),
                          SS.GW.offset);
    }
}

</t>
<t tx="leo.20191228122642.57">void TextWindow::ScreenChangeImmediatelyEditDimension(int link, uint32_t v) {
    SS.immediatelyEditDimension = !SS.immediatelyEditDimension;
    SS.GW.Invalidate(/*clearPersistent=*/true);
}

</t>
<t tx="leo.20191228122642.58">void TextWindow::ScreenChangeShowContourAreas(int link, uint32_t v) {
    SS.showContourAreas = !SS.showContourAreas;
    SS.GW.Invalidate();
}

</t>
<t tx="leo.20191228122642.59">void TextWindow::ScreenChangeCheckClosedContour(int link, uint32_t v) {
    SS.checkClosedContour = !SS.checkClosedContour;
    SS.GW.Invalidate();
}

</t>
<t tx="leo.20191228122642.6">class BspUtil {
public:
    SBsp3      *bsp;

    size_t      onc;
    size_t      posc;
    size_t      negc;
    bool       *isPos;
    bool       *isNeg;
    bool       *isOn;

    // triangle operations
    STriangle  *tr;
    STriangle  *btri; // also as alone
    STriangle  *ctri;

    // convex operations
    Vector     *on;
    size_t      npos;
    size_t      nneg;
    Vector     *vpos; // also as quad
    Vector     *vneg;

    @others
};

</t>
<t tx="leo.20191228122642.60">void TextWindow::ScreenChangeAutomaticLineConstraints(int link, uint32_t v) {
    SS.automaticLineConstraints = !SS.automaticLineConstraints;
    SS.GW.Invalidate();
}

</t>
<t tx="leo.20191228122642.61">void TextWindow::ScreenChangeShadedTriangles(int link, uint32_t v) {
    SS.exportShadedTriangles = !SS.exportShadedTriangles;
    SS.GW.Invalidate();
}

</t>
<t tx="leo.20191228122642.62">void TextWindow::ScreenChangePwlCurves(int link, uint32_t v) {
    SS.exportPwlCurves = !SS.exportPwlCurves;
    SS.GW.Invalidate();
}

</t>
<t tx="leo.20191228122642.63">void TextWindow::ScreenChangeCanvasSizeAuto(int link, uint32_t v) {
    if(link == 't') {
        SS.exportCanvasSizeAuto = true;
    } else {
        SS.exportCanvasSizeAuto = false;
    }
    SS.GW.Invalidate();
}

</t>
<t tx="leo.20191228122642.64">void TextWindow::ScreenChangeCanvasSize(int link, uint32_t v) {
    double d;
    switch(v) {
        case  0: d = SS.exportMargin.left;      break;
        case  1: d = SS.exportMargin.right;     break;
        case  2: d = SS.exportMargin.bottom;    break;
        case  3: d = SS.exportMargin.top;       break;

        case 10: d = SS.exportCanvas.width;     break;
        case 11: d = SS.exportCanvas.height;    break;
        case 12: d = SS.exportCanvas.dx;        break;
        case 13: d = SS.exportCanvas.dy;        break;

        default: return;
    }
    int col = 13;
    if(v &lt; 10) col = 11;
    SS.TW.ShowEditControl(col, SS.MmToString(d));
    SS.TW.edit.meaning = Edit::CANVAS_SIZE;
    SS.TW.edit.i = v;
}

</t>
<t tx="leo.20191228122642.65">void TextWindow::ScreenChangeGCodeParameter(int link, uint32_t v) {
    std::string buf;
    switch(link) {
        case 'd':
            SS.TW.edit.meaning = Edit::G_CODE_DEPTH;
            buf += SS.MmToString(SS.gCode.depth);
            break;

        case 's':
            SS.TW.edit.meaning = Edit::G_CODE_PASSES;
            buf += std::to_string(SS.gCode.passes);
            break;

        case 'F':
            SS.TW.edit.meaning = Edit::G_CODE_FEED;
            buf += SS.MmToString(SS.gCode.feed);
            break;

        case 'P':
            SS.TW.edit.meaning = Edit::G_CODE_PLUNGE_FEED;
            buf += SS.MmToString(SS.gCode.plungeFeed);
            break;
    }
    SS.TW.ShowEditControl(14, buf);
}

</t>
<t tx="leo.20191228122642.66">void TextWindow::ScreenChangeAutosaveInterval(int link, uint32_t v) {
    SS.TW.ShowEditControl(3, std::to_string(SS.autosaveInterval));
    SS.TW.edit.meaning = Edit::AUTOSAVE_INTERVAL;
}

</t>
<t tx="leo.20191228122642.67">void TextWindow::ShowConfiguration() {
    int i;
    Printf(true, "%Ft user color (r, g, b)");

    for(i = 0; i &lt; SS.MODEL_COLORS; i++) {
        Printf(false, "%Bp   #%d:  %Bz  %Bp  (%@, %@, %@) %f%D%Ll%Fl[change]%E",
            (i &amp; 1) ? 'd' : 'a',
            i, &amp;SS.modelColor[i],
            (i &amp; 1) ? 'd' : 'a',
            SS.modelColor[i].redF(),
            SS.modelColor[i].greenF(),
            SS.modelColor[i].blueF(),
            &amp;ScreenChangeColor, i);
    }

    Printf(false, "");
    Printf(false, "%Ft light direction               intensity");
    for(i = 0; i &lt; 2; i++) {
        Printf(false, "%Bp   #%d  (%2,%2,%2)%Fl%D%f%Ll[c]%E "
                      "%2 %Fl%D%f%Ll[c]%E",
            (i &amp; 1) ? 'd' : 'a', i,
            CO(SS.lightDir[i]), i, &amp;ScreenChangeLightDirection,
            SS.lightIntensity[i], i, &amp;ScreenChangeLightIntensity);
    }

    Printf(false, "");
    Printf(false, "%Ft chord tolerance (in percents)%E");
    Printf(false, "%Ba   %@ %% %Fl%Ll%f%D[change]%E; %@ mm, %d triangles",
        SS.chordTol,
        &amp;ScreenChangeChordTolerance, 0, SS.chordTolCalculated,
        SK.GetGroup(SS.GW.activeGroup)-&gt;displayMesh.l.n);
    Printf(false, "%Ft max piecewise linear segments%E");
    Printf(false, "%Ba   %d %Fl%Ll%f[change]%E",
        SS.maxSegments,
        &amp;ScreenChangeMaxSegments);

    Printf(false, "");
    Printf(false, "%Ft export chord tolerance (in mm)%E");
    Printf(false, "%Ba   %@ %Fl%Ll%f%D[change]%E",
        SS.exportChordTol,
        &amp;ScreenChangeExportChordTolerance, 0);
    Printf(false, "%Ft export max piecewise linear segments%E");
    Printf(false, "%Ba   %d %Fl%Ll%f[change]%E",
        SS.exportMaxSegments,
        &amp;ScreenChangeExportMaxSegments);

    Printf(false, "");
    Printf(false, "%Ft perspective factor (0 for parallel)%E");
    Printf(false, "%Ba   %# %Fl%Ll%f%D[change]%E",
        SS.cameraTangent*1000,
        &amp;ScreenChangeCameraTangent, 0);
    Printf(false, "%Ft snap grid spacing%E");
    Printf(false, "%Ba   %s %Fl%Ll%f%D[change]%E",
        SS.MmToString(SS.gridSpacing).c_str(),
        &amp;ScreenChangeGridSpacing, 0);

    Printf(false, "");
    Printf(false, "%Ft digits after decimal point to show%E");
    Printf(false, "%Ba%Ft   distances: %Fd%d %Fl%Ll%f%D[change]%E (e.g. '%s')",
        SS.UnitDigitsAfterDecimal(),
        &amp;ScreenChangeDigitsAfterDecimal, 0,
        SS.MmToString(SS.StringToMm("1.23456789")).c_str());
    Printf(false, "%Bd%Ft   angles:    %Fd%d %Fl%Ll%f%D[change]%E (e.g. '%s')",
        SS.afterDecimalDegree,
        &amp;ScreenChangeDigitsAfterDecimalDegree, 0,
        SS.DegreeToString(1.23456789).c_str());
    Printf(false, "  %Fd%f%Ll%s  use SI prefixes for distances%E",
        &amp;ScreenChangeUseSIPrefixes,
        SS.useSIPrefixes ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, "");
    Printf(false, "%Ft export scale factor (1:1=mm, 1:25.4=inch)");
    Printf(false, "%Ba   1:%# %Fl%Ll%f%D[change]%E",
        (double)SS.exportScale,
        &amp;ScreenChangeExportScale, 0);
    Printf(false, "%Ft cutter radius offset (0=no offset) ");
    Printf(false, "%Ba   %s %Fl%Ll%f%D[change]%E",
        SS.MmToString(SS.exportOffset).c_str(),
        &amp;ScreenChangeExportOffset, 0);

    Printf(false, "");
    Printf(false, "  %Fd%f%Ll%s  export shaded 2d triangles%E",
        &amp;ScreenChangeShadedTriangles,
        SS.exportShadedTriangles ? CHECK_TRUE : CHECK_FALSE);
    if(fabs(SS.exportOffset) &gt; LENGTH_EPS) {
        Printf(false, "  %Fd%s  curves as piecewise linear%E "
                      "(since cutter radius is not zero)", CHECK_TRUE);
    } else {
        Printf(false, "  %Fd%f%Ll%s  export curves as piecewise linear%E",
            &amp;ScreenChangePwlCurves,
            SS.exportPwlCurves ? CHECK_TRUE : CHECK_FALSE);
    }
    Printf(false, "  %Fd%f%Ll%s  fix white exported lines%E",
        &amp;ScreenChangeFixExportColors,
        SS.fixExportColors ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, "");
    Printf(false, "%Ft export canvas size:  "
                  "%f%Fd%Lf%s fixed%E  "
                  "%f%Fd%Lt%s auto%E",
        &amp;ScreenChangeCanvasSizeAuto,
        !SS.exportCanvasSizeAuto ? RADIO_TRUE : RADIO_FALSE,
        &amp;ScreenChangeCanvasSizeAuto,
        SS.exportCanvasSizeAuto ? RADIO_TRUE : RADIO_FALSE);

    if(SS.exportCanvasSizeAuto) {
        Printf(false, "%Ft (by margins around exported geometry)");
        Printf(false, "%Ba%Ft   left:   %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportMargin.left).c_str(), &amp;ScreenChangeCanvasSize, 0);
        Printf(false, "%Bd%Ft   right:  %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportMargin.right).c_str(), &amp;ScreenChangeCanvasSize, 1);
        Printf(false, "%Ba%Ft   bottom: %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportMargin.bottom).c_str(), &amp;ScreenChangeCanvasSize, 2);
        Printf(false, "%Bd%Ft   top:    %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportMargin.top).c_str(), &amp;ScreenChangeCanvasSize, 3);
    } else {
        Printf(false, "%Ft (by absolute dimensions and offsets)");
        Printf(false, "%Ba%Ft   width:    %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportCanvas.width).c_str(), &amp;ScreenChangeCanvasSize, 10);
        Printf(false, "%Bd%Ft   height:   %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportCanvas.height).c_str(), &amp;ScreenChangeCanvasSize, 11);
        Printf(false, "%Ba%Ft   offset x: %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportCanvas.dx).c_str(), &amp;ScreenChangeCanvasSize, 12);
        Printf(false, "%Bd%Ft   offset y: %Fd%s %Fl%Ll%f%D[change]%E",
            SS.MmToString(SS.exportCanvas.dy).c_str(), &amp;ScreenChangeCanvasSize, 13);
    }

    Printf(false, "");
    Printf(false, "%Ft exported g code parameters");
    Printf(false, "%Ba%Ft   depth:     %Fd%s %Fl%Ld%f[change]%E",
        SS.MmToString(SS.gCode.depth).c_str(), &amp;ScreenChangeGCodeParameter);
    Printf(false, "%Bd%Ft   passes:    %Fd%d %Fl%Ls%f[change]%E",
        SS.gCode.passes, &amp;ScreenChangeGCodeParameter);
    Printf(false, "%Ba%Ft   feed:      %Fd%s %Fl%LF%f[change]%E",
        SS.MmToString(SS.gCode.feed).c_str(), &amp;ScreenChangeGCodeParameter);
    Printf(false, "%Bd%Ft   plunge fd: %Fd%s %Fl%LP%f[change]%E",
        SS.MmToString(SS.gCode.plungeFeed).c_str(), &amp;ScreenChangeGCodeParameter);

    Printf(false, "");
    Printf(false, "  %Fd%f%Ll%s  draw triangle back faces in red%E",
        &amp;ScreenChangeBackFaces,
        SS.drawBackFaces ? CHECK_TRUE : CHECK_FALSE);
    Printf(false, "  %Fd%f%Ll%s  check sketch for closed contour%E",
        &amp;ScreenChangeCheckClosedContour,
        SS.checkClosedContour ? CHECK_TRUE : CHECK_FALSE);
    Printf(false, "  %Fd%f%Ll%s  show areas of closed contours%E",
        &amp;ScreenChangeShowContourAreas,
        SS.showContourAreas ? CHECK_TRUE : CHECK_FALSE);
    Printf(false, "  %Fd%f%Ll%s  enable automatic line constraints%E",
        &amp;ScreenChangeAutomaticLineConstraints,
        SS.automaticLineConstraints ? CHECK_TRUE : CHECK_FALSE);
    Printf(false, "  %Fd%f%Ll%s  use turntable mouse navigation%E", &amp;ScreenChangeTurntableNav,
        SS.turntableNav ? CHECK_TRUE : CHECK_FALSE);
    Printf(false, "  %Fd%f%Ll%s  edit newly added dimensions%E",
        &amp;ScreenChangeImmediatelyEditDimension,
        SS.immediatelyEditDimension ? CHECK_TRUE : CHECK_FALSE);
    Printf(false, "");
    Printf(false, "%Ft autosave interval (in minutes)%E");
    Printf(false, "%Ba   %d %Fl%Ll%f[change]%E",
        SS.autosaveInterval, &amp;ScreenChangeAutosaveInterval);

    if(canvas) {
        const char *gl_vendor, *gl_renderer, *gl_version;
        canvas-&gt;GetIdent(&amp;gl_vendor, &amp;gl_renderer, &amp;gl_version);
        Printf(false, "");
        Printf(false, " %Ftgl vendor   %E%s", gl_vendor);
        Printf(false, " %Ft   renderer %E%s", gl_renderer);
        Printf(false, " %Ft   version  %E%s", gl_version);
    }
}

</t>
<t tx="leo.20191228122642.68">bool TextWindow::EditControlDoneForConfiguration(const std::string &amp;s) {
    switch(edit.meaning) {
        case Edit::LIGHT_INTENSITY:
            SS.lightIntensity[edit.i] = min(1.0, max(0.0, atof(s.c_str())));
            SS.GW.Invalidate();
            break;

        case Edit::LIGHT_DIRECTION: {
            double x, y, z;
            if(sscanf(s.c_str(), "%lf, %lf, %lf", &amp;x, &amp;y, &amp;z)==3) {
                SS.lightDir[edit.i] = Vector::From(x, y, z);
                SS.GW.Invalidate();
            } else {
                Error(_("Bad format: specify coordinates as x, y, z"));
            }
            break;
        }
        case Edit::COLOR: {
            Vector rgb;
            if(sscanf(s.c_str(), "%lf, %lf, %lf", &amp;rgb.x, &amp;rgb.y, &amp;rgb.z)==3) {
                rgb = rgb.ClampWithin(0, 1);
                SS.modelColor[edit.i] = RGBf(rgb.x, rgb.y, rgb.z);
            } else {
                Error(_("Bad format: specify color as r, g, b"));
            }
            break;
        }
        case Edit::CHORD_TOLERANCE: {
            if(edit.i == 0) {
                SS.chordTol = max(0.0, atof(s.c_str()));
                SS.GenerateAll(SolveSpaceUI::Generate::ALL);
            } else {
                SS.exportChordTol = max(0.0, atof(s.c_str()));
            }
            break;
        }
        case Edit::MAX_SEGMENTS: {
            if(edit.i == 0) {
                SS.maxSegments = min(1000, max(7, atoi(s.c_str())));
                SS.GenerateAll(SolveSpaceUI::Generate::ALL);
            } else {
                SS.exportMaxSegments = min(1000, max(7, atoi(s.c_str())));
            }
            break;
        }
        case Edit::CAMERA_TANGENT: {
            SS.cameraTangent = (min(2.0, max(0.0, atof(s.c_str()))))/1000.0;
            SS.GW.Invalidate();
            if(!SS.usePerspectiveProj) {
                Message(_("The perspective factor will have no effect until you "
                          "enable View -&gt; Use Perspective Projection."));
            }
            break;
        }
        case Edit::GRID_SPACING: {
            SS.gridSpacing = (float)min(1e4, max(1e-3, SS.StringToMm(s)));
            SS.GW.Invalidate();
            break;
        }
        case Edit::DIGITS_AFTER_DECIMAL: {
            int v = atoi(s.c_str());
            if(v &lt; 0 || v &gt; 8) {
                Error(_("Specify between 0 and %d digits after the decimal."), 8);
            } else {
                SS.SetUnitDigitsAfterDecimal(v);
                SS.GW.Invalidate();
            }
            break;
        }
        case Edit::DIGITS_AFTER_DECIMAL_DEGREE: {
            int v = atoi(s.c_str());
            if(v &lt; 0 || v &gt; 4) {
                Error(_("Specify between 0 and %d digits after the decimal."), 4);
            } else {
                SS.afterDecimalDegree = v;
                SS.GW.Invalidate();
            }
            break;
        }
        case Edit::EXPORT_SCALE: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) {
                double ev = e-&gt;Eval();
                if(fabs(ev) &lt; 0.001 || isnan(ev)) {
                    Error(_("Export scale must not be zero!"));
                } else {
                    SS.exportScale = (float)ev;
                }
            }
            break;
        }
        case Edit::EXPORT_OFFSET: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) {
                double ev = SS.ExprToMm(e);
                if(isnan(ev) || ev &lt; 0) {
                    Error(_("Cutter radius offset must not be negative!"));
                } else {
                    SS.exportOffset = (float)ev;
                }
            }
            break;
        }
        case Edit::CANVAS_SIZE: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(!e) {
                break;
            }
            float d = (float)SS.ExprToMm(e);
            switch(edit.i) {
                case  0: SS.exportMargin.left   = d;    break;
                case  1: SS.exportMargin.right  = d;    break;
                case  2: SS.exportMargin.bottom = d;    break;
                case  3: SS.exportMargin.top    = d;    break;

                case 10: SS.exportCanvas.width  = d;    break;
                case 11: SS.exportCanvas.height = d;    break;
                case 12: SS.exportCanvas.dx     = d;    break;
                case 13: SS.exportCanvas.dy     = d;    break;
            }
            break;
        }
        case Edit::G_CODE_DEPTH: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) SS.gCode.depth = (float)SS.ExprToMm(e);
            break;
        }
        case Edit::G_CODE_PASSES: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) SS.gCode.passes = (int)(e-&gt;Eval());
            SS.gCode.passes = max(1, min(1000, SS.gCode.passes));
            break;
        }
        case Edit::G_CODE_FEED: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) SS.gCode.feed = (float)SS.ExprToMm(e);
            break;
        }
        case Edit::G_CODE_PLUNGE_FEED: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) SS.gCode.plungeFeed = (float)SS.ExprToMm(e);
            break;
        }
        case Edit::AUTOSAVE_INTERVAL: {
            int interval = atoi(s.c_str());
            if(interval) {
                if(interval &gt;= 1) {
                    SS.autosaveInterval = interval;
                    SS.ScheduleAutosave();
                } else {
                    Error(_("Bad value: autosave interval should be positive"));
                }
            } else {
                Error(_("Bad format: specify interval in integral minutes"));
            }
            break;
        }

        default: return false;
    }
    return true;
}

</t>
<t tx="leo.20191228122642.69">@path ./src/
//-----------------------------------------------------------------------------
// Implementation of the Constraint menu, to create new constraints in
// the sketch.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

std::string Constraint::DescriptionString() const {
    std::string s;
    switch(type) {
        case Type::POINTS_COINCIDENT:   s = C_("constr-name", "pts-coincident"); break;
        case Type::PT_PT_DISTANCE:      s = C_("constr-name", "pt-pt-distance"); break;
        case Type::PT_LINE_DISTANCE:    s = C_("constr-name", "pt-line-distance"); break;
        case Type::PT_PLANE_DISTANCE:   s = C_("constr-name", "pt-plane-distance"); break;
        case Type::PT_FACE_DISTANCE:    s = C_("constr-name", "pt-face-distance"); break;
        case Type::PROJ_PT_DISTANCE:    s = C_("constr-name", "proj-pt-pt-distance"); break;
        case Type::PT_IN_PLANE:         s = C_("constr-name", "pt-in-plane"); break;
        case Type::PT_ON_LINE:          s = C_("constr-name", "pt-on-line"); break;
        case Type::PT_ON_FACE:          s = C_("constr-name", "pt-on-face"); break;
        case Type::EQUAL_LENGTH_LINES:  s = C_("constr-name", "eq-length"); break;
        case Type::EQ_LEN_PT_LINE_D:    s = C_("constr-name", "eq-length-and-pt-ln-dist"); break;
        case Type::EQ_PT_LN_DISTANCES:  s = C_("constr-name", "eq-pt-line-distances"); break;
        case Type::LENGTH_RATIO:        s = C_("constr-name", "length-ratio"); break;
        case Type::LENGTH_DIFFERENCE:   s = C_("constr-name", "length-difference"); break;
        case Type::SYMMETRIC:           s = C_("constr-name", "symmetric"); break;
        case Type::SYMMETRIC_HORIZ:     s = C_("constr-name", "symmetric-h"); break;
        case Type::SYMMETRIC_VERT:      s = C_("constr-name", "symmetric-v"); break;
        case Type::SYMMETRIC_LINE:      s = C_("constr-name", "symmetric-line"); break;
        case Type::AT_MIDPOINT:         s = C_("constr-name", "at-midpoint"); break;
        case Type::HORIZONTAL:          s = C_("constr-name", "horizontal"); break;
        case Type::VERTICAL:            s = C_("constr-name", "vertical"); break;
        case Type::DIAMETER:            s = C_("constr-name", "diameter"); break;
        case Type::PT_ON_CIRCLE:        s = C_("constr-name", "pt-on-circle"); break;
        case Type::SAME_ORIENTATION:    s = C_("constr-name", "same-orientation"); break;
        case Type::ANGLE:               s = C_("constr-name", "angle"); break;
        case Type::PARALLEL:            s = C_("constr-name", "parallel"); break;
        case Type::ARC_LINE_TANGENT:    s = C_("constr-name", "arc-line-tangent"); break;
        case Type::CUBIC_LINE_TANGENT:  s = C_("constr-name", "cubic-line-tangent"); break;
        case Type::CURVE_CURVE_TANGENT: s = C_("constr-name", "curve-curve-tangent"); break;
        case Type::PERPENDICULAR:       s = C_("constr-name", "perpendicular"); break;
        case Type::EQUAL_RADIUS:        s = C_("constr-name", "eq-radius"); break;
        case Type::EQUAL_ANGLE:         s = C_("constr-name", "eq-angle"); break;
        case Type::EQUAL_LINE_ARC_LEN:  s = C_("constr-name", "eq-line-len-arc-len"); break;
        case Type::WHERE_DRAGGED:       s = C_("constr-name", "lock-where-dragged"); break;
        case Type::COMMENT:             s = C_("constr-name", "comment"); break;
        default:                        s = "???"; break;
    }

    return ssprintf("c%03x-%s", h.v, s.c_str());
}

#ifndef LIBRARY

//-----------------------------------------------------------------------------
// Delete all constraints with the specified type, entityA, ptA. We use this
// when auto-removing constraints that would become redundant.
//-----------------------------------------------------------------------------
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122642.7">static BspUtil *Alloc() {
    return (BspUtil *)AllocTemporary(sizeof(BspUtil));
}

</t>
<t tx="leo.20191228122642.70">void Constraint::DeleteAllConstraintsFor(Constraint::Type type, hEntity entityA, hEntity ptA)
{
    SK.constraint.ClearTags();
    for(auto &amp;constraint : SK.constraint) {
        ConstraintBase *ct = &amp;constraint;
        if(ct-&gt;type != type) continue;

        if(ct-&gt;entityA != entityA) continue;
        if(ct-&gt;ptA != ptA) continue;
        ct-&gt;tag = 1;
    }
    SK.constraint.RemoveTagged();
    // And no need to do anything special, since nothing
    // ever depends on a constraint. But do clear the
    // hover, in case the just-deleted constraint was
    // hovered.
    SS.GW.hover.Clear();
}

hConstraint Constraint::AddConstraint(Constraint *c, bool rememberForUndo) {
    if(rememberForUndo) SS.UndoRemember();

    hConstraint hc = SK.constraint.AddAndAssignId(c);
    SK.GetConstraint(hc)-&gt;Generate(&amp;SK.param);

    SS.MarkGroupDirty(c-&gt;group);
    SK.GetGroup(c-&gt;group)-&gt;dofCheckOk = false;
    return c-&gt;h;
}

hConstraint Constraint::Constrain(Constraint::Type type, hEntity ptA, hEntity ptB,
                                  hEntity entityA, hEntity entityB,
</t>
<t tx="leo.20191228122642.71">                                  bool other, bool other2)
{
    Constraint c = {};
    c.group = SS.GW.activeGroup;
    c.workplane = SS.GW.ActiveWorkplane();
    c.type = type;
    c.ptA = ptA;
    c.ptB = ptB;
    c.entityA = entityA;
    c.entityB = entityB;
    c.other = other;
    c.other2 = other2;
    return AddConstraint(&amp;c, /*rememberForUndo=*/false);
}

hConstraint Constraint::TryConstrain(Constraint::Type type, hEntity ptA, hEntity ptB,
                                     hEntity entityA, hEntity entityB,
</t>
<t tx="leo.20191228122642.72">                                     bool other, bool other2) {
    int rankBefore, rankAfter;
    SolveResult howBefore = SS.TestRankForGroup(SS.GW.activeGroup, &amp;rankBefore);
    hConstraint hc = Constrain(type, ptA, ptB, entityA, entityB, other, other2);
    SolveResult howAfter = SS.TestRankForGroup(SS.GW.activeGroup, &amp;rankAfter);
    // There are two cases where the constraint is clearly redundant:
    //   * If the group wasn't overconstrained and now it is;
    //   * If the group was overconstrained, and adding the constraint doesn't change rank at all.
    if((howBefore == SolveResult::OKAY &amp;&amp; howAfter == SolveResult::REDUNDANT_OKAY) ||
       (howBefore == SolveResult::REDUNDANT_OKAY &amp;&amp; howAfter == SolveResult::REDUNDANT_OKAY &amp;&amp;
            rankBefore == rankAfter)) {
        SK.constraint.RemoveById(hc);
        hc = {};
    }
    return hc;
}

hConstraint Constraint::ConstrainCoincident(hEntity ptA, hEntity ptB) {
    return Constrain(Type::POINTS_COINCIDENT, ptA, ptB,
        Entity::NO_ENTITY, Entity::NO_ENTITY, /*other=*/false, /*other2=*/false);
}

</t>
<t tx="leo.20191228122642.73">void Constraint::MenuConstrain(Command id) {
    Constraint c = {};
    c.group = SS.GW.activeGroup;
    c.workplane = SS.GW.ActiveWorkplane();

    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;

    switch(id) {
        case Command::DISTANCE_DIA:
        case Command::REF_DISTANCE: {
            if(gs.points == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_PT_DISTANCE;
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.n == 1) {
                c.type = Type::PT_PT_DISTANCE;
                Entity *e = SK.GetEntity(gs.entity[0]);
                c.ptA = e-&gt;point[0];
                c.ptB = e-&gt;point[1];
            } else if(gs.vectors == 1 &amp;&amp; gs.points == 2 &amp;&amp; gs.n == 3) {
                c.type = Type::PROJ_PT_DISTANCE;
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
                c.entityA = gs.vector[0];
            } else if(gs.workplanes == 1 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_PLANE_DISTANCE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_LINE_DISTANCE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.faces == 1 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_FACE_DISTANCE;
                c.ptA = gs.point[0];
                c.entityA = gs.face[0];
            } else if(gs.circlesOrArcs == 1 &amp;&amp; gs.n == 1) {
                c.type = Type::DIAMETER;
                c.entityA = gs.entity[0];
            } else {
                Error(_("Bad selection for distance / diameter constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two points (distance between points)\n"
                        "    * a line segment (length)\n"
                        "    * two points and a line segment or normal (projected distance)\n"
                        "    * a workplane and a point (minimum distance)\n"
                        "    * a line segment and a point (minimum distance)\n"
                        "    * a plane face and a point (minimum distance)\n"
                        "    * a circle or an arc (diameter)\n"));
                return;
            }
            if(c.type == Type::PT_PT_DISTANCE || c.type == Type::PROJ_PT_DISTANCE) {
                Vector n = SS.GW.projRight.Cross(SS.GW.projUp);
                Vector a = SK.GetEntity(c.ptA)-&gt;PointGetNum();
                Vector b = SK.GetEntity(c.ptB)-&gt;PointGetNum();
                c.disp.offset = n.Cross(a.Minus(b));
                c.disp.offset = (c.disp.offset).WithMagnitude(50/SS.GW.scale);
            } else {
                c.disp.offset = Vector::From(0, 0, 0);
            }

            if(id == Command::REF_DISTANCE) {
                c.reference = true;
            }

            c.valA = 0;
            c.ModifyToSatisfy();
            AddConstraint(&amp;c);
            if (SS.immediatelyEditDimension) {
                SS.GW.EditConstraint(c.h);
            }
            break;
        }

        case Command::ON_ENTITY:
            if(gs.points == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::POINTS_COINCIDENT;
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
            } else if(gs.points == 1 &amp;&amp; gs.workplanes == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_IN_PLANE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.points == 1 &amp;&amp; gs.lineSegments == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_ON_LINE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.points == 1 &amp;&amp; gs.circlesOrArcs == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_ON_CIRCLE;
                c.ptA = gs.point[0];
                c.entityA = gs.entity[0];
            } else if(gs.points == 1 &amp;&amp; gs.faces == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::PT_ON_FACE;
                c.ptA = gs.point[0];
                c.entityA = gs.face[0];
            } else {
                Error(_("Bad selection for on point / curve / plane constraint. "
                        "This constraint can apply to:\n\n"
                        "    * two points (points coincident)\n"
                        "    * a point and a workplane (point in plane)\n"
                        "    * a point and a line segment (point on line)\n"
                        "    * a point and a circle or arc (point on curve)\n"
                        "    * a point and a plane face (point on face)\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::EQUAL:
            if(gs.lineSegments == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::EQUAL_LENGTH_LINES;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
            } else if(gs.lineSegments == 2 &amp;&amp; gs.points == 2 &amp;&amp; gs.n == 4) {
                c.type = Type::EQ_PT_LN_DISTANCES;
                c.entityA = gs.entity[0];
                c.ptA = gs.point[0];
                c.entityB = gs.entity[1];
                c.ptB = gs.point[1];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.points == 2 &amp;&amp; gs.n == 3) {
                // The same line segment for the distances, but different
                // points.
                c.type = Type::EQ_PT_LN_DISTANCES;
                c.entityA = gs.entity[0];
                c.ptA = gs.point[0];
                c.entityB = gs.entity[0];
                c.ptB = gs.point[1];
            } else if(gs.lineSegments == 2 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 3) {
                c.type = Type::EQ_LEN_PT_LINE_D;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
                c.ptA = gs.point[0];
            } else if(gs.vectors == 4 &amp;&amp; gs.n == 4) {
                c.type = Type::EQUAL_ANGLE;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
                c.entityC = gs.vector[2];
                c.entityD = gs.vector[3];
            } else if(gs.vectors == 3 &amp;&amp; gs.n == 3) {
                c.type = Type::EQUAL_ANGLE;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
                c.entityC = gs.vector[1];
                c.entityD = gs.vector[2];
            } else if(gs.circlesOrArcs == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::EQUAL_RADIUS;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
            } else if(gs.arcs == 1 &amp;&amp; gs.lineSegments == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::EQUAL_LINE_ARC_LEN;
                if(SK.GetEntity(gs.entity[0])-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
                    c.entityA = gs.entity[1];
                    c.entityB = gs.entity[0];
                } else {
                    c.entityA = gs.entity[0];
                    c.entityB = gs.entity[1];
                }
            } else {
                Error(_("Bad selection for equal length / radius constraint. "
                        "This constraint can apply to:\n\n"
                        "    * two line segments (equal length)\n"
                        "    * two line segments and two points "
                                "(equal point-line distances)\n"
                        "    * a line segment and two points "
                                "(equal point-line distances)\n"
                        "    * a line segment, and a point and line segment "
                                "(point-line distance equals length)\n"
                        "    * four line segments or normals "
                                "(equal angle between A,B and C,D)\n"
                        "    * three line segments or normals "
                                "(equal angle between A,B and B,C)\n"
                        "    * two circles or arcs (equal radius)\n"
                        "    * a line segment and an arc "
                                "(line segment length equals arc length)\n"));
                return;
            }
            if(c.type == Type::EQUAL_ANGLE) {
                // Infer the nearest supplementary angle from the sketch.
                Vector a1 = SK.GetEntity(c.entityA)-&gt;VectorGetNum(),
                       b1 = SK.GetEntity(c.entityB)-&gt;VectorGetNum(),
                       a2 = SK.GetEntity(c.entityC)-&gt;VectorGetNum(),
                       b2 = SK.GetEntity(c.entityD)-&gt;VectorGetNum();
                double d1 = a1.Dot(b1), d2 = a2.Dot(b2);

                if(d1*d2 &lt; 0) {
                    c.other = true;
                }
            }
            AddConstraint(&amp;c);
            break;

        case Command::RATIO:
            if(gs.lineSegments == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::LENGTH_RATIO;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
            } else {
                Error(_("Bad selection for length ratio constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two line segments\n"));
                return;
            }

            c.valA = 0;
            c.ModifyToSatisfy();
            AddConstraint(&amp;c);
            break;

        case Command::DIFFERENCE:
            if(gs.lineSegments == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::LENGTH_DIFFERENCE;
                c.entityA = gs.entity[0];
                c.entityB = gs.entity[1];
            } else {
                Error(_("Bad selection for length difference constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two line segments\n"));
                return;
            }

            c.valA = 0;
            c.ModifyToSatisfy();
            AddConstraint(&amp;c);
            break;

        case Command::AT_MIDPOINT:
            if(gs.lineSegments == 1 &amp;&amp; gs.points == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::AT_MIDPOINT;
                c.entityA = gs.entity[0];
                c.ptA = gs.point[0];

                // If a point is at-midpoint, then no reason to also constrain
                // it on-line; so auto-remove that.
                DeleteAllConstraintsFor(Type::PT_ON_LINE, c.entityA, c.ptA);
            } else if(gs.lineSegments == 1 &amp;&amp; gs.workplanes == 1 &amp;&amp; gs.n == 2) {
                c.type = Type::AT_MIDPOINT;
                int i = SK.GetEntity(gs.entity[0])-&gt;IsWorkplane() ? 1 : 0;
                c.entityA = gs.entity[i];
                c.entityB = gs.entity[1-i];
            } else {
                Error(_("Bad selection for at midpoint constraint. This "
                        "constraint can apply to:\n\n"
                        "    * a line segment and a point "
                              "(point at midpoint)\n"
                        "    * a line segment and a workplane "
                              "(line's midpoint on plane)\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::SYMMETRIC:
            if(gs.points == 2 &amp;&amp;
                                ((gs.workplanes == 1 &amp;&amp; gs.n == 3) ||
                                 (gs.n == 2)))
            {
                if(gs.entities &gt; 0)
                    c.entityA = gs.entity[0];
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
                c.type = Type::SYMMETRIC;
            } else if(gs.lineSegments == 1 &amp;&amp;
                                ((gs.workplanes == 1 &amp;&amp; gs.n == 2) ||
                                 (gs.n == 1)))
            {
                Entity *line;
                if(SK.GetEntity(gs.entity[0])-&gt;IsWorkplane()) {
                    line = SK.GetEntity(gs.entity[1]);
                    c.entityA = gs.entity[0];
                } else {
                    line = SK.GetEntity(gs.entity[0]);
                }
                c.ptA = line-&gt;point[0];
                c.ptB = line-&gt;point[1];
                c.type = Type::SYMMETRIC;
            } else if(SS.GW.LockedInWorkplane()
                        &amp;&amp; gs.lineSegments == 2 &amp;&amp; gs.n == 2)
            {
                Entity *l0 = SK.GetEntity(gs.entity[0]),
                       *l1 = SK.GetEntity(gs.entity[1]);

                if((l1-&gt;group != SS.GW.activeGroup) ||
                   (l1-&gt;construction &amp;&amp; !(l0-&gt;construction)))
                {
                    swap(l0, l1);
                }
                c.ptA = l1-&gt;point[0];
                c.ptB = l1-&gt;point[1];
                c.entityA = l0-&gt;h;
                c.type = Type::SYMMETRIC_LINE;
            } else if(SS.GW.LockedInWorkplane()
                        &amp;&amp; gs.lineSegments == 1 &amp;&amp; gs.points == 2 &amp;&amp; gs.n == 3)
            {
                c.ptA = gs.point[0];
                c.ptB = gs.point[1];
                c.entityA = gs.entity[0];
                c.type = Type::SYMMETRIC_LINE;
            } else {
                Error(_("Bad selection for symmetric constraint. This constraint "
                        "can apply to:\n\n"
                        "    * two points or a line segment "
                            "(symmetric about workplane's coordinate axis)\n"
                        "    * line segment, and two points or a line segment "
                            "(symmetric about line segment)\n"
                        "    * workplane, and two points or a line segment "
                            "(symmetric about workplane)\n"));
                return;
            }
            if(c.entityA == Entity::NO_ENTITY) {
                // Horizontal / vertical symmetry, implicit symmetry plane
                // normal to the workplane
                if(c.workplane == Entity::FREE_IN_3D) {
                    Error(_("A workplane must be active when constraining "
                            "symmetric without an explicit symmetry plane."));
                    return;
                }
                Vector pa = SK.GetEntity(c.ptA)-&gt;PointGetNum();
                Vector pb = SK.GetEntity(c.ptB)-&gt;PointGetNum();
                Vector dp = pa.Minus(pb);
                EntityBase *norm = SK.GetEntity(c.workplane)-&gt;Normal();;
                Vector u = norm-&gt;NormalU(), v = norm-&gt;NormalV();
                if(fabs(dp.Dot(u)) &gt; fabs(dp.Dot(v))) {
                    c.type = Type::SYMMETRIC_HORIZ;
                } else {
                    c.type = Type::SYMMETRIC_VERT;
                }
                if(gs.lineSegments == 1) {
                    // If this line segment is already constrained horiz or
                    // vert, then auto-remove that redundant constraint.
                    DeleteAllConstraintsFor(Type::HORIZONTAL, (gs.entity[0]),
                        Entity::NO_ENTITY);
                    DeleteAllConstraintsFor(Type::VERTICAL, (gs.entity[0]),
                        Entity::NO_ENTITY);
                }
            }
            AddConstraint(&amp;c);
            break;

        case Command::VERTICAL:
        case Command::HORIZONTAL: {
            hEntity ha, hb;
            if(c.workplane == Entity::FREE_IN_3D) {
                Error(_("Activate a workplane (with Sketch -&gt; In Workplane) before "
                        "applying a horizontal or vertical constraint."));
                return;
            }
            if(gs.lineSegments == 1 &amp;&amp; gs.n == 1) {
                c.entityA = gs.entity[0];
                Entity *e = SK.GetEntity(c.entityA);
                ha = e-&gt;point[0];
                hb = e-&gt;point[1];
            } else if(gs.points == 2 &amp;&amp; gs.n == 2) {
                ha = c.ptA = gs.point[0];
                hb = c.ptB = gs.point[1];
            } else {
                Error(_("Bad selection for horizontal / vertical constraint. "
                        "This constraint can apply to:\n\n"
                        "    * two points\n"
                        "    * a line segment\n"));
                return;
            }
            if(id == Command::HORIZONTAL) {
                c.type = Type::HORIZONTAL;
            } else {
                c.type = Type::VERTICAL;
            }
            AddConstraint(&amp;c);
            break;
        }

        case Command::ORIENTED_SAME: {
            if(gs.anyNormals == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::SAME_ORIENTATION;
                c.entityA = gs.anyNormal[0];
                c.entityB = gs.anyNormal[1];
            } else {
                Error(_("Bad selection for same orientation constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two normals\n"));
                return;
            }
            SS.UndoRemember();

            Entity *nfree = SK.GetEntity(c.entityA);
            Entity *nref  = SK.GetEntity(c.entityB);
            if(nref-&gt;group == SS.GW.activeGroup) {
                swap(nref, nfree);
            }
            if(nfree-&gt;group == SS.GW.activeGroup &amp;&amp; nref-&gt;group != SS.GW.activeGroup) {
                // nfree is free, and nref is locked (since it came from a
                // previous group); so let's force nfree aligned to nref,
                // and make convergence easy
                Vector ru = nref -&gt;NormalU(), rv = nref -&gt;NormalV();
                Vector fu = nfree-&gt;NormalU(), fv = nfree-&gt;NormalV();

                if(fabs(fu.Dot(ru)) &lt; fabs(fu.Dot(rv))) {
                    // There might be an odd*90 degree rotation about the
                    // normal vector; allow that, since the numerical
                    // constraint does
                    swap(ru, rv);
                }
                fu = fu.Dot(ru) &gt; 0 ? ru : ru.ScaledBy(-1);
                fv = fv.Dot(rv) &gt; 0 ? rv : rv.ScaledBy(-1);

                nfree-&gt;NormalForceTo(Quaternion::From(fu, fv));
            }
            AddConstraint(&amp;c, /*rememberForUndo=*/false);
            break;
        }

        case Command::OTHER_ANGLE:
            if(gs.constraints == 1 &amp;&amp; gs.n == 0) {
                Constraint *c = SK.GetConstraint(gs.constraint[0]);
                if(c-&gt;type == Type::ANGLE) {
                    SS.UndoRemember();
                    c-&gt;other = !(c-&gt;other);
                    c-&gt;ModifyToSatisfy();
                    break;
                }
                if(c-&gt;type == Type::EQUAL_ANGLE) {
                    SS.UndoRemember();
                    c-&gt;other = !(c-&gt;other);
                    SS.MarkGroupDirty(c-&gt;group);
                    break;
                }
            }
            Error(_("Must select an angle constraint."));
            return;

        case Command::REFERENCE:
            if(gs.constraints == 1 &amp;&amp; gs.n == 0) {
                Constraint *c = SK.GetConstraint(gs.constraint[0]);
                if(c-&gt;HasLabel() &amp;&amp; c-&gt;type != Type::COMMENT) {
                    (c-&gt;reference) = !(c-&gt;reference);
                    SS.MarkGroupDirty(c-&gt;group, /*onlyThis=*/true);
                    break;
                }
            }
            Error(_("Must select a constraint with associated label."));
            return;

        case Command::ANGLE:
        case Command::REF_ANGLE: {
            if(gs.vectors == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::ANGLE;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
                c.valA = 0;
            } else {
                Error(_("Bad selection for angle constraint. This constraint "
                        "can apply to:\n\n"
                        "    * two line segments\n"
                        "    * a line segment and a normal\n"
                        "    * two normals\n"));
                return;
            }

            Entity *ea = SK.GetEntity(c.entityA),
                   *eb = SK.GetEntity(c.entityB);
            if(ea-&gt;type == Entity::Type::LINE_SEGMENT &amp;&amp;
               eb-&gt;type == Entity::Type::LINE_SEGMENT)
            {
                Vector a0 = SK.GetEntity(ea-&gt;point[0])-&gt;PointGetNum(),
                       a1 = SK.GetEntity(ea-&gt;point[1])-&gt;PointGetNum(),
                       b0 = SK.GetEntity(eb-&gt;point[0])-&gt;PointGetNum(),
                       b1 = SK.GetEntity(eb-&gt;point[1])-&gt;PointGetNum();
                if(a0.Equals(b0) || a1.Equals(b1)) {
                    // okay, vectors should be drawn in same sense
                } else if(a0.Equals(b1) || a1.Equals(b0)) {
                    // vectors are in opposite sense
                    c.other = true;
                } else {
                    // no shared point; not clear which intersection to draw
                }
            }

            if(id == Command::REF_ANGLE) {
                c.reference = true;
            }

            c.ModifyToSatisfy();
            AddConstraint(&amp;c);
            if (SS.immediatelyEditDimension) {
                SS.GW.EditConstraint(c.h);
            }
            break;
        }

        case Command::PARALLEL:
            if(gs.vectors == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::PARALLEL;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.arcs == 1 &amp;&amp; gs.n == 2) {
                Entity *line = SK.GetEntity(gs.entity[0]);
                Entity *arc  = SK.GetEntity(gs.entity[1]);
                if(line-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
                    swap(line, arc);
                }
                Vector l0 = SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum(),
                       l1 = SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum();
                Vector a1 = SK.GetEntity(arc-&gt;point[1])-&gt;PointGetNum(),
                       a2 = SK.GetEntity(arc-&gt;point[2])-&gt;PointGetNum();

                if(l0.Equals(a1) || l1.Equals(a1)) {
                    c.other = false;
                } else if(l0.Equals(a2) || l1.Equals(a2)) {
                    c.other = true;
                } else {
                    Error(_("The tangent arc and line segment must share an "
                            "endpoint. Constrain them with Constrain -&gt; "
                            "On Point before constraining tangent."));
                    return;
                }
                c.type = Type::ARC_LINE_TANGENT;
                c.entityA = arc-&gt;h;
                c.entityB = line-&gt;h;
            } else if(gs.lineSegments == 1 &amp;&amp; gs.cubics == 1 &amp;&amp; gs.n == 2) {
                Entity *line  = SK.GetEntity(gs.entity[0]);
                Entity *cubic = SK.GetEntity(gs.entity[1]);
                if(line-&gt;type == Entity::Type::CUBIC) {
                    swap(line, cubic);
                }
                Vector l0 = SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum(),
                       l1 = SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum();
                Vector as = cubic-&gt;CubicGetStartNum(),
                       af = cubic-&gt;CubicGetFinishNum();

                if(l0.Equals(as) || l1.Equals(as)) {
                    c.other = false;
                } else if(l0.Equals(af) || l1.Equals(af)) {
                    c.other = true;
                } else {
                    Error(_("The tangent cubic and line segment must share an "
                            "endpoint. Constrain them with Constrain -&gt; "
                            "On Point before constraining tangent."));
                    return;
                }
                c.type = Type::CUBIC_LINE_TANGENT;
                c.entityA = cubic-&gt;h;
                c.entityB = line-&gt;h;
            } else if(gs.cubics + gs.arcs == 2 &amp;&amp; gs.n == 2) {
                if(!SS.GW.LockedInWorkplane()) {
                    Error(_("Curve-curve tangency must apply in workplane."));
                    return;
                }
                Entity *eA = SK.GetEntity(gs.entity[0]),
                       *eB = SK.GetEntity(gs.entity[1]);
                Vector as = eA-&gt;EndpointStart(),
                       af = eA-&gt;EndpointFinish(),
                       bs = eB-&gt;EndpointStart(),
                       bf = eB-&gt;EndpointFinish();
                if(as.Equals(bs)) {
                    c.other = false; c.other2 = false;
                } else if(as.Equals(bf)) {
                    c.other = false; c.other2 = true;
                } else if(af.Equals(bs)) {
                    c.other = true; c.other2 = false;
                } else if(af.Equals(bf)) {
                    c.other = true; c.other2 = true;
                } else {
                    Error(_("The curves must share an endpoint. Constrain them "
                            "with Constrain -&gt; On Point before constraining "
                            "tangent."));
                    return;
                }
                c.type = Type::CURVE_CURVE_TANGENT;
                c.entityA = eA-&gt;h;
                c.entityB = eB-&gt;h;
            } else {
                Error(_("Bad selection for parallel / tangent constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two line segments (parallel)\n"
                        "    * a line segment and a normal (parallel)\n"
                        "    * two normals (parallel)\n"
                        "    * two line segments, arcs, or beziers, that share "
                              "an endpoint (tangent)\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::PERPENDICULAR:
            if(gs.vectors == 2 &amp;&amp; gs.n == 2) {
                c.type = Type::PERPENDICULAR;
                c.entityA = gs.vector[0];
                c.entityB = gs.vector[1];
            } else {
                Error(_("Bad selection for perpendicular constraint. This "
                        "constraint can apply to:\n\n"
                        "    * two line segments\n"
                        "    * a line segment and a normal\n"
                        "    * two normals\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::WHERE_DRAGGED:
            if(gs.points == 1 &amp;&amp; gs.n == 1) {
                c.type = Type::WHERE_DRAGGED;
                c.ptA = gs.point[0];
            } else {
                Error(_("Bad selection for lock point where dragged constraint. "
                        "This constraint can apply to:\n\n"
                        "    * a point\n"));
                return;
            }
            AddConstraint(&amp;c);
            break;

        case Command::COMMENT:
            SS.GW.pending.operation = GraphicsWindow::Pending::COMMAND;
            SS.GW.pending.command = Command::COMMENT;
            SS.GW.pending.description = _("click center of comment text");
            SS.ScheduleShowTW();
            break;

        default: ssassert(false, "Unexpected menu ID");
    }

    for(const Constraint &amp;cc : SK.constraint) {
        if(c.h != cc.h &amp;&amp; c.Equals(cc)) {
            // Oops, we already have this exact constraint. Remove the one we just added.
            SK.constraint.RemoveById(c.h);
            SS.GW.ClearSelection();
            // And now select the old one, to give feedback.
            SS.GW.MakeSelected(cc.h);
            return;
        }
    }

    if(SK.constraint.FindByIdNoOops(c.h)) {
        Constraint *constraint = SK.GetConstraint(c.h);
        if(SS.TestRankForGroup(c.group) == SolveResult::REDUNDANT_OKAY &amp;&amp;
                !SK.GetGroup(SS.GW.activeGroup)-&gt;allowRedundant &amp;&amp;
                @others
}

#endif /* ! LIBRARY */
</t>
<t tx="leo.20191228122642.74">            constraint-&gt;HasLabel()) {
        constraint-&gt;reference = true;
    }
}

SS.GW.ClearSelection();
</t>
<t tx="leo.20191228122642.75">@path ./src/
//-----------------------------------------------------------------------------
// Given a constraint, generate one or more equations in our symbolic algebra
// system to represent that constraint; also various geometric helper
// functions for that.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

const hConstraint ConstraintBase::NO_CONSTRAINT = { 0 };

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122642.76">bool ConstraintBase::HasLabel() const {
    switch(type) {
        case Type::PT_LINE_DISTANCE:
        case Type::PT_PLANE_DISTANCE:
        case Type::PT_FACE_DISTANCE:
        case Type::PT_PT_DISTANCE:
        case Type::PROJ_PT_DISTANCE:
        case Type::DIAMETER:
        case Type::LENGTH_RATIO:
        case Type::LENGTH_DIFFERENCE:
        case Type::ANGLE:
        case Type::COMMENT:
            return true;

        default:
            return false;
    }
}

ExprVector ConstraintBase::VectorsParallel3d(ExprVector a, ExprVector b, hParam p) {
    return a.Minus(b.ScaledBy(Expr::From(p)));
}

Expr *ConstraintBase::PointLineDistance(hEntity wrkpl, hEntity hpt, hEntity hln)
{
    EntityBase *ln = SK.GetEntity(hln);
    EntityBase *a = SK.GetEntity(ln-&gt;point[0]);
    EntityBase *b = SK.GetEntity(ln-&gt;point[1]);

    EntityBase *p = SK.GetEntity(hpt);

    if(wrkpl == EntityBase::FREE_IN_3D) {
        ExprVector ep = p-&gt;PointGetExprs();

        ExprVector ea = a-&gt;PointGetExprs();
        ExprVector eb = b-&gt;PointGetExprs();
        ExprVector eab = ea.Minus(eb);
        Expr *m = eab.Magnitude();

        return ((eab.Cross(ea.Minus(ep))).Magnitude())-&gt;Div(m);
    } else {
        Expr *ua, *va, *ub, *vb;
        a-&gt;PointGetExprsInWorkplane(wrkpl, &amp;ua, &amp;va);
        b-&gt;PointGetExprsInWorkplane(wrkpl, &amp;ub, &amp;vb);

        Expr *du = ua-&gt;Minus(ub);
        Expr *dv = va-&gt;Minus(vb);

        Expr *u, *v;
        p-&gt;PointGetExprsInWorkplane(wrkpl, &amp;u, &amp;v);

        Expr *m = ((du-&gt;Square())-&gt;Plus(dv-&gt;Square()))-&gt;Sqrt();

        Expr *proj = (dv-&gt;Times(ua-&gt;Minus(u)))-&gt;Minus(
                     (du-&gt;Times(va-&gt;Minus(v))));

        return proj-&gt;Div(m);
    }
}

Expr *ConstraintBase::PointPlaneDistance(ExprVector p, hEntity hpl) {
    ExprVector n;
    Expr *d;
    SK.GetEntity(hpl)-&gt;WorkplaneGetPlaneExprs(&amp;n, &amp;d);
    return (p.Dot(n))-&gt;Minus(d);
}

Expr *ConstraintBase::Distance(hEntity wrkpl, hEntity hpa, hEntity hpb) {
    EntityBase *pa = SK.GetEntity(hpa);
    EntityBase *pb = SK.GetEntity(hpb);
    ssassert(pa-&gt;IsPoint() &amp;&amp; pb-&gt;IsPoint(),
             "Expected two points to measure projected distance between");

    if(wrkpl == EntityBase::FREE_IN_3D) {
        // This is true distance
        ExprVector ea, eb, eab;
        ea = pa-&gt;PointGetExprs();
        eb = pb-&gt;PointGetExprs();
        eab = ea.Minus(eb);

        return eab.Magnitude();
    } else {
        // This is projected distance, in the given workplane.
        Expr *au, *av, *bu, *bv;

        pa-&gt;PointGetExprsInWorkplane(wrkpl, &amp;au, &amp;av);
        pb-&gt;PointGetExprsInWorkplane(wrkpl, &amp;bu, &amp;bv);

        Expr *du = au-&gt;Minus(bu);
        Expr *dv = av-&gt;Minus(bv);

        return ((du-&gt;Square())-&gt;Plus(dv-&gt;Square()))-&gt;Sqrt();
    }
}

//-----------------------------------------------------------------------------
// Return the cosine of the angle between two vectors. If a workplane is
// specified, then it's the cosine of their projections into that workplane.
//-----------------------------------------------------------------------------
Expr *ConstraintBase::DirectionCosine(hEntity wrkpl,
                                      ExprVector ae, ExprVector be)
{
    if(wrkpl == EntityBase::FREE_IN_3D) {
        Expr *mags = (ae.Magnitude())-&gt;Times(be.Magnitude());
        return (ae.Dot(be))-&gt;Div(mags);
    } else {
        EntityBase *w = SK.GetEntity(wrkpl);
        ExprVector u = w-&gt;Normal()-&gt;NormalExprsU();
        ExprVector v = w-&gt;Normal()-&gt;NormalExprsV();
        Expr *ua = u.Dot(ae);
        Expr *va = v.Dot(ae);
        Expr *ub = u.Dot(be);
        Expr *vb = v.Dot(be);
        Expr *maga = (ua-&gt;Square()-&gt;Plus(va-&gt;Square()))-&gt;Sqrt();
        Expr *magb = (ub-&gt;Square()-&gt;Plus(vb-&gt;Square()))-&gt;Sqrt();
        Expr *dot = (ua-&gt;Times(ub))-&gt;Plus(va-&gt;Times(vb));
        return dot-&gt;Div(maga-&gt;Times(magb));
    }
}

ExprVector ConstraintBase::PointInThreeSpace(hEntity workplane,
                                             Expr *u, Expr *v)
{
    EntityBase *w = SK.GetEntity(workplane);

    ExprVector ub = w-&gt;Normal()-&gt;NormalExprsU();
    ExprVector vb = w-&gt;Normal()-&gt;NormalExprsV();
    ExprVector ob = w-&gt;WorkplaneGetOffsetExprs();

    return (ub.ScaledBy(u)).Plus(vb.ScaledBy(v)).Plus(ob);
}

</t>
<t tx="leo.20191228122642.77">void ConstraintBase::ModifyToSatisfy() {
    if(type == Type::ANGLE) {
        Vector a = SK.GetEntity(entityA)-&gt;VectorGetNum();
        Vector b = SK.GetEntity(entityB)-&gt;VectorGetNum();
        if(other) a = a.ScaledBy(-1);
        if(workplane != EntityBase::FREE_IN_3D) {
            a = a.ProjectVectorInto(workplane);
            b = b.ProjectVectorInto(workplane);
        }
        double c = (a.Dot(b))/(a.Magnitude() * b.Magnitude());
        valA = acos(c)*180/PI;
    } else if(type == Type::PT_ON_LINE) {
        EntityBase *eln = SK.GetEntity(entityA);
        EntityBase *ea = SK.GetEntity(eln-&gt;point[0]);
        EntityBase *eb = SK.GetEntity(eln-&gt;point[1]);
        EntityBase *ep = SK.GetEntity(ptA);
        ExprVector exp = ep-&gt;PointGetExprsInWorkplane(workplane);
        ExprVector exa = ea-&gt;PointGetExprsInWorkplane(workplane);
        ExprVector exb = eb-&gt;PointGetExprsInWorkplane(workplane);
        ExprVector exba = exb.Minus(exa);
        SK.GetParam(valP)-&gt;val = exba.Dot(exp.Minus(exa))-&gt;Eval() / exba.Dot(exba)-&gt;Eval();
    } else {
        // We'll fix these ones up by looking at their symbolic equation;
        // that means no extra work.
        IdList&lt;Equation,hEquation&gt; l = {};
        // Generate the equations even if this is a reference dimension
        GenerateEquations(&amp;l, /*forReference=*/true);
        ssassert(l.n == 1, "Expected constraint to generate a single equation");

        // These equations are written in the form f(...) - d = 0, where
        // d is the value of the valA.
        valA += (l[0].e)-&gt;Eval();

        l.Clear();
    }
}

</t>
<t tx="leo.20191228122642.78">void ConstraintBase::AddEq(IdList&lt;Equation,hEquation&gt; *l, Expr *expr, int index) const
{
    Equation eq;
    eq.e = expr;
    eq.h = h.equation(index);
    l-&gt;Add(&amp;eq);
}

</t>
<t tx="leo.20191228122642.79">void ConstraintBase::AddEq(IdList&lt;Equation,hEquation&gt; *l, const ExprVector &amp;v,
                           int baseIndex) const {
    AddEq(l, v.x, baseIndex);
    AddEq(l, v.y, baseIndex + 1);
    if(workplane == EntityBase::FREE_IN_3D) {
        AddEq(l, v.z, baseIndex + 2);
    }
}

</t>
<t tx="leo.20191228122642.8">void AllocOn() {
    on = (Vector *)AllocTemporary(sizeof(Vector) * 2);
}

</t>
<t tx="leo.20191228122642.80">void ConstraintBase::Generate(IdList&lt;Param,hParam&gt; *l) {
    switch(type) {
        case Type::PARALLEL:
        case Type::CUBIC_LINE_TANGENT:
            // Add new parameter only when we operate in 3d space
            if(workplane != EntityBase::FREE_IN_3D) break;
            // fallthrough
        case Type::SAME_ORIENTATION:
        case Type::PT_ON_LINE: {
            Param p = {};
            valP = h.param(0);
            p.h = valP;
            l-&gt;Add(&amp;p);
            break;
        }

        default:
            break;
    }
}

</t>
<t tx="leo.20191228122642.81">void ConstraintBase::GenerateEquations(IdList&lt;Equation,hEquation&gt; *l,
                                       bool forReference) const {
    if(reference &amp;&amp; !forReference) return;

    Expr *exA = Expr::From(valA);
    switch(type) {
        case Type::PT_PT_DISTANCE:
            AddEq(l, Distance(workplane, ptA, ptB)-&gt;Minus(exA), 0);
            return;

        case Type::PROJ_PT_DISTANCE: {
            ExprVector pA = SK.GetEntity(ptA)-&gt;PointGetExprs(),
                       pB = SK.GetEntity(ptB)-&gt;PointGetExprs(),
                       dp = pB.Minus(pA);

            ExprVector pp = SK.GetEntity(entityA)-&gt;VectorGetExprs();
            pp = pp.WithMagnitude(Expr::From(1.0));

            AddEq(l, (dp.Dot(pp))-&gt;Minus(exA), 0);
            return;
        }

        case Type::PT_LINE_DISTANCE:
            AddEq(l,
                PointLineDistance(workplane, ptA, entityA)-&gt;Minus(exA), 0);
            return;

        case Type::PT_PLANE_DISTANCE: {
            ExprVector pt = SK.GetEntity(ptA)-&gt;PointGetExprs();
            AddEq(l, (PointPlaneDistance(pt, entityA))-&gt;Minus(exA), 0);
            return;
        }

        case Type::PT_FACE_DISTANCE: {
            ExprVector pt = SK.GetEntity(ptA)-&gt;PointGetExprs();
            EntityBase *f = SK.GetEntity(entityA);
            ExprVector p0 = f-&gt;FaceGetPointExprs();
            ExprVector n = f-&gt;FaceGetNormalExprs();
            AddEq(l, (pt.Minus(p0)).Dot(n)-&gt;Minus(exA), 0);
            return;
        }

        case Type::EQUAL_LENGTH_LINES: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            AddEq(l, Distance(workplane, a-&gt;point[0], a-&gt;point[1])-&gt;Minus(
                     Distance(workplane, b-&gt;point[0], b-&gt;point[1])), 0);
            return;
        }

        // These work on distance squared, since the pt-line distances are
        // signed, and we want the absolute value.
        case Type::EQ_LEN_PT_LINE_D: {
            EntityBase *forLen = SK.GetEntity(entityA);
            Expr *d1 = Distance(workplane, forLen-&gt;point[0], forLen-&gt;point[1]);
            Expr *d2 = PointLineDistance(workplane, ptA, entityB);
            AddEq(l, (d1-&gt;Square())-&gt;Minus(d2-&gt;Square()), 0);
            return;
        }
        case Type::EQ_PT_LN_DISTANCES: {
            Expr *d1 = PointLineDistance(workplane, ptA, entityA);
            Expr *d2 = PointLineDistance(workplane, ptB, entityB);
            AddEq(l, (d1-&gt;Square())-&gt;Minus(d2-&gt;Square()), 0);
            return;
        }

        case Type::LENGTH_RATIO: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            Expr *la = Distance(workplane, a-&gt;point[0], a-&gt;point[1]);
            Expr *lb = Distance(workplane, b-&gt;point[0], b-&gt;point[1]);
            AddEq(l, (la-&gt;Div(lb))-&gt;Minus(exA), 0);
            return;
        }

        case Type::LENGTH_DIFFERENCE: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            Expr *la = Distance(workplane, a-&gt;point[0], a-&gt;point[1]);
            Expr *lb = Distance(workplane, b-&gt;point[0], b-&gt;point[1]);
            AddEq(l, (la-&gt;Minus(lb))-&gt;Minus(exA), 0);
            return;
        }

        case Type::DIAMETER: {
            EntityBase *circle = SK.GetEntity(entityA);
            Expr *r = circle-&gt;CircleGetRadiusExpr();
            AddEq(l, (r-&gt;Times(Expr::From(2)))-&gt;Minus(exA), 0);
            return;
        }

        case Type::EQUAL_RADIUS: {
            EntityBase *c1 = SK.GetEntity(entityA);
            EntityBase *c2 = SK.GetEntity(entityB);
            AddEq(l, (c1-&gt;CircleGetRadiusExpr())-&gt;Minus(
                      c2-&gt;CircleGetRadiusExpr()), 0);
            return;
        }

        case Type::EQUAL_LINE_ARC_LEN: {
            EntityBase *line = SK.GetEntity(entityA),
                       *arc  = SK.GetEntity(entityB);

            // Get the line length
            ExprVector l0 = SK.GetEntity(line-&gt;point[0])-&gt;PointGetExprs(),
                       l1 = SK.GetEntity(line-&gt;point[1])-&gt;PointGetExprs();
            Expr *ll = (l1.Minus(l0)).Magnitude();

            // And get the arc radius, and the cosine of its angle
            EntityBase *ao = SK.GetEntity(arc-&gt;point[0]),
                       *as = SK.GetEntity(arc-&gt;point[1]),
                       *af = SK.GetEntity(arc-&gt;point[2]);

            ExprVector aos = (as-&gt;PointGetExprs()).Minus(ao-&gt;PointGetExprs()),
                       aof = (af-&gt;PointGetExprs()).Minus(ao-&gt;PointGetExprs());
            Expr *r = aof.Magnitude();

            ExprVector n = arc-&gt;Normal()-&gt;NormalExprsN();
            ExprVector u = aos.WithMagnitude(Expr::From(1.0));
            ExprVector v = n.Cross(u);
            // so in our new csys, we start at (1, 0, 0)
            Expr *costheta = aof.Dot(u)-&gt;Div(r);
            Expr *sintheta = aof.Dot(v)-&gt;Div(r);

            double thetas, thetaf, dtheta;
            arc-&gt;ArcGetAngles(&amp;thetas, &amp;thetaf, &amp;dtheta);
            Expr *theta;
            if(dtheta &lt; 3*PI/4) {
                theta = costheta-&gt;ACos();
            } else if(dtheta &lt; 5*PI/4) {
                // As the angle crosses pi, cos theta is not invertible;
                // so use the sine to stop blowing up
                theta = Expr::From(PI)-&gt;Minus(sintheta-&gt;ASin());
            } else {
                theta = (Expr::From(2*PI))-&gt;Minus(costheta-&gt;ACos());
            }

            // And write the equation; r*theta = L
            AddEq(l, (r-&gt;Times(theta))-&gt;Minus(ll), 0);
            return;
        }

        case Type::POINTS_COINCIDENT: {
            EntityBase *a = SK.GetEntity(ptA);
            EntityBase *b = SK.GetEntity(ptB);
            if(workplane == EntityBase::FREE_IN_3D) {
                ExprVector pa = a-&gt;PointGetExprs();
                ExprVector pb = b-&gt;PointGetExprs();
                AddEq(l, pa.x-&gt;Minus(pb.x), 0);
                AddEq(l, pa.y-&gt;Minus(pb.y), 1);
                AddEq(l, pa.z-&gt;Minus(pb.z), 2);
            } else {
                Expr *au, *av;
                Expr *bu, *bv;
                a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
                b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);
                AddEq(l, au-&gt;Minus(bu), 0);
                AddEq(l, av-&gt;Minus(bv), 1);
            }
            return;
        }

        case Type::PT_IN_PLANE:
            // This one works the same, whether projected or not.
            AddEq(l, PointPlaneDistance(
                        SK.GetEntity(ptA)-&gt;PointGetExprs(), entityA), 0);
            return;

        case Type::PT_ON_FACE: {
            // a plane, n dot (p - p0) = 0
            ExprVector p = SK.GetEntity(ptA)-&gt;PointGetExprs();
            EntityBase *f = SK.GetEntity(entityA);
            ExprVector p0 = f-&gt;FaceGetPointExprs();
            ExprVector n = f-&gt;FaceGetNormalExprs();
            AddEq(l, (p.Minus(p0)).Dot(n), 0);
            return;
        }

        case Type::PT_ON_LINE: {
            EntityBase *ln = SK.GetEntity(entityA);
            EntityBase *a = SK.GetEntity(ln-&gt;point[0]);
            EntityBase *b = SK.GetEntity(ln-&gt;point[1]);
            EntityBase *p = SK.GetEntity(ptA);

            ExprVector ep = p-&gt;PointGetExprsInWorkplane(workplane);
            ExprVector ea = a-&gt;PointGetExprsInWorkplane(workplane);
            ExprVector eb = b-&gt;PointGetExprsInWorkplane(workplane);

            ExprVector ptOnLine = ea.Plus(eb.Minus(ea).ScaledBy(Expr::From(valP)));
            ExprVector eq = ptOnLine.Minus(ep);

            AddEq(l, eq);
            return;
        }

        case Type::PT_ON_CIRCLE: {
            // This actually constrains the point to lie on the cylinder.
            EntityBase *circle = SK.GetEntity(entityA);
            ExprVector center = SK.GetEntity(circle-&gt;point[0])-&gt;PointGetExprs();
            ExprVector pt     = SK.GetEntity(ptA)-&gt;PointGetExprs();
            EntityBase *normal = SK.GetEntity(circle-&gt;normal);
            ExprVector u = normal-&gt;NormalExprsU(),
                       v = normal-&gt;NormalExprsV();

            Expr *du = (center.Minus(pt)).Dot(u),
                 *dv = (center.Minus(pt)).Dot(v);

            Expr *r = circle-&gt;CircleGetRadiusExpr();

            AddEq(l, du-&gt;Square()-&gt;Plus(dv-&gt;Square())-&gt;Sqrt()-&gt;Minus(r), 0);
            return;
        }

        case Type::AT_MIDPOINT:
            if(workplane == EntityBase::FREE_IN_3D) {
                EntityBase *ln = SK.GetEntity(entityA);
                ExprVector a = SK.GetEntity(ln-&gt;point[0])-&gt;PointGetExprs();
                ExprVector b = SK.GetEntity(ln-&gt;point[1])-&gt;PointGetExprs();
                ExprVector m = (a.Plus(b)).ScaledBy(Expr::From(0.5));

                if(ptA.v) {
                    ExprVector p = SK.GetEntity(ptA)-&gt;PointGetExprs();
                    AddEq(l, (m.x)-&gt;Minus(p.x), 0);
                    AddEq(l, (m.y)-&gt;Minus(p.y), 1);
                    AddEq(l, (m.z)-&gt;Minus(p.z), 2);
                } else {
                    AddEq(l, PointPlaneDistance(m, entityB), 0);
                }
            } else {
                EntityBase *ln = SK.GetEntity(entityA);
                EntityBase *a = SK.GetEntity(ln-&gt;point[0]);
                EntityBase *b = SK.GetEntity(ln-&gt;point[1]);

                Expr *au, *av, *bu, *bv;
                a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
                b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);
                Expr *mu = Expr::From(0.5)-&gt;Times(au-&gt;Plus(bu));
                Expr *mv = Expr::From(0.5)-&gt;Times(av-&gt;Plus(bv));

                if(ptA.v) {
                    EntityBase *p = SK.GetEntity(ptA);
                    Expr *pu, *pv;
                    p-&gt;PointGetExprsInWorkplane(workplane, &amp;pu, &amp;pv);
                    AddEq(l, pu-&gt;Minus(mu), 0);
                    AddEq(l, pv-&gt;Minus(mv), 1);
                } else {
                    ExprVector m = PointInThreeSpace(workplane, mu, mv);
                    AddEq(l, PointPlaneDistance(m, entityB), 0);
                }
            }
            return;

        case Type::SYMMETRIC:
            if(workplane == EntityBase::FREE_IN_3D) {
                EntityBase *plane = SK.GetEntity(entityA);
                EntityBase *ea = SK.GetEntity(ptA);
                EntityBase *eb = SK.GetEntity(ptB);
                ExprVector a = ea-&gt;PointGetExprs();
                ExprVector b = eb-&gt;PointGetExprs();

                // The midpoint of the line connecting the symmetric points
                // lies on the plane of the symmetry.
                ExprVector m = (a.Plus(b)).ScaledBy(Expr::From(0.5));
                AddEq(l, PointPlaneDistance(m, plane-&gt;h), 0);

                // And projected into the plane of symmetry, the points are
                // coincident.
                Expr *au, *av, *bu, *bv;
                ea-&gt;PointGetExprsInWorkplane(plane-&gt;h, &amp;au, &amp;av);
                eb-&gt;PointGetExprsInWorkplane(plane-&gt;h, &amp;bu, &amp;bv);
                AddEq(l, au-&gt;Minus(bu), 1);
                AddEq(l, av-&gt;Minus(bv), 2);
            } else {
                EntityBase *plane = SK.GetEntity(entityA);
                EntityBase *a = SK.GetEntity(ptA);
                EntityBase *b = SK.GetEntity(ptB);

                Expr *au, *av, *bu, *bv;
                a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
                b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);
                Expr *mu = Expr::From(0.5)-&gt;Times(au-&gt;Plus(bu));
                Expr *mv = Expr::From(0.5)-&gt;Times(av-&gt;Plus(bv));

                ExprVector m = PointInThreeSpace(workplane, mu, mv);
                AddEq(l, PointPlaneDistance(m, plane-&gt;h), 0);

                // Construct a vector within the workplane that is normal
                // to the symmetry pane's normal (i.e., that lies in the
                // plane of symmetry). The line connecting the points is
                // perpendicular to that constructed vector.
                EntityBase *w = SK.GetEntity(workplane);
                ExprVector u = w-&gt;Normal()-&gt;NormalExprsU();
                ExprVector v = w-&gt;Normal()-&gt;NormalExprsV();

                ExprVector pa = a-&gt;PointGetExprs();
                ExprVector pb = b-&gt;PointGetExprs();
                ExprVector n;
                Expr *d;
                plane-&gt;WorkplaneGetPlaneExprs(&amp;n, &amp;d);
                AddEq(l, (n.Cross(u.Cross(v))).Dot(pa.Minus(pb)), 1);
            }
            return;

        case Type::SYMMETRIC_HORIZ:
        case Type::SYMMETRIC_VERT: {
            ssassert(workplane != Entity::FREE_IN_3D,
                     "Unexpected horizontal/vertical symmetric constraint in 3d");

            EntityBase *a = SK.GetEntity(ptA);
            EntityBase *b = SK.GetEntity(ptB);

            Expr *au, *av, *bu, *bv;
            a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
            b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);

            if(type == Type::SYMMETRIC_HORIZ) {
                AddEq(l, av-&gt;Minus(bv), 0);
                AddEq(l, au-&gt;Plus(bu), 1);
            } else {
                AddEq(l, au-&gt;Minus(bu), 0);
                AddEq(l, av-&gt;Plus(bv), 1);
            }
            return;
        }

        case Type::SYMMETRIC_LINE: {
            EntityBase *pa = SK.GetEntity(ptA);
            EntityBase *pb = SK.GetEntity(ptB);

            Expr *pau, *pav, *pbu, *pbv;
            pa-&gt;PointGetExprsInWorkplane(workplane, &amp;pau, &amp;pav);
            pb-&gt;PointGetExprsInWorkplane(workplane, &amp;pbu, &amp;pbv);

            EntityBase *ln = SK.GetEntity(entityA);
            EntityBase *la = SK.GetEntity(ln-&gt;point[0]);
            EntityBase *lb = SK.GetEntity(ln-&gt;point[1]);
            Expr *lau, *lav, *lbu, *lbv;
            la-&gt;PointGetExprsInWorkplane(workplane, &amp;lau, &amp;lav);
            lb-&gt;PointGetExprsInWorkplane(workplane, &amp;lbu, &amp;lbv);

            Expr *dpu = pbu-&gt;Minus(pau), *dpv = pbv-&gt;Minus(pav);
            Expr *dlu = lbu-&gt;Minus(lau), *dlv = lbv-&gt;Minus(lav);

            // The line through the points is perpendicular to the line
            // of symmetry.
            AddEq(l, (dlu-&gt;Times(dpu))-&gt;Plus(dlv-&gt;Times(dpv)), 0);

            // And the signed distances of the points to the line are
            // equal in magnitude and opposite in sign, so sum to zero
            Expr *dista = (dlv-&gt;Times(lau-&gt;Minus(pau)))-&gt;Minus(
                          (dlu-&gt;Times(lav-&gt;Minus(pav))));
            Expr *distb = (dlv-&gt;Times(lau-&gt;Minus(pbu)))-&gt;Minus(
                          (dlu-&gt;Times(lav-&gt;Minus(pbv))));
            AddEq(l, dista-&gt;Plus(distb), 1);

            return;
        }

        case Type::HORIZONTAL:
        case Type::VERTICAL: {
            ssassert(workplane != Entity::FREE_IN_3D,
                     "Unexpected horizontal/vertical constraint in 3d");

            hEntity ha, hb;
            if(entityA.v) {
                EntityBase *e = SK.GetEntity(entityA);
                ha = e-&gt;point[0];
                hb = e-&gt;point[1];
            } else {
                ha = ptA;
                hb = ptB;
            }
            EntityBase *a = SK.GetEntity(ha);
            EntityBase *b = SK.GetEntity(hb);

            Expr *au, *av, *bu, *bv;
            a-&gt;PointGetExprsInWorkplane(workplane, &amp;au, &amp;av);
            b-&gt;PointGetExprsInWorkplane(workplane, &amp;bu, &amp;bv);

            AddEq(l, (type == Type::HORIZONTAL) ? av-&gt;Minus(bv) : au-&gt;Minus(bu), 0);
            return;
        }

        case Type::SAME_ORIENTATION: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);

            ExprVector au = a-&gt;NormalExprsU(),
                       an = a-&gt;NormalExprsN();
            ExprVector bu = b-&gt;NormalExprsU(),
                       bv = b-&gt;NormalExprsV(),
                       bn = b-&gt;NormalExprsN();

            ExprVector eq = VectorsParallel3d(an, bn, valP);
            AddEq(l, eq.x, 0);
            AddEq(l, eq.y, 1);
            AddEq(l, eq.z, 2);
            Expr *d1 = au.Dot(bv);
            Expr *d2 = au.Dot(bu);
            // Allow either orientation for the coordinate system, depending
            // on how it was drawn.
            if(fabs(d1-&gt;Eval()) &lt; fabs(d2-&gt;Eval())) {
                AddEq(l, d1, 3);
            } else {
                AddEq(l, d2, 3);
            }
            return;
        }

        case Type::PERPENDICULAR:
        case Type::ANGLE: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            ExprVector ae = a-&gt;VectorGetExprs();
            ExprVector be = b-&gt;VectorGetExprs();
            if(other) ae = ae.ScaledBy(Expr::From(-1));
            Expr *c = DirectionCosine(workplane, ae, be);

            if(type == Type::ANGLE) {
                // The direction cosine is equal to the cosine of the
                // specified angle
                Expr *rads = exA-&gt;Times(Expr::From(PI/180)),
                     *rc   = rads-&gt;Cos();
                double arc = fabs(rc-&gt;Eval());
                // avoid false detection of inconsistent systems by gaining
                // up as the difference in dot products gets small at small
                // angles; doubles still have plenty of precision, only
                // problem is that rank test
                Expr *mult = Expr::From(arc &gt; 0.99 ? 0.01/(1.00001 - arc) : 1);
                AddEq(l, (c-&gt;Minus(rc))-&gt;Times(mult), 0);
            } else {
                // The dot product (and therefore the direction cosine)
                // is equal to zero, perpendicular.
                AddEq(l, c, 0);
            }
            return;
        }

        case Type::EQUAL_ANGLE: {
            EntityBase *a = SK.GetEntity(entityA);
            EntityBase *b = SK.GetEntity(entityB);
            EntityBase *c = SK.GetEntity(entityC);
            EntityBase *d = SK.GetEntity(entityD);
            ExprVector ae = a-&gt;VectorGetExprs();
            ExprVector be = b-&gt;VectorGetExprs();
            ExprVector ce = c-&gt;VectorGetExprs();
            ExprVector de = d-&gt;VectorGetExprs();

            if(other) ae = ae.ScaledBy(Expr::From(-1));

            Expr *cab = DirectionCosine(workplane, ae, be);
            Expr *ccd = DirectionCosine(workplane, ce, de);

            AddEq(l, cab-&gt;Minus(ccd), 0);
            return;
        }

        case Type::ARC_LINE_TANGENT: {
            EntityBase *arc  = SK.GetEntity(entityA);
            EntityBase *line = SK.GetEntity(entityB);

            ExprVector ac = SK.GetEntity(arc-&gt;point[0])-&gt;PointGetExprs();
            ExprVector ap =
                SK.GetEntity(arc-&gt;point[other ? 2 : 1])-&gt;PointGetExprs();

            ExprVector ld = line-&gt;VectorGetExprs();

            // The line is perpendicular to the radius
            AddEq(l, ld.Dot(ac.Minus(ap)), 0);
            return;
        }

        case Type::CUBIC_LINE_TANGENT: {
            EntityBase *cubic = SK.GetEntity(entityA);
            EntityBase *line  = SK.GetEntity(entityB);

            ExprVector a;
            if(other) {
                a = cubic-&gt;CubicGetFinishTangentExprs();
            } else {
                a = cubic-&gt;CubicGetStartTangentExprs();
            }

            ExprVector b = line-&gt;VectorGetExprs();

            if(workplane == EntityBase::FREE_IN_3D) {
                ExprVector eq = VectorsParallel3d(a, b, valP);
                AddEq(l, eq);
            } else {
                EntityBase *w = SK.GetEntity(workplane);
                ExprVector wn = w-&gt;Normal()-&gt;NormalExprsN();
                AddEq(l, (a.Cross(b)).Dot(wn), 0);
            }
            return;
        }

        case Type::CURVE_CURVE_TANGENT: {
            bool parallel = true;
            int i;
            ExprVector dir[2];
            for(i = 0; i &lt; 2; i++) {
                EntityBase *e = SK.GetEntity((i == 0) ? entityA : entityB);
                bool oth = (i == 0) ? other : other2;

                if(e-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
                    ExprVector center, endpoint;
                    center = SK.GetEntity(e-&gt;point[0])-&gt;PointGetExprs();
                    endpoint =
                        SK.GetEntity(e-&gt;point[oth ? 2 : 1])-&gt;PointGetExprs();
                    dir[i] = endpoint.Minus(center);
                    // We're using the vector from the center of the arc to
                    // an endpoint; so that's normal to the tangent, not
                    // parallel.
                    parallel = !parallel;
                } else if(e-&gt;type == Entity::Type::CUBIC) { // BRANCH_ALWAYS_TAKEN
                    if(oth) {
                        dir[i] = e-&gt;CubicGetFinishTangentExprs();
                    } else {
                        dir[i] = e-&gt;CubicGetStartTangentExprs();
                    }
                } else {
                    ssassert(false, "Unexpected entity types for CURVE_CURVE_TANGENT");
                }
            }
            if(parallel) {
                EntityBase *w = SK.GetEntity(workplane);
                ExprVector wn = w-&gt;Normal()-&gt;NormalExprsN();
                AddEq(l, ((dir[0]).Cross(dir[1])).Dot(wn), 0);
            } else {
                AddEq(l, (dir[0]).Dot(dir[1]), 0);
            }
            return;
        }

        case Type::PARALLEL: {
            EntityBase *ea = SK.GetEntity(entityA), *eb = SK.GetEntity(entityB);
            ExprVector a = ea-&gt;VectorGetExprsInWorkplane(workplane);
            ExprVector b = eb-&gt;VectorGetExprsInWorkplane(workplane);

            if(workplane == EntityBase::FREE_IN_3D) {
                ExprVector eq = VectorsParallel3d(a, b, valP);
                AddEq(l, eq);
            } else {
                // We use expressions written in workplane csys, so we can assume the workplane
                // normal is (0, 0, 1). We can write the equation as:
                //   Expr *eq = a.Cross(b).Dot(ExprVector::From(0.0, 0.0, 1.0));
                // but this will just result in elimination of x and y terms after dot product.
                // We can only use the z expression:
                //   Expr *eq = a.Cross(b).z;
                // but it's more efficient to write it in the terms of pseudo-scalar product:
                Expr *eq = (a.x-&gt;Times(b.y))-&gt;Minus(a.y-&gt;Times(b.x));
                AddEq(l, eq, 0);
            }

            return;
        }

        case Type::WHERE_DRAGGED: {
            EntityBase *ep = SK.GetEntity(ptA);
            if(workplane == EntityBase::FREE_IN_3D) {
                ExprVector ev = ep-&gt;PointGetExprs();
                Vector v = ep-&gt;PointGetNum();

                AddEq(l, ev.x-&gt;Minus(Expr::From(v.x)), 0);
                AddEq(l, ev.y-&gt;Minus(Expr::From(v.y)), 1);
                AddEq(l, ev.z-&gt;Minus(Expr::From(v.z)), 2);
            } else {
                Expr *u, *v;
                ep-&gt;PointGetExprsInWorkplane(workplane, &amp;u, &amp;v);
                AddEq(l, u-&gt;Minus(Expr::From(u-&gt;Eval())), 0);
                AddEq(l, v-&gt;Minus(Expr::From(v-&gt;Eval())), 1);
            }
            return;
        }

        case Type::COMMENT:
            return;
    }
    ssassert(false, "Unexpected constraint ID");
}

</t>
<t tx="leo.20191228122642.82">@path ./src/
//-----------------------------------------------------------------------------
// The screens when an entity is selected, that show some description of it--
// endpoints of the lines, diameter of the circle, etc.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122642.83">void TextWindow::ScreenUnselectAll(int link, uint32_t v) {
    GraphicsWindow::MenuEdit(Command::UNSELECT_ALL);
}

</t>
<t tx="leo.20191228122642.9">void AllocTriangle() {
    btri = (STriangle *)AllocTemporary(sizeof(STriangle));
}

</t>
<t tx="leo.20191228122643.1">void TextWindow::ScreenEditTtfText(int link, uint32_t v) {
    hRequest hr = { v };
    Request *r = SK.GetRequest(hr);

    SS.TW.ShowEditControl(10, r-&gt;str);
    SS.TW.edit.meaning = Edit::TTF_TEXT;
    SS.TW.edit.request = hr;
}

</t>
<t tx="leo.20191228122643.10">bool GraphicsWindow::Selection::HasEndpoints() {
    if(!entity.v) return false;
    Entity *e = SK.GetEntity(entity);
    return e-&gt;HasEndpoints();
}

</t>
<t tx="leo.20191228122643.100">void DeepCopyInto(IdList&lt;T,H&gt; *l) {
    l-&gt;Clear();
    l-&gt;elem = (T *)MemAlloc(elemsAllocated * sizeof(elem[0]));
    for(int i = 0; i &lt; n; i++)
        new(&amp;l-&gt;elem[i]) T(elem[i]);
    l-&gt;elemsAllocated = elemsAllocated;
    l-&gt;n = n;
}

</t>
<t tx="leo.20191228122643.101">void Clear() {
    for(int i = 0; i &lt; n; i++) {
        elem[i].Clear();
        elem[i].~T();
    }
    if(elem) MemFree(elem);
    elem = NULL;
    elemsAllocated = n = 0;
}

</t>
<t tx="leo.20191228122643.102">class BandedMatrix {
public:
    enum {
        MAX_UNKNOWNS   = 16,
        RIGHT_OF_DIAG  = 1,
        LEFT_OF_DIAG   = 2
    };

    double A[MAX_UNKNOWNS][MAX_UNKNOWNS];
    double B[MAX_UNKNOWNS];
    double X[MAX_UNKNOWNS];
    int n;

    void Solve();
};

#define RGBi(r, g, b) RgbaColor::From((r), (g), (b))
#define RGBf(r, g, b) RgbaColor::FromFloat((float)(r), (float)(g), (float)(b))

// Note: sizeof(class RgbaColor) should be exactly 4
//
</t>
<t tx="leo.20191228122643.103">class RgbaColor {
public:
    uint8_t red, green, blue, alpha;

    float redF()   const { return (float)red   / 255.0f; }
    float greenF() const { return (float)green / 255.0f; }
    float blueF()  const { return (float)blue  / 255.0f; }
    float alphaF() const { return (float)alpha / 255.0f; }

    bool IsEmpty() const { return alpha == 0; }

    @others
};

struct RgbaColorCompare {
</t>
<t tx="leo.20191228122643.104">bool Equals(RgbaColor c) const {
    return
        c.red   == red   &amp;&amp;
        c.green == green &amp;&amp;
        c.blue  == blue  &amp;&amp;
        c.alpha == alpha;
}

RgbaColor WithAlpha(uint8_t newAlpha) const {
    RgbaColor color = *this;
    color.alpha = newAlpha;
    return color;
}

uint32_t ToPackedIntBGRA() const {
    return
        blue |
        (uint32_t)(green &lt;&lt; 8) |
        (uint32_t)(red &lt;&lt; 16) |
        (uint32_t)((255 - alpha) &lt;&lt; 24);
}

uint32_t ToPackedInt() const {
    return
        red |
        (uint32_t)(green &lt;&lt; 8) |
        (uint32_t)(blue &lt;&lt; 16) |
        (uint32_t)((255 - alpha) &lt;&lt; 24);
}

uint32_t ToARGB32() const {
    return
        blue |
        (uint32_t)(green &lt;&lt; 8) |
        (uint32_t)(red &lt;&lt; 16) |
        (uint32_t)(alpha &lt;&lt; 24);
}

</t>
<t tx="leo.20191228122643.105">static RgbaColor From(int r, int g, int b, int a = 255) {
    RgbaColor c;
    c.red   = (uint8_t)r;
    c.green = (uint8_t)g;
    c.blue  = (uint8_t)b;
    c.alpha = (uint8_t)a;
    return c;
}

</t>
<t tx="leo.20191228122643.106">static RgbaColor FromFloat(float r, float g, float b, float a = 1.0) {
    return From(
        (int)(255.1f * r),
        (int)(255.1f * g),
        (int)(255.1f * b),
        (int)(255.1f * a));
}

</t>
<t tx="leo.20191228122643.107">static RgbaColor FromPackedInt(uint32_t rgba) {
    return From(
        (int)((rgba)       &amp; 0xff),
        (int)((rgba &gt;&gt; 8)  &amp; 0xff),
        (int)((rgba &gt;&gt; 16) &amp; 0xff),
        (int)(255 - ((rgba &gt;&gt; 24) &amp; 0xff)));
}

</t>
<t tx="leo.20191228122643.108">static RgbaColor FromPackedIntBGRA(uint32_t bgra) {
    return From(
        (int)((bgra &gt;&gt; 16) &amp; 0xff),
        (int)((bgra &gt;&gt; 8)  &amp; 0xff),
        (int)((bgra)       &amp; 0xff),
        (int)(255 - ((bgra &gt;&gt; 24) &amp; 0xff)));
}
</t>
<t tx="leo.20191228122643.109">    bool operator()(RgbaColor a, RgbaColor b) const {
        return a.ToARGB32() &lt; b.ToARGB32();
    }
};

</t>
<t tx="leo.20191228122643.11">void GraphicsWindow::Selection::Clear() {
    entity.v = constraint.v = 0;
    emphasized = false;
}

</t>
<t tx="leo.20191228122643.110">class BBox {
public:
    Vector minp;
    Vector maxp;

    static BBox From(const Vector &amp;p0, const Vector &amp;p1);

    Vector GetOrigin() const;
    Vector GetExtents() const;

    void Include(const Vector &amp;v, double r = 0.0);
    bool Overlaps(const BBox &amp;b1) const;
    bool Contains(const Point2d &amp;p, double r = 0.0) const;
};

#endif
</t>
<t tx="leo.20191228122643.111">@path ./src/
//-----------------------------------------------------------------------------
// The implementation of our entities in the symbolic algebra system, methods
// to return a symbolic representation of the entity (line by its endpoints,
// circle by center and radius, etc.).
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

const hEntity  EntityBase::FREE_IN_3D = { 0 };
const hEntity  EntityBase::NO_ENTITY = { 0 };

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122643.112">bool EntityBase::HasVector() const {
    switch(type) {
        case Type::LINE_SEGMENT:
        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return true;

        default:
            return false;
    }
}

ExprVector EntityBase::VectorGetExprsInWorkplane(hEntity wrkpl) const {
    switch(type) {
        case Type::LINE_SEGMENT:
            return (SK.GetEntity(point[0])-&gt;PointGetExprsInWorkplane(wrkpl)).Minus(
                    SK.GetEntity(point[1])-&gt;PointGetExprsInWorkplane(wrkpl));

        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA: {
            ExprVector ev = NormalExprsN();
            if(wrkpl == EntityBase::FREE_IN_3D) {
                return ev;
            }
            // Get the offset and basis vectors for this weird exotic csys.
            EntityBase *w = SK.GetEntity(wrkpl);
            ExprVector wu = w-&gt;Normal()-&gt;NormalExprsU();
            ExprVector wv = w-&gt;Normal()-&gt;NormalExprsV();

            // Get our coordinates in three-space, and project them into that
            // coordinate system.
            ExprVector result;
            result.x = ev.Dot(wu);
            result.y = ev.Dot(wv);
            result.z = Expr::From(0.0);
            return result;
        }
        default: ssassert(false, "Unexpected entity type");
    }
}

ExprVector EntityBase::VectorGetExprs() const {
    return VectorGetExprsInWorkplane(EntityBase::FREE_IN_3D);
}

Vector EntityBase::VectorGetNum() const {
    switch(type) {
        case Type::LINE_SEGMENT:
            return (SK.GetEntity(point[0])-&gt;PointGetNum()).Minus(
                    SK.GetEntity(point[1])-&gt;PointGetNum());

        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return NormalN();

        default: ssassert(false, "Unexpected entity type");
    }
}

Vector EntityBase::VectorGetRefPoint() const {
    switch(type) {
        case Type::LINE_SEGMENT:
            return ((SK.GetEntity(point[0])-&gt;PointGetNum()).Plus(
                     SK.GetEntity(point[1])-&gt;PointGetNum())).ScaledBy(0.5);

        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return SK.GetEntity(point[0])-&gt;PointGetNum();

        default: ssassert(false, "Unexpected entity type");
    }
}

Vector EntityBase::VectorGetStartPoint() const {
    switch(type) {
        case Type::LINE_SEGMENT:
            return SK.GetEntity(point[1])-&gt;PointGetNum();

        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return SK.GetEntity(point[0])-&gt;PointGetNum();

        default: ssassert(false, "Unexpected entity type");
    }
}

</t>
<t tx="leo.20191228122643.113">bool EntityBase::IsCircle() const {
    return (type == Type::CIRCLE) || (type == Type::ARC_OF_CIRCLE);
}

Expr *EntityBase::CircleGetRadiusExpr() const {
    if(type == Type::CIRCLE) {
        return SK.GetEntity(distance)-&gt;DistanceGetExpr();
    } else if(type == Type::ARC_OF_CIRCLE) {
        return Constraint::Distance(workplane, point[0], point[1]);
    } else ssassert(false, "Unexpected entity type");
}

double EntityBase::CircleGetRadiusNum() const {
    if(type == Type::CIRCLE) {
        return SK.GetEntity(distance)-&gt;DistanceGetNum();
    } else if(type == Type::ARC_OF_CIRCLE) {
        Vector c  = SK.GetEntity(point[0])-&gt;PointGetNum();
        Vector pa = SK.GetEntity(point[1])-&gt;PointGetNum();
        return (pa.Minus(c)).Magnitude();
    } else ssassert(false, "Unexpected entity type");
}

</t>
<t tx="leo.20191228122643.114">void EntityBase::ArcGetAngles(double *thetaa, double *thetab, double *dtheta) const {
    ssassert(type == Type::ARC_OF_CIRCLE, "Unexpected entity type");

    Quaternion q = Normal()-&gt;NormalGetNum();
    Vector u = q.RotationU(), v = q.RotationV();

    Vector c  = SK.GetEntity(point[0])-&gt;PointGetNum();
    Vector pa = SK.GetEntity(point[1])-&gt;PointGetNum();
    Vector pb = SK.GetEntity(point[2])-&gt;PointGetNum();

    Point2d c2  = c.Project2d(u, v);
    Point2d pa2 = (pa.Project2d(u, v)).Minus(c2);
    Point2d pb2 = (pb.Project2d(u, v)).Minus(c2);

    *thetaa = atan2(pa2.y, pa2.x);
    *thetab = atan2(pb2.y, pb2.x);
    *dtheta = *thetab - *thetaa;
    // If the endpoints are coincident, call it a full arc, not a zero arc;
    // useful concept to have when splitting
    while(*dtheta &lt; 1e-6) *dtheta += 2*PI;
    while(*dtheta &gt; (2*PI)) *dtheta -= 2*PI;
}

Vector EntityBase::CubicGetStartNum() const {
    return SK.GetEntity(point[0])-&gt;PointGetNum();
}
Vector EntityBase::CubicGetFinishNum() const {
    return SK.GetEntity(point[3+extraPoints])-&gt;PointGetNum();
}
ExprVector EntityBase::CubicGetStartTangentExprs() const {
    ExprVector pon  = SK.GetEntity(point[0])-&gt;PointGetExprs(),
               poff = SK.GetEntity(point[1])-&gt;PointGetExprs();
    return (pon.Minus(poff));
}
ExprVector EntityBase::CubicGetFinishTangentExprs() const {
    ExprVector pon  = SK.GetEntity(point[3+extraPoints])-&gt;PointGetExprs(),
               poff = SK.GetEntity(point[2+extraPoints])-&gt;PointGetExprs();
    return (pon.Minus(poff));
}
Vector EntityBase::CubicGetStartTangentNum() const {
    Vector pon  = SK.GetEntity(point[0])-&gt;PointGetNum(),
           poff = SK.GetEntity(point[1])-&gt;PointGetNum();
    return (pon.Minus(poff));
}
Vector EntityBase::CubicGetFinishTangentNum() const {
    Vector pon  = SK.GetEntity(point[3+extraPoints])-&gt;PointGetNum(),
           poff = SK.GetEntity(point[2+extraPoints])-&gt;PointGetNum();
    return (pon.Minus(poff));
}

</t>
<t tx="leo.20191228122643.115">bool EntityBase::IsWorkplane() const {
    return (type == Type::WORKPLANE);
}

ExprVector EntityBase::WorkplaneGetOffsetExprs() const {
    return SK.GetEntity(point[0])-&gt;PointGetExprs();
}

Vector EntityBase::WorkplaneGetOffset() const {
    return SK.GetEntity(point[0])-&gt;PointGetNum();
}

</t>
<t tx="leo.20191228122643.116">void EntityBase::WorkplaneGetPlaneExprs(ExprVector *n, Expr **dn) const {
    if(type == Type::WORKPLANE) {
        *n = Normal()-&gt;NormalExprsN();

        ExprVector p0 = SK.GetEntity(point[0])-&gt;PointGetExprs();
        // The plane is n dot (p - p0) = 0, or
        //              n dot p - n dot p0 = 0
        // so dn = n dot p0
        *dn = p0.Dot(*n);
    } else ssassert(false, "Unexpected entity type");
}

</t>
<t tx="leo.20191228122643.117">bool EntityBase::IsDistance() const {
    return (type == Type::DISTANCE) ||
           (type == Type::DISTANCE_N_COPY);
}
double EntityBase::DistanceGetNum() const {
    if(type == Type::DISTANCE) {
        return SK.GetParam(param[0])-&gt;val;
    } else if(type == Type::DISTANCE_N_COPY) {
        return numDistance;
    } else ssassert(false, "Unexpected entity type");
}
Expr *EntityBase::DistanceGetExpr() const {
    if(type == Type::DISTANCE) {
        return Expr::From(param[0]);
    } else if(type == Type::DISTANCE_N_COPY) {
        return Expr::From(numDistance);
    } else ssassert(false, "Unexpected entity type");
}
</t>
<t tx="leo.20191228122643.118">void EntityBase::DistanceForceTo(double v) {
    if(type == Type::DISTANCE) {
        (SK.GetParam(param[0]))-&gt;val = v;
    } else if(type == Type::DISTANCE_N_COPY) {
        // do nothing, it's locked
    } else ssassert(false, "Unexpected entity type");
}

EntityBase *EntityBase::Normal() const {
    return SK.GetEntity(normal);
}

</t>
<t tx="leo.20191228122643.119">bool EntityBase::IsPoint() const {
    switch(type) {
        case Type::POINT_IN_3D:
        case Type::POINT_IN_2D:
        case Type::POINT_N_COPY:
        case Type::POINT_N_TRANS:
        case Type::POINT_N_ROT_TRANS:
        case Type::POINT_N_ROT_AA:
        case Type::POINT_N_ROT_AXIS_TRANS:
            return true;

        default:
            return false;
    }
}

</t>
<t tx="leo.20191228122643.12">void GraphicsWindow::Selection::Draw(bool isHovered, Canvas *canvas) {
    const Camera &amp;camera = canvas-&gt;GetCamera();

    std::vector&lt;Vector&gt; refs;
    if(entity.v) {
        Entity *e = SK.GetEntity(entity);
        e-&gt;Draw(isHovered ? Entity::DrawAs::HOVERED :
                            Entity::DrawAs::SELECTED,
                canvas);
        if(emphasized) {
            e-&gt;GetReferencePoints(&amp;refs);
        }
    }
    if(constraint.v) {
        Constraint *c = SK.GetConstraint(constraint);
        c-&gt;Draw(isHovered ? Constraint::DrawAs::HOVERED :
                            Constraint::DrawAs::SELECTED,
                canvas);
        if(emphasized) {
            c-&gt;GetReferencePoints(camera, &amp;refs);
        }
    }
    if(emphasized &amp;&amp; (constraint.v || entity.v)) {
        // We want to emphasize this constraint or entity, by drawing a thick
        // line from the top left corner of the screen to the reference point(s)
        // of that entity or constraint.
        Canvas::Stroke strokeEmphasis = {};
        strokeEmphasis.layer  = Canvas::Layer::FRONT;
        strokeEmphasis.color  = Style::Color(Style::HOVERED).WithAlpha(50);
        strokeEmphasis.width  = 40;
        strokeEmphasis.unit   = Canvas::Unit::PX;
        Canvas::hStroke hcsEmphasis = canvas-&gt;GetStroke(strokeEmphasis);

        Point2d topLeftScreen;
        topLeftScreen.x = -(double)camera.width / 2;
        topLeftScreen.y = (double)camera.height / 2;
        Vector topLeft = camera.UnProjectPoint(topLeftScreen);

        @others
}

</t>
<t tx="leo.20191228122643.120">bool EntityBase::IsNormal() const {
    switch(type) {
        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
            return true;

        default:           return false;
    }
}

Quaternion EntityBase::NormalGetNum() const {
    Quaternion q;
    switch(type) {
        case Type::NORMAL_IN_3D:
            q = Quaternion::From(param[0], param[1], param[2], param[3]);
            break;

        case Type::NORMAL_IN_2D: {
            EntityBase *wrkpl = SK.GetEntity(workplane);
            EntityBase *norm = SK.GetEntity(wrkpl-&gt;normal);
            q = norm-&gt;NormalGetNum();
            break;
        }
        case Type::NORMAL_N_COPY:
            q = numNormal;
            break;

        case Type::NORMAL_N_ROT:
            q = Quaternion::From(param[0], param[1], param[2], param[3]);
            q = q.Times(numNormal);
            break;

        case Type::NORMAL_N_ROT_AA: {
            q = GetAxisAngleQuaternion(0);
            q = q.Times(numNormal);
            break;
        }

        default: ssassert(false, "Unexpected entity type");
    }
    return q;
}

</t>
<t tx="leo.20191228122643.121">void EntityBase::NormalForceTo(Quaternion q) {
    switch(type) {
        case Type::NORMAL_IN_3D:
            SK.GetParam(param[0])-&gt;val = q.w;
            SK.GetParam(param[1])-&gt;val = q.vx;
            SK.GetParam(param[2])-&gt;val = q.vy;
            SK.GetParam(param[3])-&gt;val = q.vz;
            break;

        case Type::NORMAL_IN_2D:
        case Type::NORMAL_N_COPY:
            // There's absolutely nothing to do; these are locked.
            break;
        case Type::NORMAL_N_ROT: {
            Quaternion qp = q.Times(numNormal.Inverse());

            SK.GetParam(param[0])-&gt;val = qp.w;
            SK.GetParam(param[1])-&gt;val = qp.vx;
            SK.GetParam(param[2])-&gt;val = qp.vy;
            SK.GetParam(param[3])-&gt;val = qp.vz;
            break;
        }

        case Type::NORMAL_N_ROT_AA:
            // Not sure if I'll bother implementing this one
            break;

        default: ssassert(false, "Unexpected entity type");
    }
}

Vector EntityBase::NormalU() const {
    return NormalGetNum().RotationU();
}
Vector EntityBase::NormalV() const {
    return NormalGetNum().RotationV();
}
Vector EntityBase::NormalN() const {
    return NormalGetNum().RotationN();
}

ExprVector EntityBase::NormalExprsU() const {
    return NormalGetExprs().RotationU();
}
ExprVector EntityBase::NormalExprsV() const {
    return NormalGetExprs().RotationV();
}
ExprVector EntityBase::NormalExprsN() const {
    return NormalGetExprs().RotationN();
}

ExprQuaternion EntityBase::NormalGetExprs() const {
    ExprQuaternion q;
    switch(type) {
        case Type::NORMAL_IN_3D:
            q = ExprQuaternion::From(param[0], param[1], param[2], param[3]);
            break;

        case Type::NORMAL_IN_2D: {
            EntityBase *wrkpl = SK.GetEntity(workplane);
            EntityBase *norm = SK.GetEntity(wrkpl-&gt;normal);
            q = norm-&gt;NormalGetExprs();
            break;
        }
        case Type::NORMAL_N_COPY:
            q = ExprQuaternion::From(numNormal);
            break;

        case Type::NORMAL_N_ROT: {
            ExprQuaternion orig = ExprQuaternion::From(numNormal);
            q = ExprQuaternion::From(param[0], param[1], param[2], param[3]);

            q = q.Times(orig);
            break;
        }

        case Type::NORMAL_N_ROT_AA: {
            ExprQuaternion orig = ExprQuaternion::From(numNormal);
            q = GetAxisAngleQuaternionExprs(0);
            q = q.Times(orig);
            break;
        }

        default: ssassert(false, "Unexpected entity type");
    }
    return q;
}

</t>
<t tx="leo.20191228122643.122">void EntityBase::PointForceParamTo(Vector p) {
    switch(type) {
        case Type::POINT_IN_3D:
            SK.GetParam(param[0])-&gt;val = p.x;
            SK.GetParam(param[1])-&gt;val = p.y;
            SK.GetParam(param[2])-&gt;val = p.z;
            break;

        case Type::POINT_IN_2D:
            SK.GetParam(param[0])-&gt;val = p.x;
            SK.GetParam(param[1])-&gt;val = p.y;
            break;

        default: ssassert(false, "Unexpected entity type");
    }
}

</t>
<t tx="leo.20191228122643.123">void EntityBase::PointForceTo(Vector p) {
    switch(type) {
        case Type::POINT_IN_3D:
            SK.GetParam(param[0])-&gt;val = p.x;
            SK.GetParam(param[1])-&gt;val = p.y;
            SK.GetParam(param[2])-&gt;val = p.z;
            break;

        case Type::POINT_IN_2D: {
            EntityBase *c = SK.GetEntity(workplane);
            p = p.Minus(c-&gt;WorkplaneGetOffset());
            SK.GetParam(param[0])-&gt;val = p.Dot(c-&gt;Normal()-&gt;NormalU());
            SK.GetParam(param[1])-&gt;val = p.Dot(c-&gt;Normal()-&gt;NormalV());
            break;
        }

        case Type::POINT_N_TRANS: {
            if(timesApplied == 0) break;
            Vector trans = (p.Minus(numPoint)).ScaledBy(1.0/timesApplied);
            SK.GetParam(param[0])-&gt;val = trans.x;
            SK.GetParam(param[1])-&gt;val = trans.y;
            SK.GetParam(param[2])-&gt;val = trans.z;
            break;
        }

        case Type::POINT_N_ROT_TRANS: {
            // Force only the translation; leave the rotation unchanged. But
            // remember that we're working with respect to the rotated
            // point.
            Vector trans = p.Minus(PointGetQuaternion().Rotate(numPoint));
            SK.GetParam(param[0])-&gt;val = trans.x;
            SK.GetParam(param[1])-&gt;val = trans.y;
            SK.GetParam(param[2])-&gt;val = trans.z;
            break;
        }

        case Type::POINT_N_ROT_AA: {
            // Force only the angle; the axis and center of rotation stay
            Vector offset = Vector::From(param[0], param[1], param[2]);
            Vector normal = Vector::From(param[4], param[5], param[6]);
            Vector u = normal.Normal(0), v = normal.Normal(1);
            Vector po = p.Minus(offset), numo = numPoint.Minus(offset);
            double thetap = atan2(v.Dot(po), u.Dot(po));
            double thetan = atan2(v.Dot(numo), u.Dot(numo));
            double thetaf = (thetap - thetan);
            double thetai = (SK.GetParam(param[3])-&gt;val)*timesApplied*2;
            double dtheta = thetaf - thetai;
            // Take the smallest possible change in the actual step angle,
            // in order to avoid jumps when you cross from +pi to -pi
            while(dtheta &lt; -PI) dtheta += 2*PI;
            while(dtheta &gt; PI) dtheta -= 2*PI;
            // this extra *2 explains the mystery *4
            SK.GetParam(param[3])-&gt;val = (thetai + dtheta)/(timesApplied*2);
            break;
        }

        case Type::POINT_N_ROT_AXIS_TRANS: {
            if(timesApplied == 0) break;
            // is the point on the rotation axis?
            Vector offset = Vector::From(param[0], param[1], param[2]);
            Vector normal = Vector::From(param[4], param[5], param[6]).WithMagnitude(1.0);
            Vector check = numPoint.Minus(offset).Cross(normal);
            if (check.Dot(check) &lt; LENGTH_EPS) { // if so, do extrusion style drag
                Vector trans = (p.Minus(numPoint));
                SK.GetParam(param[7])-&gt;val = trans.Dot(normal)/timesApplied;
            } else { // otherwise do rotation style
                Vector u = normal.Normal(0), v = normal.Normal(1);
                Vector po = p.Minus(offset), numo = numPoint.Minus(offset);
                double thetap = atan2(v.Dot(po), u.Dot(po));
                double thetan = atan2(v.Dot(numo), u.Dot(numo));
                double thetaf = (thetap - thetan);
                double thetai = (SK.GetParam(param[3])-&gt;val)*timesApplied*2;
                double dtheta = thetaf - thetai;
                // Take the smallest possible change in the actual step angle,
                // in order to avoid jumps when you cross from +pi to -pi
                while(dtheta &lt; -PI) dtheta += 2*PI;
                while(dtheta &gt; PI) dtheta -= 2*PI;
                // this extra *2 explains the mystery *4
                SK.GetParam(param[3])-&gt;val = (thetai + dtheta)/(timesApplied*2);
            }
            break;
        }

        case Type::POINT_N_COPY:
            // Nothing to do; it's a static copy
            break;

        default: ssassert(false, "Unexpected entity type");
    }
}

Vector EntityBase::PointGetNum() const {
    Vector p;
    switch(type) {
        case Type::POINT_IN_3D:
            p = Vector::From(param[0], param[1], param[2]);
            break;

        case Type::POINT_IN_2D: {
            EntityBase *c = SK.GetEntity(workplane);
            Vector u = c-&gt;Normal()-&gt;NormalU();
            Vector v = c-&gt;Normal()-&gt;NormalV();
            p =        u.ScaledBy(SK.GetParam(param[0])-&gt;val);
            p = p.Plus(v.ScaledBy(SK.GetParam(param[1])-&gt;val));
            p = p.Plus(c-&gt;WorkplaneGetOffset());
            break;
        }

        case Type::POINT_N_TRANS: {
            Vector trans = Vector::From(param[0], param[1], param[2]);
            p = numPoint.Plus(trans.ScaledBy(timesApplied));
            break;
        }

        case Type::POINT_N_ROT_TRANS: {
            Vector offset = Vector::From(param[0], param[1], param[2]);
            Quaternion q = PointGetQuaternion();
            p = q.Rotate(numPoint);
            p = p.Plus(offset);
            break;
        }

        case Type::POINT_N_ROT_AA: {
            Vector offset = Vector::From(param[0], param[1], param[2]);
            Quaternion q = PointGetQuaternion();
            p = numPoint.Minus(offset);
            p = q.Rotate(p);
            p = p.Plus(offset);
            break;
        }

        case Type::POINT_N_ROT_AXIS_TRANS: {
            Vector offset = Vector::From(param[0], param[1], param[2]);
            Vector displace = Vector::From(param[4], param[5], param[6])
               .WithMagnitude(SK.GetParam(param[7])-&gt;val).ScaledBy(timesApplied);
            Quaternion q = PointGetQuaternion();
            p = numPoint.Minus(offset);
            p = q.Rotate(p);
            p = p.Plus(offset).Plus(displace);
            break;
        }

        case Type::POINT_N_COPY:
            p = numPoint;
            break;

        default: ssassert(false, "Unexpected entity type");
    }
    return p;
}

ExprVector EntityBase::PointGetExprs() const {
    ExprVector r;
    switch(type) {
        case Type::POINT_IN_3D:
            r = ExprVector::From(param[0], param[1], param[2]);
            break;

        case Type::POINT_IN_2D: {
            EntityBase *c = SK.GetEntity(workplane);
            ExprVector u = c-&gt;Normal()-&gt;NormalExprsU();
            ExprVector v = c-&gt;Normal()-&gt;NormalExprsV();
            r = c-&gt;WorkplaneGetOffsetExprs();
            r = r.Plus(u.ScaledBy(Expr::From(param[0])));
            r = r.Plus(v.ScaledBy(Expr::From(param[1])));
            break;
        }
        case Type::POINT_N_TRANS: {
            ExprVector orig = ExprVector::From(numPoint);
            ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
            r = orig.Plus(trans.ScaledBy(Expr::From(timesApplied)));
            break;
        }
        case Type::POINT_N_ROT_TRANS: {
            ExprVector orig = ExprVector::From(numPoint);
            ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
            ExprQuaternion q =
                ExprQuaternion::From(param[3], param[4], param[5], param[6]);
            orig = q.Rotate(orig);
            r = orig.Plus(trans);
            break;
        }
        case Type::POINT_N_ROT_AA: {
            ExprVector orig = ExprVector::From(numPoint);
            ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
            ExprQuaternion q = GetAxisAngleQuaternionExprs(3);
            orig = orig.Minus(trans);
            orig = q.Rotate(orig);
            r = orig.Plus(trans);
            break;
        }
        case Type::POINT_N_ROT_AXIS_TRANS: {
            ExprVector orig = ExprVector::From(numPoint);
            ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
            ExprVector displace = ExprVector::From(param[4], param[5], param[6])
               .WithMagnitude(Expr::From(1.0)).ScaledBy(Expr::From(timesApplied)).ScaledBy(Expr::From(param[7]));

            ExprQuaternion q = GetAxisAngleQuaternionExprs(3);
            orig = orig.Minus(trans);
            orig = q.Rotate(orig);
            r = orig.Plus(trans).Plus(displace);
            break;
        }
        case Type::POINT_N_COPY:
            r = ExprVector::From(numPoint);
            break;

        default: ssassert(false, "Unexpected entity type");
    }
    return r;
}

</t>
<t tx="leo.20191228122643.124">void EntityBase::PointGetExprsInWorkplane(hEntity wrkpl, Expr **u, Expr **v) const {
    if(type == Type::POINT_IN_2D &amp;&amp; workplane == wrkpl) {
        // They want our coordinates in the form that we've written them,
        // very nice.
        *u = Expr::From(param[0]);
        *v = Expr::From(param[1]);
    } else {
        // Get the offset and basis vectors for this weird exotic csys.
        EntityBase *w = SK.GetEntity(wrkpl);
        ExprVector wp = w-&gt;WorkplaneGetOffsetExprs();
        ExprVector wu = w-&gt;Normal()-&gt;NormalExprsU();
        ExprVector wv = w-&gt;Normal()-&gt;NormalExprsV();

        // Get our coordinates in three-space, and project them into that
        // coordinate system.
        ExprVector ev = PointGetExprs();
        ev = ev.Minus(wp);
        *u = ev.Dot(wu);
        *v = ev.Dot(wv);
    }
}

ExprVector EntityBase::PointGetExprsInWorkplane(hEntity wrkpl) const {
    if(wrkpl == Entity::FREE_IN_3D) {
        return PointGetExprs();
    }

    ExprVector r;
    PointGetExprsInWorkplane(wrkpl, &amp;r.x, &amp;r.y);
    r.z = Expr::From(0.0);
    return r;
}

</t>
<t tx="leo.20191228122643.125">void EntityBase::PointForceQuaternionTo(Quaternion q) {
    ssassert(type == Type::POINT_N_ROT_TRANS, "Unexpected entity type");

    SK.GetParam(param[3])-&gt;val = q.w;
    SK.GetParam(param[4])-&gt;val = q.vx;
    SK.GetParam(param[5])-&gt;val = q.vy;
    SK.GetParam(param[6])-&gt;val = q.vz;
}

Quaternion EntityBase::GetAxisAngleQuaternion(int param0) const {
    Quaternion q;
    double theta = timesApplied*SK.GetParam(param[param0+0])-&gt;val;
    double s = sin(theta), c = cos(theta);
    q.w = c;
    q.vx = s*SK.GetParam(param[param0+1])-&gt;val;
    q.vy = s*SK.GetParam(param[param0+2])-&gt;val;
    q.vz = s*SK.GetParam(param[param0+3])-&gt;val;
    return q;
}

ExprQuaternion EntityBase::GetAxisAngleQuaternionExprs(int param0) const {
    ExprQuaternion q;

    Expr *theta = Expr::From(timesApplied)-&gt;Times(
                  Expr::From(param[param0+0]));
    Expr *c = theta-&gt;Cos(), *s = theta-&gt;Sin();
    q.w = c;
    q.vx = s-&gt;Times(Expr::From(param[param0+1]));
    q.vy = s-&gt;Times(Expr::From(param[param0+2]));
    q.vz = s-&gt;Times(Expr::From(param[param0+3]));
    return q;
}

Quaternion EntityBase::PointGetQuaternion() const {
    Quaternion q;

    if(type == Type::POINT_N_ROT_AA || type == Type::POINT_N_ROT_AXIS_TRANS) {
        q = GetAxisAngleQuaternion(3);
    } else if(type == Type::POINT_N_ROT_TRANS) {
        q = Quaternion::From(param[3], param[4], param[5], param[6]);
    } else ssassert(false, "Unexpected entity type");

    return q;
}

</t>
<t tx="leo.20191228122643.126">bool EntityBase::IsFace() const {
    switch(type) {
        case Type::FACE_NORMAL_PT:
        case Type::FACE_XPROD:
        case Type::FACE_N_ROT_TRANS:
        case Type::FACE_N_TRANS:
        case Type::FACE_N_ROT_AA:
            return true;
        default:
            return false;
    }
}

ExprVector EntityBase::FaceGetNormalExprs() const {
    ExprVector r;
    if(type == Type::FACE_NORMAL_PT) {
        Vector v = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        r = ExprVector::From(v.WithMagnitude(1));
    } else if(type == Type::FACE_XPROD) {
        ExprVector vc = ExprVector::From(param[0], param[1], param[2]);
        ExprVector vn =
            ExprVector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        r = vc.Cross(vn);
        r = r.WithMagnitude(Expr::From(1.0));
    } else if(type == Type::FACE_N_ROT_TRANS) {
        // The numerical normal vector gets the rotation; the numerical
        // normal has magnitude one, and the rotation doesn't change that,
        // so there's no need to fix it up.
        r = ExprVector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        ExprQuaternion q =
            ExprQuaternion::From(param[3], param[4], param[5], param[6]);
        r = q.Rotate(r);
    } else if(type == Type::FACE_N_TRANS) {
        r = ExprVector::From(numNormal.vx, numNormal.vy, numNormal.vz);
    } else if(type == Type::FACE_N_ROT_AA) {
        r = ExprVector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        ExprQuaternion q = GetAxisAngleQuaternionExprs(3);
        r = q.Rotate(r);
    } else ssassert(false, "Unexpected entity type");
    return r;
}

Vector EntityBase::FaceGetNormalNum() const {
    Vector r;
    if(type == Type::FACE_NORMAL_PT) {
        r = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
    } else if(type == Type::FACE_XPROD) {
        Vector vc = Vector::From(param[0], param[1], param[2]);
        Vector vn = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        r = vc.Cross(vn);
    } else if(type == Type::FACE_N_ROT_TRANS) {
        // The numerical normal vector gets the rotation
        r = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        Quaternion q = Quaternion::From(param[3], param[4], param[5], param[6]);
        r = q.Rotate(r);
    } else if(type == Type::FACE_N_TRANS) {
        r = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
    } else if(type == Type::FACE_N_ROT_AA) {
        r = Vector::From(numNormal.vx, numNormal.vy, numNormal.vz);
        Quaternion q = GetAxisAngleQuaternion(3);
        r = q.Rotate(r);
    } else ssassert(false, "Unexpected entity type");
    return r.WithMagnitude(1);
}

ExprVector EntityBase::FaceGetPointExprs() const {
    ExprVector r;
    if(type == Type::FACE_NORMAL_PT) {
        r = SK.GetEntity(point[0])-&gt;PointGetExprs();
    } else if(type == Type::FACE_XPROD) {
        r = ExprVector::From(numPoint);
    } else if(type == Type::FACE_N_ROT_TRANS) {
        // The numerical point gets the rotation and translation.
        ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
        ExprQuaternion q =
            ExprQuaternion::From(param[3], param[4], param[5], param[6]);
        r = ExprVector::From(numPoint);
        r = q.Rotate(r);
        r = r.Plus(trans);
    } else if(type == Type::FACE_N_TRANS) {
        ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
        r = ExprVector::From(numPoint);
        r = r.Plus(trans.ScaledBy(Expr::From(timesApplied)));
    } else if(type == Type::FACE_N_ROT_AA) {
        ExprVector trans = ExprVector::From(param[0], param[1], param[2]);
        ExprQuaternion q = GetAxisAngleQuaternionExprs(3);
        r = ExprVector::From(numPoint);
        r = r.Minus(trans);
        r = q.Rotate(r);
        r = r.Plus(trans);
    } else ssassert(false, "Unexpected entity type");
    return r;
}

Vector EntityBase::FaceGetPointNum() const {
    Vector r;
    if(type == Type::FACE_NORMAL_PT) {
        r = SK.GetEntity(point[0])-&gt;PointGetNum();
    } else if(type == Type::FACE_XPROD) {
        r = numPoint;
    } else if(type == Type::FACE_N_ROT_TRANS) {
        // The numerical point gets the rotation and translation.
        Vector trans = Vector::From(param[0], param[1], param[2]);
        Quaternion q = Quaternion::From(param[3], param[4], param[5], param[6]);
        r = q.Rotate(numPoint);
        r = r.Plus(trans);
    } else if(type == Type::FACE_N_TRANS) {
        Vector trans = Vector::From(param[0], param[1], param[2]);
        r = numPoint.Plus(trans.ScaledBy(timesApplied));
    } else if(type == Type::FACE_N_ROT_AA) {
        Vector trans = Vector::From(param[0], param[1], param[2]);
        Quaternion q = GetAxisAngleQuaternion(3);
        r = numPoint.Minus(trans);
        r = q.Rotate(r);
        r = r.Plus(trans);
    } else ssassert(false, "Unexpected entity type");
    return r;
}

</t>
<t tx="leo.20191228122643.127">bool EntityBase::HasEndpoints() const {
    return (type == Type::LINE_SEGMENT) ||
           (type == Type::CUBIC) ||
           (type == Type::ARC_OF_CIRCLE);
}
Vector EntityBase::EndpointStart() const {
    if(type == Type::LINE_SEGMENT) {
        return SK.GetEntity(point[0])-&gt;PointGetNum();
    } else if(type == Type::CUBIC) {
        return CubicGetStartNum();
    } else if(type == Type::ARC_OF_CIRCLE) {
        return SK.GetEntity(point[1])-&gt;PointGetNum();
    } else ssassert(false, "Unexpected entity type");
}
Vector EntityBase::EndpointFinish() const {
    if(type == Type::LINE_SEGMENT) {
        return SK.GetEntity(point[1])-&gt;PointGetNum();
    } else if(type == Type::CUBIC) {
        return CubicGetFinishNum();
    } else if(type == Type::ARC_OF_CIRCLE) {
        return SK.GetEntity(point[2])-&gt;PointGetNum();
    } else ssassert(false, "Unexpected entity type");
}
</t>
<t tx="leo.20191228122643.128">static bool PointInPlane(hEntity h, Vector norm, double distance) {
    Vector p = SK.GetEntity(h)-&gt;PointGetNum();
    return (fabs(norm.Dot(p) - distance) &lt; LENGTH_EPS);
}
</t>
<t tx="leo.20191228122643.129">bool EntityBase::IsInPlane(Vector norm, double distance) const {
    switch(type) {
        case Type::LINE_SEGMENT: {
            return PointInPlane(point[0], norm, distance)
                &amp;&amp; PointInPlane(point[1], norm, distance);
        }
        case Type::CUBIC:
        case Type::CUBIC_PERIODIC: {
            bool periodic = type == Type::CUBIC_PERIODIC;
            int n = periodic ? 3 + extraPoints : extraPoints;
            int i;
            for (i=0; i&lt;n; i++) {
                if (!PointInPlane(point[i], norm, distance)) return false;
            }
            return true;
        }

        case Type::CIRCLE:
        case Type::ARC_OF_CIRCLE: {
            // If it is an (arc of) a circle, check whether the normals
            // are parallel and the mid point is in the plane.
            Vector n = Normal()-&gt;NormalN();
            if (!norm.Equals(n) &amp;&amp; !norm.Equals(n.Negated())) return false;
            return PointInPlane(point[0], norm, distance);
        }

        case Type::TTF_TEXT: {
            Vector n = Normal()-&gt;NormalN();
            if (!norm.Equals(n) &amp;&amp; !norm.Equals(n.Negated())) return false;
            return PointInPlane(point[0], norm, distance)
                &amp;&amp; PointInPlane(point[1], norm, distance);
        }

        default:
            return false;
    }
}

</t>
<t tx="leo.20191228122643.13">    auto it = std::unique(refs.begin(), refs.end(),
                          [](Vector a, Vector b) { return a.Equals(b); });
    refs.erase(it, refs.end());
    for(Vector p : refs) {
        canvas-&gt;DrawLine(topLeft, p, hcsEmphasis);
    }
}
</t>
<t tx="leo.20191228122643.130">void EntityBase::RectGetPointsExprs(ExprVector *eb, ExprVector *ec) const {
    ssassert(type == Type::TTF_TEXT || type == Type::IMAGE,
             "Unexpected entity type");

    EntityBase *a = SK.GetEntity(point[0]);
    EntityBase *o = SK.GetEntity(point[1]);

    // Write equations for each point in the current workplane.
    // This reduces the complexity of resulting equations.
    ExprVector ea = a-&gt;PointGetExprsInWorkplane(workplane);
    ExprVector eo = o-&gt;PointGetExprsInWorkplane(workplane);

    // Take perpendicular vector and scale it by aspect ratio.
    ExprVector eu = ea.Minus(eo);
    ExprVector ev = ExprVector::From(eu.y, eu.x-&gt;Negate(), eu.z).ScaledBy(Expr::From(aspectRatio));

    *eb = eo.Plus(ev);
    *ec = eo.Plus(eu).Plus(ev);
}

</t>
<t tx="leo.20191228122643.131">void EntityBase::AddEq(IdList&lt;Equation,hEquation&gt; *l, Expr *expr, int index) const {
    Equation eq;
    eq.e = expr;
    eq.h = h.equation(index);
    l-&gt;Add(&amp;eq);
}

</t>
<t tx="leo.20191228122643.132">void EntityBase::GenerateEquations(IdList&lt;Equation,hEquation&gt; *l) const {
    switch(type) {
        case Type::NORMAL_IN_3D: {
            ExprQuaternion q = NormalGetExprs();
            AddEq(l, (q.Magnitude())-&gt;Minus(Expr::From(1)), 0);
            break;
        }

        case Type::ARC_OF_CIRCLE: {
            // If this is a copied entity, with its point already fixed
            // with respect to each other, then we don't want to generate
            // the distance constraint!
            if(SK.GetEntity(point[0])-&gt;type != Type::POINT_IN_2D) break;

            // If the two endpoints of the arc are constrained coincident
            // (to make a complete circle), then our distance constraint
            // would be redundant and therefore overconstrain things.
            @others
}
</t>
<t tx="leo.20191228122643.133">        auto it = std::find_if(SK.constraint.begin(), SK.constraint.end(),
                               [&amp;](ConstraintBase const &amp;con) {
                                   return (con.group == group) &amp;&amp;
                                          (con.type == Constraint::Type::POINTS_COINCIDENT) &amp;&amp;
                                          ((con.ptA == point[1] &amp;&amp; con.ptB == point[2]) ||
                                           (con.ptA == point[2] &amp;&amp; con.ptB == point[1]));
                               });
        if(it != SK.constraint.end()) {
            break;
        }

        Expr *ra = Constraint::Distance(workplane, point[0], point[1]);
        Expr *rb = Constraint::Distance(workplane, point[0], point[2]);
        AddEq(l, ra-&gt;Minus(rb), 0);
        break;
    }

    case Type::IMAGE:
    case Type::TTF_TEXT: {
        if(SK.GetEntity(point[0])-&gt;type != Type::POINT_IN_2D) break;
        EntityBase *b = SK.GetEntity(point[2]);
        EntityBase *c = SK.GetEntity(point[3]);
        ExprVector eb = b-&gt;PointGetExprsInWorkplane(workplane);
        ExprVector ec = c-&gt;PointGetExprsInWorkplane(workplane);

        ExprVector ebp, ecp;
        RectGetPointsExprs(&amp;ebp, &amp;ecp);

        ExprVector beq = eb.Minus(ebp);
        AddEq(l, beq.x, 0);
        AddEq(l, beq.y, 1);
        ExprVector ceq = ec.Minus(ecp);
        AddEq(l, ceq.x, 2);
        AddEq(l, ceq.y, 3);
        break;
    }

    default: // Most entities do not generate equations.
        break;
}
</t>
<t tx="leo.20191228122643.134">@path ./src/
//-----------------------------------------------------------------------------
// The 2d vector output stuff that isn't specific to any particular file
// format: getting the appropriate lines and curves, performing hidden line
// removal, calculating bounding boxes, and so on. Also raster and triangle
// mesh output.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"
#include "config.h"

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122643.135">void SolveSpaceUI::ExportSectionTo(const Platform::Path &amp;filename) {
    Vector gn = (SS.GW.projRight).Cross(SS.GW.projUp);
    gn = gn.WithMagnitude(1);

    Group *g = SK.GetGroup(SS.GW.activeGroup);
    g-&gt;GenerateDisplayItems();
    if(g-&gt;displayMesh.IsEmpty()) {
        Error(_("No solid model present; draw one with extrudes and revolves, "
                "or use Export 2d View to export bare lines and curves."));
        return;
    }

    // The plane in which the exported section lies; need this because we'll
    // reorient from that plane into the xy plane before exporting.
    Vector origin, u, v, n;
    double d;

    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;
    if((gs.n == 0 &amp;&amp; g-&gt;activeWorkplane != Entity::FREE_IN_3D)) {
        Entity *wrkpl = SK.GetEntity(g-&gt;activeWorkplane);
        origin = wrkpl-&gt;WorkplaneGetOffset();
        n = wrkpl-&gt;Normal()-&gt;NormalN();
        u = wrkpl-&gt;Normal()-&gt;NormalU();
        v = wrkpl-&gt;Normal()-&gt;NormalV();
    } else if(gs.n == 1 &amp;&amp; gs.faces == 1) {
        Entity *face = SK.GetEntity(gs.entity[0]);
        origin = face-&gt;FaceGetPointNum();
        n = face-&gt;FaceGetNormalNum();
        if(n.Dot(gn) &lt; 0) n = n.ScaledBy(-1);
        u = n.Normal(0);
        v = n.Normal(1);
    } else if(gs.n == 3 &amp;&amp; gs.vectors == 2 &amp;&amp; gs.points == 1) {
        Vector ut = SK.GetEntity(gs.entity[0])-&gt;VectorGetNum(),
               vt = SK.GetEntity(gs.entity[1])-&gt;VectorGetNum();
        ut = ut.WithMagnitude(1);
        vt = vt.WithMagnitude(1);

        if(fabs(SS.GW.projUp.Dot(vt)) &lt; fabs(SS.GW.projUp.Dot(ut))) {
            swap(ut, vt);
        }
        if(SS.GW.projRight.Dot(ut) &lt; 0) ut = ut.ScaledBy(-1);
        if(SS.GW.projUp.   Dot(vt) &lt; 0) vt = vt.ScaledBy(-1);

        origin = SK.GetEntity(gs.point[0])-&gt;PointGetNum();
        n = ut.Cross(vt);
        u = ut.WithMagnitude(1);
        v = (n.Cross(u)).WithMagnitude(1);
    } else {
        Error(_("Bad selection for export section. Please select:\n\n"
                "    * nothing, with an active workplane "
                          "(workplane is section plane)\n"
                "    * a face (section plane through face)\n"
                "    * a point and two line segments "
                          "(plane through point and parallel to lines)\n"));
        return;
    }
    SS.GW.ClearSelection();

    n = n.WithMagnitude(1);
    d = origin.Dot(n);

    SEdgeList el = {};
    SBezierList bl = {};

    // If there's a mesh, then grab the edges from it.
    g-&gt;runningMesh.MakeEdgesInPlaneInto(&amp;el, n, d);

    // If there's a shell, then grab the edges and possibly Beziers.
    bool export_as_pwl = SS.exportPwlCurves || fabs(SS.exportOffset) &gt; LENGTH_EPS;
    g-&gt;runningShell.MakeSectionEdgesInto(n, d, &amp;el, export_as_pwl ? NULL : &amp;bl);

    // All of these are solid model edges, so use the appropriate style.
    SEdge *se;
    for(se = el.l.First(); se; se = el.l.NextAfter(se)) {
        se-&gt;auxA = Style::SOLID_EDGE;
    }
    SBezier *sb;
    for(sb = bl.l.First(); sb; sb = bl.l.NextAfter(sb)) {
        sb-&gt;auxA = Style::SOLID_EDGE;
    }

    // Remove all overlapping edges/beziers to merge the areas they describe.
    el.CullExtraneousEdges(/*both=*/true);
    bl.CullIdenticalBeziers(/*both=*/true);

    // Collect lines and beziers with custom style &amp; export.
    for(auto &amp;ent : SK.entity) {
        Entity *e = &amp;ent;
        if (!e-&gt;IsVisible()) continue;
        if (e-&gt;style.v &lt; Style::FIRST_CUSTOM) continue;
        if (!Style::Exportable(e-&gt;style.v)) continue;
        if (!e-&gt;IsInPlane(n,d)) continue;
        if (export_as_pwl) {
            e-&gt;GenerateEdges(&amp;el);
        } else {
            e-&gt;GenerateBezierCurves(&amp;bl);
        }
    }

    // Only remove half of the overlapping edges/beziers to support TTF Stick Fonts.
    el.CullExtraneousEdges(/*both=*/false);
    bl.CullIdenticalBeziers(/*both=*/false);

    // And write the edges.
    VectorFileWriter *out = VectorFileWriter::ForFile(filename);
    if(out) {
        // parallel projection (no perspective), and no mesh
        ExportLinesAndMesh(&amp;el, &amp;bl, NULL,
                           u, v, n, origin, 0,
                           out);
    }
    el.Clear();
    bl.Clear();
}

// This is an awful temporary hack to replace Constraint::GetEdges until we have proper
// export through Canvas.
</t>
<t tx="leo.20191228122643.136">class GetEdgesCanvas : public Canvas {
public:
    Camera     camera;
    SEdgeList *edges;

    @others
};

</t>
<t tx="leo.20191228122643.137">const Camera &amp;GetCamera() const override {
    return camera;
}

</t>
<t tx="leo.20191228122643.138">void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) override {
    edges-&gt;AddEdge(a, b, Style::CONSTRAINT);
}
</t>
<t tx="leo.20191228122643.139">void DrawEdges(const SEdgeList &amp;el, hStroke hcs) override {
    for(const SEdge &amp;e : el.l) {
        edges-&gt;AddEdge(e.a, e.b, Style::CONSTRAINT);
    }
}
</t>
<t tx="leo.20191228122643.14">void GraphicsWindow::ClearSelection() {
    selection.Clear();
    SS.ScheduleShowTW();
    Invalidate();
}

</t>
<t tx="leo.20191228122643.140">void DrawVectorText(const std::string &amp;text, double height,
                    const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                    hStroke hcs) override {
    auto traceEdge = [&amp;](Vector a, Vector b) { edges-&gt;AddEdge(a, b, Style::CONSTRAINT); };
    VectorFont::Builtin()-&gt;Trace(height, o, u, v, text, traceEdge, camera);
}

</t>
<t tx="leo.20191228122643.141">void DrawQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d,
              hFill hcf) override {
    // Do nothing
}

</t>
<t tx="leo.20191228122643.142">bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo.20191228122643.143">void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo.20191228122643.144">void DrawPoint(const Vector &amp;o, hStroke hcs) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo.20191228122643.145">void DrawPolygon(const SPolygon &amp;p, hFill hcf) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo.20191228122643.146">void DrawMesh(const SMesh &amp;m, hFill hcfFront, hFill hcfBack = {}) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo.20191228122643.147">void DrawFaces(const SMesh &amp;m, const std::vector&lt;uint32_t&gt; &amp;faces, hFill hcf) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo.20191228122643.148">void DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
                        const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                        const Point2d &amp;ta, const Point2d &amp;tb, hFill hcf) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo.20191228122643.149">void InvalidatePixmap(std::shared_ptr&lt;const Pixmap&gt; pm) override {
    ssassert(false, "Not implemented");
}
</t>
<t tx="leo.20191228122643.15">void GraphicsWindow::ClearNonexistentSelectionItems() {
    bool change = false;
    Selection *s;
    selection.ClearTags();
    for(s = selection.First(); s; s = selection.NextAfter(s)) {
        if(s-&gt;constraint.v &amp;&amp; !(SK.constraint.FindByIdNoOops(s-&gt;constraint))) {
            s-&gt;tag = 1;
            change = true;
        }
        if(s-&gt;entity.v &amp;&amp; !(SK.entity.FindByIdNoOops(s-&gt;entity))) {
            s-&gt;tag = 1;
            change = true;
        }
    }
    selection.RemoveTagged();
    if(change) Invalidate();
}

//-----------------------------------------------------------------------------
// Is this entity/constraint selected?
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122643.150">void SolveSpaceUI::ExportViewOrWireframeTo(const Platform::Path &amp;filename, bool exportWireframe) {
    SEdgeList edges = {};
    SBezierList beziers = {};

    VectorFileWriter *out = VectorFileWriter::ForFile(filename);
    if(!out) return;

    SS.exportMode = true;
    GenerateAll(Generate::ALL);

    SMesh *sm = NULL;
    if(SS.GW.showShaded || SS.GW.drawOccludedAs != GraphicsWindow::DrawOccludedAs::VISIBLE) {
        Group *g = SK.GetGroup(SS.GW.activeGroup);
        g-&gt;GenerateDisplayItems();
        sm = &amp;(g-&gt;displayMesh);
    }
    if(sm &amp;&amp; sm-&gt;IsEmpty()) {
        sm = NULL;
    }

    for(auto &amp;entity : SK.entity) {
        Entity *e = &amp;entity;
        if(!e-&gt;IsVisible()) continue;
        if(e-&gt;construction) continue;

        if(SS.exportPwlCurves || sm || fabs(SS.exportOffset) &gt; LENGTH_EPS)
        {
            // We will be doing hidden line removal, which we can't do on
            // exact curves; so we need things broken down to pwls. Same
            // problem with cutter radius compensation.
            e-&gt;GenerateEdges(&amp;edges);
        } else {
            e-&gt;GenerateBezierCurves(&amp;beziers);
        }
    }

    if(SS.GW.showEdges || SS.GW.showOutlines) {
        Group *g = SK.GetGroup(SS.GW.activeGroup);
        g-&gt;GenerateDisplayItems();
        if(SS.GW.showEdges) {
            g-&gt;displayOutlines.ListTaggedInto(&amp;edges, Style::SOLID_EDGE);
        }
    }

    if(SS.GW.showConstraints) {
        if(!out-&gt;OutputConstraints(&amp;SK.constraint)) {
            GetEdgesCanvas canvas = {};
            canvas.camera = SS.GW.GetCamera();
            canvas.edges  = &amp;edges;

            // The output format cannot represent constraints directly,
            // so convert them to edges.
            for(Constraint &amp;c : SK.constraint) {
                c.Draw(Constraint::DrawAs::DEFAULT, &amp;canvas);
            }

            canvas.Clear();
        }
    }

    if(exportWireframe) {
        Vector u = Vector::From(1.0, 0.0, 0.0),
               v = Vector::From(0.0, 1.0, 0.0),
               n = Vector::From(0.0, 0.0, 1.0),
               origin = Vector::From(0.0, 0.0, 0.0);
        double cameraTan = 0.0,

        out-&gt;SetModelviewProjection(u, v, n, origin,
                                    SS.CameraTangent()*SS.GW.scale, SS.exportScale);

        ExportLinesAndMesh(&amp;edges, &amp;beziers, sm,
                           u, v, n, origin, SS.CameraTangent()*SS.GW.scale,
                           out);

        if(!out-&gt;HasCanvasSize()) {
            // These file formats don't have a canvas size, so they just
            // get exported in the raw coordinate system. So indicate what
            // that was on-screen.
            SS.justExportedInfo.showOrigin = true;
            SS.justExportedInfo.pt = origin;
            SS.justExportedInfo.u = u;
            SS.justExportedInfo.v = v;
        } else {
            SS.justExportedInfo.showOrigin = false;
        }

        SS.justExportedInfo.draw = true;
        GW.Invalidate();
    }

    edges.Clear();
    beziers.Clear();
}

</t>
<t tx="leo.20191228122643.151">void SolveSpaceUI::ExportWireframeCurves(SEdgeList *sel, SBezierList *sbl,
                           VectorFileWriter *out)
{
    SBezierLoopSetSet sblss = {};
    SEdge *se;
    for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
        SBezier sb = SBezier::From(
                                (se-&gt;a).ScaledBy(1.0 / SS.exportScale),
                                (se-&gt;b).ScaledBy(1.0 / SS.exportScale));
        sblss.AddOpenPath(&amp;sb);
    }

    sbl-&gt;ScaleSelfBy(1.0/SS.exportScale);
    SBezier *sb;
    for(sb = sbl-&gt;l.First(); sb; sb = sbl-&gt;l.NextAfter(sb)) {
        sblss.AddOpenPath(sb);
    }

    out-&gt;OutputLinesAndMesh(&amp;sblss, NULL);
    sblss.Clear();
}

</t>
<t tx="leo.20191228122643.152">void SolveSpaceUI::ExportLinesAndMesh(SEdgeList *sel, SBezierList *sbl, SMesh *sm,
                                      Vector u, Vector v, Vector n,
                                      Vector origin, double cameraTan,
                                      VectorFileWriter *out)
{
    double s = 1.0 / SS.exportScale;

    // Project into the export plane; so when we're done, z doesn't matter,
    // and x and y are what goes in the DXF.
    for(SEdge *e = sel-&gt;l.First(); e; e = sel-&gt;l.NextAfter(e)) {
        // project into the specified csys, and apply export scale
        (e-&gt;a) = e-&gt;a.InPerspective(u, v, n, origin, cameraTan).ScaledBy(s);
        (e-&gt;b) = e-&gt;b.InPerspective(u, v, n, origin, cameraTan).ScaledBy(s);
    }

    if(sbl) {
        for(SBezier *b = sbl-&gt;l.First(); b; b = sbl-&gt;l.NextAfter(b)) {
            *b = b-&gt;InPerspective(u, v, n, origin, cameraTan);
            int i;
            for(i = 0; i &lt;= b-&gt;deg; i++) {
                b-&gt;ctrl[i] = (b-&gt;ctrl[i]).ScaledBy(s);
            }
        }
    }

    // If cutter radius compensation is requested, then perform it now
    if(fabs(SS.exportOffset) &gt; LENGTH_EPS) {
        // assemble those edges into a polygon, and clear the edge list
        SPolygon sp = {};
        sel-&gt;AssemblePolygon(&amp;sp, NULL);
        sel-&gt;Clear();

        SPolygon compd = {};
        sp.normal = Vector::From(0, 0, -1);
        sp.FixContourDirections();
        sp.OffsetInto(&amp;compd, SS.exportOffset*s);
        sp.Clear();

        compd.MakeEdgesInto(sel);
        compd.Clear();
    }

    // Now the triangle mesh; project, then build a BSP to perform
    // occlusion testing and generated the shaded surfaces.
    SMesh smp = {};
    if(sm) {
        Vector l0 = (SS.lightDir[0]).WithMagnitude(1),
               l1 = (SS.lightDir[1]).WithMagnitude(1);
        STriangle *tr;
        for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
            STriangle tt = *tr;
            tt.a = (tt.a).InPerspective(u, v, n, origin, cameraTan).ScaledBy(s);
            tt.b = (tt.b).InPerspective(u, v, n, origin, cameraTan).ScaledBy(s);
            tt.c = (tt.c).InPerspective(u, v, n, origin, cameraTan).ScaledBy(s);

            // And calculate lighting for the triangle
            Vector n = tt.Normal().WithMagnitude(1);
            double lighting = SS.ambientIntensity +
    SMesh sms = {};

    // We need the mesh for occlusion testing, but if we don't/can't export it,
    // don't generate it.
    if(SS.GW.showShaded &amp;&amp; out-&gt;CanOutputMesh()) {
        // Use the BSP routines to generate the split triangles in paint order.
        SBsp3 *bsp = SBsp3::FromMesh(&amp;smp);
        if(bsp) bsp-&gt;GenerateInPaintOrder(&amp;sms);
        // And cull the back-facing triangles
        STriangle *tr;
        sms.l.ClearTags();
        for(tr = sms.l.First(); tr; tr = sms.l.NextAfter(tr)) {
            Vector n = tr-&gt;Normal();
            if(n.z &lt; 0) {
                tr-&gt;tag = 1;
            }
        }
        sms.l.RemoveTagged();
    }

    // And now we perform hidden line removal if requested
    SEdgeList hlrd = {};
    if(sm) {
        SKdNode *root = SKdNode::From(&amp;smp);

        // Generate the edges where a curved surface turns from front-facing
        // to back-facing.
        if(SS.GW.showEdges || SS.GW.showOutlines) {
            root-&gt;MakeCertainEdgesInto(sel, EdgeKind::TURNING,
                                       /*coplanarIsInter=*/false, NULL, NULL,
                                       GW.showOutlines ? Style::OUTLINE : Style::SOLID_EDGE);
        }

        root-&gt;ClearTags();
        int cnt = 1234;

        SEdge *se;
        for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
            if(se-&gt;auxA == Style::CONSTRAINT) {
                // Constraints should not get hidden line removed; they're
                // always on top.
                hlrd.AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA);
                continue;
            }

            SEdgeList edges = {};
            // Split the original edge against the mesh
            edges.AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA);
            root-&gt;OcclusionTestLine(*se, &amp;edges, cnt);
            if(SS.GW.drawOccludedAs == GraphicsWindow::DrawOccludedAs::STIPPLED) {
                for(SEdge &amp;se : edges.l) {
                    if(se.tag == 1) {
                        se.auxA = Style::HIDDEN_EDGE;
                    }
                }
            } else if(SS.GW.drawOccludedAs == GraphicsWindow::DrawOccludedAs::INVISIBLE) {
                edges.l.RemoveTagged();
            }

            // the occlusion test splits unnecessarily; so fix those
            edges.MergeCollinearSegments(se-&gt;a, se-&gt;b);
            cnt++;
            // And add the results to our output
            SEdge *sen;
            for(sen = edges.l.First(); sen; sen = edges.l.NextAfter(sen)) {
                hlrd.AddEdge(sen-&gt;a, sen-&gt;b, sen-&gt;auxA);
            }
            edges.Clear();
        }

        sel = &amp;hlrd;
    }

    // Clean up: remove overlapping line segments and
    // segments with zero-length projections.
    sel-&gt;l.ClearTags();
    for(int i = 0; i &lt; sel-&gt;l.n; ++i) {
        SEdge *sei = &amp;sel-&gt;l[i];
        hStyle hsi = { (uint32_t)sei-&gt;auxA };
        Style *si = Style::Get(hsi);
        if(sei-&gt;tag != 0) continue;

        // Remove segments with zero length projections.
        Vector ai = sei-&gt;a;
        ai.z = 0.0;
        Vector bi = sei-&gt;b;
        bi.z = 0.0;
        Vector di = bi.Minus(ai);
        if(fabs(di.x) &lt; LENGTH_EPS &amp;&amp; fabs(di.y) &lt; LENGTH_EPS) {
            sei-&gt;tag = 1;
            continue;
        }

        for(int j = i + 1; j &lt; sel-&gt;l.n; ++j) {
            SEdge *sej = &amp;sel-&gt;l[j];
            if(sej-&gt;tag != 0) continue;

            Vector *pAj = &amp;sej-&gt;a;
            Vector *pBj = &amp;sej-&gt;b;

            // Remove segments with zero length projections.
            Vector aj = sej-&gt;a;
            aj.z = 0.0;
            Vector bj = sej-&gt;b;
            bj.z = 0.0;
            Vector dj = bj.Minus(aj);
            if(fabs(dj.x) &lt; LENGTH_EPS &amp;&amp; fabs(dj.y) &lt; LENGTH_EPS) {
                sej-&gt;tag = 1;
                continue;
            }

            // Skip non-collinear segments.
            const double eps = 1e-6;
            if(aj.DistanceToLine(ai, di) &gt; eps) continue;
            if(bj.DistanceToLine(ai, di) &gt; eps) continue;

            double ta = aj.Minus(ai).Dot(di) / di.Dot(di);
            double tb = bj.Minus(ai).Dot(di) / di.Dot(di);
            if(ta &gt; tb) {
                std::swap(pAj, pBj);
                std::swap(ta, tb);
            }

            hStyle hsj = { (uint32_t)sej-&gt;auxA };
            Style *sj = Style::Get(hsj);

            bool canRemoveI = sej-&gt;auxA == sei-&gt;auxA || si-&gt;zIndex &lt; sj-&gt;zIndex;
            bool canRemoveJ = sej-&gt;auxA == sei-&gt;auxA || sj-&gt;zIndex &lt; si-&gt;zIndex;

            if(canRemoveJ) {
                // j-segment inside i-segment
                if(ta &gt; 0.0 - eps &amp;&amp; tb &lt; 1.0 + eps) {
                    sej-&gt;tag = 1;
                    continue;
                }

                // cut segment
                bool aInside = ta &gt; 0.0 - eps &amp;&amp; ta &lt; 1.0 + eps;
                if(tb &gt; 1.0 - eps &amp;&amp; aInside) {
                    *pAj = sei-&gt;b;
                    continue;
                }

                // cut segment
                bool bInside = tb &gt; 0.0 - eps &amp;&amp; tb &lt; 1.0 + eps;
                if(ta &lt; 0.0 - eps &amp;&amp; bInside) {
                    *pBj = sei-&gt;a;
                    continue;
                }

                // split segment
                if(ta &lt; 0.0 - eps &amp;&amp; tb &gt; 1.0 + eps) {
                    sel-&gt;AddEdge(sei-&gt;b, *pBj, sej-&gt;auxA, sej-&gt;auxB);
                    *pBj = sei-&gt;a;
                    continue;
                }
            }

            if(canRemoveI) {
                // j-segment inside i-segment
                if(ta &lt; 0.0 + eps &amp;&amp; tb &gt; 1.0 - eps) {
                    sei-&gt;tag = 1;
                    break;
                }

                // cut segment
                bool aInside = ta &gt; 0.0 + eps &amp;&amp; ta &lt; 1.0 - eps;
                if(tb &gt; 1.0 - eps &amp;&amp; aInside) {
                    sei-&gt;b = *pAj;
                    i--;
                    break;
                }

                // cut segment
                bool bInside = tb &gt; 0.0 + eps &amp;&amp; tb &lt; 1.0 - eps;
                if(ta &lt; 0.0 + eps &amp;&amp; bInside) {
                    sei-&gt;a = *pBj;
                    i--;
                    break;
                }

                // split segment
                if(ta &gt; 0.0 + eps &amp;&amp; tb &lt; 1.0 - eps) {
                    sel-&gt;AddEdge(*pBj, sei-&gt;b, sei-&gt;auxA, sei-&gt;auxB);
                    sei-&gt;b = *pAj;
                    i--;
                    break;
                }
            }
        }
    }
    sel-&gt;l.RemoveTagged();

    // We kept the line segments and Beziers separate until now; but put them
    // all together, and also project everything into the xy plane, since not
    // all export targets ignore the z component of the points.
    ssassert(sbl != nullptr, "Adding line segments to beziers assumes bezier list is non-null.");
    for(SEdge *e = sel-&gt;l.First(); e; e = sel-&gt;l.NextAfter(e)) {
        SBezier sb = SBezier::From(e-&gt;a, e-&gt;b);
        sb.auxA = e-&gt;auxA;
        sbl-&gt;l.Add(&amp;sb);
    }
    for(SBezier *b = sbl-&gt;l.First(); b; b = sbl-&gt;l.NextAfter(b)) {
        for(int i = 0; i &lt;= b-&gt;deg; i++) {
            b-&gt;ctrl[i].z = 0;
        }
    }

    // If possible, then we will assemble these output curves into loops. They
    // will then get exported as closed paths.
    SBezierLoopSetSet sblss = {};
    SBezierLoopSet leftovers = {};
    SSurface srf = SSurface::FromPlane(Vector::From(0, 0, 0),
                                       Vector::From(1, 0, 0),
                                       Vector::From(0, 1, 0));
    SPolygon spxyz = {};
    bool allClosed;
    SEdge notClosedAt;
    sbl-&gt;l.ClearTags();
    sblss.FindOuterFacesFrom(sbl, &amp;spxyz, &amp;srf,
                             SS.ExportChordTolMm(),
                             &amp;allClosed, &amp;notClosedAt,
                             NULL, NULL,
                             &amp;leftovers);
    sblss.l.Add(&amp;leftovers);

    // Now write the lines and triangles to the output file
    out-&gt;OutputLinesAndMesh(&amp;sblss, &amp;sms);

    spxyz.Clear();
    sblss.Clear();
    smp.Clear();
    sms.Clear();
    hlrd.Clear();
}

double VectorFileWriter::MmToPts(double mm) {
    // 72 points in an inch
    return (mm/25.4)*72;
}

VectorFileWriter *VectorFileWriter::ForFile(const Platform::Path &amp;filename) {
    VectorFileWriter *ret;
    bool needOpen = true;
    if(filename.HasExtension("dxf")) {
        static DxfFileWriter DxfWriter;
        ret = &amp;DxfWriter;
        needOpen = false;
    } else if(filename.HasExtension("ps") || filename.HasExtension("eps")) {
        static EpsFileWriter EpsWriter;
        ret = &amp;EpsWriter;
    } else if(filename.HasExtension("pdf")) {
        static PdfFileWriter PdfWriter;
        ret = &amp;PdfWriter;
    } else if(filename.HasExtension("svg")) {
        static SvgFileWriter SvgWriter;
        ret = &amp;SvgWriter;
    } else if(filename.HasExtension("plt") || filename.HasExtension("hpgl")) {
        static HpglFileWriter HpglWriter;
        ret = &amp;HpglWriter;
    } else if(filename.HasExtension("step") || filename.HasExtension("stp")) {
        static Step2dFileWriter Step2dWriter;
        ret = &amp;Step2dWriter;
    } else if(filename.HasExtension("txt") || filename.HasExtension("ngc")) {
        static GCodeFileWriter GCodeWriter;
        ret = &amp;GCodeWriter;
    } else {
        Error("Can't identify output file type from file extension of "
        "filename '%s'; try "
        ".step, .stp, .dxf, .svg, .plt, .hpgl, .pdf, .txt, .ngc, "
        ".eps, or .ps.",
            filename.raw.c_str());
        return NULL;
    }
    ret-&gt;filename = filename;
    if(!needOpen) return ret;

    FILE *f = OpenFile(filename, "wb");
    if(!f) {
        Error("Couldn't write to '%s'", filename.raw.c_str());
        return NULL;
    }
    ret-&gt;f = f;
    return ret;
}

</t>
<t tx="leo.20191228122643.16">bool GraphicsWindow::IsSelected(hEntity he) {
    Selection s = {};
    s.entity = he;
    return IsSelected(&amp;s);
}
</t>
<t tx="leo.20191228122643.17">bool GraphicsWindow::IsSelected(Selection *st) {
    Selection *s;
    for(s = selection.First(); s; s = selection.NextAfter(s)) {
        if(s-&gt;Equals(st)) {
            return true;
        }
    }
    return false;
}

//-----------------------------------------------------------------------------
// Unselect an item, if it is selected. We can either unselect just that item,
// or also unselect any coincident points. The latter is useful if the user
// somehow selects two coincident points (like with select all), because it
// would otherwise be impossible to de-select the lower of the two.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122643.18">void GraphicsWindow::MakeUnselected(hEntity he, bool coincidentPointTrick) {
    Selection stog = {};
    stog.entity = he;
    MakeUnselected(&amp;stog, coincidentPointTrick);
}
</t>
<t tx="leo.20191228122643.19">void GraphicsWindow::MakeUnselected(Selection *stog, bool coincidentPointTrick){
    if(stog-&gt;IsEmpty()) return;

    Selection *s;

    // If an item was selected, then we just un-select it.
    selection.ClearTags();
    for(s = selection.First(); s; s = selection.NextAfter(s)) {
        if(s-&gt;Equals(stog)) {
            s-&gt;tag = 1;
        }
    }
    // If two points are coincident, then it's impossible to hover one of
    // them. But make sure to deselect both, to avoid mysterious seeming
    // inability to deselect if the bottom one did somehow get selected.
    if(stog-&gt;entity.v &amp;&amp; coincidentPointTrick) {
        Entity *e = SK.GetEntity(stog-&gt;entity);
        if(e-&gt;IsPoint()) {
            Vector ep = e-&gt;PointGetNum();
            for(s = selection.First(); s; s = selection.NextAfter(s)) {
                if(!s-&gt;entity.v) continue;
                if(s-&gt;entity == stog-&gt;entity)
                    continue;
                Entity *se = SK.GetEntity(s-&gt;entity);
                if(!se-&gt;IsPoint()) continue;
                if(ep.Equals(se-&gt;PointGetNum())) {
                    s-&gt;tag = 1;
                }
            }
        }
    }
    selection.RemoveTagged();
}

//-----------------------------------------------------------------------------
// Select an item, if it isn't selected already.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122643.2">void TextWindow::ScreenSetTtfFont(int link, uint32_t v) {
    int i = (int)v;
    if(i &lt; 0) return;
    if(i &gt;= SS.fonts.l.n) return;

    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;
    if(gs.entities != 1 || gs.n != 1) return;

    Entity *e = SK.entity.FindByIdNoOops(gs.entity[0]);
    if(!e || e-&gt;type != Entity::Type::TTF_TEXT || !e-&gt;h.isFromRequest()) return;

    Request *r = SK.request.FindByIdNoOops(e-&gt;h.request());
    if(!r) return;

    SS.UndoRemember();
    r-&gt;font = SS.fonts.l[i].FontFileBaseName();
    SS.MarkGroupDirty(r-&gt;group);
    SS.ScheduleShowTW();
}

</t>
<t tx="leo.20191228122643.20">void GraphicsWindow::MakeSelected(hEntity he) {
    Selection stog = {};
    stog.entity = he;
    MakeSelected(&amp;stog);
}

</t>
<t tx="leo.20191228122643.21">void GraphicsWindow::MakeSelected(hConstraint hc) {
    Selection stog = {};
    stog.constraint = hc;
    MakeSelected(&amp;stog);
}

</t>
<t tx="leo.20191228122643.22">void GraphicsWindow::MakeSelected(Selection *stog) {
    if(stog-&gt;IsEmpty()) return;
    if(IsSelected(stog)) return;

    if(stog-&gt;entity.v != 0 &amp;&amp; SK.GetEntity(stog-&gt;entity)-&gt;IsFace()) {
        // In the interest of speed for the triangle drawing code,
        // only two faces may be selected at a time.
        int c = 0;
        Selection *s;
        selection.ClearTags();
        for(s = selection.First(); s; s = selection.NextAfter(s)) {
            hEntity he = s-&gt;entity;
            if(he.v != 0 &amp;&amp; SK.GetEntity(he)-&gt;IsFace()) {
                c++;
                if(c &gt;= 2) s-&gt;tag = 1;
            }
        }
        selection.RemoveTagged();
    }

    selection.Add(stog);
}

//-----------------------------------------------------------------------------
// Select everything that lies within the marquee view-aligned rectangle.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122643.23">void GraphicsWindow::SelectByMarquee() {
    Point2d marqueePoint = ProjectPoint(orig.marqueePoint);
    BBox marqueeBBox = BBox::From(Vector::From(marqueePoint.x, marqueePoint.y, -1),
                                  Vector::From(orig.mouse.x,   orig.mouse.y,    1));

    Entity *e;
    for(e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
        if(e-&gt;group != SS.GW.activeGroup) continue;
        if(e-&gt;IsFace() || e-&gt;IsDistance()) continue;
        if(!e-&gt;IsVisible()) continue;

        bool entityHasBBox;
        BBox entityBBox = e-&gt;GetOrGenerateScreenBBox(&amp;entityHasBBox);
        if(entityHasBBox &amp;&amp; entityBBox.Overlaps(marqueeBBox)) {
            MakeSelected(e-&gt;h);
        }
    }
}

//-----------------------------------------------------------------------------
// Sort the selection according to various critieria: the entities and
// constraints separately, counts of certain types of entities (circles,
// lines, etc.), and so on.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122643.24">void GraphicsWindow::GroupSelection() {
    gs = {};
    int i;
    for(i = 0; i &lt; selection.n; i++) {
        Selection *s = &amp;(selection[i]);
        if(s-&gt;entity.v) {
            (gs.n)++;

            Entity *e = SK.entity.FindById(s-&gt;entity);

            if(e-&gt;IsStylable()) gs.stylables++;

            // A list of points, and a list of all entities that aren't points.
            if(e-&gt;IsPoint()) {
                gs.points++;
                gs.point.push_back(s-&gt;entity);
            } else {
                gs.entities++;
                gs.entity.push_back(s-&gt;entity);
            }

            // And an auxiliary list of normals, including normals from
            // workplanes.
            if(e-&gt;IsNormal()) {
                gs.anyNormals++;
                gs.anyNormal.push_back(s-&gt;entity);
            } else if(e-&gt;IsWorkplane()) {
                gs.anyNormals++;
                gs.anyNormal.push_back(e-&gt;Normal()-&gt;h);
            }

            // And of vectors (i.e., stuff with a direction to constrain)
            if(e-&gt;HasVector()) {
                gs.vectors++;
                gs.vector.push_back(s-&gt;entity);
            }

            // Faces (which are special, associated/drawn with triangles)
            if(e-&gt;IsFace()) {
                gs.faces++;
                gs.face.push_back(s-&gt;entity);
            }

            if(e-&gt;HasEndpoints()) {
                (gs.withEndpoints)++;
            }

            // And some aux counts too
            switch(e-&gt;type) {
                case Entity::Type::WORKPLANE:      (gs.workplanes)++; break;
                case Entity::Type::LINE_SEGMENT:   (gs.lineSegments)++; break;
                case Entity::Type::CUBIC:          (gs.cubics)++; break;
                case Entity::Type::CUBIC_PERIODIC: (gs.periodicCubics)++; break;

                case Entity::Type::ARC_OF_CIRCLE:
                    (gs.circlesOrArcs)++;
                    (gs.arcs)++;
                    break;

                case Entity::Type::CIRCLE:         (gs.circlesOrArcs)++; break;

                default: break;
            }
        }
        if(s-&gt;constraint.v) {
            gs.constraints++;
            gs.constraint.push_back(s-&gt;constraint);
            Constraint *c = SK.GetConstraint(s-&gt;constraint);
            if(c-&gt;IsStylable()) gs.stylables++;
            if(c-&gt;HasLabel()) gs.constraintLabels++;
        }
    }
}

Camera GraphicsWindow::GetCamera() const {
    Camera camera = {};
    window-&gt;GetContentSize(&amp;camera.width, &amp;camera.height);
    camera.pixelRatio = window-&gt;GetDevicePixelRatio();
    camera.gridFit    = (window-&gt;GetDevicePixelRatio() == 1);
    camera.offset     = offset;
    camera.projUp     = projUp;
    camera.projRight  = projRight;
    camera.scale      = scale;
    camera.tangent    = SS.CameraTangent();
    return camera;
}

Lighting GraphicsWindow::GetLighting() const {
    Lighting lighting = {};
    lighting.backgroundColor   = SS.backgroundColor;
    lighting.ambientIntensity  = SS.ambientIntensity;
    lighting.lightIntensity[0] = SS.lightIntensity[0];
    lighting.lightIntensity[1] = SS.lightIntensity[1];
    lighting.lightDirection[0] = SS.lightDir[0];
    lighting.lightDirection[1] = SS.lightDir[1];
    return lighting;
}

GraphicsWindow::Selection GraphicsWindow::ChooseFromHoverToSelect() {
    Selection sel = {};
    if(hoverList.IsEmpty())
        return sel;

    Group *activeGroup = SK.GetGroup(SS.GW.activeGroup);
    int bestOrder = -1;
    int bestZIndex = 0;
    for(const Hover &amp;hov : hoverList) {
        hGroup hg = {};
        if(hov.selection.entity.v != 0) {
            hg = SK.GetEntity(hov.selection.entity)-&gt;group;
        } else if(hov.selection.constraint.v != 0) {
            hg = SK.GetConstraint(hov.selection.constraint)-&gt;group;
        }

        Group *g = SK.GetGroup(hg);
        if(g-&gt;order &gt; activeGroup-&gt;order) continue;
        if(bestOrder != -1 &amp;&amp; (bestOrder &gt;= g-&gt;order || bestZIndex &gt; hov.zIndex)) continue;
        bestOrder  = g-&gt;order;
        bestZIndex = hov.zIndex;
        sel = hov.selection;
    }
    return sel;
}

GraphicsWindow::Selection GraphicsWindow::ChooseFromHoverToDrag() {
    Selection sel = {};
    for(const Hover &amp;hov : hoverList) {
        if(hov.selection.entity.v == 0) continue;
        if(!hov.selection.entity.isFromRequest()) continue;
        sel = hov.selection;
        break;
    }
    if(!sel.IsEmpty()) {
        return sel;
    }
    return ChooseFromHoverToSelect();
}

</t>
<t tx="leo.20191228122643.25">void GraphicsWindow::HitTestMakeSelection(Point2d mp) {
    hoverList = {};
    Selection sel = {};

    // Did the view projection change? If so, invalidate bounding boxes.
    if(!offset.EqualsExactly(cached.offset) ||
           !projRight.EqualsExactly(cached.projRight) ||
           !projUp.EqualsExactly(cached.projUp) ||
           EXACT(scale != cached.scale)) {
        cached.offset = offset;
        cached.projRight = projRight;
        cached.projUp = projUp;
        cached.scale = scale;
        for(Entity *e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
            e-&gt;screenBBoxValid = false;
        }
    }

    ObjectPicker canvas = {};
    canvas.camera    = GetCamera();
    canvas.selRadius = 10.0;
    canvas.point     = mp;
    canvas.maxZIndex = -1;

    // Always do the entities; we might be dragging something that should
    // be auto-constrained, and we need the hover for that.
    for(Entity &amp;e : SK.entity) {
        if(!e.IsVisible()) continue;

        // If faces aren't selectable, image entities aren't either.
        if(e.type == Entity::Type::IMAGE &amp;&amp; !showFaces) continue;

        // Don't hover whatever's being dragged.
        if(IsFromPending(e.h.request())) {
            // The one exception is when we're creating a new cubic; we
            // want to be able to hover the first point, because that's
            // how we turn it into a periodic spline.
            if(!e.IsPoint()) continue;
            if(!e.h.isFromRequest()) continue;
            Request *r = SK.GetRequest(e.h.request());
            if(r-&gt;type != Request::Type::CUBIC) continue;
            if(r-&gt;extraPoints &lt; 2) continue;
            if(e.h.v != r-&gt;h.entity(1).v) continue;
        }

        if(canvas.Pick([&amp;]{ e.Draw(Entity::DrawAs::DEFAULT, &amp;canvas); })) {
            Hover hov = {};
            hov.distance = canvas.minDistance;
            hov.zIndex   = canvas.maxZIndex;
            hov.selection.entity = e.h;
            hoverList.Add(&amp;hov);
        }
    }

    // The constraints and faces happen only when nothing's in progress.
    if(pending.operation == Pending::NONE) {
        // Constraints
        for(Constraint &amp;c : SK.constraint) {
            if(canvas.Pick([&amp;]{ c.Draw(Constraint::DrawAs::DEFAULT, &amp;canvas); })) {
                Hover hov = {};
                hov.distance = canvas.minDistance;
                hov.zIndex   = canvas.maxZIndex;
                hov.selection.constraint = c.h;
                hoverList.Add(&amp;hov);
            }
        }
    }

    std::sort(hoverList.begin(), hoverList.end(),
        [](const Hover &amp;a, const Hover &amp;b) {
            if(a.zIndex == b.zIndex) return a.distance &lt; b.distance;
            return a.zIndex &gt; b.zIndex;
        });
    sel = ChooseFromHoverToSelect();

    if(pending.operation == Pending::NONE) {
        // Faces, from the triangle mesh; these are lowest priority
        if(sel.constraint.v == 0 &amp;&amp; sel.entity.v == 0 &amp;&amp; showShaded &amp;&amp; showFaces) {
            Group *g = SK.GetGroup(activeGroup);
            SMesh *m = &amp;(g-&gt;displayMesh);

            uint32_t v = m-&gt;FirstIntersectionWith(mp);
            if(v) {
                sel.entity.v = v;
            }
        }
    }

    canvas.Clear();

    if(!sel.Equals(&amp;hover)) {
        hover = sel;
        Invalidate();
    }
}

//-----------------------------------------------------------------------------
// Project a point in model space to screen space, exactly as gl would; return
// units are pixels.
//-----------------------------------------------------------------------------
Point2d GraphicsWindow::ProjectPoint(Vector p) {
    Vector p3 = ProjectPoint3(p);
    Point2d p2 = { p3.x, p3.y };
    return p2;
}
//-----------------------------------------------------------------------------
// Project a point in model space to screen space, exactly as gl would; return
// units are pixels. The z coordinate is also returned, also in pixels.
//-----------------------------------------------------------------------------
Vector GraphicsWindow::ProjectPoint3(Vector p) {
    double w;
    Vector r = ProjectPoint4(p, &amp;w);
    return r.ScaledBy(scale/w);
}
//-----------------------------------------------------------------------------
// Project a point in model space halfway into screen space. The scale is
// not applied, and the perspective divide isn't applied; instead the w
// coordinate is returned separately.
//-----------------------------------------------------------------------------
Vector GraphicsWindow::ProjectPoint4(Vector p, double *w) {
    p = p.Plus(offset);

    Vector r;
    r.x = p.Dot(projRight);
    r.y = p.Dot(projUp);
    r.z = p.Dot(projUp.Cross(projRight));

    *w = 1 + r.z*SS.CameraTangent()*scale;
    return r;
}

//-----------------------------------------------------------------------------
// Return a point in the plane parallel to the screen and through the offset,
// that projects onto the specified (x, y) coordinates.
//-----------------------------------------------------------------------------
Vector GraphicsWindow::UnProjectPoint(Point2d p) {
    Vector orig = offset.ScaledBy(-1);

    // Note that we ignoring the effects of perspective. Since our returned
    // point has the same component normal to the screen as the offset, it
    // will have z = 0 after the rotation is applied, thus w = 1. So this is
    // correct.
    orig = orig.Plus(projRight.ScaledBy(p.x / scale)).Plus(
                     projUp.   ScaledBy(p.y / scale));
    return orig;
}

Vector GraphicsWindow::UnProjectPoint3(Vector p) {
    p.z = p.z / (scale - p.z * SS.CameraTangent() * scale);
    double w = 1 + p.z * SS.CameraTangent() * scale;
    p.x *= w / scale;
    p.y *= w / scale;

    Vector orig = offset.ScaledBy(-1);
    orig = orig.Plus(projRight.ScaledBy(p.x)).Plus(
                     projUp.   ScaledBy(p.y).Plus(
                     projRight.Cross(projUp). ScaledBy(p.z)));
    return orig;
}

</t>
<t tx="leo.20191228122643.26">void GraphicsWindow::NormalizeProjectionVectors() {
    if(projRight.Magnitude() &lt; LENGTH_EPS) {
        projRight = Vector::From(1, 0, 0);
    }

    Vector norm = projRight.Cross(projUp);
    // If projRight and projUp somehow ended up parallel, then pick an
    // arbitrary projUp normal to projRight.
    if(norm.Magnitude() &lt; LENGTH_EPS) {
        norm = projRight.Normal(0);
    }
    projUp = norm.Cross(projRight);

    projUp = projUp.WithMagnitude(1);
    projRight = projRight.WithMagnitude(1);
}

</t>
<t tx="leo.20191228122643.27">void GraphicsWindow::DrawSnapGrid(Canvas *canvas) {
    if(!LockedInWorkplane()) return;

    const Camera &amp;camera = canvas-&gt;GetCamera();
    double width  = camera.width,
    wn = norm-&gt;NormalN();

    double g = SS.gridSpacing;

    @others
}

</t>
<t tx="leo.20191228122643.28">double umin = VERY_POSITIVE, umax = VERY_NEGATIVE,
       vmin = VERY_POSITIVE, vmax = VERY_NEGATIVE;
int a;
for(a = 0; a &lt; 4; a++) {
    // Ideally, we would just do +/- half the width and height; but
    // allow some extra slop for rounding.
    Vector horiz = projRight.ScaledBy((0.6*width)/scale  + 2*g),
           vert  = projUp.   ScaledBy((0.6*height)/scale + 2*g);
    if(a == 2 || a == 3) horiz = horiz.ScaledBy(-1);
    if(a == 1 || a == 3) vert  = vert. ScaledBy(-1);
    Vector tp = horiz.Plus(vert).Minus(offset);

    // Project the point into our grid plane, normal to the screen
    // (not to the grid plane). If the plane is on edge then this is
    // impossible so don't try to draw the grid.
    bool parallel;
    Vector tpp = Vector::AtIntersectionOfPlaneAndLine(
                                    wn, wn.Dot(wp),
                                    tp, tp.Plus(n),
                                    &amp;parallel);
    if(parallel) return;

    tpp = tpp.Minus(wp);
    double uu = tpp.Dot(wu),
i0 = (int)(umin / g);
i1 = (int)(umax / g);
j0 = (int)(vmin / g);
j1 = (int)(vmax / g);

if(i0 &gt; i1 || i1 - i0 &gt; 400) return;
if(j0 &gt; j1 || j1 - j0 &gt; 400) return;

Canvas::Stroke stroke = {};
stroke.layer  = Canvas::Layer::BACK;
stroke.color  = Style::Color(Style::DATUM).WithAlpha(75);
stroke.unit   = Canvas::Unit::PX;
stroke.width  = 1.0f;
Canvas::hStroke hcs = canvas-&gt;GetStroke(stroke);

for(i = i0 + 1; i &lt; i1; i++) {
    canvas-&gt;DrawLine(wp.Plus(wu.ScaledBy(i*g)).Plus(wv.ScaledBy(j0*g)),
                     wp.Plus(wu.ScaledBy(i*g)).Plus(wv.ScaledBy(j1*g)),
                     hcs);
}
for(j = j0 + 1; j &lt; j1; j++) {
    canvas-&gt;DrawLine(wp.Plus(wu.ScaledBy(i0*g)).Plus(wv.ScaledBy(j*g)),
                     wp.Plus(wu.ScaledBy(i1*g)).Plus(wv.ScaledBy(j*g)),
                     hcs);
}
</t>
<t tx="leo.20191228122643.29">void GraphicsWindow::DrawEntities(Canvas *canvas, bool persistent) {
    for(Entity &amp;e : SK.entity) {
        if(persistent == (e.IsNormal() || e.IsWorkplane())) continue;
        switch(SS.GW.drawOccludedAs) {
            case DrawOccludedAs::VISIBLE:
                e.Draw(Entity::DrawAs::OVERLAY, canvas);
                break;

            case DrawOccludedAs::STIPPLED:
                e.Draw(Entity::DrawAs::HIDDEN, canvas);
                /* fallthrough */
            case DrawOccludedAs::INVISIBLE:
                e.Draw(Entity::DrawAs::DEFAULT, canvas);
                break;
        }
    }
}

</t>
<t tx="leo.20191228122643.3">void TextWindow::ScreenConstraintShowAsRadius(int link, uint32_t v) {
    hConstraint hc = { v };
    Constraint *c = SK.GetConstraint(hc);

    SS.UndoRemember();
    c-&gt;other = !c-&gt;other;

    SS.ScheduleShowTW();
}

</t>
<t tx="leo.20191228122643.30">void GraphicsWindow::DrawPersistent(Canvas *canvas) {
    // Draw the active group; this does stuff like the mesh and edges.
    SK.GetGroup(activeGroup)-&gt;Draw(canvas);

    // Now draw the entities that don't change with viewport.
    DrawEntities(canvas, /*persistent=*/true);

    // Draw filled paths in all groups, when those filled paths were requested
    // specially by assigning a style with a fill color, or when the filled
    // paths are just being filled by default. This should go last, to make
    // the transparency work.
    for(hGroup hg : SK.groupOrder) {
        Group *g = SK.GetGroup(hg);
        if(!(g-&gt;IsVisible())) continue;
        g-&gt;DrawFilledPaths(canvas);
    }
}

</t>
<t tx="leo.20191228122643.31">void GraphicsWindow::Draw(Canvas *canvas) {
    const Camera &amp;camera = canvas-&gt;GetCamera();

    // Nasty case when we're reloading the linked files; could be that
    // we get an error, so a dialog pops up, and a message loop starts, and
    // we have to get called to paint ourselves. If the sketch is screwed
    // up, then we could trigger an oops trying to draw.
    if(!SS.allConsistent) return;

    if(showSnapGrid) DrawSnapGrid(canvas);

    // Draw all the things that don't change when we rotate.
    if(persistentCanvas != NULL) {
        if(persistentDirty) {
            persistentDirty = false;

            persistentCanvas-&gt;Clear();
            DrawPersistent(&amp;*persistentCanvas);
            persistentCanvas-&gt;Finalize();
        }

        persistentCanvas-&gt;Draw();
    } else {
        DrawPersistent(canvas);
    }

    // Draw the entities that do change with viewport.
    DrawEntities(canvas, /*persistent=*/false);

    // Draw the polygon errors.
    if(SS.checkClosedContour) {
        SK.GetGroup(activeGroup)-&gt;DrawPolyError(canvas);
    }

    // Draw the constraints
    for(Constraint &amp;c : SK.constraint) {
        c.Draw(Constraint::DrawAs::DEFAULT, canvas);
    }

    // Draw areas
    if(SS.showContourAreas) {
        for(hGroup hg : SK.groupOrder) {
            Group *g = SK.GetGroup(hg);
            if(g-&gt;h != activeGroup) continue;
            if(!(g-&gt;IsVisible())) continue;
            g-&gt;DrawContourAreaLabels(canvas);
        }
    }

    // Draw the "pending" constraint, i.e. a constraint that would be
    // placed on a line that is almost horizontal or vertical.
    if(SS.GW.pending.operation == Pending::DRAGGING_NEW_LINE_POINT &amp;&amp;
            SS.GW.pending.hasSuggestion) {
        Constraint c = {};
        c.group = SS.GW.activeGroup;
        c.workplane = SS.GW.ActiveWorkplane();
        c.type = SS.GW.pending.suggestion;
        c.entityA = SS.GW.pending.request.entity(0);
        c.Draw(Constraint::DrawAs::DEFAULT, canvas);
    }

    Canvas::Stroke strokeAnalyze = Style::Stroke(Style::ANALYZE);
    strokeAnalyze.layer = Canvas::Layer::FRONT;
    Canvas::hStroke hcsAnalyze = canvas-&gt;GetStroke(strokeAnalyze);

    // Draw the traced path, if one exists
    SEdgeList tracedEdges = {};
    SS.traced.path.MakeEdgesInto(&amp;tracedEdges);
    canvas-&gt;DrawEdges(tracedEdges, hcsAnalyze);
    tracedEdges.Clear();

    Canvas::Stroke strokeError = Style::Stroke(Style::DRAW_ERROR);
    strokeError.layer = Canvas::Layer::FRONT;
    strokeError.width = 12;
    Canvas::hStroke hcsError = canvas-&gt;GetStroke(strokeError);

    // And the naked edges, if the user did Analyze -&gt; Show Naked Edges.
    canvas-&gt;DrawEdges(SS.nakedEdges, hcsError);

    // Then redraw whatever the mouse is hovering over, highlighted.
    hover.Draw(/*isHovered=*/true, canvas);
    SK.GetGroup(activeGroup)-&gt;DrawMesh(Group::DrawMeshAs::HOVERED, canvas);

    // And finally draw the selection, same mechanism.
    for(Selection *s = selection.First(); s; s = selection.NextAfter(s)) {
        s-&gt;Draw(/*isHovered=*/false, canvas);
    }
    SK.GetGroup(activeGroup)-&gt;DrawMesh(Group::DrawMeshAs::SELECTED, canvas);

    Canvas::Stroke strokeDatum = Style::Stroke(Style::DATUM);
    strokeDatum.unit  = Canvas::Unit::PX;
    strokeDatum.layer = Canvas::Layer::FRONT;
    strokeDatum.width = 1;
    Canvas::hStroke hcsDatum = canvas-&gt;GetStroke(strokeDatum);

    // An extra line, used to indicate the origin when rotating within the
    // plane of the monitor.
    if(SS.extraLine.draw) {
        canvas-&gt;DrawLine(SS.extraLine.ptA, SS.extraLine.ptB, hcsDatum);
    }

    if(SS.centerOfMass.draw &amp;&amp; !SS.centerOfMass.dirty) {
        Vector p = SS.centerOfMass.position;
        Vector u = camera.projRight;
        Vector v = camera.projUp;

        const double size = 10.0;
        const int subdiv = 16;
        double h = Style::DefaultTextHeight() / camera.scale;
        canvas-&gt;DrawVectorText(ssprintf("%.3f, %.3f, %.3f", p.x, p.y, p.z), h,
                               p.Plus(u.ScaledBy((size + 5.0)/scale)).Minus(v.ScaledBy(h / 2.0)),
                               u, v,hcsDatum);
        u = u.WithMagnitude(size / scale);
        v = v.WithMagnitude(size / scale);

        canvas-&gt;DrawLine(p.Minus(u), p.Plus(u), hcsDatum);
        canvas-&gt;DrawLine(p.Minus(v), p.Plus(v), hcsDatum);
        Vector prev;
        for(int i = 0; i &lt;= subdiv; i++) {
            double a = (double)i / subdiv * 2.0 * PI;
            Vector point = p.Plus(u.ScaledBy(cos(a))).Plus(v.ScaledBy(sin(a)));
            if(i &gt; 0) {
                canvas-&gt;DrawLine(point, prev, hcsDatum);
            }
            prev = point;
        }
    }

    // A note to indicate the origin in the just-exported file.
    if(SS.justExportedInfo.draw) {
        Vector p, u, v;
        if(SS.justExportedInfo.showOrigin) {
            p = SS.justExportedInfo.pt,
            u = SS.justExportedInfo.u,
            v = SS.justExportedInfo.v;
        } else {
            p = camera.offset.ScaledBy(-1);
            u = camera.projRight;
            v = camera.projUp;
        }
        canvas-&gt;DrawVectorText("previewing exported geometry; press Esc to return",
                              Style::DefaultTextHeight() / camera.scale,
                              p.Plus(u.ScaledBy(10/scale)).Plus(v.ScaledBy(10/scale)), u, v,
                              hcsDatum);

        if(SS.justExportedInfo.showOrigin) {
            Vector um = p.Plus(u.WithMagnitude(-15/scale)),
                   up = p.Plus(u.WithMagnitude(30/scale)),
                   vm = p.Plus(v.WithMagnitude(-15/scale)),
                   vp = p.Plus(v.WithMagnitude(30/scale));
            canvas-&gt;DrawLine(um, up, hcsDatum);
            canvas-&gt;DrawLine(vm, vp, hcsDatum);
            canvas-&gt;DrawVectorText("(x, y) = (0, 0) for file just exported",
                                  Style::DefaultTextHeight() / camera.scale,
                                  p.Plus(u.ScaledBy(40/scale)).Plus(
                                         v.ScaledBy(-(Style::DefaultTextHeight())/scale)), u, v,
                                  hcsDatum);
        }
    }
}

</t>
<t tx="leo.20191228122643.32">void GraphicsWindow::Paint() {
    ssassert(window != NULL &amp;&amp; canvas != NULL,
             "Cannot paint without window and canvas");

    havePainted = true;

    Camera   camera   = GetCamera();
    Lighting lighting = GetLighting();

    if(!SS.ActiveGroupsOkay()) {
        // Draw a different background whenever we're having solve problems.
        RgbaColor bgColor = Style::Color(Style::DRAW_ERROR);
        bgColor = RgbaColor::FromFloat(0.4f*bgColor.redF(),
                                       0.4f*bgColor.greenF(),
                                       0.4f*bgColor.blueF());
        lighting.backgroundColor = bgColor;
        // And show the text window, which has info to debug it
        ForceTextWindowShown();
    }

    auto renderStartTime = std::chrono::high_resolution_clock::now();

    canvas-&gt;SetLighting(lighting);
    canvas-&gt;SetCamera(camera);
    canvas-&gt;StartFrame();
    Draw(canvas.get());
    canvas-&gt;FlushFrame();

    auto renderEndTime = std::chrono::high_resolution_clock::now();
    std::chrono::duration&lt;double, std::milli&gt; renderTime = renderEndTime - renderStartTime;

    camera.LoadIdentity();
    camera.offset.x = -(double)camera.width  / 2.0;
    camera.offset.y = -(double)camera.height / 2.0;
    canvas-&gt;SetCamera(camera);

    UiCanvas uiCanvas = {};
    uiCanvas.canvas = canvas;

    // If a marquee selection is in progress, then draw the selection
    // rectangle, as an outline and a transparent fill.
    if(pending.operation == Pending::DRAGGING_MARQUEE) {
        Point2d begin = ProjectPoint(orig.marqueePoint);
        uiCanvas.DrawRect((int)orig.mouse.x + (int)camera.width / 2,
                          (int)begin.x + (int)camera.width / 2,
                          (int)orig.mouse.y + (int)camera.height / 2,
                          (int)begin.y + (int)camera.height / 2,
                          /*fillColor=*/Style::Color(Style::HOVERED).WithAlpha(25),
                          /*outlineColor=*/Style::Color(Style::HOVERED));
    }

    // If we've had a screenshot requested, take it now, before the UI is overlaid.
    if(!SS.screenshotFile.IsEmpty()) {
        FILE *f = OpenFile(SS.screenshotFile, "wb");
        if(!f || !canvas-&gt;ReadFrame()-&gt;WritePng(f, /*flip=*/true)) {
            Error("Couldn't write to '%s'", SS.screenshotFile.raw.c_str());
        }
        if(f) fclose(f);
        SS.screenshotFile.Clear();
    }

    // And finally the toolbar.
    if(SS.showToolbar) {
        canvas-&gt;SetCamera(camera);
        ToolbarDraw(&amp;uiCanvas);
    }

    // Also display an fps counter.
    RgbaColor renderTimeColor;
    if(renderTime.count() &gt; 16.67) {
        // We aim for a steady 60fps; draw the counter in red when we're slower.
        renderTimeColor = { 255, 0, 0, 255 };
    } else {
        renderTimeColor = { 255, 255, 255, 255 };
    }
    uiCanvas.DrawBitmapText(ssprintf("rendered in %ld ms (%ld 1/s)",
                                     (long)renderTime.count(),
                                     (long)(1000 / std::max(0.1, renderTime.count()))),
                            5, 5, renderTimeColor);

    canvas-&gt;FlushFrame();
    canvas-&gt;FinishFrame();
    canvas-&gt;Clear();
}

</t>
<t tx="leo.20191228122643.33">void GraphicsWindow::Invalidate(bool clearPersistent) {
    if(window) {
        if(clearPersistent) {
            persistentDirty = true;
        }
        window-&gt;Invalidate();
    }
}
</t>
<t tx="leo.20191228122643.34">@path ./src/
//-----------------------------------------------------------------------------
// Given a constraint, draw a graphical and user-selectable representation
// of that constraint on-screen. We can either draw with gl, or compute the
// distance from a point (the location of the mouse pointer) to the lines
// that we would have drawn, for selection.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

std::string Constraint::Label() const {
    std::string result;
    if(type == Type::ANGLE) {
        result = SS.DegreeToString(valA) + "°";
    } else if(type == Type::LENGTH_RATIO) {
        result = ssprintf("%.3f:1", valA);
    } else if(type == Type::COMMENT) {
        result = comment;
    } else if(type == Type::DIAMETER) {
        if(!other) {
            result = "⌀" + SS.MmToStringSI(valA);
        } else {
            result = "R" + SS.MmToStringSI(valA / 2);
        }
    } else {
        // valA has units of distance
        result = SS.MmToStringSI(fabs(valA));
    }
    if(reference) {
        result += " REF";
    }
    return result;
}

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122643.35">void Constraint::DoLine(Canvas *canvas, Canvas::hStroke hcs, Vector a, Vector b) {
    const Camera &amp;camera = canvas-&gt;GetCamera();

    a = camera.AlignToPixelGrid(a);
    b = camera.AlignToPixelGrid(b);
    canvas-&gt;DrawLine(a, b, hcs);
}

</t>
<t tx="leo.20191228122643.36">void Constraint::DoStippledLine(Canvas *canvas, Canvas::hStroke hcs, Vector a, Vector b) {
    Canvas::Stroke strokeStippled = *canvas-&gt;strokes.FindById(hcs);
    strokeStippled.stipplePattern = StipplePattern::SHORT_DASH;
    strokeStippled.stippleScale   = 4.0;
    Canvas::hStroke hcsStippled = canvas-&gt;GetStroke(strokeStippled);
    DoLine(canvas, hcsStippled, a, b);
}

</t>
<t tx="leo.20191228122643.37">void Constraint::DoLabel(Canvas *canvas, Canvas::hStroke hcs,
                         Vector ref, Vector *labelPos, Vector gr, Vector gu) {
    const Camera &amp;camera = canvas-&gt;GetCamera();

    std::string s = Label();
    double textHeight = Style::TextHeight(GetStyle()) / camera.scale;
    @others
}

</t>
<t tx="leo.20191228122643.38">double swidth  = VectorFont::Builtin()-&gt;GetWidth(textHeight, s),
       sheight = VectorFont::Builtin()-&gt;GetCapHeight(textHeight);

// By default, the reference is from the center; but the style could
// specify otherwise if one is present, and it could also specify a
// rotation.
if(type == Type::COMMENT &amp;&amp; disp.style.v) {
    Style *st = Style::Get(disp.style);
    // rotation first
    double rads = st-&gt;textAngle*PI/180;
    double c = cos(rads), s = sin(rads);
    Vector pr = gr, pu = gu;
    gr = pr.ScaledBy( c).Plus(pu.ScaledBy(s));
    gu = pr.ScaledBy(-s).Plus(pu.ScaledBy(c));
    // then origin
    uint32_t o = (uint32_t)st-&gt;textOrigin;
    if(o &amp; (uint32_t)Style::TextOrigin::LEFT) ref = ref.Plus(gr.WithMagnitude(swidth/2));
    if(o &amp; (uint32_t)Style::TextOrigin::RIGHT) ref = ref.Minus(gr.WithMagnitude(swidth/2));
    if(o &amp; (uint32_t)Style::TextOrigin::BOT) ref = ref.Plus(gu.WithMagnitude(sheight/2));
    if(o &amp; (uint32_t)Style::TextOrigin::TOP) ref = ref.Minus(gu.WithMagnitude(sheight/2));
}

Vector o = ref.Minus(gr.WithMagnitude(swidth/2)).Minus(
                     gu.WithMagnitude(sheight/2));
canvas-&gt;DrawVectorText(s, textHeight, o, gr.WithMagnitude(1), gu.WithMagnitude(1), hcs);
if(labelPos) *labelPos = o;
</t>
<t tx="leo.20191228122643.39">void Constraint::DoProjectedPoint(Canvas *canvas, Canvas::hStroke hcs,
                                  Vector *r, Vector n, Vector o) {
    double d = r-&gt;DistanceToPlane(n, o);
    Vector p = r-&gt;Minus(n.ScaledBy(d));
    DoStippledLine(canvas, hcs, p, *r);
    *r = p;
}

</t>
<t tx="leo.20191228122643.4">void TextWindow::DescribeSelection() {
    Printf(false, "");

    auto const &amp;gs = SS.GW.gs;
    if(gs.n == 1 &amp;&amp; (gs.points == 1 || gs.entities == 1)) {
        Entity *e = SK.GetEntity(gs.points == 1 ? gs.point[0] : gs.entity[0]);
        Vector p;

#define COSTR(p) \
    SS.MmToString((p).x).c_str(), \
    SS.MmToString((p).y).c_str(), \
    SS.MmToString((p).z).c_str()
#define PT_AS_STR "(%Fi%s%E, %Fi%s%E, %Fi%s%E)"
#define PT_AS_NUM "(%Fi%3%E, %Fi%3%E, %Fi%3%E)"
        switch(e-&gt;type) {
            case Entity::Type::POINT_IN_3D:
            case Entity::Type::POINT_IN_2D:
            case Entity::Type::POINT_N_TRANS:
            case Entity::Type::POINT_N_ROT_TRANS:
            case Entity::Type::POINT_N_COPY:
            case Entity::Type::POINT_N_ROT_AA:
                p = e-&gt;PointGetNum();
                Printf(false, "%FtPOINT%E at " PT_AS_STR, COSTR(p));
                break;

            case Entity::Type::NORMAL_IN_3D:
            case Entity::Type::NORMAL_IN_2D:
            case Entity::Type::NORMAL_N_COPY:
            case Entity::Type::NORMAL_N_ROT:
            case Entity::Type::NORMAL_N_ROT_AA: {
                Quaternion q = e-&gt;NormalGetNum();
                p = q.RotationN();
                Printf(false, "%FtNORMAL / COORDINATE SYSTEM%E");
                Printf(true,  "  basis n = " PT_AS_NUM, CO(p));
                p = q.RotationU();
                Printf(false, "        u = " PT_AS_NUM, CO(p));
                p = q.RotationV();
                Printf(false, "        v = " PT_AS_NUM, CO(p));
                break;
            }
            case Entity::Type::WORKPLANE: {
                p = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                Printf(false, "%FtWORKPLANE%E");
                Printf(true, "   origin = " PT_AS_STR, COSTR(p));
                Quaternion q = e-&gt;Normal()-&gt;NormalGetNum();
                p = q.RotationN();
                Printf(true, "   normal = " PT_AS_NUM, CO(p));
                break;
            }
            case Entity::Type::LINE_SEGMENT: {
                Vector p0 = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                p = p0;
                Printf(false, "%FtLINE SEGMENT%E");
                Printf(true,  "   thru " PT_AS_STR, COSTR(p));
                Vector p1 = SK.GetEntity(e-&gt;point[1])-&gt;PointGetNum();
                p = p1;
                Printf(false, "        " PT_AS_STR, COSTR(p));
                Printf(true,  "   len = %Fi%s%E",
                    SS.MmToString((p1.Minus(p0).Magnitude())).c_str());
                break;
            }
            case Entity::Type::CUBIC_PERIODIC:
            case Entity::Type::CUBIC:
                int pts;
                if(e-&gt;type == Entity::Type::CUBIC_PERIODIC) {
                    Printf(false, "%FtPERIODIC C2 CUBIC SPLINE%E");
                    pts = (3 + e-&gt;extraPoints);
                } else if(e-&gt;extraPoints &gt; 0) {
                    Printf(false, "%FtINTERPOLATING C2 CUBIC SPLINE%E");
                    pts = (4 + e-&gt;extraPoints);
                } else {
                    Printf(false, "%FtCUBIC BEZIER CURVE%E");
                    pts = 4;
                }
                for(int i = 0; i &lt; pts; i++) {
                    p = SK.GetEntity(e-&gt;point[i])-&gt;PointGetNum();
                    Printf((i==0), "   p%d = " PT_AS_STR, i, COSTR(p));
                }
                break;

            case Entity::Type::ARC_OF_CIRCLE: {
                Printf(false, "%FtARC OF A CIRCLE%E");
                p = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                Printf(true,  "     center = " PT_AS_STR, COSTR(p));
                p = SK.GetEntity(e-&gt;point[1])-&gt;PointGetNum();
                Printf(true,  "  endpoints = " PT_AS_STR, COSTR(p));
                p = SK.GetEntity(e-&gt;point[2])-&gt;PointGetNum();
                Printf(false, "              " PT_AS_STR, COSTR(p));
                double r = e-&gt;CircleGetRadiusNum();
                Printf(true, "   diameter =  %Fi%s", SS.MmToString(r*2).c_str());
                Printf(false, "     radius =  %Fi%s", SS.MmToString(r).c_str());
                double thetas, thetaf, dtheta;
                e-&gt;ArcGetAngles(&amp;thetas, &amp;thetaf, &amp;dtheta);
                Printf(false, "    arc len =  %Fi%s", SS.MmToString(dtheta*r).c_str());
                break;
            }
            case Entity::Type::CIRCLE: {
                Printf(false, "%FtCIRCLE%E");
                p = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                Printf(true,  "     center = " PT_AS_STR, COSTR(p));
                double r = e-&gt;CircleGetRadiusNum();
                Printf(true,  "   diameter =  %Fi%s", SS.MmToString(r*2).c_str());
                Printf(false, "     radius =  %Fi%s", SS.MmToString(r).c_str());
                break;
            }
            case Entity::Type::FACE_NORMAL_PT:
            case Entity::Type::FACE_XPROD:
            case Entity::Type::FACE_N_ROT_TRANS:
            case Entity::Type::FACE_N_ROT_AA:
            case Entity::Type::FACE_N_TRANS:
                Printf(false, "%FtPLANE FACE%E");
                p = e-&gt;FaceGetNormalNum();
                Printf(true,  "   normal = " PT_AS_NUM, CO(p));
                p = e-&gt;FaceGetPointNum();
                Printf(false, "     thru = " PT_AS_STR, COSTR(p));
                break;

            case Entity::Type::TTF_TEXT: {
                Printf(false, "%FtTRUETYPE FONT TEXT%E");
                Printf(true, "  font = '%Fi%s%E'", e-&gt;font.c_str());
                if(e-&gt;h.isFromRequest()) {
                    Printf(false, "  text = '%Fi%s%E' %Fl%Ll%f%D[change]%E",
                        e-&gt;str.c_str(), &amp;ScreenEditTtfText, e-&gt;h.request().v);
                    Printf(true, "  select new font");
                    SS.fonts.LoadAll();
                    // Not using range-for here because we use i inside the output.
                    for(int i = 0; i &lt; SS.fonts.l.n; i++) {
                        TtfFont *tf = &amp;(SS.fonts.l[i]);
                        if(e-&gt;font == tf-&gt;FontFileBaseName()) {
                            Printf(false, "%Bp    %s",
                                (i &amp; 1) ? 'd' : 'a',
                                tf-&gt;name.c_str());
                        } else {
                            Printf(false, "%Bp    %f%D%Fl%Ll%s%E%Bp",
                                (i &amp; 1) ? 'd' : 'a',
                                &amp;ScreenSetTtfFont, i,
                                tf-&gt;name.c_str(),
                                (i &amp; 1) ? 'd' : 'a');
                        }
                    }
                } else {
                    Printf(false, "  text = '%Fi%s%E'", e-&gt;str.c_str());
                }
                break;
            }
            case Entity::Type::IMAGE: {
                Printf(false, "%FtIMAGE%E");
                Platform::Path relativePath = e-&gt;file.RelativeTo(SS.saveFile.Parent());
                if(relativePath.IsEmpty()) {
                    Printf(true, "  file = '%Fi%s%E'", e-&gt;file.raw.c_str());
                } else {
                    Printf(true, "  file = '%Fi%s%E'", relativePath.raw.c_str());
                }
                break;
            }

            default:
                Printf(true, "%Ft?? ENTITY%E");
                break;
        }

        Group *g = SK.GetGroup(e-&gt;group);
        Printf(false, "");
        Printf(false, "%FtIN GROUP%E      %s", g-&gt;DescriptionString().c_str());
        if(e-&gt;workplane == Entity::FREE_IN_3D) {
            Printf(false, "%FtNOT LOCKED IN WORKPLANE%E");
        } else {
            Entity *w = SK.GetEntity(e-&gt;workplane);
            Printf(false, "%FtIN WORKPLANE%E  %s", w-&gt;DescriptionString().c_str());
        }
        if(e-&gt;style.v) {
            Style *s = Style::Get(e-&gt;style);
            Printf(false, "%FtIN STYLE%E      %s", s-&gt;DescriptionString().c_str());
        } else {
            Printf(false, "%FtIN STYLE%E      none");
        }
        if(e-&gt;construction) {
            Printf(false, "%FtCONSTRUCTION");
        }

        std::vector&lt;hConstraint&gt; lhc = {};
        for(const Constraint &amp;c : SK.constraint) {
            if(!(c.ptA == e-&gt;h ||
                 c.ptB == e-&gt;h ||
                 c.entityA == e-&gt;h ||
                 c.entityB == e-&gt;h ||
                 c.entityC == e-&gt;h ||
                 c.entityD == e-&gt;h))
                continue;
            lhc.push_back(c.h);
        }

        if(!lhc.empty()) {
            Printf(true, "%FtCONSTRAINED BY:%E");

            int a = 0;
            for(hConstraint hc : lhc) {
                Constraint *c = SK.GetConstraint(hc);
                std::string s = c-&gt;DescriptionString();
                Printf(false, "%Bp   %Fl%Ll%D%f%h%s%E %s",
                    (a &amp; 1) ? 'd' : 'a',
                    c-&gt;h.v, (&amp;TextWindow::ScreenSelectConstraint),
                    (&amp;TextWindow::ScreenHoverConstraint), s.c_str(),
                    c-&gt;reference ? "(ref)" : "");
                a++;
            }
        }
    } else if(gs.n == 2 &amp;&amp; gs.points == 2) {
        Printf(false, "%FtTWO POINTS");
        Vector p0 = SK.GetEntity(gs.point[0])-&gt;PointGetNum();
        Printf(true,  "   at " PT_AS_STR, COSTR(p0));
        Vector p1 = SK.GetEntity(gs.point[1])-&gt;PointGetNum();
        Printf(false, "      " PT_AS_STR, COSTR(p1));
        double d = (p1.Minus(p0)).Magnitude();
        Printf(true, "  d = %Fi%s", SS.MmToString(d).c_str());
    } else if(gs.n == 2 &amp;&amp; gs.points == 1 &amp;&amp; gs.circlesOrArcs == 1) {
        Entity *ec = SK.GetEntity(gs.entity[0]);
        if(ec-&gt;type == Entity::Type::CIRCLE) {
            Printf(false, "%FtPOINT AND A CIRCLE");
        } else if(ec-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
            Printf(false, "%FtPOINT AND AN ARC");
        } else ssassert(false, "Unexpected entity type");
        Vector p = SK.GetEntity(gs.point[0])-&gt;PointGetNum();
        Printf(true,  "        pt at " PT_AS_STR, COSTR(p));
        Vector c = SK.GetEntity(ec-&gt;point[0])-&gt;PointGetNum();
        Printf(true,  "     center = " PT_AS_STR, COSTR(c));
        double r = ec-&gt;CircleGetRadiusNum();
        Printf(false, "   diameter =  %Fi%s", SS.MmToString(r*2).c_str());
        Printf(false, "     radius =  %Fi%s", SS.MmToString(r).c_str());
        double d = (p.Minus(c)).Magnitude() - r;
        Printf(true,  "   distance = %Fi%s", SS.MmToString(d).c_str());
    } else if(gs.n == 2 &amp;&amp; gs.faces == 1 &amp;&amp; gs.points == 1) {
        Printf(false, "%FtA POINT AND A PLANE FACE");
        Vector pt = SK.GetEntity(gs.point[0])-&gt;PointGetNum();
        Printf(true,  "        point = " PT_AS_STR, COSTR(pt));
        Vector n = SK.GetEntity(gs.face[0])-&gt;FaceGetNormalNum();
        Printf(true,  " plane normal = " PT_AS_NUM, CO(n));
        Vector pl = SK.GetEntity(gs.face[0])-&gt;FaceGetPointNum();
        Printf(false, "   plane thru = " PT_AS_STR, COSTR(pl));
        double dd = n.Dot(pl) - n.Dot(pt);
        Printf(true,  "     distance = %Fi%s", SS.MmToString(dd).c_str());
    } else if(gs.n == 3 &amp;&amp; gs.points == 2 &amp;&amp; gs.vectors == 1) {
        Printf(false, "%FtTWO POINTS AND A VECTOR");
        Vector p0 = SK.GetEntity(gs.point[0])-&gt;PointGetNum();
        Printf(true,  "  pointA = " PT_AS_STR, COSTR(p0));
        Vector p1 = SK.GetEntity(gs.point[1])-&gt;PointGetNum();
        Printf(false, "  pointB = " PT_AS_STR, COSTR(p1));
        Vector v  = SK.GetEntity(gs.vector[0])-&gt;VectorGetNum();
        v = v.WithMagnitude(1);
        Printf(true,  "  vector = " PT_AS_NUM, CO(v));
        double d = (p1.Minus(p0)).Dot(v);
        Printf(true,  "  proj_d = %Fi%s", SS.MmToString(d).c_str());
    } else if(gs.n == 2 &amp;&amp; gs.lineSegments == 1 &amp;&amp; gs.points == 1) {
        Entity *ln = SK.GetEntity(gs.entity[0]);
        Vector lp0 = SK.GetEntity(ln-&gt;point[0])-&gt;PointGetNum(),
               lp1 = SK.GetEntity(ln-&gt;point[1])-&gt;PointGetNum();
        Printf(false, "%FtLINE SEGMENT AND POINT%E");
        Printf(true,  "   ln thru " PT_AS_STR, COSTR(lp0));
        Printf(false, "           " PT_AS_STR, COSTR(lp1));
        Entity *p  = SK.GetEntity(gs.point[0]);
        Vector pp = p-&gt;PointGetNum();
        Printf(true,  "     point " PT_AS_STR, COSTR(pp));
        Printf(true,  " pt-ln distance = %Fi%s%E",
            SS.MmToString(pp.DistanceToLine(lp0, lp1.Minus(lp0))).c_str());
        hEntity wrkpl = SS.GW.ActiveWorkplane();
        if(wrkpl != Entity::FREE_IN_3D &amp;&amp; !(p-&gt;workplane == wrkpl &amp;&amp; ln-&gt;workplane == wrkpl)) {
            Vector ppw  = pp.ProjectInto(wrkpl);
            Vector lp0w = lp0.ProjectInto(wrkpl);
            Vector lp1w = lp1.ProjectInto(wrkpl);
            Printf(false, "    or distance = %Fi%s%E (in workplane)",
                SS.MmToString(ppw.DistanceToLine(lp0w, lp1w.Minus(lp0w))).c_str());
        }
    } else if(gs.n == 2 &amp;&amp; gs.vectors == 2) {
        Printf(false, "%FtTWO VECTORS");

        Vector v0 = SK.GetEntity(gs.entity[0])-&gt;VectorGetNum(),
               v1 = SK.GetEntity(gs.entity[1])-&gt;VectorGetNum();
        v0 = v0.WithMagnitude(1);
        v1 = v1.WithMagnitude(1);

        Printf(true,  "  vectorA = " PT_AS_NUM, CO(v0));
        Printf(false, "  vectorB = " PT_AS_NUM, CO(v1));

        double theta = acos(v0.Dot(v1));
        Printf(true,  "    angle = %Fi%2%E degrees", theta*180/PI);
        while(theta &lt; PI/2) theta += PI;
        while(theta &gt; PI/2) theta -= PI;
        Printf(false, " or angle = %Fi%2%E (mod 180)", theta*180/PI);
    } else if(gs.n == 2 &amp;&amp; gs.faces == 2) {
        Printf(false, "%FtTWO PLANE FACES");

        Vector n0 = SK.GetEntity(gs.face[0])-&gt;FaceGetNormalNum();
        Printf(true,  " planeA normal = " PT_AS_NUM, CO(n0));
        Vector p0 = SK.GetEntity(gs.face[0])-&gt;FaceGetPointNum();
        Printf(false, "   planeA thru = " PT_AS_STR, COSTR(p0));

        Vector n1 = SK.GetEntity(gs.face[1])-&gt;FaceGetNormalNum();
        Printf(true,  " planeB normal = " PT_AS_NUM, CO(n1));
        Vector p1 = SK.GetEntity(gs.face[1])-&gt;FaceGetPointNum();
        Printf(false, "   planeB thru = " PT_AS_STR, COSTR(p1));

        double theta = acos(n0.Dot(n1));
        Printf(true,  "         angle = %Fi%2%E degrees", theta*180/PI);
        while(theta &lt; PI/2) theta += PI;
        while(theta &gt; PI/2) theta -= PI;
        Printf(false, "      or angle = %Fi%2%E (mod 180)", theta*180/PI);

        if(fabs(theta) &lt; 0.01) {
            double d = (p1.Minus(p0)).Dot(n0);
            Printf(true,  "      distance = %Fi%s", SS.MmToString(d).c_str());
        }
    } else if(gs.n == 0 &amp;&amp; gs.stylables &gt; 0) {
        Printf(false, "%FtSELECTED:%E comment text");
    } else if(gs.n == 0 &amp;&amp; gs.constraints == 1) {
        Constraint *c = SK.GetConstraint(gs.constraint[0]);

        if(c-&gt;type == Constraint::Type::DIAMETER) {
            Printf(false, "%FtDIAMETER CONSTRAINT");

            Printf(true, "  %Fd%f%D%Ll%s  show as radius",
                   &amp;ScreenConstraintShowAsRadius, gs.constraint[0].v,
                   c-&gt;other ? CHECK_TRUE : CHECK_FALSE);
        } else {
            Printf(false, "%FtSELECTED:%E %s",
            c-&gt;DescriptionString().c_str());
        }

        std::vector&lt;hEntity&gt; lhe = {};
        lhe.push_back(c-&gt;ptA);
        lhe.push_back(c-&gt;ptB);
        lhe.push_back(c-&gt;entityA);
        lhe.push_back(c-&gt;entityB);
        lhe.push_back(c-&gt;entityC);
        lhe.push_back(c-&gt;entityD);

        @others
}

</t>
<t tx="leo.20191228122643.40">void Constraint::DoProjectedPoint(Canvas *canvas, Canvas::hStroke hcs, Vector *r) {
    Vector p = r-&gt;ProjectInto(workplane);
    DoStippledLine(canvas, hcs, p, *r);
    *r = p;
}

//-----------------------------------------------------------------------------
// There is a rectangular box, aligned to our display axes (projRight, projUp)
// centered at ref. This is where a dimension label will be drawn. We want to
// draw a line from A to B. If that line would intersect the label box, then
// trim the line to leave a gap for it, and return zero. If not, then extend
// the line to almost meet the box, and return either positive or negative,
// depending whether that extension was from A or from B.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122643.41">int Constraint::DoLineTrimmedAgainstBox(Canvas *canvas, Canvas::hStroke hcs,
                                        Vector ref, Vector a, Vector b, bool extend) {
    const Camera &amp;camera = canvas-&gt;GetCamera();
    double th      = Style::TextHeight(GetStyle()) / camera.scale;
    double pixels  = 1.0 / camera.scale;
    @others
}

</t>
<t tx="leo.20191228122643.42">    double swidth  = VectorFont::Builtin()-&gt;GetWidth(th, Label()) + 8 * pixels,
           sheight = VectorFont::Builtin()-&gt;GetCapHeight(th) + 8 * pixels;
    Vector gu = camera.projUp.WithMagnitude(1),
           gr = camera.projRight.WithMagnitude(1);
    return DoLineTrimmedAgainstBox(canvas, hcs, ref, a, b, extend, gr, gu, swidth, sheight);
}

int Constraint::DoLineTrimmedAgainstBox(Canvas *canvas, Canvas::hStroke hcs,
                                        Vector ref, Vector a, Vector b, bool extend,
                                        Vector gr, Vector gu, double swidth, double sheight) {
    struct {
        Vector n;
        double d;
    } planes[4];
    // reference pos is the center of box occupied by text; build a rectangle
    // around that, aligned to axes gr and gu, from four planes will all four
    // normals pointing inward
    planes[0].n = gu.ScaledBy(-1); planes[0].d = -(gu.Dot(ref) + sheight/2);
    planes[1].n = gu;              planes[1].d =   gu.Dot(ref) - sheight/2;
    planes[2].n = gr;              planes[2].d =   gr.Dot(ref) - swidth/2;
    planes[3].n = gr.ScaledBy(-1); planes[3].d = -(gr.Dot(ref) + swidth/2);

    double tmin = VERY_POSITIVE, tmax = VERY_NEGATIVE;
    Vector dl = b.Minus(a);

    for(int i = 0; i &lt; 4; i++) {
        bool parallel;
        Vector p = Vector::AtIntersectionOfPlaneAndLine(
                                planes[i].n, planes[i].d,
                                a, b, &amp;parallel);
        if(parallel) continue;

        int j;
        for(j = 0; j &lt; 4; j++) {
            double d = (planes[j].n).Dot(p) - planes[j].d;
            if(d &lt; -LENGTH_EPS) break;
        }
        if(j &lt; 4) continue;

        double t = (p.Minus(a)).DivProjected(dl);
        tmin = min(t, tmin);
        tmax = max(t, tmax);
    }

    // Both in range; so there's pieces of the line on both sides of the label box.
    if(tmin &gt;= 0.0 &amp;&amp; tmin &lt;= 1.0 &amp;&amp; tmax &gt;= 0.0 &amp;&amp; tmax &lt;= 1.0) {
        DoLine(canvas, hcs, a, a.Plus(dl.ScaledBy(tmin)));
        DoLine(canvas, hcs, a.Plus(dl.ScaledBy(tmax)), b);
        return 0;
    }

    // Only one intersection in range; so the box is right on top of the endpoint
    if(tmin &gt;= 0.0 &amp;&amp; tmin &lt;= 1.0) {
        DoLine(canvas, hcs, a, a.Plus(dl.ScaledBy(tmin)));
        return 0;
    }

    // Likewise.
    if(tmax &gt;= 0.0 &amp;&amp; tmax &lt;= 1.0) {
        DoLine(canvas, hcs, a.Plus(dl.ScaledBy(tmax)), b);
        return 0;
    }

    // The line does not intersect the label; so the line should get
    // extended to just barely meet the label.
    // 0 means the label lies within the line, negative means it's outside
    // and closer to b, positive means outside and closer to a.
    if(tmax &lt; 0.0) {
        if(extend) a = a.Plus(dl.ScaledBy(tmax));
        DoLine(canvas, hcs, a, b);
        return 1;
    }

    if(tmin &gt; 1.0) {
        if(extend) b = a.Plus(dl.ScaledBy(tmin));
        DoLine(canvas, hcs, a, b);
        return -1;
    }

    // This will happen if the entire line lies within the box.
    return 0;
</t>
<t tx="leo.20191228122643.43">void Constraint::DoArrow(Canvas *canvas, Canvas::hStroke hcs,
                         Vector p, Vector dir, Vector n, double width, double angle, double da) {
    dir = dir.WithMagnitude(width / cos(angle));
    dir = dir.RotatedAbout(n, da);
    DoLine(canvas, hcs, p, p.Plus(dir.RotatedAbout(n,  angle)));
    DoLine(canvas, hcs, p, p.Plus(dir.RotatedAbout(n, -angle)));
}

//-----------------------------------------------------------------------------
// Draw a line with arrows on both ends, and possibly a gap in the middle for
// the dimension. We will use these for most length dimensions. The length
// being dimensioned is from A to B; but those points get extended perpendicular
// to the line AB, until the line between the extensions crosses ref (the
// center of the label).
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122643.44">void Constraint::DoLineWithArrows(Canvas *canvas, Canvas::hStroke hcs,
                                  Vector ref, Vector a, Vector b,
                                  bool onlyOneExt)
{
    const Camera &amp;camera = canvas-&gt;GetCamera();
    double pixels = 1.0 / camera.scale;

    Vector ab   = a.Minus(b);
    Vector ar   = a.Minus(ref);
    // Normal to a plane containing the line and the label origin.
    Vector n    = ab.Cross(ar);
    // Within that plane, and normal to the line AB; so that's our extension
    // line.
    Vector out  = ab.Cross(n).WithMagnitude(1);
    out = out.ScaledBy(-out.Dot(ar));

    Vector ae = a.Plus(out), be = b.Plus(out);

    // Extension lines extend 10 pixels beyond where the arrows get
    // drawn (which is at the same offset perpendicular from AB as the
    // label).
    DoLine(canvas, hcs, a, ae.Plus(out.WithMagnitude(10*pixels)));
    if(!onlyOneExt) {
        DoLine(canvas, hcs, b, be.Plus(out.WithMagnitude(10*pixels)));
    }

    int within = DoLineTrimmedAgainstBox(canvas, hcs, ref, ae, be);

    // Arrow heads are 13 pixels long, with an 18 degree half-angle.
    double theta = 18*PI/180;
    Vector arrow = (be.Minus(ae)).WithMagnitude(13*pixels);

    if(within != 0) {
        arrow = arrow.ScaledBy(-1);
        Vector seg = (be.Minus(ae)).WithMagnitude(18*pixels);
        if(within &lt; 0) DoLine(canvas, hcs, ae, ae.Minus(seg));
        if(within &gt; 0) DoLine(canvas, hcs, be, be.Plus(seg));
    }

    DoArrow(canvas, hcs, ae, arrow, n, 13.0 * pixels, theta, 0.0);
    DoArrow(canvas, hcs, be, arrow.Negated(), n, 13.0 * pixels, theta, 0.0);
}

</t>
<t tx="leo.20191228122643.45">void Constraint::DoEqualLenTicks(Canvas *canvas, Canvas::hStroke hcs,
                                 Vector a, Vector b, Vector gn, Vector *refp) {
    const Camera &amp;camera = canvas-&gt;GetCamera();

    Vector m = (a.ScaledBy(1.0/3)).Plus(b.ScaledBy(2.0/3));
    if(refp) *refp = m;
    Vector ab = a.Minus(b);
    Vector n = (gn.Cross(ab)).WithMagnitude(10/camera.scale);

    DoLine(canvas, hcs, m.Minus(n), m.Plus(n));
}

</t>
<t tx="leo.20191228122643.46">void Constraint::DoEqualRadiusTicks(Canvas *canvas, Canvas::hStroke hcs,
                                    hEntity he, Vector *refp) {
    const Camera &amp;camera = canvas-&gt;GetCamera();
    Entity *circ = SK.GetEntity(he);

    Vector center = SK.GetEntity(circ-&gt;point[0])-&gt;PointGetNum();
    double r = circ-&gt;CircleGetRadiusNum();
    Quaternion q = circ-&gt;Normal()-&gt;NormalGetNum();
    Vector u = q.RotationU(), v = q.RotationV();

    double theta;
    if(circ-&gt;type == Entity::Type::CIRCLE) {
        theta = PI/2;
    } else if(circ-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
        double thetaa, thetab, dtheta;
        circ-&gt;ArcGetAngles(&amp;thetaa, &amp;thetab, &amp;dtheta);
        theta = thetaa + dtheta/2;
    } else ssassert(false, "Unexpected entity type");

    Vector d = u.ScaledBy(cos(theta)).Plus(v.ScaledBy(sin(theta)));
    d = d.ScaledBy(r);
    Vector p = center.Plus(d);
    if(refp) *refp = p;
    Vector tick = d.WithMagnitude(10/camera.scale);
    DoLine(canvas, hcs, p.Plus(tick), p.Minus(tick));
}

</t>
<t tx="leo.20191228122643.47">void Constraint::DoArcForAngle(Canvas *canvas, Canvas::hStroke hcs,
                               Vector a0, Vector da, Vector b0, Vector db,
                               Vector offset, Vector *ref, bool trim)
{
    const Camera &amp;camera = canvas-&gt;GetCamera();
    double pixels = 1.0 / camera.scale;
    Vector gr = camera.projRight.ScaledBy(1.0);
    Vector gu = camera.projUp.ScaledBy(1.0);

    if(workplane != Entity::FREE_IN_3D) {
        a0 = a0.ProjectInto(workplane);
        b0 = b0.ProjectInto(workplane);
        da = da.ProjectVectorInto(workplane);
        db = db.ProjectVectorInto(workplane);
    }

    Vector a1 = a0.Plus(da);
    Vector b1 = b0.Plus(db);

    bool skew;
    Vector pi = Vector::AtIntersectionOfLines(a0, a0.Plus(da),
                                              b0, b0.Plus(db), &amp;skew);

    if(!skew) {
        *ref = pi.Plus(offset);
        // We draw in a coordinate system centered at the intersection point.
        // One basis vector is da, and the other is normal to da and in
        // the plane that contains our lines (so normal to its normal).
        da = da.WithMagnitude(1);
        db = db.WithMagnitude(1);

        Vector norm = da.Cross(db);

        Vector dna = norm.Cross(da).WithMagnitude(1.0);
        Vector dnb = norm.Cross(db).WithMagnitude(1.0);

        // da and db magnitudes are 1.0
        double thetaf = acos(da.Dot(db));

        // Calculate median
        Vector m = da.ScaledBy(cos(thetaf/2)).Plus(
                   dna.ScaledBy(sin(thetaf/2)));
        Vector rm = (*ref).Minus(pi);

        // Test which side we have to place an arc
        if(m.Dot(rm) &lt; 0) {
            da = da.ScaledBy(-1); dna = dna.ScaledBy(-1);
            db = db.ScaledBy(-1); dnb = dnb.ScaledBy(-1);
        }

        double rda = rm.Dot(da), rdna = rm.Dot(dna);

        // Introduce minimal arc radius in pixels
        double r = max(sqrt(rda*rda + rdna*rdna), 15.0 * pixels);

        double th = Style::TextHeight(GetStyle()) / camera.scale;
        double swidth   = VectorFont::Builtin()-&gt;GetWidth(th, Label()) + 8*pixels,
        double arrowA = 18.0 * PI / 180.0;
        bool arrowVisible = apb.Minus(apa).Magnitude() &gt; 2.5 * arrowW;
        // Arrow reversing indicator
        bool arrowRev = false;

        // The minimal extension length in angular representation
        double extAngle = 18 * pixels / r;

        // Arc additional angle
        double addAngle = 0.0;
        // Arc start angle
        double startAngle = 0.0;

        // Arc extension to db.
        // We have just enlarge angle value.
        if(HasLabel() &amp;&amp; rm.Dot(dnb) &gt; 0.0) {
            // rm direction projected to plane with u = da, v = dna
            Vector rmp = da.ScaledBy(rda).Plus(dna.ScaledBy(rdna)).WithMagnitude(1.0);
            // rmp and db magnitudes are 1.0
            addAngle = std::max(acos(rmp.Dot(db)), extAngle);

            if(arrowVisible) {
                startAngle = -extAngle;
                addAngle += extAngle;
                arrowRev = true;
            }
        }

        // Arc extension to da.
        // We are enlarge angle value and rewrite basis to align along rm projection.
        if(HasLabel() &amp;&amp; rm.Dot(dna) &lt; 0.0) {
            // rm direction projected to plane with u = da, v = dna
            Vector rmp = da.ScaledBy(rda).Plus(dna.ScaledBy(rdna)).WithMagnitude(1.0);
            // rmp and da magnitudes are 1.0
            startAngle = -std::max(acos(rmp.Dot(da)), extAngle);
            addAngle = -startAngle;

            if(arrowVisible) {
                addAngle += extAngle;
                arrowRev = true;
            }
        }

        Vector prev;
        int n = 30;
        for(int i = 0; i &lt;= n; i++) {
            double theta = startAngle + (i*(thetaf + addAngle))/n;
            Vector p =  da.ScaledBy(r*cos(theta)).Plus(
                       dna.ScaledBy(r*sin(theta))).Plus(pi);
            if(i &gt; 0) {
                if(trim) {
                    DoLineTrimmedAgainstBox(canvas, hcs, *ref, prev, p,
                                            /*extend=*/false, gr, gu, swidth, sheight + 2*pixels);
                } else {
                    DoLine(canvas, hcs, prev, p);
                }
            }
            prev = p;
        }

        DoLineExtend(canvas, hcs, a0, a1, apa, 5.0 * pixels);
        DoLineExtend(canvas, hcs, b0, b1, apb, 5.0 * pixels);

        // Draw arrows only when we have enough space.
        if(arrowVisible) {
            double angleCorr = arrowW / (2.0 * r);
            if(arrowRev) {
                dna = dna.ScaledBy(-1.0);
                angleCorr = -angleCorr;
            }
            DoArrow(canvas, hcs, apa, dna, norm, arrowW, arrowA, angleCorr);
            DoArrow(canvas, hcs, apb, dna, norm, arrowW, arrowA, thetaf + PI - angleCorr);
        }
    } else {
        // The lines are skew; no wonderful way to illustrate that.

        *ref = a0.Plus(b0);
        *ref = (*ref).ScaledBy(0.5).Plus(disp.offset);
        gu = gu.WithMagnitude(1);
        double textHeight = Style::TextHeight(GetStyle()) / camera.scale;
        Vector trans =
            (*ref).Plus(gu.ScaledBy(-1.5*VectorFont::Builtin()-&gt;GetCapHeight(textHeight)));
        canvas-&gt;DrawVectorText("angle between skew lines", textHeight,
                               trans, gr.WithMagnitude(1), gu.WithMagnitude(1),
                               hcs);
    }
}

</t>
<t tx="leo.20191228122643.48">bool Constraint::IsVisible() const {
    if(!SS.GW.showConstraints) return false;
    Group *g = SK.GetGroup(group);
    // If the group is hidden, then the constraints are hidden and not
    // able to be selected.
    if(!(g-&gt;visible)) return false;
    // And likewise if the group is not the active group; except for comments
    // with an assigned style.
    if(g-&gt;h != SS.GW.activeGroup &amp;&amp; !(type == Type::COMMENT &amp;&amp; disp.style.v)) {
        return false;
    }
    if(disp.style.v) {
        Style *s = Style::Get(disp.style);
        if(!s-&gt;visible) return false;
    }
    return true;
}

</t>
<t tx="leo.20191228122643.49">bool Constraint::DoLineExtend(Canvas *canvas, Canvas::hStroke hcs,
                              Vector p0, Vector p1, Vector pt, double salient) {
    Vector dir = p1.Minus(p0);
    double k = dir.Dot(pt.Minus(p0)) / dir.Dot(dir);
    Vector ptOnLine = p0.Plus(dir.ScaledBy(k));

    // Draw projection line.
    DoLine(canvas, hcs, pt, ptOnLine);

    // Calculate salient direction.
    Vector sd = dir.WithMagnitude(1.0).ScaledBy(salient);

    Vector from;
    Vector to;

    if(k &lt; 0.0) {
        from = p0;
        to = ptOnLine.Minus(sd);
    } else if(k &gt; 1.0) {
        from = p1;
        to = ptOnLine.Plus(sd);
    } else {
        return false;
    }

    // Draw extension line.
    DoLine(canvas, hcs, from, to);
    return true;
}

</t>
<t tx="leo.20191228122643.5">    auto it = std::remove_if(lhe.begin(), lhe.end(), [](hEntity he) {
        return he == Entity::NO_ENTITY || !he.isFromRequest();
    });
    lhe.erase(it, lhe.end());

    if(!lhe.empty()) {
        Printf(true, "%FtCONSTRAINS:%E");

        int a = 0;
        for(hEntity he : lhe) {
            Request *r = SK.GetRequest(he.request());
            std::string s = r-&gt;DescriptionString();
            Printf(false, "%Bp   %Fl%Ll%D%f%h%s%E",
                (a &amp; 1) ? 'd' : 'a',
                r-&gt;h.v, (&amp;TextWindow::ScreenSelectRequest),
                &amp;(TextWindow::ScreenHoverRequest), s.c_str());
            a++;
        }
    }
} else {
    int n = SS.GW.selection.n;
    Printf(false, "%FtSELECTED:%E %d item%s", n, n == 1 ? "" : "s");
}

if(shown.screen == Screen::STYLE_INFO &amp;&amp;
   shown.style.v &gt;= Style::FIRST_CUSTOM &amp;&amp; gs.stylables &gt; 0)
{
    // If we are showing a screen for a particular style, then offer the
    // option to assign our selected entities to that style.
    Style *s = Style::Get(shown.style);
    Printf(true, "%Fl%D%f%Ll(assign to style %s)%E",
        shown.style.v,
        &amp;ScreenAssignSelectionToStyle,
        s-&gt;DescriptionString().c_str());
}
// If any of the selected entities have an assigned style, then offer
// the option to remove that style.
bool styleAssigned = false;
for(int i = 0; i &lt; gs.entities; i++) {
    Entity *e = SK.GetEntity(gs.entity[i]);
    if(e-&gt;style.v != 0) {
        styleAssigned = true;
    }
}
for(int i = 0; i &lt; gs.constraints; i++) {
    Constraint *c = SK.GetConstraint(gs.constraint[i]);
    if(c-&gt;type == Constraint::Type::COMMENT &amp;&amp; c-&gt;disp.style.v != 0) {
        styleAssigned = true;
    }
}
if(styleAssigned) {
    Printf(true, "%Fl%D%f%Ll(remove assigned style)%E",
        0,
        &amp;ScreenAssignSelectionToStyle);
}

Printf(true, "%Fl%f%Ll(unselect all)%E", &amp;TextWindow::ScreenUnselectAll);
</t>
<t tx="leo.20191228122643.50">void Constraint::DoLayout(DrawAs how, Canvas *canvas,
                          Vector *labelPos, std::vector&lt;Vector&gt; *refs) {
    if(!(how == DrawAs::HOVERED || how == DrawAs::SELECTED) &amp;&amp;
       !IsVisible()) return;

    // Unit vectors that describe our current view of the scene. One pixel
    // long, not one actual unit.
    const Camera &amp;camera = canvas-&gt;GetCamera();
    Vector gr = camera.projRight.ScaledBy(1/camera.scale);
    Vector gu = camera.projUp.ScaledBy(1/camera.scale);
    Vector gn = (gr.Cross(gu)).WithMagnitude(1/camera.scale);

    double textHeight = Style::TextHeight(GetStyle()) / camera.scale;

    RgbaColor color = {};
    switch(how) {
        case DrawAs::DEFAULT:  color = Style::Color(GetStyle()); break;
        case DrawAs::HOVERED:  color = Style::Color(Style::HOVERED);    break;
        case DrawAs::SELECTED: color = Style::Color(Style::SELECTED);   break;
    }
    Canvas::Stroke stroke = Style::Stroke(GetStyle());
    stroke.layer    = Canvas::Layer::FRONT;
    stroke.color    = color;
    stroke.zIndex   = 4;
    Canvas::hStroke hcs = canvas-&gt;GetStroke(stroke);

    Canvas::Fill fill = {};
    fill.layer      = Canvas::Layer::FRONT;
    fill.color      = color;
    fill.zIndex     = stroke.zIndex;
    Canvas::hFill hcf = canvas-&gt;GetFill(fill);

    switch(type) {
        case Type::PT_PT_DISTANCE: {
            Vector ap = SK.GetEntity(ptA)-&gt;PointGetNum();
            Vector bp = SK.GetEntity(ptB)-&gt;PointGetNum();

            if(workplane != Entity::FREE_IN_3D) {
                DoProjectedPoint(canvas, hcs, &amp;ap);
                DoProjectedPoint(canvas, hcs, &amp;bp);
            }

            Vector ref = ((ap.Plus(bp)).ScaledBy(0.5)).Plus(disp.offset);
            if(refs) refs-&gt;push_back(ref);

            DoLineWithArrows(canvas, hcs, ref, ap, bp, /*onlyOneExt=*/false);
            DoLabel(canvas, hcs, ref, labelPos, gr, gu);
            return;
        }

        case Type::PROJ_PT_DISTANCE: {
            Vector ap = SK.GetEntity(ptA)-&gt;PointGetNum(),
                   bp = SK.GetEntity(ptB)-&gt;PointGetNum(),
                   dp = (bp.Minus(ap)),
                   pp = SK.GetEntity(entityA)-&gt;VectorGetNum();

            Vector ref = ((ap.Plus(bp)).ScaledBy(0.5)).Plus(disp.offset);
            if(refs) refs-&gt;push_back(ref);

            pp = pp.WithMagnitude(1);
            double d = dp.Dot(pp);
            Vector bpp = ap.Plus(pp.ScaledBy(d));
            DoStippledLine(canvas, hcs, ap, bpp);
            DoStippledLine(canvas, hcs, bp, bpp);

            DoLineWithArrows(canvas, hcs, ref, ap, bpp, /*onlyOneExt=*/false);
            DoLabel(canvas, hcs, ref, labelPos, gr, gu);
            return;
        }

        case Type::PT_FACE_DISTANCE:
        case Type::PT_PLANE_DISTANCE: {
            Vector pt = SK.GetEntity(ptA)-&gt;PointGetNum();
            Entity *enta = SK.GetEntity(entityA);
            Vector n, p;
            if(type == Type::PT_PLANE_DISTANCE) {
                n = enta-&gt;Normal()-&gt;NormalN();
                p = enta-&gt;WorkplaneGetOffset();
            } else {
                n = enta-&gt;FaceGetNormalNum();
                p = enta-&gt;FaceGetPointNum();
            }

            double d = (p.Minus(pt)).Dot(n);
            Vector closest = pt.Plus(n.WithMagnitude(d));

            Vector ref = ((closest.Plus(pt)).ScaledBy(0.5)).Plus(disp.offset);
            if(refs) refs-&gt;push_back(ref);

            if(!pt.Equals(closest)) {
                DoLineWithArrows(canvas, hcs, ref, pt, closest, /*onlyOneExt=*/true);
            }

            DoLabel(canvas, hcs, ref, labelPos, gr, gu);
            return;
        }

        case Type::PT_LINE_DISTANCE: {
            Vector pt = SK.GetEntity(ptA)-&gt;PointGetNum();
            Entity *line = SK.GetEntity(entityA);
            Vector lA = SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum();
            Vector lB = SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum();
            Vector dl = lB.Minus(lA);

            if(workplane != Entity::FREE_IN_3D) {
                lA = lA.ProjectInto(workplane);
                lB = lB.ProjectInto(workplane);
                DoProjectedPoint(canvas, hcs, &amp;pt);
            }

            // Find the closest point on the line
            Vector closest = pt.ClosestPointOnLine(lA, dl);

            Vector ref = ((closest.Plus(pt)).ScaledBy(0.5)).Plus(disp.offset);
            if(refs) refs-&gt;push_back(ref);
            DoLabel(canvas, hcs, ref, labelPos, gr, gu);

            if(!pt.Equals(closest)) {
                DoLineWithArrows(canvas, hcs, ref, pt, closest, /*onlyOneExt=*/true);

                // Draw projected point
                Vector a    = pt;
                Vector b    = closest;
                Vector ab   = a.Minus(b);
                Vector ar   = a.Minus(ref);
                Vector n    = ab.Cross(ar);
                Vector out  = ab.Cross(n).WithMagnitude(1);
                out = out.ScaledBy(-out.Dot(ar));
                Vector be   = b.Plus(out);
                Vector np   = lA.Minus(pt).Cross(lB.Minus(pt)).WithMagnitude(1.0);
                DoProjectedPoint(canvas, hcs, &amp;be, np, pt);

                // Extensions to line
                double pixels = 1.0 / camera.scale;
                Vector refClosest = ref.ClosestPointOnLine(lA, dl);
                double ddl = dl.Dot(dl);
                if(fabs(ddl) &gt; LENGTH_EPS * LENGTH_EPS) {
                    double t = refClosest.Minus(lA).Dot(dl) / ddl;
                    if(t &lt; 0.0) {
                        DoLine(canvas, hcs, refClosest.Minus(dl.WithMagnitude(10.0 * pixels)), lA);
                    } else if(t &gt; 1.0) {
                        DoLine(canvas, hcs, refClosest.Plus(dl.WithMagnitude(10.0 * pixels)), lB);
                    }
                }
            }

            if(workplane != Entity::FREE_IN_3D) {
                // Draw the projection marker from the closest point on the
                // projected line to the projected point on the real line.
                Vector lAB = (lA.Minus(lB));
                double t = (lA.Minus(closest)).DivProjected(lAB);

                Vector lA = SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum();
                Vector lB = SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum();

                Vector c2 = (lA.ScaledBy(1-t)).Plus(lB.ScaledBy(t));
                DoProjectedPoint(canvas, hcs, &amp;c2);
            }
            return;
        }

        case Type::DIAMETER: {
            Entity *circle = SK.GetEntity(entityA);
            Vector center = SK.GetEntity(circle-&gt;point[0])-&gt;PointGetNum();
            Quaternion q = SK.GetEntity(circle-&gt;normal)-&gt;NormalGetNum();
            Vector n = q.RotationN().WithMagnitude(1);
            double r = circle-&gt;CircleGetRadiusNum();

            Vector ref = center.Plus(disp.offset);
            // Force the label into the same plane as the circle.
            ref = ref.Minus(n.ScaledBy(n.Dot(ref) - n.Dot(center)));
            if(refs) refs-&gt;push_back(ref);

            Vector mark = ref.Minus(center);
            mark = mark.WithMagnitude(mark.Magnitude()-r);
            DoLineTrimmedAgainstBox(canvas, hcs, ref, ref, ref.Minus(mark));

            Vector topLeft;
            DoLabel(canvas, hcs, ref, &amp;topLeft, gr, gu);
            if(labelPos) *labelPos = topLeft;
            return;
        }

        case Type::POINTS_COINCIDENT: {
            if(how == DrawAs::DEFAULT) {
                // Let's adjust the color of this constraint to have the same
                // rough luma as the point color, so that the constraint does not
                // stand out in an ugly way.
                RgbaColor cd = Style::Color(Style::DATUM),
                          cc = Style::Color(Style::CONSTRAINT);
                // convert from 8-bit color to a vector
                Vector vd = Vector::From(cd.redF(), cd.greenF(), cd.blueF()),
                       vc = Vector::From(cc.redF(), cc.greenF(), cc.blueF());
                // and scale the constraint color to have the same magnitude as
                // the datum color, maybe a bit dimmer
                vc = vc.WithMagnitude(vd.Magnitude()*0.9);
                // and set the color to that.
                fill.color = RGBf(vc.x, vc.y, vc.z);
                hcf = canvas-&gt;GetFill(fill);
            }

            for(int a = 0; a &lt; 2; a++) {
                Vector r = camera.projRight.ScaledBy((a+1)/camera.scale);
                Vector d = camera.projUp.ScaledBy((2-a)/camera.scale);
                for(int i = 0; i &lt; 2; i++) {
                    Vector p = SK.GetEntity(i == 0 ? ptA : ptB)-&gt; PointGetNum();
                    if(refs) refs-&gt;push_back(p);
                    canvas-&gt;DrawQuad(p.Plus (r).Plus (d),
                                     p.Plus (r).Minus(d),
                                     p.Minus(r).Minus(d),
                                     p.Minus(r).Plus (d),
                                     hcf);
                }

            }
            return;
        }

        case Type::PT_ON_CIRCLE:
        case Type::PT_ON_LINE:
        case Type::PT_ON_FACE:
        case Type::PT_IN_PLANE: {
            double s = 8/camera.scale;
            Vector p = SK.GetEntity(ptA)-&gt;PointGetNum();
            if(refs) refs-&gt;push_back(p);
            Vector r, d;
            if(type == Type::PT_ON_FACE) {
                Vector n = SK.GetEntity(entityA)-&gt;FaceGetNormalNum();
                r = n.Normal(0);
                d = n.Normal(1);
            } else if(type == Type::PT_IN_PLANE) {
                EntityBase *n = SK.GetEntity(entityA)-&gt;Normal();
                r = n-&gt;NormalU();
                d = n-&gt;NormalV();
            } else {
                r = gr;
                d = gu;
                s *= (6.0/8); // draw these a little smaller
            }
            r = r.WithMagnitude(s); d = d.WithMagnitude(s);
            DoLine(canvas, hcs, p.Plus (r).Plus (d), p.Plus (r).Minus(d));
            DoLine(canvas, hcs, p.Plus (r).Minus(d), p.Minus(r).Minus(d));
            DoLine(canvas, hcs, p.Minus(r).Minus(d), p.Minus(r).Plus (d));
            DoLine(canvas, hcs, p.Minus(r).Plus (d), p.Plus (r).Plus (d));
            return;
        }

        case Type::WHERE_DRAGGED: {
            Vector p = SK.GetEntity(ptA)-&gt;PointGetNum();
            if(refs) refs-&gt;push_back(p);
            Vector u = p.Plus(gu.WithMagnitude(8/camera.scale)).Plus(
                              gr.WithMagnitude(8/camera.scale)),
                   uu = u.Minus(gu.WithMagnitude(5/camera.scale)),
                   ur = u.Minus(gr.WithMagnitude(5/camera.scale));
            // Draw four little crop marks, uniformly spaced (by ninety
            // degree rotations) around the point.
            int i;
            for(i = 0; i &lt; 4; i++) {
                DoLine(canvas, hcs, u, uu);
                DoLine(canvas, hcs, u, ur);
                u = u.RotatedAbout(p, gn, PI/2);
                ur = ur.RotatedAbout(p, gn, PI/2);
                uu = uu.RotatedAbout(p, gn, PI/2);
            }
            return;
        }

        case Type::SAME_ORIENTATION: {
            for(int i = 0; i &lt; 2; i++) {
                Entity *e = SK.GetEntity(i == 0 ? entityA : entityB);
                Quaternion q = e-&gt;NormalGetNum();
                Vector n = q.RotationN().WithMagnitude(25/camera.scale);
                Vector u = q.RotationU().WithMagnitude(6/camera.scale);
                Vector p = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                p = p.Plus(n.WithMagnitude(10/camera.scale));
                if(refs) refs-&gt;push_back(p);

                DoLine(canvas, hcs, p.Plus(u), p.Minus(u).Plus(n));
                DoLine(canvas, hcs, p.Minus(u), p.Plus(u).Plus(n));
            }
            return;
        }

        case Type::EQUAL_ANGLE: {
            Vector ref;
            Entity *a = SK.GetEntity(entityA);
            Entity *b = SK.GetEntity(entityB);
            Entity *c = SK.GetEntity(entityC);
            Entity *d = SK.GetEntity(entityD);

            Vector a0 = a-&gt;VectorGetStartPoint();
            Vector b0 = b-&gt;VectorGetStartPoint();
            Vector c0 = c-&gt;VectorGetStartPoint();
            Vector d0 = d-&gt;VectorGetStartPoint();
            Vector da = a-&gt;VectorGetNum();
            Vector db = b-&gt;VectorGetNum();
            Vector dc = c-&gt;VectorGetNum();
            Vector dd = d-&gt;VectorGetNum();

            if(other) {
                a0 = a0.Plus(da);
                da = da.ScaledBy(-1);
            }

            DoArcForAngle(canvas, hcs, a0, da, b0, db,
                da.WithMagnitude(40/camera.scale), &amp;ref, /*trim=*/false);
            if(refs) refs-&gt;push_back(ref);
            DoArcForAngle(canvas, hcs, c0, dc, d0, dd,
                dc.WithMagnitude(40/camera.scale), &amp;ref, /*trim=*/false);
            if(refs) refs-&gt;push_back(ref);

            return;
        }

        case Type::ANGLE: {
            Entity *a = SK.GetEntity(entityA);
            Entity *b = SK.GetEntity(entityB);

            Vector a0 = a-&gt;VectorGetStartPoint();
            Vector b0 = b-&gt;VectorGetStartPoint();
            Vector da = a-&gt;VectorGetNum();
            Vector db = b-&gt;VectorGetNum();
            if(other) {
                a0 = a0.Plus(da);
                da = da.ScaledBy(-1);
            }

            Vector ref;
            DoArcForAngle(canvas, hcs, a0, da, b0, db, disp.offset, &amp;ref, /*trim=*/true);
            DoLabel(canvas, hcs, ref, labelPos, gr, gu);
            if(refs) refs-&gt;push_back(ref);
            return;
        }

        case Type::PERPENDICULAR: {
            Vector u = Vector::From(0, 0, 0), v = Vector::From(0, 0, 0);
            Vector rn, ru;
            if(workplane == Entity::FREE_IN_3D) {
                rn = gn;
                ru = gu;
            } else {
                EntityBase *normal = SK.GetEntity(workplane)-&gt;Normal();
                rn = normal-&gt;NormalN();
                ru = normal-&gt;NormalV(); // ru meaning r_up, not u/v
            }

            for(int i = 0; i &lt; 2; i++) {
                Entity *e = SK.GetEntity(i == 0 ? entityA : entityB);

                if(i == 0) {
                    // Calculate orientation of perpendicular sign only
                    // once, so that it's the same both times it's drawn
                    u = e-&gt;VectorGetNum();
                    u = u.WithMagnitude(16/camera.scale);
                    v = (rn.Cross(u)).WithMagnitude(16/camera.scale);
                    // a bit of bias to stop it from flickering between the
                    // two possibilities
                    if(fabs(u.Dot(ru)) &lt; fabs(v.Dot(ru)) + LENGTH_EPS) {
                        swap(u, v);
                    }
                    if(u.Dot(ru) &lt; 0) u = u.ScaledBy(-1);
                }

                Vector p = e-&gt;VectorGetRefPoint();
                Vector s = p.Plus(u).Plus(v);
                DoLine(canvas, hcs, s, s.Plus(v));
                Vector m = s.Plus(v.ScaledBy(0.5));
                DoLine(canvas, hcs, m, m.Plus(u));
                if(refs) refs-&gt;push_back(m);
            }
            return;
        }

        case Type::CURVE_CURVE_TANGENT:
        case Type::CUBIC_LINE_TANGENT:
        case Type::ARC_LINE_TANGENT: {
            Vector textAt, u, v;

            if(type == Type::ARC_LINE_TANGENT) {
                Entity *arc = SK.GetEntity(entityA);
                Entity *norm = SK.GetEntity(arc-&gt;normal);
                Vector c = SK.GetEntity(arc-&gt;point[0])-&gt;PointGetNum();
                Vector p =
                    SK.GetEntity(arc-&gt;point[other ? 2 : 1])-&gt;PointGetNum();
                Vector r = p.Minus(c);
                textAt = p.Plus(r.WithMagnitude(14/camera.scale));
                u = norm-&gt;NormalU();
                v = norm-&gt;NormalV();
            } else if(type == Type::CUBIC_LINE_TANGENT) {
                Vector n;
                if(workplane == Entity::FREE_IN_3D) {
                    u = gr;
                    v = gu;
                    n = gn;
                } else {
                    EntityBase *wn = SK.GetEntity(workplane)-&gt;Normal();
                    u = wn-&gt;NormalU();
                    v = wn-&gt;NormalV();
                    n = wn-&gt;NormalN();
                }

                Entity *cubic = SK.GetEntity(entityA);
                Vector p = other ? cubic-&gt;CubicGetFinishNum() :
                                   cubic-&gt;CubicGetStartNum();
                Vector dir = SK.GetEntity(entityB)-&gt;VectorGetNum();
                Vector out = n.Cross(dir);
                textAt = p.Plus(out.WithMagnitude(14/camera.scale));
            } else {
                Vector n, dir;
                EntityBase *wn = SK.GetEntity(workplane)-&gt;Normal();
                u = wn-&gt;NormalU();
                v = wn-&gt;NormalV();
                n = wn-&gt;NormalN();
                EntityBase *eA = SK.GetEntity(entityA);
                // Big pain; we have to get a vector tangent to the curve
                // at the shared point, which could be from either a cubic
                // or an arc.
                if(other) {
                    textAt = eA-&gt;EndpointFinish();
                    if(eA-&gt;type == Entity::Type::CUBIC) {
                        dir = eA-&gt;CubicGetFinishTangentNum();
                    } else {
                        dir = SK.GetEntity(eA-&gt;point[0])-&gt;PointGetNum().Minus(
                              SK.GetEntity(eA-&gt;point[2])-&gt;PointGetNum());
                        dir = n.Cross(dir);
                    }
                } else {
                    textAt = eA-&gt;EndpointStart();
                    if(eA-&gt;type == Entity::Type::CUBIC) {
                        dir = eA-&gt;CubicGetStartTangentNum();
                    } else {
                        dir = SK.GetEntity(eA-&gt;point[0])-&gt;PointGetNum().Minus(
                              SK.GetEntity(eA-&gt;point[1])-&gt;PointGetNum());
                        dir = n.Cross(dir);
                    }
                }
                dir = n.Cross(dir);
                textAt = textAt.Plus(dir.WithMagnitude(14/camera.scale));
            }

            Vector ex = VectorFont::Builtin()-&gt;GetExtents(textHeight, "T");
            canvas-&gt;DrawVectorText("T", textHeight, textAt.Minus(ex.ScaledBy(0.5)),
                                   u.WithMagnitude(1), v.WithMagnitude(1), hcs);
            if(refs) refs-&gt;push_back(textAt);
            return;
        }

        case Type::PARALLEL: {
            for(int i = 0; i &lt; 2; i++) {
                Entity *e = SK.GetEntity(i == 0 ? entityA : entityB);
                Vector n = e-&gt;VectorGetNum();
                n = n.WithMagnitude(25/camera.scale);
                Vector u = (gn.Cross(n)).WithMagnitude(4/camera.scale);
                Vector p = e-&gt;VectorGetRefPoint();

                DoLine(canvas, hcs, p.Plus(u), p.Plus(u).Plus(n));
                DoLine(canvas, hcs, p.Minus(u), p.Minus(u).Plus(n));
                if(refs) refs-&gt;push_back(p.Plus(n.ScaledBy(0.5)));
            }
            return;
        }

        case Type::EQUAL_RADIUS: {
            for(int i = 0; i &lt; 2; i++) {
                Vector ref;
                DoEqualRadiusTicks(canvas, hcs, i == 0 ? entityA : entityB, &amp;ref);
                if(refs) refs-&gt;push_back(ref);
            }
            return;
        }

        case Type::EQUAL_LINE_ARC_LEN: {
            Entity *line = SK.GetEntity(entityA);
            Vector ref;
            DoEqualLenTicks(canvas, hcs,
                SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum(),
                SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum(),
                gn, &amp;ref);
            if(refs) refs-&gt;push_back(ref);
            DoEqualRadiusTicks(canvas, hcs, entityB, &amp;ref);
            if(refs) refs-&gt;push_back(ref);
            return;
        }

        case Type::LENGTH_RATIO:
        case Type::LENGTH_DIFFERENCE:
        case Type::EQUAL_LENGTH_LINES: {
            Vector a, b = Vector::From(0, 0, 0);
            for(int i = 0; i &lt; 2; i++) {
                Entity *e = SK.GetEntity(i == 0 ? entityA : entityB);
                a = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                b = SK.GetEntity(e-&gt;point[1])-&gt;PointGetNum();

                if(workplane != Entity::FREE_IN_3D) {
                    DoProjectedPoint(canvas, hcs, &amp;a);
                    DoProjectedPoint(canvas, hcs, &amp;b);
                }

                Vector ref;
                DoEqualLenTicks(canvas, hcs, a, b, gn, &amp;ref);
                if(refs) refs-&gt;push_back(ref);
            }
            if((type == Type::LENGTH_RATIO) || (type == Type::LENGTH_DIFFERENCE)) {
                Vector ref = ((a.Plus(b)).ScaledBy(0.5)).Plus(disp.offset);
                DoLabel(canvas, hcs, ref, labelPos, gr, gu);
            }
            return;
        }

        case Type::EQ_LEN_PT_LINE_D: {
            Entity *forLen = SK.GetEntity(entityA);
            Vector a = SK.GetEntity(forLen-&gt;point[0])-&gt;PointGetNum(),
                   b = SK.GetEntity(forLen-&gt;point[1])-&gt;PointGetNum();
            if(workplane != Entity::FREE_IN_3D) {
                DoProjectedPoint(canvas, hcs, &amp;a);
                DoProjectedPoint(canvas, hcs, &amp;b);
            }
            Vector refa;
            DoEqualLenTicks(canvas, hcs, a, b, gn, &amp;refa);
            if(refs) refs-&gt;push_back(refa);

            Entity *ln = SK.GetEntity(entityB);
            Vector la = SK.GetEntity(ln-&gt;point[0])-&gt;PointGetNum(),
                   lb = SK.GetEntity(ln-&gt;point[1])-&gt;PointGetNum();
            Vector pt = SK.GetEntity(ptA)-&gt;PointGetNum();
            if(workplane != Entity::FREE_IN_3D) {
                DoProjectedPoint(canvas, hcs, &amp;pt);
                la = la.ProjectInto(workplane);
                lb = lb.ProjectInto(workplane);
            }

            Vector closest = pt.ClosestPointOnLine(la, lb.Minus(la));
            DoLine(canvas, hcs, pt, closest);
            Vector refb;
            DoEqualLenTicks(canvas, hcs, pt, closest, gn, &amp;refb);
            if(refs) refs-&gt;push_back(refb);
            return;
        }

        case Type::EQ_PT_LN_DISTANCES: {
            for(int i = 0; i &lt; 2; i++) {
                Entity *ln = SK.GetEntity(i == 0 ? entityA : entityB);
                Vector la = SK.GetEntity(ln-&gt;point[0])-&gt;PointGetNum(),
                       lb = SK.GetEntity(ln-&gt;point[1])-&gt;PointGetNum();
                Entity *pte = SK.GetEntity(i == 0 ? ptA : ptB);
                Vector pt = pte-&gt;PointGetNum();

                if(workplane != Entity::FREE_IN_3D) {
                    DoProjectedPoint(canvas, hcs, &amp;pt);
                    la = la.ProjectInto(workplane);
                    lb = lb.ProjectInto(workplane);
                }

                Vector closest = pt.ClosestPointOnLine(la, lb.Minus(la));
                DoLine(canvas, hcs, pt, closest);

                Vector ref;
                DoEqualLenTicks(canvas, hcs, pt, closest, gn, &amp;ref);
                if(refs) refs-&gt;push_back(ref);
            }
            return;
        }

        {
        case Type::SYMMETRIC:
            Vector n;
            n = SK.GetEntity(entityA)-&gt;Normal()-&gt;NormalN(); goto s;
        case Type::SYMMETRIC_HORIZ:
            n = SK.GetEntity(workplane)-&gt;Normal()-&gt;NormalU(); goto s;
        case Type::SYMMETRIC_VERT:
            n = SK.GetEntity(workplane)-&gt;Normal()-&gt;NormalV(); goto s;
        case Type::SYMMETRIC_LINE: {
            Entity *ln = SK.GetEntity(entityA);
            Vector la = SK.GetEntity(ln-&gt;point[0])-&gt;PointGetNum(),
                   lb = SK.GetEntity(ln-&gt;point[1])-&gt;PointGetNum();
            la = la.ProjectInto(workplane);
            lb = lb.ProjectInto(workplane);
            n = lb.Minus(la);
            Vector nw = SK.GetEntity(workplane)-&gt;Normal()-&gt;NormalN();
            n = n.RotatedAbout(nw, PI/2);
            goto s;
        }
s:
            Vector a = SK.GetEntity(ptA)-&gt;PointGetNum();
            Vector b = SK.GetEntity(ptB)-&gt;PointGetNum();

            for(int i = 0; i &lt; 2; i++) {
                Vector tail = (i == 0) ? a : b;
                Vector d = (i == 0) ? b : a;
                d = d.Minus(tail);
                // Project the direction in which the arrow is drawn normal
                // to the symmetry plane; for projected symmetry constraints,
                // they might not be in the same direction, even when the
                // constraint is fully solved.
                d = n.ScaledBy(d.Dot(n));
                d = d.WithMagnitude(20/camera.scale);
                Vector tip = tail.Plus(d);

                DoLine(canvas, hcs, tail, tip);
                d = d.WithMagnitude(9/camera.scale);
                DoLine(canvas, hcs, tip, tip.Minus(d.RotatedAbout(gn,  0.6)));
                DoLine(canvas, hcs, tip, tip.Minus(d.RotatedAbout(gn, -0.6)));
                if(refs) refs-&gt;push_back(tip);
            }
            return;
        }

        case Type::AT_MIDPOINT:
        case Type::HORIZONTAL:
        case Type::VERTICAL:
            if(entityA.v) {
                Vector r, u, n;
                if(workplane == Entity::FREE_IN_3D) {
                    r = gr; u = gu; n = gn;
                } else {
                    r = SK.GetEntity(workplane)-&gt;Normal()-&gt;NormalU();
                    u = SK.GetEntity(workplane)-&gt;Normal()-&gt;NormalV();
                    n = r.Cross(u);
                }
                // For "at midpoint", this branch is always taken.
                Entity *e = SK.GetEntity(entityA);
                Vector a = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
                Vector b = SK.GetEntity(e-&gt;point[1])-&gt;PointGetNum();
                Vector m = (a.ScaledBy(0.5)).Plus(b.ScaledBy(0.5));
                Vector offset = (a.Minus(b)).Cross(n);
                offset = offset.WithMagnitude(textHeight);
                // Draw midpoint constraint on other side of line, so that
                // a line can be midpoint and horizontal at same time.
                if(type == Type::AT_MIDPOINT) offset = offset.ScaledBy(-1);

                std::string s;
                switch(type) {
                    case Type::HORIZONTAL:  s = "H"; break;
                    case Type::VERTICAL:    s = "V"; break;
                    case Type::AT_MIDPOINT: s = "M"; break;
                    default: ssassert(false, "Unexpected constraint type");
                }
                Vector o  = m.Plus(offset).Plus(u.WithMagnitude(textHeight/5)),
                       ex = VectorFont::Builtin()-&gt;GetExtents(textHeight, s);
                Vector shift = r.WithMagnitude(ex.x).Plus(
                               u.WithMagnitude(ex.y));

                canvas-&gt;DrawVectorText(s, textHeight, o.Minus(shift.ScaledBy(0.5)),
                                       r.WithMagnitude(1), u.WithMagnitude(1), hcs);
                if(refs) refs-&gt;push_back(o);
            } else {
                Vector a = SK.GetEntity(ptA)-&gt;PointGetNum();
                Vector b = SK.GetEntity(ptB)-&gt;PointGetNum();

                Entity *w = SK.GetEntity(workplane);
                Vector cu = w-&gt;Normal()-&gt;NormalU();
                Vector cv = w-&gt;Normal()-&gt;NormalV();
                Vector cn = w-&gt;Normal()-&gt;NormalN();

                int i;
                for(i = 0; i &lt; 2; i++) {
                    Vector o = (i == 0) ? a : b;
                    Vector oo = (i == 0) ? a.Minus(b) : b.Minus(a);
                    Vector d = (type == Type::HORIZONTAL) ? cu : cv;
                    if(oo.Dot(d) &lt; 0) d = d.ScaledBy(-1);

                    Vector dp = cn.Cross(d);
                    d = d.WithMagnitude(14/camera.scale);
                    Vector c = o.Minus(d);
                    DoLine(canvas, hcs, o, c);
                    d = d.WithMagnitude(3/camera.scale);
                    dp = dp.WithMagnitude(2/camera.scale);
                    canvas-&gt;DrawQuad((c.Plus(d)).Plus(dp),
                                     (c.Minus(d)).Plus(dp),
                                     (c.Minus(d)).Minus(dp),
                                     (c.Plus(d)).Minus(dp),
                                     hcf);
                    if(refs) refs-&gt;push_back(c);
                }
            }
            return;

        case Type::COMMENT: {
            Vector u, v;
            if(workplane == Entity::FREE_IN_3D) {
                u = gr;
                v = gu;
            } else {
                EntityBase *norm = SK.GetEntity(workplane)-&gt;Normal();
                u = norm-&gt;NormalU();
                v = norm-&gt;NormalV();
            }

            if(disp.style.v != 0) {
                RgbaColor color = stroke.color;
                stroke = Style::Stroke(disp.style);
                stroke.layer = Canvas::Layer::FRONT;
                if(how != DrawAs::DEFAULT) {
                    stroke.color = color;
                }
                hcs = canvas-&gt;GetStroke(stroke);
            }
            DoLabel(canvas, hcs, disp.offset, labelPos, u, v);
            if(refs) refs-&gt;push_back(disp.offset);
            return;
        }
    }
    ssassert(false, "Unexpected constraint type");
}

</t>
<t tx="leo.20191228122643.51">void Constraint::Draw(DrawAs how, Canvas *canvas) {
    DoLayout(how, canvas, NULL, NULL);
}

Vector Constraint::GetLabelPos(const Camera &amp;camera) {
    Vector p;

    ObjectPicker canvas = {};
    canvas.camera = camera;
    DoLayout(DrawAs::DEFAULT, &amp;canvas, &amp;p, NULL);
    canvas.Clear();

    return p;
}

</t>
<t tx="leo.20191228122643.52">void Constraint::GetReferencePoints(const Camera &amp;camera, std::vector&lt;Vector&gt; *refs) {
    ObjectPicker canvas = {};
    canvas.camera = camera;
    DoLayout(DrawAs::DEFAULT, &amp;canvas, NULL, refs);
    canvas.Clear();
}

</t>
<t tx="leo.20191228122643.53">bool Constraint::IsStylable() const {
    if(type == Type::COMMENT) return true;
    return false;
}

hStyle Constraint::GetStyle() const {
    if(disp.style.v != 0) return disp.style;
    return { Style::CONSTRAINT };
}

</t>
<t tx="leo.20191228122643.54">bool Constraint::HasLabel() const {
    switch(type) {
        case Type::COMMENT:
        case Type::PT_PT_DISTANCE:
        case Type::PT_PLANE_DISTANCE:
        case Type::PT_LINE_DISTANCE:
        case Type::PT_FACE_DISTANCE:
        case Type::PROJ_PT_DISTANCE:
        case Type::LENGTH_RATIO:
        case Type::LENGTH_DIFFERENCE:
        case Type::DIAMETER:
        case Type::ANGLE:
            return true;

        default:
            return false;
    }
}
</t>
<t tx="leo.20191228122643.55">@path ./src/
//-----------------------------------------------------------------------------
// Draw a representation of an entity on-screen, in the case of curves up
// to our chord tolerance, or return the distance from the user's mouse pointer
// to the entity for selection.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

std::string Entity::DescriptionString() const {
    if(h.isFromRequest()) {
        Request *r = SK.GetRequest(h.request());
        return r-&gt;DescriptionString();
    } else {
        Group *g = SK.GetGroup(h.group());
        return g-&gt;DescriptionString();
    }
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122643.56">void Entity::GenerateEdges(SEdgeList *el) {
    SBezierList *sbl = GetOrGenerateBezierCurves();

    for(int i = 0; i &lt; sbl-&gt;l.n; i++) {
        SBezier *sb = &amp;(sbl-&gt;l[i]);

        List&lt;Vector&gt; lv = {};
        sb-&gt;MakePwlInto(&amp;lv);
        for(int j = 1; j &lt; lv.n; j++) {
            el-&gt;AddEdge(lv[j-1], lv[j], style.v, i);
        }
        lv.Clear();
    }
}

SBezierList *Entity::GetOrGenerateBezierCurves() {
    if(beziers.l.IsEmpty())
        GenerateBezierCurves(&amp;beziers);
    return &amp;beziers;
}

SEdgeList *Entity::GetOrGenerateEdges() {
    if(!edges.l.IsEmpty()) {
        if(EXACT(edgesChordTol == SS.ChordTolMm()))
            return &amp;edges;
        edges.l.Clear();
    }
    if(edges.l.IsEmpty())
        GenerateEdges(&amp;edges);
    edgesChordTol = SS.ChordTolMm();
    return &amp;edges;
}

BBox Entity::GetOrGenerateScreenBBox(bool *hasBBox) {
    SBezierList *sbl = GetOrGenerateBezierCurves();

    // We don't bother with bounding boxes for workplanes, etc.
    *hasBBox = (IsPoint() || IsNormal() || !sbl-&gt;l.IsEmpty());
    if(!*hasBBox) return {};

    if(screenBBoxValid)
        return screenBBox;

    if(IsPoint()) {
        Vector proj = SS.GW.ProjectPoint3(PointGetNum());
        screenBBox = BBox::From(proj, proj);
    } else if(IsNormal()) {
        Vector proj = SK.GetEntity(point[0])-&gt;PointGetNum();
        screenBBox = BBox::From(proj, proj);
    } else if(!sbl-&gt;l.IsEmpty()) {
        Vector first = SS.GW.ProjectPoint3(sbl-&gt;l[0].ctrl[0]);
        screenBBox = BBox::From(first, first);
        for(auto &amp;sb : sbl-&gt;l) {
            for(int i = 0; i &lt; sb.deg; ++i) { screenBBox.Include(SS.GW.ProjectPoint3(sb.ctrl[i])); }
        }
    } else
        ssassert(false, "Expected entity to be a point or have beziers");

    screenBBoxValid = true;
    return screenBBox;
}

</t>
<t tx="leo.20191228122643.57">void Entity::GetReferencePoints(std::vector&lt;Vector&gt; *refs) {
    switch(type) {
        case Type::POINT_N_COPY:
        case Type::POINT_N_TRANS:
        case Type::POINT_N_ROT_TRANS:
        case Type::POINT_N_ROT_AA:
        case Type::POINT_N_ROT_AXIS_TRANS:
        case Type::POINT_IN_3D:
        case Type::POINT_IN_2D:
            refs-&gt;push_back(PointGetNum());
            break;

        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D:
        case Type::WORKPLANE:
        case Type::CIRCLE:
        case Type::ARC_OF_CIRCLE:
        case Type::CUBIC:
        case Type::CUBIC_PERIODIC:
        case Type::TTF_TEXT:
        case Type::IMAGE:
            refs-&gt;push_back(SK.GetEntity(point[0])-&gt;PointGetNum());
            break;

        case Type::LINE_SEGMENT: {
            Vector a = SK.GetEntity(point[0])-&gt;PointGetNum(),
                   b = SK.GetEntity(point[1])-&gt;PointGetNum();
            refs-&gt;push_back(b.Plus(a.Minus(b).ScaledBy(0.5)));
            break;
        }

        case Type::DISTANCE:
        case Type::DISTANCE_N_COPY:
        case Type::FACE_NORMAL_PT:
        case Type::FACE_XPROD:
        case Type::FACE_N_ROT_TRANS:
        case Type::FACE_N_TRANS:
        case Type::FACE_N_ROT_AA:
            break;
    }
}

</t>
<t tx="leo.20191228122643.58">int Entity::GetPositionOfPoint(const Camera &amp;camera, Point2d p) {
    int position;

    ObjectPicker canvas = {};
    canvas.camera      = camera;
    canvas.point       = p;
    canvas.minDistance = 1e12;
    Draw(DrawAs::DEFAULT, &amp;canvas);
    position = canvas.position;
    canvas.Clear();

    return position;
}

</t>
<t tx="leo.20191228122643.59">bool Entity::IsStylable() const {
    if(IsPoint()) return false;
    if(IsWorkplane()) return false;
    if(IsNormal()) return false;
    return true;
}

</t>
<t tx="leo.20191228122643.6">void TextWindow::GoToScreen(Screen screen) {
    shown.screen = screen;
}

</t>
<t tx="leo.20191228122643.60">bool Entity::IsVisible() const {
    Group *g = SK.GetGroup(group);

    if(g-&gt;h == Group::HGROUP_REFERENCES &amp;&amp; IsNormal()) {
        // The reference normals are always shown
        return true;
    }
    if(!(g-&gt;IsVisible())) return false;

    if(IsPoint() &amp;&amp; !SS.GW.showPoints) return false;
    if(IsNormal() &amp;&amp; !SS.GW.showNormals) return false;
    if(construction &amp;&amp; !SS.GW.showConstruction) return false;

    if(!SS.GW.showWorkplanes) {
        if(IsWorkplane() &amp;&amp; !h.isFromRequest()) {
            if(g-&gt;h != SS.GW.activeGroup) {
                // The group-associated workplanes are hidden outside
                // their group.
                return false;
            }
        }
    }

    if(style.v) {
        Style *s = Style::Get(style);
        if(!s-&gt;visible) return false;
    }

    if(forceHidden) return false;

    return true;
}

</t>
<t tx="leo.20191228122643.61">void Entity::CalculateNumerical(bool forExport) {
    if(IsPoint()) actPoint = PointGetNum();
    if(IsNormal()) actNormal = NormalGetNum();
    if(type == Type::DISTANCE || type == Type::DISTANCE_N_COPY) {
        actDistance = DistanceGetNum();
    }
    if(IsFace()) {
        actPoint  = FaceGetPointNum();
        Vector n = FaceGetNormalNum();
        actNormal = Quaternion::From(0, n.x, n.y, n.z);
    }
    if(forExport) {
        // Visibility in copied linked entities follows source file
        actVisible = IsVisible();
    } else {
        // Copied entities within a file are always visible
        actVisible = true;
    }
}

//-----------------------------------------------------------------------------
// Compute a cubic, second derivative continuous, interpolating spline. Same
// routine for periodic splines (in a loop) or open splines (with specified
// end tangents).
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122643.62">void Entity::ComputeInterpolatingSpline(SBezierList *sbl, bool periodic) const {
    static const int MAX_N = BandedMatrix::MAX_UNKNOWNS;
    int ep = extraPoints;

    // The number of unknowns to solve for.
    int n   = periodic ? 3 + ep : ep;
    ssassert(n &lt; MAX_N, "Too many unknowns");
    // The number of on-curve points, one more than the number of segments.
    int pts = periodic ? 4 + ep : 2 + ep;

    int i, j, a;

    // The starting and finishing control points that define our end tangents
    // (if the spline isn't periodic), and the on-curve points.
    Vector ctrl_s = Vector::From(0, 0, 0);
    Vector ctrl_f = Vector::From(0, 0, 0);
    Vector pt[MAX_N+4];
    if(periodic) {
        for(i = 0; i &lt; ep + 3; i++) {
            pt[i] = SK.GetEntity(point[i])-&gt;PointGetNum();
        }
        pt[i++] = SK.GetEntity(point[0])-&gt;PointGetNum();
    } else {
        ctrl_s = SK.GetEntity(point[1])-&gt;PointGetNum();
        ctrl_f = SK.GetEntity(point[ep+2])-&gt;PointGetNum();
        j = 0;
        pt[j++] = SK.GetEntity(point[0])-&gt;PointGetNum();
        for(i = 2; i &lt;= ep + 1; i++) {
            pt[j++] = SK.GetEntity(point[i])-&gt;PointGetNum();
        }
        pt[j++] = SK.GetEntity(point[ep+3])-&gt;PointGetNum();
    }

    // The unknowns that we will be solving for, a set for each coordinate.
    double Xx[MAX_N], Xy[MAX_N], Xz[MAX_N];
    // For a cubic Bezier section f(t) as t goes from 0 to 1,
    //    f' (0) = 3*(P1 - P0)
    //    f' (1) = 3*(P3 - P2)
    //    f''(0) = 6*(P0 - 2*P1 + P2)
    //    f''(1) = 6*(P3 - 2*P2 + P1)
    for(a = 0; a &lt; 3; a++) {
        BandedMatrix bm = {};
        bm.n = n;

        for(i = 0; i &lt; n; i++) {
            int im, it, ip;
            if(periodic) {
                im = WRAP(i - 1, n);
                it = i;
                ip = WRAP(i + 1, n);
            } else {
                im = i;
                it = i + 1;
                ip = i + 2;
            }
            // All of these are expressed in terms of a constant part, and
            // of X[i-1], X[i], and X[i+1]; so let these be the four
            // components of that vector;
            Vector4 A, B, C, D, E;
            // The on-curve interpolated point
            C = Vector4::From((pt[it]).Element(a), 0, 0, 0);
            // control point one back, C - X[i]
            B = C.Plus(Vector4::From(0, 0, -1, 0));
            // control point one forward, C + X[i]
            D = C.Plus(Vector4::From(0, 0, 1, 0));
            // control point two back
            if(i == 0 &amp;&amp; !periodic) {
                A = Vector4::From(ctrl_s.Element(a), 0, 0, 0);
            } else {
                // pt[im] + X[i-1]
                A = Vector4::From(pt[im].Element(a), 1, 0, 0);
            }
            // control point two forward
            if(i == (n - 1) &amp;&amp; !periodic) {
                E = Vector4::From(ctrl_f.Element(a), 0, 0, 0);
            } else {
                // pt[ip] - X[i+1]
                E = Vector4::From((pt[ip]).Element(a), 0, 0, -1);
            }
            // Write the second derivatives of each segment, dropping constant
            Vector4 fprev_pp = (C.Minus(B.ScaledBy(2))).Plus(A),
                    fnext_pp = (C.Minus(D.ScaledBy(2))).Plus(E),
                    eq       = fprev_pp.Minus(fnext_pp);

            bm.B[i] = -eq.w;
            if(periodic) {
                bm.A[i][WRAP(i-2, n)] = eq.x;
                bm.A[i][WRAP(i-1, n)] = eq.y;
                bm.A[i][i]            = eq.z;
            } else {
                // The wrapping would work, except when n = 1 and everything
                // wraps to zero...
                if(i &gt; 0)     bm.A[i][i - 1] = eq.x;
                /**/          bm.A[i][i]     = eq.y;
                if(i &lt; (n-1)) bm.A[i][i + 1] = eq.z;
            }
        }
        bm.Solve();
        double *X = (a == 0) ? Xx :
                    (a == 1) ? Xy :
                               Xz;
        memcpy(X, bm.X, n*sizeof(double));
    }

    for(i = 0; i &lt; pts - 1; i++) {
        Vector p0, p1, p2, p3;
        if(periodic) {
            p0 = pt[i];
            int iw = WRAP(i - 1, n);
            p1 = p0.Plus(Vector::From(Xx[iw], Xy[iw], Xz[iw]));
        } else if(i == 0) {
            p0 = pt[0];
            p1 = ctrl_s;
        } else {
            p0 = pt[i];
            p1 = p0.Plus(Vector::From(Xx[i-1], Xy[i-1], Xz[i-1]));
        }
        if(periodic) {
            p3 = pt[i+1];
            int iw = WRAP(i, n);
            p2 = p3.Minus(Vector::From(Xx[iw], Xy[iw], Xz[iw]));
        } else if(i == (pts - 2)) {
            p3 = pt[pts-1];
            p2 = ctrl_f;
        } else {
            p3 = pt[i+1];
            p2 = p3.Minus(Vector::From(Xx[i], Xy[i], Xz[i]));
        }
        SBezier sb = SBezier::From(p0, p1, p2, p3);
        sbl-&gt;l.Add(&amp;sb);
    }
}

</t>
<t tx="leo.20191228122643.63">void Entity::GenerateBezierCurves(SBezierList *sbl) const {
    SBezier sb;

    int i = sbl-&gt;l.n;

    switch(type) {
        case Type::LINE_SEGMENT: {
            Vector a = SK.GetEntity(point[0])-&gt;PointGetNum();
            Vector b = SK.GetEntity(point[1])-&gt;PointGetNum();
            sb = SBezier::From(a, b);
            sb.entity = h.v;
            sbl-&gt;l.Add(&amp;sb);
            break;
        }
        case Type::CUBIC:
            ComputeInterpolatingSpline(sbl, /*periodic=*/false);
            break;

        case Type::CUBIC_PERIODIC:
            ComputeInterpolatingSpline(sbl, /*periodic=*/true);
            break;

        case Type::CIRCLE:
        case Type::ARC_OF_CIRCLE: {
            Vector center = SK.GetEntity(point[0])-&gt;PointGetNum();
            Quaternion q = SK.GetEntity(normal)-&gt;NormalGetNum();
            Vector u = q.RotationU(), v = q.RotationV();
            double r = CircleGetRadiusNum();
            double thetaa, thetab, dtheta;

            if(r &lt; LENGTH_EPS) {
                // If a circle or an arc gets dragged through zero radius,
                // then we just don't generate anything.
                break;
            }

            if(type == Type::CIRCLE) {
                thetaa = 0;
                thetab = 2*PI;
                dtheta = 2*PI;
            } else {
                ArcGetAngles(&amp;thetaa, &amp;thetab, &amp;dtheta);
            }
            int i, n;
            if(dtheta &gt; (3*PI/2 + 0.01)) {
                n = 4;
            } else if(dtheta &gt; (PI + 0.01)) {
                n = 3;
            } else if(dtheta &gt; (PI/2 + 0.01)) {
                n = 2;
            } else {
                n = 1;
            }
            dtheta /= n;

            for(i = 0; i &lt; n; i++) {
                double s, c;

                c = cos(thetaa);
                s = sin(thetaa);
                // The start point of the curve, and the tangent vector at
                // that start point.
                Vector p0 = center.Plus(u.ScaledBy( r*c)).Plus(v.ScaledBy(r*s)),
                       t0 =             u.ScaledBy(-r*s). Plus(v.ScaledBy(r*c));

                thetaa += dtheta;

                c = cos(thetaa);
                s = sin(thetaa);
                Vector p2 = center.Plus(u.ScaledBy( r*c)).Plus(v.ScaledBy(r*s)),
                       t2 =             u.ScaledBy(-r*s). Plus(v.ScaledBy(r*c));

                // The control point must lie on both tangents.
                Vector p1 = Vector::AtIntersectionOfLines(p0, p0.Plus(t0),
                                                          p2, p2.Plus(t2),
                                                          NULL);

                SBezier sb = SBezier::From(p0, p1, p2);
                sb.weight[1] = cos(dtheta/2);
                sbl-&gt;l.Add(&amp;sb);
            }
            break;
        }

        case Type::TTF_TEXT: {
            Vector topLeft = SK.GetEntity(point[0])-&gt;PointGetNum();
            Vector botLeft = SK.GetEntity(point[1])-&gt;PointGetNum();
            Vector n = Normal()-&gt;NormalN();
            Vector v = topLeft.Minus(botLeft);
            Vector u = (v.Cross(n)).WithMagnitude(v.Magnitude());

            SS.fonts.PlotString(font, str, sbl, botLeft, u, v);
            break;
        }

        default:
            // Not a problem, points and normals and such don't generate curves
            break;
    }

    // Record our style for all of the Beziers that we just created.
    for(; i &lt; sbl-&gt;l.n; i++) {
        sbl-&gt;l[i].auxA = style.v;
    }
}

</t>
<t tx="leo.20191228122643.64">void Entity::Draw(DrawAs how, Canvas *canvas) {
    if(!(how == DrawAs::HOVERED || how == DrawAs::SELECTED) &amp;&amp;
       !IsVisible()) return;

    int zIndex;
    if(IsPoint()) {
        zIndex = 5;
    } else if(how == DrawAs::HIDDEN) {
        zIndex = 2;
    } else if(group != SS.GW.activeGroup) {
        zIndex = 3;
    } else {
        zIndex = 4;
    }

    hStyle hs;
    if(IsPoint()) {
        hs.v = Style::DATUM;
    } else if(IsNormal() || type == Type::WORKPLANE) {
        hs.v = Style::NORMALS;
    } else {
        hs = Style::ForEntity(h);
    }

    Canvas::Stroke stroke = Style::Stroke(hs);
    switch(how) {
        case DrawAs::DEFAULT:
            stroke.layer = Canvas::Layer::NORMAL;
            break;

        case DrawAs::OVERLAY:
            stroke.layer = Canvas::Layer::FRONT;
            break;

        case DrawAs::HIDDEN:
            stroke.layer = Canvas::Layer::OCCLUDED;
            stroke.stipplePattern = Style::PatternType({ Style::HIDDEN_EDGE });
            stroke.stippleScale   = Style::Get({ Style::HIDDEN_EDGE })-&gt;stippleScale;
            break;

        case DrawAs::HOVERED:
            stroke.layer = Canvas::Layer::FRONT;
            stroke.color = Style::Color(Style::HOVERED);
            break;

        case DrawAs::SELECTED:
            stroke.layer = Canvas::Layer::FRONT;
            stroke.color = Style::Color(Style::SELECTED);
            break;
    }
    stroke.zIndex = zIndex;
    Canvas::hStroke hcs = canvas-&gt;GetStroke(stroke);

    switch(type) {
        case Type::POINT_N_COPY:
        case Type::POINT_N_TRANS:
        case Type::POINT_N_ROT_TRANS:
        case Type::POINT_N_ROT_AA:
        case Type::POINT_N_ROT_AXIS_TRANS:
        case Type::POINT_IN_3D:
        case Type::POINT_IN_2D: {
            if(how == DrawAs::HIDDEN) return;

            // If we're analyzing the sketch to show the degrees of freedom,
            // then we draw big colored squares over the points that are
            // free to move.
            bool free = false;
            if(type == Type::POINT_IN_3D) {
                Param *px = SK.GetParam(param[0]),
                      *py = SK.GetParam(param[1]),
                      *pz = SK.GetParam(param[2]);

                free = px-&gt;free || py-&gt;free || pz-&gt;free;
            } else if(type == Type::POINT_IN_2D) {
                Param *pu = SK.GetParam(param[0]),
                      *pv = SK.GetParam(param[1]);

                free = pu-&gt;free || pv-&gt;free;
            }

            Canvas::Stroke pointStroke = {};
            pointStroke.layer  = (free) ? Canvas::Layer::FRONT : stroke.layer;
            pointStroke.zIndex = stroke.zIndex;
            pointStroke.color  = stroke.color;
            pointStroke.width  = 7.0;
            pointStroke.unit   = Canvas::Unit::PX;
            Canvas::hStroke hcsPoint = canvas-&gt;GetStroke(pointStroke);

            if(free) {
                Canvas::Stroke analyzeStroke = Style::Stroke(Style::ANALYZE);
                analyzeStroke.width = 14.0;
                analyzeStroke.layer = Canvas::Layer::FRONT;
                Canvas::hStroke hcsAnalyze = canvas-&gt;GetStroke(analyzeStroke);

                canvas-&gt;DrawPoint(PointGetNum(), hcsAnalyze);
            }

            canvas-&gt;DrawPoint(PointGetNum(), hcsPoint);
            return;
        }

        case Type::NORMAL_N_COPY:
        case Type::NORMAL_N_ROT:
        case Type::NORMAL_N_ROT_AA:
        case Type::NORMAL_IN_3D:
        case Type::NORMAL_IN_2D: {
            const Camera &amp;camera = canvas-&gt;GetCamera();

            if(how == DrawAs::HIDDEN) return;

            for(int i = 0; i &lt; 2; i++) {
                bool asReference = (i == 1);
                if(asReference) {
                    if(!h.request().IsFromReferences()) continue;
                } else {
                    if(!SK.GetGroup(group)-&gt;IsVisible() || !SS.GW.showNormals) continue;
                }

                stroke.layer = (asReference) ? Canvas::Layer::FRONT : Canvas::Layer::NORMAL;
                if(how != DrawAs::HOVERED &amp;&amp; how != DrawAs::SELECTED) {
                    // Always draw the x, y, and z axes in red, green, and blue;
                    // brighter for the ones at the bottom left of the screen,
                    // dimmer for the ones at the model origin.
                    hRequest hr   = h.request();
                    uint8_t  luma = (asReference) ? 255 : 100;
                    if(hr == Request::HREQUEST_REFERENCE_XY) {
                        stroke.color = RgbaColor::From(0, 0, luma);
                    } else if(hr == Request::HREQUEST_REFERENCE_YZ) {
                        stroke.color = RgbaColor::From(luma, 0, 0);
                    } else if(hr == Request::HREQUEST_REFERENCE_ZX) {
                        stroke.color = RgbaColor::From(0, luma, 0);
                    }
                }

                Quaternion q = NormalGetNum();
                Vector tail;
                if(asReference) {
                    // Draw an extra copy of the x, y, and z axes, that's
                    // always in the corner of the view and at the front.
                    // So those are always available, perhaps useful.
                    stroke.width = 2;
                    double s = camera.scale;
                    double h = 60 - camera.height / 2.0;
                    double w = 60 - camera.width  / 2.0;
                    // Shift the axis to the right if they would overlap with the toolbar.
                    if(SS.showToolbar) {
                        if(h + 30 &gt; -(34*16 + 3*16 + 8) / 2)
                            w += 60;
                    }
                    tail = camera.projRight.ScaledBy(w/s).Plus(
                           camera.projUp.   ScaledBy(h/s)).Minus(camera.offset);
                } else {
                    tail = SK.GetEntity(point[0])-&gt;PointGetNum();
                }
                tail = camera.AlignToPixelGrid(tail);

                hcs = canvas-&gt;GetStroke(stroke);
                Vector v = (q.RotationN()).WithMagnitude(50.0 / camera.scale);
                Vector tip = tail.Plus(v);
                canvas-&gt;DrawLine(tail, tip, hcs);

                v = v.WithMagnitude(12.0 / camera.scale);
                Vector axis = q.RotationV();
                canvas-&gt;DrawLine(tip, tip.Minus(v.RotatedAbout(axis,  0.6)), hcs);
                canvas-&gt;DrawLine(tip, tip.Minus(v.RotatedAbout(axis, -0.6)), hcs);

                if(type == Type::NORMAL_IN_3D) {
                    Param *nw = SK.GetParam(param[0]),
                          *nx = SK.GetParam(param[1]),
                          *ny = SK.GetParam(param[2]),
                          *nz = SK.GetParam(param[3]);

                    if(nw-&gt;free || nx-&gt;free || ny-&gt;free || nz-&gt;free) {
                        Canvas::Stroke analyzeStroke = Style::Stroke(Style::ANALYZE);
                        analyzeStroke.layer = Canvas::Layer::FRONT;
                        Canvas::hStroke hcsAnalyze = canvas-&gt;GetStroke(analyzeStroke);
                        canvas-&gt;DrawLine(tail, tip, hcsAnalyze);
                    }
                }
            }
            return;
        }

        case Type::DISTANCE:
        case Type::DISTANCE_N_COPY:
            // These are used only as data structures, nothing to display.
            return;

        case Type::WORKPLANE: {
            const Camera &amp;camera = canvas-&gt;GetCamera();

            Vector p = SK.GetEntity(point[0])-&gt;PointGetNum();
            p = camera.AlignToPixelGrid(p);

            Vector u = Normal()-&gt;NormalU();
            Vector v = Normal()-&gt;NormalV();

            double s = (std::min(camera.width, camera.height)) * 0.45 / camera.scale;

            Vector us = u.ScaledBy(s);
            Vector vs = v.ScaledBy(s);

            Vector pp = p.Plus (us).Plus (vs);
            Vector pm = p.Plus (us).Minus(vs);
            Vector mm = p.Minus(us).Minus(vs), mm2 = mm;
            Vector mp = p.Minus(us).Plus (vs);

            Canvas::Stroke strokeBorder = stroke;
            strokeBorder.zIndex        -= 3;
            strokeBorder.stipplePattern = StipplePattern::SHORT_DASH;
            strokeBorder.stippleScale   = 8.0;
            Canvas::hStroke hcsBorder = canvas-&gt;GetStroke(strokeBorder);

            double textHeight = Style::TextHeight(hs) / camera.scale;

            if(!h.isFromRequest()) {
                mm = mm.Plus(v.ScaledBy(textHeight * 4.7));
                mm2 = mm2.Plus(u.ScaledBy(textHeight * 4.7));
                canvas-&gt;DrawLine(mm2, mm, hcsBorder);
            }
            canvas-&gt;DrawLine(pp,  pm, hcsBorder);
            canvas-&gt;DrawLine(mm2, pm, hcsBorder);
            canvas-&gt;DrawLine(mm,  mp, hcsBorder);
            canvas-&gt;DrawLine(pp,  mp, hcsBorder);

            Vector o = mm2.Plus(u.ScaledBy(3.0 / camera.scale)).Plus(
                                v.ScaledBy(3.0 / camera.scale));
            std::string shortDesc = DescriptionString().substr(5);
            canvas-&gt;DrawVectorText(shortDesc, textHeight, o, u, v, hcs);
            return;
        }

        case Type::LINE_SEGMENT:
        case Type::CIRCLE:
        case Type::ARC_OF_CIRCLE:
        case Type::CUBIC:
        case Type::CUBIC_PERIODIC:
        case Type::TTF_TEXT: {
            // Generate the rational polynomial curves, then piecewise linearize
            // them, and display those.
            if(!canvas-&gt;DrawBeziers(*GetOrGenerateBezierCurves(),  hcs)) {
                canvas-&gt;DrawEdges(*GetOrGenerateEdges(), hcs);
            }
            if(type == Type::CIRCLE) {
                Entity *dist = SK.GetEntity(distance);
                if(dist-&gt;type == Type::DISTANCE) {
                    Param *p = SK.GetParam(dist-&gt;param[0]);
                    if(p-&gt;free) {
                        Canvas::Stroke analyzeStroke = Style::Stroke(Style::ANALYZE);
                        analyzeStroke.layer = Canvas::Layer::FRONT;
                        Canvas::hStroke hcsAnalyze = canvas-&gt;GetStroke(analyzeStroke);
                        if(!canvas-&gt;DrawBeziers(*GetOrGenerateBezierCurves(), hcsAnalyze)) {
                            canvas-&gt;DrawEdges(*GetOrGenerateEdges(), hcsAnalyze);
                        }
                    }
                }
            }
            return;
        }
        case Type::IMAGE: {
            Canvas::Fill fill = {};
            std::shared_ptr&lt;Pixmap&gt; pixmap;
            switch(how) {
                case DrawAs::HIDDEN: return;

                case DrawAs::HOVERED: {
                    fill.color   = Style::Color(Style::HOVERED).WithAlpha(180);
                    fill.pattern = Canvas::FillPattern::CHECKERED_A;
                    fill.zIndex  = 2;
                    break;
                }

                case DrawAs::SELECTED: {
                    fill.color   = Style::Color(Style::SELECTED).WithAlpha(180);
                    fill.pattern = Canvas::FillPattern::CHECKERED_B;
                    fill.zIndex  = 1;
                    break;
                }

                default:
                    fill.color   = RgbaColor::FromFloat(1.0f, 1.0f, 1.0f);
                    pixmap       = SS.images[file];
                    break;
            }

            Canvas::hFill hf = canvas-&gt;GetFill(fill);
            Vector v[4] = {};
            for(int i = 0; i &lt; 4; i++) {
                v[i] = SK.GetEntity(point[i])-&gt;PointGetNum();
            }
            Vector iu = v[3].Minus(v[0]);
            Vector iv = v[1].Minus(v[0]);

            if(how == DrawAs::DEFAULT &amp;&amp; pixmap == NULL) {
                Canvas::Stroke stroke = Style::Stroke(Style::DRAW_ERROR);
                stroke.color = stroke.color.WithAlpha(50);
                Canvas::hStroke hs = canvas-&gt;GetStroke(stroke);
                canvas-&gt;DrawLine(v[0], v[2], hs);
                canvas-&gt;DrawLine(v[1], v[3], hs);
                for(int i = 0; i &lt; 4; i++) {
                    canvas-&gt;DrawLine(v[i], v[(i + 1) % 4], hs);
                }
            } else {
                canvas-&gt;DrawPixmap(pixmap, v[0], iu, iv,
                                   Point2d::From(0.0, 0.0), Point2d::From(1.0, 1.0), hf);
            }
        }

        case Type::FACE_NORMAL_PT:
        case Type::FACE_XPROD:
        case Type::FACE_N_ROT_TRANS:
        case Type::FACE_N_TRANS:
        case Type::FACE_N_ROT_AA:
            // Do nothing; these are drawn with the triangle mesh
            return;
    }
    ssassert(false, "Unexpected entity type");
}
</t>
<t tx="leo.20191228122643.65">@path ./src/
//-----------------------------------------------------------------------------
// Data structures used frequently in the program, various kinds of vectors
// (of real numbers, not symbolic algebra stuff) and our templated lists.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#ifndef SOLVESPACE_DSC_H
#define SOLVESPACE_DSC_H

#include "solvespace.h"

#include &lt;type_traits&gt;

/// Trait indicating which types are handle types and should get the associated operators.
/// Specialize for each handle type and inherit from std::true_type.
template&lt;typename T&gt;
struct IsHandleOracle : std::false_type {};

// Equality-compare any two instances of a handle type.
template&lt;typename T&gt;
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122643.66">static inline typename std::enable_if&lt;IsHandleOracle&lt;T&gt;::value, bool&gt;::type
operator==(T const &amp;lhs, T const &amp;rhs) {
    return lhs.v == rhs.v;
}

// Inequality-compare any two instances of a handle type.
template&lt;typename T&gt;
</t>
<t tx="leo.20191228122643.67">static inline typename std::enable_if&lt;IsHandleOracle&lt;T&gt;::value, bool&gt;::type
operator!=(T const &amp;lhs, T const &amp;rhs) {
    return !(lhs == rhs);
}

// Less-than-compare any two instances of a handle type.
template&lt;typename T&gt;
</t>
<t tx="leo.20191228122643.68">static inline typename std::enable_if&lt;IsHandleOracle&lt;T&gt;::value, bool&gt;::type
operator&lt;(T const &amp;lhs, T const &amp;rhs) {
    return lhs.v &lt; rhs.v;
}

class Vector;
class Vector4;
class Point2d;
class hEntity;
class hParam;

</t>
<t tx="leo.20191228122643.69">class Quaternion {
public:
    // a + (vx)*i + (vy)*j + (vz)*k
    double w, vx, vy, vz;

    static const Quaternion IDENTITY;

    static Quaternion From(double w, double vx, double vy, double vz);
    static Quaternion From(hParam w, hParam vx, hParam vy, hParam vz);
    static Quaternion From(Vector u, Vector v);
    static Quaternion From(Vector axis, double dtheta);

    Quaternion Plus(Quaternion b) const;
    Quaternion Minus(Quaternion b) const;
    Quaternion ScaledBy(double s) const;
    double Magnitude() const;
    Quaternion WithMagnitude(double s) const;

    // Call a rotation matrix [ u' v' n' ]'; this returns the first and
    // second rows, where that matrix is generated by this quaternion
    Vector RotationU() const;
    Vector RotationV() const;
    Vector RotationN() const;
    Vector Rotate(Vector p) const;

    Quaternion ToThe(double p) const;
    Quaternion Inverse() const;
    Quaternion Times(Quaternion b) const;
    Quaternion Mirror() const;
};

</t>
<t tx="leo.20191228122643.7">@path ./src/
//-----------------------------------------------------------------------------
// The root function to paint our graphics window, after setting up all the
// views and such appropriately. Also contains all the stuff to manage the
// selection.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122643.70">class Vector {
public:
    double x, y, z;

    static Vector From(double x, double y, double z);
    static Vector From(hParam x, hParam y, hParam z);
    static Vector AtIntersectionOfPlanes(Vector n1, double d1,
                                         Vector nc, double dc, bool *parallel);
    static void ClosestPointBetweenLines(Vector pa, Vector da,
    double DirectionCosineWith(Vector b) const;
    double Dot(Vector b) const;
    Vector Normal(int which) const;
    Vector RotatedAbout(Vector orig, Vector axis, double theta) const;
    Vector RotatedAbout(Vector axis, double theta) const;
    Vector DotInToCsys(Vector u, Vector v, Vector n) const;
    Vector ScaleOutOfCsys(Vector u, Vector v, Vector n) const;
    double DistanceToLine(Vector p0, Vector dp) const;
    double DistanceToPlane(Vector normal, Vector origin) const;
    bool OnLineSegment(Vector a, Vector b, double tol=LENGTH_EPS) const;
    Vector ClosestPointOnLine(Vector p0, Vector deltal) const;
    double Magnitude() const;
    double MagSquared() const;
    Vector WithMagnitude(double s) const;
    Vector ScaledBy(double s) const;
    Vector ProjectInto(hEntity wrkpl) const;
    Vector ProjectVectorInto(hEntity wrkpl) const;
    double DivProjected(Vector delta) const;
    Vector ClosestOrtho() const;
    void MakeMaxMin(Vector *maxv, Vector *minv) const;
    Vector ClampWithin(double minv, double maxv) const;
    static bool BoundingBoxesDisjoint(Vector amax, Vector amin,

inline double Vector::Element(int i) const {
    switch (i) {
    case 0: return x;
    case 1: return y;
    case 2: return z;
    default: ssassert(false, "Unexpected vector element index");
    }
}

inline bool Vector::Equals(Vector v, double tol) const {
    // Quick axis-aligned tests before going further
    const Vector dv = this-&gt;Minus(v);
    if (fabs(dv.x) &gt; tol) return false;
    if (fabs(dv.y) &gt; tol) return false;
    if (fabs(dv.z) &gt; tol) return false;

    return dv.MagSquared() &lt; tol*tol;
}

struct VectorHash {
    size_t operator()(const Vector &amp;v) const;
};

struct VectorPred {
    bool operator()(Vector a, Vector b) const;
};

</t>
<t tx="leo.20191228122643.71">class Vector4 {
public:
    double w, x, y, z;

    static Vector4 From(double w, double x, double y, double z);
    static Vector4 From(double w, Vector v3);
    static Vector4 Blend(Vector4 a, Vector4 b, double t);

    Vector4 Plus(Vector4 b) const;
    Vector4 Minus(Vector4 b) const;
    Vector4 ScaledBy(double s) const;
    Vector PerspectiveProject() const;
};

</t>
<t tx="leo.20191228122643.72">class Point2d {
public:
    double x, y;

    static Point2d From(double x, double y);
    static Point2d FromPolar(double r, double a);

    Point2d Plus(const Point2d &amp;b) const;
    Point2d Minus(const Point2d &amp;b) const;
    Point2d ScaledBy(double s) const;
    double DivProjected(Point2d delta) const;
    double Dot(Point2d p) const;
    double DistanceTo(const Point2d &amp;p) const;
    double DistanceToLine(const Point2d &amp;p0, const Point2d &amp;dp, bool asSegment) const;
    double DistanceToLineSigned(const Point2d &amp;p0, const Point2d &amp;dp, bool asSegment) const;
    double Angle() const;
    double AngleTo(const Point2d &amp;p) const;
    double Magnitude() const;
    double MagSquared() const;
    Point2d WithMagnitude(double v) const;
    Point2d Normal() const;
    bool Equals(Point2d v, double tol=LENGTH_EPS) const;
};

// A simple list
template&lt;class T&gt;
</t>
<t tx="leo.20191228122643.73">class List {
    T *elem            = nullptr;
    int elemsAllocated = 0;

public:
    int  n = 0;

    bool IsEmpty() const { return n == 0; }

    @others
};

// Comparison functor used by IdList and related classes
template &lt;class T, class H&gt;
struct CompareId {
</t>
<t tx="leo.20191228122643.74">void ReserveMore(int howMuch) {
    if(n + howMuch &gt; elemsAllocated) {
        elemsAllocated = n + howMuch;
        T *newElem = (T *)MemAlloc((size_t)elemsAllocated*sizeof(T));
        for(int i = 0; i &lt; n; i++) {
            new(&amp;newElem[i]) T(std::move(elem[i]));
            elem[i].~T();
        }
        MemFree(elem);
        elem = newElem;
    }
}

</t>
<t tx="leo.20191228122643.75">void AllocForOneMore() {
    if(n &gt;= elemsAllocated) {
        ReserveMore((elemsAllocated + 32)*2 - n);
    }
}

</t>
<t tx="leo.20191228122643.76">void Add(const T *t) {
    AllocForOneMore();
    new(&amp;elem[n++]) T(*t);
}

</t>
<t tx="leo.20191228122643.77">void AddToBeginning(const T *t) {
    AllocForOneMore();
    new(&amp;elem[n]) T();
    std::move_backward(elem, elem + 1, elem + n + 1);
    elem[0] = *t;
    n++;
}

T *First() {
    return IsEmpty() ? nullptr : &amp;(elem[0]);
}
</t>
<t tx="leo.20191228122643.78">const T *First() const {
    return IsEmpty() ? nullptr : &amp;(elem[0]);
}

T *Last() { return IsEmpty() ? nullptr : &amp;(elem[n - 1]); }
const T *Last() const { return IsEmpty() ? nullptr : &amp;(elem[n - 1]); }

T *NextAfter(T *prev) {
    if(IsEmpty() || !prev) return NULL;
    if(prev - First() == (n - 1)) return NULL;
    return prev + 1;
}
</t>
<t tx="leo.20191228122643.79">const T *NextAfter(const T *prev) const {
    if(IsEmpty() || !prev) return NULL;
    if(prev - First() == (n - 1)) return NULL;
    return prev + 1;
}

T &amp;Get(size_t i) { return elem[i]; }
T const &amp;Get(size_t i) const { return elem[i]; }
T &amp;operator[](size_t i) { return Get(i); }
T const &amp;operator[](size_t i) const { return Get(i); }

T *begin() { return IsEmpty() ? nullptr : &amp;elem[0]; }
T *end() { return IsEmpty() ? nullptr : &amp;elem[n]; }
const T *begin() const { return IsEmpty() ? nullptr : &amp;elem[0]; }
const T *end() const { return IsEmpty() ? nullptr : &amp;elem[n]; }
const T *cbegin() const { return begin(); }
const T *cend() const { return end(); }

</t>
<t tx="leo.20191228122643.8">bool GraphicsWindow::Selection::Equals(Selection *b) {
    if(entity     != b-&gt;entity)     return false;
    if(constraint != b-&gt;constraint) return false;
    return true;
}

</t>
<t tx="leo.20191228122643.80">void ClearTags() {
    for(auto &amp; elt : *this) {
        elt.tag = 0;
    }
}

</t>
<t tx="leo.20191228122643.81">void Clear() {
    for(int i = 0; i &lt; n; i++)
        elem[i].~T();
    if(elem) MemFree(elem);
    elem = NULL;
    n = elemsAllocated = 0;
}

</t>
<t tx="leo.20191228122643.82">void RemoveTagged() {
    @others
}

</t>
<t tx="leo.20191228122643.83">auto newEnd = std::remove_if(this-&gt;begin(), this-&gt;end(), [](T &amp;t) {
    if(t.tag) {
        return true;
    }
    return false;
});
auto oldEnd = this-&gt;end();
n = newEnd - begin();
if (newEnd != nullptr &amp;&amp; oldEnd != nullptr) {
    while(newEnd != oldEnd) {
        newEnd-&gt;~T();
        ++newEnd;
    }
}
// and elemsAllocated is untouched, because we didn't resize
</t>
<t tx="leo.20191228122643.84">void RemoveLast(int cnt) {
    ssassert(n &gt;= cnt, "Removing more elements than the list contains");
    for(int i = n - cnt; i &lt; n; i++)
        elem[i].~T();
    n -= cnt;
    // and elemsAllocated is untouched, same as in RemoveTagged
}

</t>
<t tx="leo.20191228122643.85">void Reverse() {
    int i;
    for(i = 0; i &lt; (n/2); i++) {
        swap(elem[i], elem[(n-1)-i]);
    }
}
</t>
<t tx="leo.20191228122643.86">bool operator()(T const&amp; lhs, T const&amp; rhs) const {
    return lhs.h.v &lt; rhs.h.v;
}
</t>
<t tx="leo.20191228122643.87">    bool operator()(T const&amp; lhs, H rhs) const {
        return lhs.h.v &lt; rhs.v;
    }
};

// A list, where each element has an integer identifier. The list is kept
// sorted by that identifier, and items can be looked up in log n time by
// id.
template &lt;class T, class H&gt;
</t>
<t tx="leo.20191228122643.88">class IdList {
    T *elem            = nullptr;
    int elemsAllocated = 0;
public:
    int n = 0;

    using Compare = CompareId&lt;T, H&gt;;

    @others
};

</t>
<t tx="leo.20191228122643.89">bool IsEmpty() const {
    return n == 0;
}

</t>
<t tx="leo.20191228122643.9">bool GraphicsWindow::Selection::IsEmpty() {
    if(entity.v)        return false;
    if(constraint.v)    return false;
    return true;
}

</t>
<t tx="leo.20191228122643.90">void AllocForOneMore() {
    if(n &gt;= elemsAllocated) {
        ReserveMore((elemsAllocated + 32)*2 - n);
    }
}

uint32_t MaximumId() {
    if(IsEmpty()) {
        return 0;
    } else {
        return Last()-&gt;h.v;
    }
}

H AddAndAssignId(T *t) {
    t-&gt;h.v = (MaximumId() + 1);
    Add(t);

    return t-&gt;h;
}

T * LowerBound(T const&amp; t) {
    if(IsEmpty()) {
        return nullptr;
    }
    auto it = std::lower_bound(begin(), end(), t, Compare());
    return it;
}

T * LowerBound(H const&amp; h) {
    if(IsEmpty()) {
        return nullptr;
    }
    auto it = std::lower_bound(begin(), end(), h, Compare());
    return it;
}

</t>
<t tx="leo.20191228122643.91">int LowerBoundIndex(T const&amp; t) {
    if(IsEmpty()) {
        return 0;
    }
    auto it = LowerBound(t);
    auto idx = std::distance(begin(), it);
    auto i = static_cast&lt;int&gt;(idx);
    return i;
}
</t>
<t tx="leo.20191228122643.92">void ReserveMore(int howMuch) {
    if(n + howMuch &gt; elemsAllocated) {
        elemsAllocated = n + howMuch;
        T *newElem = (T *)MemAlloc((size_t)elemsAllocated*sizeof(T));
        for(int i = 0; i &lt; n; i++) {
            new(&amp;newElem[i]) T(std::move(elem[i]));
            elem[i].~T();
        }
        MemFree(elem);
        elem = newElem;
    }
}

</t>
<t tx="leo.20191228122643.93">void Add(T *t) {
    AllocForOneMore();

    // Look to see if we already have something with the same handle value.
    ssassert(FindByIdNoOops(t-&gt;h) == nullptr, "Handle isn't unique");

    // Copy-construct at the end of the list.
    new(&amp;elem[n]) T(*t);
    ++n;
    // The item we just added is trivially sorted, so "merge"
    std::inplace_merge(begin(), end() - 1, end(), Compare());
}

T *FindById(H h) {
    T *t = FindByIdNoOops(h);
    ssassert(t != NULL, "Cannot find handle");
    return t;
}

</t>
<t tx="leo.20191228122643.94">int IndexOf(H h) {
    if(IsEmpty()) {
        return -1;
    }
    auto it = LowerBound(h);
    auto idx = std::distance(begin(), it);
    if (idx &lt; n) {
        return idx;
    }
    return -1;
}

T *FindByIdNoOops(H h) {
    if(IsEmpty()) {
        return nullptr;
    }
    auto it = LowerBound(h);
    if (it == nullptr || it == end()) {
        return nullptr;
    }
    if (it-&gt;h.v == h.v) {
        return it;
    }
    return nullptr;
}

T *First() {
    return (IsEmpty()) ? NULL : &amp;(elem[0]);
}
T *Last() {
    return (IsEmpty()) ? NULL : &amp;(elem[n-1]);
}
T *NextAfter(T *prev) {
    if(IsEmpty() || !prev) return NULL;
    if(prev - First() == (n - 1)) return NULL;
    return prev + 1;
}

T &amp;Get(size_t i) { return elem[i]; }
T const &amp;Get(size_t i) const { return elem[i]; }
T &amp;operator[](size_t i) { return Get(i); }
T const &amp;operator[](size_t i) const { return Get(i); }

T *begin() { return IsEmpty() ? nullptr : &amp;elem[0]; }
T *end() { return IsEmpty() ? nullptr : &amp;elem[0] + n; }
const T *begin() const { return IsEmpty() ? nullptr : &amp;elem[0]; }
const T *end() const { return IsEmpty() ? nullptr : &amp;elem[0] + n; }
const T *cbegin() const { return begin(); }
const T *cend() const { return end(); }

</t>
<t tx="leo.20191228122643.95">void ClearTags() {
    for(auto &amp;elt : *this) { elt.tag = 0; }
}

</t>
<t tx="leo.20191228122643.96">void Tag(H h, int tag) {
    auto it = FindByIdNoOops(h);
    if (it != nullptr) {
        it-&gt;tag = tag;
    }
}

</t>
<t tx="leo.20191228122643.97">void RemoveTagged() {
    int src, dest;
    dest = 0;
    for(src = 0; src &lt; n; src++) {
        if(elem[src].tag) {
            // this item should be deleted
            elem[src].Clear();
        } else {
            if(src != dest) {
                elem[dest] = elem[src];
            }
            dest++;
        }
    }
    for(int i = dest; i &lt; n; i++)
        elem[i].~T();
    n = dest;
    // and elemsAllocated is untouched, because we didn't resize
}
</t>
<t tx="leo.20191228122643.98">void RemoveById(H h) {
    ClearTags();
    FindById(h)-&gt;tag = 1;
    RemoveTagged();
}

</t>
<t tx="leo.20191228122643.99">void MoveSelfInto(IdList&lt;T,H&gt; *l) {
    l-&gt;Clear();
    std::swap(l-&gt;elem, elem);
    std::swap(l-&gt;elemsAllocated, elemsAllocated);
    std::swap(l-&gt;n, n);
}

</t>
<t tx="leo.20191228122644.1">void VectorFileWriter::SetModelviewProjection(const Vector &amp;u, const Vector &amp;v, const Vector &amp;n,
                                              const Vector &amp;origin, double cameraTan,
                                              double scale) {
    this-&gt;u = u;
    this-&gt;v = v;
    this-&gt;n = n;
    this-&gt;origin = origin;
    this-&gt;cameraTan = cameraTan;
    this-&gt;scale = scale;
}

Vector VectorFileWriter::Transform(Vector &amp;pos) const {
    return pos.InPerspective(u, v, n, origin, cameraTan).ScaledBy(1.0 / scale);
}

</t>
<t tx="leo.20191228122644.10">void SolveSpaceUI::ExportMeshAsVrmlTo(FILE *f, const Platform::Path &amp;filename, SMesh *sm) {
    struct STriangleSpan {
        STriangle *first, *past_last;

        STriangle *begin() const { return first; }
        STriangle *end() const { return past_last; }
    };


    std::string basename = filename.FileStem();
    for(auto &amp; c : basename) {
        if(!(isalnum(c) || ((unsigned)c &gt;= 0x80))) {
            c = '_';
        }
    }

    fprintf(f, "#VRML V2.0 utf8\n"
               "#Exported from SolveSpace %s\n"
               "\n"
               "DEF %s Transform {\n"
               "  children [",
            PACKAGE_VERSION,
            basename.c_str());


    std::map&lt;std::uint8_t, std::vector&lt;STriangleSpan&gt;&gt; opacities;
    STriangle *start          = sm-&gt;l.begin();
    std::uint8_t last_opacity = start-&gt;meta.color.alpha;
    for(auto &amp; tr : sm-&gt;l) {
        if(tr.meta.color.alpha != last_opacity) {
            opacities[last_opacity].push_back(STriangleSpan{start, &amp;tr});
            start = &amp;tr;
            last_opacity = start-&gt;meta.color.alpha;
        }
    }
    opacities[last_opacity].push_back(STriangleSpan{start, sm-&gt;l.end()});

    for(auto &amp;&amp; op : opacities) {
        fprintf(f, "\n"
                   "    Shape {\n"
                   "      appearance Appearance {\n"
                   "        material DEF %s_material_%u Material {\n"
                   "          diffuseColor %f %f %f\n"
                   "          ambientIntensity %f\n"
                   "          transparency %f\n"
                   "        }\n"
                   "      }\n"
                   "      geometry IndexedFaceSet {\n"
                   "        colorPerVertex TRUE\n"
                   "        coord Coordinate { point [\n",
                basename.c_str(),
                (unsigned)op.first,
                SS.ambientIntensity,
                SS.ambientIntensity,
                SS.ambientIntensity,
                SS.ambientIntensity,
                1.f - ((float)op.first / 255.0f));

        SPointList spl = {};

        for(const auto &amp; sp : op.second) {
            for(const auto &amp; tr : sp) {
                spl.IncrementTagFor(tr.a);
                spl.IncrementTagFor(tr.b);
                spl.IncrementTagFor(tr.c);
            }
        }

        // Output all the vertices.
        for(auto sp : spl.l) {
            fprintf(f, "          %f %f %f,\n",
                    sp.p.x / SS.exportScale,
                    sp.p.y / SS.exportScale,
                    sp.p.z / SS.exportScale);
        }

        fputs("        ] }\n"
              "        coordIndex [\n", f);
        // And now all the triangular faces, in terms of those vertices.
        for(const auto &amp; sp : op.second) {
            for(const auto &amp; tr : sp) {
                fprintf(f, "          %d, %d, %d, -1,\n",
                        spl.IndexForPoint(tr.a),
                        spl.IndexForPoint(tr.b),
                        spl.IndexForPoint(tr.c));
            }
        }

        fputs("        ]\n"
              "        color Color { color [\n", f);
        // Output triangle colors.
        std::vector&lt;int&gt; triangle_colour_ids;
        std::vector&lt;RgbaColor&gt; colours_present;
        for(const auto &amp; sp : op.second) {
            for(const auto &amp; tr : sp) {
                @others
}

//-----------------------------------------------------------------------------
// Export a view of the model as an image; we just take a screenshot, by
// rendering the view in the usual way and then copying the pixels.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122644.100">class ExprParser {
public:
    enum class TokenType {
        ERROR = 0,

        PAREN_LEFT,
        PAREN_RIGHT,
        BINARY_OP,
        UNARY_OP,
        OPERAND,

        END,
    };

    @others
};

ExprParser::Token ExprParser::Token::From(TokenType type, Expr *expr) {
    Token t;
    t.type = type;
    t.expr = expr;
    return t;
}

ExprParser::Token ExprParser::Token::From(TokenType type, Expr::Op op) {
    Token t;
    t.type = type;
    t.expr = Expr::AllocExpr();
    t.expr-&gt;op = op;
    return t;
}

</t>
<t tx="leo.20191228122644.101">class Token {
public:
    TokenType  type;
    Expr      *expr;

    static Token From(TokenType type = TokenType::ERROR, Expr *expr = NULL);
    static Token From(TokenType type, Expr::Op op);
    bool IsError() const { return type == TokenType::ERROR; }
};

std::string::const_iterator it, end;
std::vector&lt;Token&gt; stack;

char ReadChar();
char PeekChar();

std::string ReadWord();
void SkipSpace();

Token PopOperator(std::string *error);
Token PopOperand(std::string *error);

int Precedence(Token token);
Token LexNumber(std::string *error);
Token Lex(std::string *error);
bool Reduce(std::string *error);
bool Parse(std::string *error, size_t reduceUntil = 0);

static Expr *Parse(const std::string &amp;input, std::string *error);
</t>
<t tx="leo.20191228122644.102">char ExprParser::ReadChar() {
    return *it++;
}

</t>
<t tx="leo.20191228122644.103">char ExprParser::PeekChar() {
    if(it == end) {
        return '\0';
    } else {
        return *it;
    }
}

std::string ExprParser::ReadWord() {
    std::string s;

    while(char c = PeekChar()) {
        if(!isalnum(c)) break;
        s.push_back(ReadChar());
    }

    return s;
}

</t>
<t tx="leo.20191228122644.104">void ExprParser::SkipSpace() {
    while(char c = PeekChar()) {
        if(!isspace(c)) break;
        ReadChar();
    }
}

ExprParser::Token ExprParser::LexNumber(std::string *error) {
    std::string s;

    while(char c = PeekChar()) {
        if(!((c &gt;= '0' &amp;&amp; c &lt;= '9') || c == 'e' || c == 'E' || c == '.' || c == '_')) break;
        if(c == '_') {
            ReadChar();
            continue;
        }
        s.push_back(ReadChar());
    }

    char *endptr;
    double d = strtod(s.c_str(), &amp;endptr);

    Token t = Token::From();
    if(endptr == s.c_str() + s.size()) {
        t = Token::From(TokenType::OPERAND, Expr::Op::CONSTANT);
        t.expr-&gt;v = d;
    } else {
        *error = "'" + s + "' is not a valid number";
    }
    return t;
}

ExprParser::Token ExprParser::Lex(std::string *error) {
    SkipSpace();

    Token t = Token::From();
    char c = PeekChar();
    if(isupper(c)) {
        std::string n = ReadWord();
        t = Token::From(TokenType::OPERAND, Expr::Op::VARIABLE);
    } else if(isalpha(c)) {
        std::string s = ReadWord();
        if(s == "sqrt") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::SQRT);
        } else if(s == "square") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::SQUARE);
        } else if(s == "sin") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::SIN);
        } else if(s == "cos") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::COS);
        } else if(s == "asin") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::ASIN);
        } else if(s == "acos") {
            t = Token::From(TokenType::UNARY_OP, Expr::Op::ACOS);
        } else if(s == "pi") {
            t = Token::From(TokenType::OPERAND, Expr::Op::CONSTANT);
            t.expr-&gt;v = PI;
        } else {
            *error = "'" + s + "' is not a valid variable, function or constant";
        }
    } else if(isdigit(c) || c == '.') {
        return LexNumber(error);
    } else if(ispunct(c)) {
        ReadChar();
        if(c == '+') {
            t = Token::From(TokenType::BINARY_OP, Expr::Op::PLUS);
        } else if(c == '-') {
            t = Token::From(TokenType::BINARY_OP, Expr::Op::MINUS);
        } else if(c == '*') {
            t = Token::From(TokenType::BINARY_OP, Expr::Op::TIMES);
        } else if(c == '/') {
            t = Token::From(TokenType::BINARY_OP, Expr::Op::DIV);
        } else if(c == '(') {
            t = Token::From(TokenType::PAREN_LEFT);
        } else if(c == ')') {
            t = Token::From(TokenType::PAREN_RIGHT);
        } else {
            *error = "'" + std::string(1, c) + "' is not a valid operator";
        }
    } else if(c == '\0') {
        t = Token::From(TokenType::END);
    } else {
        *error = "Unexpected character '" + std::string(1, c) + "'";
    }

    return t;
}

ExprParser::Token ExprParser::PopOperand(std::string *error) {
    Token t = Token::From();
    if(stack.empty() || stack.back().type != TokenType::OPERAND) {
        *error = "Expected an operand";
    } else {
        t = stack.back();
        stack.pop_back();
    }
    return t;
}

ExprParser::Token ExprParser::PopOperator(std::string *error) {
    Token t = Token::From();
    if(stack.empty() || (stack.back().type != TokenType::UNARY_OP &amp;&amp;
                         stack.back().type != TokenType::BINARY_OP)) {
        *error = "Expected an operator";
    } else {
        t = stack.back();
        stack.pop_back();
    }
    return t;
}

</t>
<t tx="leo.20191228122644.105">int ExprParser::Precedence(Token t) {
    ssassert(t.type == TokenType::BINARY_OP ||
             t.type == TokenType::UNARY_OP ||
             t.type == TokenType::OPERAND,
             "Unexpected token type");

    if(t.type == TokenType::UNARY_OP) {
        return 30;
    } else if(t.expr-&gt;op == Expr::Op::TIMES ||
              t.expr-&gt;op == Expr::Op::DIV) {
        return 20;
    } else if(t.expr-&gt;op == Expr::Op::PLUS ||
              t.expr-&gt;op == Expr::Op::MINUS) {
        return 10;
    } else if(t.type == TokenType::OPERAND) {
        return 0;
    } else ssassert(false, "Unexpected operator");
}

</t>
<t tx="leo.20191228122644.106">bool ExprParser::Reduce(std::string *error) {
    Token a = PopOperand(error);
    if(a.IsError()) return false;

    Token op = PopOperator(error);
    if(op.IsError()) return false;

    Token r = Token::From(TokenType::OPERAND);
    switch(op.type) {
        case TokenType::BINARY_OP: {
            Token b = PopOperand(error);
            if(b.IsError()) return false;
            r.expr = b.expr-&gt;AnyOp(op.expr-&gt;op, a.expr);
            break;
        }

        case TokenType::UNARY_OP: {
            Expr *e = a.expr;
            switch(op.expr-&gt;op) {
                case Expr::Op::NEGATE: e = e-&gt;Negate(); break;
                case Expr::Op::SQRT:   e = e-&gt;Sqrt(); break;
                case Expr::Op::SQUARE: e = e-&gt;Times(e); break;
                case Expr::Op::SIN:    e = e-&gt;Times(Expr::From(PI/180))-&gt;Sin(); break;
                case Expr::Op::COS:    e = e-&gt;Times(Expr::From(PI/180))-&gt;Cos(); break;
                case Expr::Op::ASIN:   e = e-&gt;ASin()-&gt;Times(Expr::From(180/PI)); break;
                case Expr::Op::ACOS:   e = e-&gt;ACos()-&gt;Times(Expr::From(180/PI)); break;
                default: ssassert(false, "Unexpected unary operator");
            }
            r.expr = e;
            break;
        }

        default: ssassert(false, "Unexpected operator");
    }
    stack.push_back(r);

    return true;
}

</t>
<t tx="leo.20191228122644.107">bool ExprParser::Parse(std::string *error, size_t reduceUntil) {
    while(true) {
        Token t = Lex(error);
        switch(t.type) {
            case TokenType::ERROR:
                return false;

            case TokenType::END:
            case TokenType::PAREN_RIGHT:
                while(stack.size() &gt; 1 + reduceUntil) {
                    if(!Reduce(error)) return false;
                }

                if(t.type == TokenType::PAREN_RIGHT) {
                    stack.push_back(t);
                }
                return true;

            case TokenType::PAREN_LEFT: {
                // sub-expression
                if(!Parse(error, /*reduceUntil=*/stack.size())) return false;

                if(stack.empty() || stack.back().type != TokenType::PAREN_RIGHT) {
                    *error = "Expected ')'";
                    return false;
                }
                stack.pop_back();
                break;
            }

            case TokenType::BINARY_OP:
                if((stack.size() &gt; reduceUntil &amp;&amp; stack.back().type != TokenType::OPERAND) ||
                   stack.size() == reduceUntil) {
                    if(t.expr-&gt;op == Expr::Op::MINUS) {
                        t.type = TokenType::UNARY_OP;
                        t.expr-&gt;op = Expr::Op::NEGATE;
                        stack.push_back(t);
                        break;
                    }
                }

                while(stack.size() &gt; 1 + reduceUntil &amp;&amp;
                      Precedence(t) &lt;= Precedence(stack[stack.size() - 2])) {
                    if(!Reduce(error)) return false;
                }

                stack.push_back(t);
                break;

            case TokenType::UNARY_OP:
            case TokenType::OPERAND:
                stack.push_back(t);
                break;
        }
    }

    return true;
}

Expr *ExprParser::Parse(const std::string &amp;input, std::string *error) {
    ExprParser parser;
    parser.it  = input.cbegin();
    parser.end = input.cend();
    if(!parser.Parse(error)) return NULL;

    Token r = parser.PopOperand(error);
    if(r.IsError()) return NULL;
    return r.expr;
}

Expr *Expr::Parse(const std::string &amp;input, std::string *error) {
    return ExprParser::Parse(input, error);
}

Expr *Expr::From(const std::string &amp;input, bool popUpError) {
    std::string error;
    Expr *e = ExprParser::Parse(input, &amp;error);
    if(!e) {
        dbp("Parse/lex error: %s", error.c_str());
        if(popUpError) {
            Error("Not a valid number or expression: '%s'.\n%s.",
                  input.c_str(), error.c_str());
        }
    }
    return e;
}
</t>
<t tx="leo.20191228122644.108">@path ./src/
//-----------------------------------------------------------------------------
// An expression in our symbolic algebra system, used to write, linearize,
// and solve our constraint equations.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#ifndef SOLVESPACE_EXPR_H
#define SOLVESPACE_EXPR_H

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122644.109">class Expr {
public:

    enum class Op : uint32_t {
        // A parameter, by the hParam handle
        PARAM          =  0,
        // A parameter, by a pointer straight in to the param table (faster,
        // if we know that the param table won't move around)
        PARAM_PTR      =  1,

        // Operands
        CONSTANT       = 20,
        VARIABLE       = 21,

        // Binary ops
        PLUS           = 100,
        MINUS          = 101,
        TIMES          = 102,
        DIV            = 103,
        // Unary ops
        NEGATE         = 104,
        SQRT           = 105,
        SQUARE         = 106,
        SIN            = 107,
        COS            = 108,
        ASIN           = 109,
        ACOS           = 110,
    };

    Op      op;
    Expr    *a;
    union {
        double  v;
        hParam  parh;
        Param  *parp;
        Expr    *b;
    };

    Expr() = default;
    Expr(double val) : op(Op::CONSTANT) { v = val; }

    static inline Expr *AllocExpr()

    inline Expr *Negate() { return AnyOp(Op::NEGATE, NULL); }
    inline Expr *Sqrt  () { return AnyOp(Op::SQRT,   NULL); }
    inline Expr *Square() { return AnyOp(Op::SQUARE, NULL); }
    inline Expr *Sin   () { return AnyOp(Op::SIN,    NULL); }
    inline Expr *Cos   () { return AnyOp(Op::COS,    NULL); }
    inline Expr *ASin  () { return AnyOp(Op::ASIN,   NULL); }
    inline Expr *ACos  () { return AnyOp(Op::ACOS,   NULL); }

    Expr *PartialWrt(hParam p) const;
    double Eval() const;
    uint64_t ParamsUsed() const;
    bool DependsOn(hParam p) const;
    static bool Tol(double a, double b);
    Expr *FoldConstants();
    void Substitute(hParam oldh, hParam newh);

    static const hParam NO_PARAMS, MULTIPLE_PARAMS;
    hParam ReferencedParams(ParamList *pl) const;

    void ParamsToPointers();

    std::string Print() const;

    // number of child nodes: 0 (e.g. constant), 1 (sqrt), or 2 (+)
    int Children() const;
    // total number of nodes in the tree
    int Nodes() const;

    // Make a simple copy
    Expr *DeepCopy() const;
    // Make a copy, with the parameters (usually referenced by hParam)
    // resolved to pointers to the actual value. This speeds things up
    // considerably.
    Expr *DeepCopyWithParamsAsPointers(IdList&lt;Param,hParam&gt; *firstTry,
                                       IdList&lt;Param,hParam&gt; *thenTry) const;

    static Expr *Parse(const std::string &amp;input, std::string *error);
    static Expr *From(const std::string &amp;input, bool popUpError);
};

</t>
<t tx="leo.20191228122644.11">            const auto colour_itr = std::find_if(colours_present.begin(), colours_present.end(),
                                                 [&amp;](const RgbaColor &amp; c) {
                                                     return c.Equals(tr.meta.color);
                                                 });
            if(colour_itr == colours_present.end()) {
                fprintf(f, "          %.10f %.10f %.10f,\n",
                        tr.meta.color.redF(),
                        tr.meta.color.greenF(),
                        tr.meta.color.blueF());
                triangle_colour_ids.push_back(colours_present.size());
                colours_present.insert(colours_present.end(), tr.meta.color);
            } else {
                triangle_colour_ids.push_back(colour_itr - colours_present.begin());
            }
        }
    }

    fputs("        ] }\n"
          "        colorIndex [\n", f);

    for(auto colour_idx : triangle_colour_ids) {
        fprintf(f, "          %d, %d, %d, -1,\n", colour_idx, colour_idx, colour_idx);
    }

    fputs("        ]\n"
          "      }\n"
          "    }\n", f);

    spl.Clear();
}

fputs("  ]\n"
      "}\n", f);
</t>
<t tx="leo.20191228122644.110">class ExprVector {
public:
    Expr *x, *y, *z;

    static ExprVector From(Expr *x, Expr *y, Expr *z);
    static ExprVector From(Vector vn);
    static ExprVector From(hParam x, hParam y, hParam z);
    static ExprVector From(double x, double y, double z);

    ExprVector Plus(ExprVector b) const;
    ExprVector Minus(ExprVector b) const;
    Expr *Dot(ExprVector b) const;
    ExprVector Cross(ExprVector b) const;
    ExprVector ScaledBy(Expr *s) const;
    ExprVector WithMagnitude(Expr *s) const;
    Expr *Magnitude() const;

    Vector Eval() const;
};

</t>
<t tx="leo.20191228122644.111">class ExprQuaternion {
public:
    Expr *w, *vx, *vy, *vz;

    static ExprQuaternion From(Expr *w, Expr *vx, Expr *vy, Expr *vz);
    static ExprQuaternion From(Quaternion qn);
    static ExprQuaternion From(hParam w, hParam vx, hParam vy, hParam vz);

    ExprVector RotationU() const;
    ExprVector RotationV() const;
    ExprVector RotationN() const;

    ExprVector Rotate(ExprVector p) const;
    ExprQuaternion Times(ExprQuaternion b) const;

    Expr *Magnitude() const;
};
#endif
</t>
<t tx="leo.20191228122644.112">@path ./src/
//-----------------------------------------------------------------------------
// Routines to write and read our .slvs file format.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

#define VERSION_STRING "\261\262\263" "SolveSpaceREVa"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122644.113">static int StrStartsWith(const char *str, const char *start) {
    return memcmp(str, start, strlen(start)) == 0;
}

//-----------------------------------------------------------------------------
// Clear and free all the dynamic memory associated with our currently-loaded
// sketch. This does not leave the program in an acceptable state (with the
// references created, and so on), so anyone calling this must fix that later.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122644.114">void SolveSpaceUI::ClearExisting() {
    UndoClearStack(&amp;redo);
    UndoClearStack(&amp;undo);

    for(hGroup hg : SK.groupOrder) {
        Group *g = SK.GetGroup(hg);
        g-&gt;Clear();
    }

    SK.constraint.Clear();
    SK.request.Clear();
    SK.group.Clear();
    SK.groupOrder.Clear();
    SK.style.Clear();

    SK.entity.Clear();
    SK.param.Clear();
    images.clear();
}

hGroup SolveSpaceUI::CreateDefaultDrawingGroup() {
    Group g = {};

    // And an empty group, for the first stuff the user draws.
    g.visible = true;
    g.name = C_("group-name", "sketch-in-plane");
    g.type = Group::Type::DRAWING_WORKPLANE;
    g.subtype = Group::Subtype::WORKPLANE_BY_POINT_ORTHO;
    g.order = 1;
    g.predef.q = Quaternion::From(1, 0, 0, 0);
    hRequest hr = Request::HREQUEST_REFERENCE_XY;
    g.predef.origin = hr.entity(1);
    SK.group.AddAndAssignId(&amp;g);
    SK.GetGroup(g.h)-&gt;activeWorkplane = g.h.entity(0);
    return g.h;
}

</t>
<t tx="leo.20191228122644.115">void SolveSpaceUI::NewFile() {
    ClearExisting();

    // Our initial group, that contains the references.
    Group g = {};
    g.visible = true;
    g.name = C_("group-name", "#references");
    g.type = Group::Type::DRAWING_3D;
    g.order = 0;
    g.h = Group::HGROUP_REFERENCES;
    SK.group.Add(&amp;g);

    // Let's create three two-d coordinate systems, for the coordinate
    // planes; these are our references, present in every sketch.
    Request r = {};
    r.type = Request::Type::WORKPLANE;
    r.group = Group::HGROUP_REFERENCES;
    r.workplane = Entity::FREE_IN_3D;

    r.h = Request::HREQUEST_REFERENCE_XY;
    SK.request.Add(&amp;r);

    r.h = Request::HREQUEST_REFERENCE_YZ;
    SK.request.Add(&amp;r);

    r.h = Request::HREQUEST_REFERENCE_ZX;
    SK.request.Add(&amp;r);

    CreateDefaultDrawingGroup();
}

</t>
<t tx="leo.20191228122644.116">const SolveSpaceUI::SaveTable SolveSpaceUI::SAVED[] = {
    { 'g',  "Group.h.v",                'x',    &amp;(SS.sv.g.h.v)                },
    { 'g',  "Group.type",               'd',    &amp;(SS.sv.g.type)               },
    { 'g',  "Group.order",              'd',    &amp;(SS.sv.g.order)              },
    { 'g',  "Group.name",               'S',    &amp;(SS.sv.g.name)               },
    { 'g',  "Group.activeWorkplane.v",  'x',    &amp;(SS.sv.g.activeWorkplane.v)  },
    { 'g',  "Group.opA.v",              'x',    &amp;(SS.sv.g.opA.v)              },
    { 'g',  "Group.opB.v",              'x',    &amp;(SS.sv.g.opB.v)              },
    { 'g',  "Group.valA",               'f',    &amp;(SS.sv.g.valA)               },
    { 'g',  "Group.valB",               'f',    &amp;(SS.sv.g.valB)               },
    { 'g',  "Group.valC",               'f',    &amp;(SS.sv.g.valB)               },
    { 'g',  "Group.color",              'c',    &amp;(SS.sv.g.color)              },
    { 'g',  "Group.subtype",            'd',    &amp;(SS.sv.g.subtype)            },
    { 'g',  "Group.skipFirst",          'b',    &amp;(SS.sv.g.skipFirst)          },
    { 'g',  "Group.meshCombine",        'd',    &amp;(SS.sv.g.meshCombine)        },
    { 'g',  "Group.forceToMesh",        'd',    &amp;(SS.sv.g.forceToMesh)        },
    { 'g',  "Group.predef.q.w",         'f',    &amp;(SS.sv.g.predef.q.w)         },
    { 'g',  "Group.predef.q.vx",        'f',    &amp;(SS.sv.g.predef.q.vx)        },
    { 'g',  "Group.predef.q.vy",        'f',    &amp;(SS.sv.g.predef.q.vy)        },
    { 'g',  "Group.predef.q.vz",        'f',    &amp;(SS.sv.g.predef.q.vz)        },
    { 'g',  "Group.predef.origin.v",    'x',    &amp;(SS.sv.g.predef.origin.v)    },
    { 'g',  "Group.predef.entityB.v",   'x',    &amp;(SS.sv.g.predef.entityB.v)   },
    { 'g',  "Group.predef.entityC.v",   'x',    &amp;(SS.sv.g.predef.entityC.v)   },
    { 'g',  "Group.predef.swapUV",      'b',    &amp;(SS.sv.g.predef.swapUV)      },
    { 'g',  "Group.predef.negateU",     'b',    &amp;(SS.sv.g.predef.negateU)     },
    { 'g',  "Group.predef.negateV",     'b',    &amp;(SS.sv.g.predef.negateV)     },
    { 'g',  "Group.visible",            'b',    &amp;(SS.sv.g.visible)            },
    { 'g',  "Group.suppress",           'b',    &amp;(SS.sv.g.suppress)           },
    { 'g',  "Group.relaxConstraints",   'b',    &amp;(SS.sv.g.relaxConstraints)   },
    { 'g',  "Group.allowRedundant",     'b',    &amp;(SS.sv.g.allowRedundant)     },
    { 'g',  "Group.allDimsReference",   'b',    &amp;(SS.sv.g.allDimsReference)   },
    { 'g',  "Group.scale",              'f',    &amp;(SS.sv.g.scale)              },
    { 'g',  "Group.remap",              'M',    &amp;(SS.sv.g.remap)              },
    { 'g',  "Group.impFile",            'i',    NULL                          },
    { 'g',  "Group.impFileRel",         'P',    &amp;(SS.sv.g.linkFile)           },

    { 'p',  "Param.h.v.",               'x',    &amp;(SS.sv.p.h.v)                },
    { 'p',  "Param.val",                'f',    &amp;(SS.sv.p.val)                },

    { 'r',  "Request.h.v",              'x',    &amp;(SS.sv.r.h.v)                },
    { 'r',  "Request.type",             'd',    &amp;(SS.sv.r.type)               },
    { 'r',  "Request.extraPoints",      'd',    &amp;(SS.sv.r.extraPoints)        },
    { 'r',  "Request.workplane.v",      'x',    &amp;(SS.sv.r.workplane.v)        },
    { 'r',  "Request.group.v",          'x',    &amp;(SS.sv.r.group.v)            },
    { 'r',  "Request.construction",     'b',    &amp;(SS.sv.r.construction)       },
    { 'r',  "Request.style",            'x',    &amp;(SS.sv.r.style)              },
    { 'r',  "Request.str",              'S',    &amp;(SS.sv.r.str)                },
    { 'r',  "Request.font",             'S',    &amp;(SS.sv.r.font)               },
    { 'r',  "Request.file",             'P',    &amp;(SS.sv.r.file)               },
    { 'r',  "Request.aspectRatio",      'f',    &amp;(SS.sv.r.aspectRatio)        },

    { 'e',  "Entity.h.v",               'x',    &amp;(SS.sv.e.h.v)                },
    { 'e',  "Entity.type",              'd',    &amp;(SS.sv.e.type)               },
    { 'e',  "Entity.construction",      'b',    &amp;(SS.sv.e.construction)       },
    { 'e',  "Entity.style",             'x',    &amp;(SS.sv.e.style)              },
    { 'e',  "Entity.str",               'S',    &amp;(SS.sv.e.str)                },
    { 'e',  "Entity.font",              'S',    &amp;(SS.sv.e.font)               },
    { 'e',  "Entity.file",              'P',    &amp;(SS.sv.e.file)               },
    { 'e',  "Entity.point[0].v",        'x',    &amp;(SS.sv.e.point[0].v)         },
    { 'e',  "Entity.point[1].v",        'x',    &amp;(SS.sv.e.point[1].v)         },
    { 'e',  "Entity.point[2].v",        'x',    &amp;(SS.sv.e.point[2].v)         },
    { 'e',  "Entity.point[3].v",        'x',    &amp;(SS.sv.e.point[3].v)         },
    { 'e',  "Entity.point[4].v",        'x',    &amp;(SS.sv.e.point[4].v)         },
    { 'e',  "Entity.point[5].v",        'x',    &amp;(SS.sv.e.point[5].v)         },
    { 'e',  "Entity.point[6].v",        'x',    &amp;(SS.sv.e.point[6].v)         },
    { 'e',  "Entity.point[7].v",        'x',    &amp;(SS.sv.e.point[7].v)         },
    { 'e',  "Entity.point[8].v",        'x',    &amp;(SS.sv.e.point[8].v)         },
    { 'e',  "Entity.point[9].v",        'x',    &amp;(SS.sv.e.point[9].v)         },
    { 'e',  "Entity.point[10].v",       'x',    &amp;(SS.sv.e.point[10].v)        },
    { 'e',  "Entity.point[11].v",       'x',    &amp;(SS.sv.e.point[11].v)        },
    { 'e',  "Entity.extraPoints",       'd',    &amp;(SS.sv.e.extraPoints)        },
    { 'e',  "Entity.normal.v",          'x',    &amp;(SS.sv.e.normal.v)           },
    { 'e',  "Entity.distance.v",        'x',    &amp;(SS.sv.e.distance.v)         },
    { 'e',  "Entity.workplane.v",       'x',    &amp;(SS.sv.e.workplane.v)        },
    { 'e',  "Entity.actPoint.x",        'f',    &amp;(SS.sv.e.actPoint.x)         },
    { 'e',  "Entity.actPoint.y",        'f',    &amp;(SS.sv.e.actPoint.y)         },
    { 'e',  "Entity.actPoint.z",        'f',    &amp;(SS.sv.e.actPoint.z)         },
    { 'e',  "Entity.actNormal.w",       'f',    &amp;(SS.sv.e.actNormal.w)        },
    { 'e',  "Entity.actNormal.vx",      'f',    &amp;(SS.sv.e.actNormal.vx)       },
    { 'e',  "Entity.actNormal.vy",      'f',    &amp;(SS.sv.e.actNormal.vy)       },
    { 'e',  "Entity.actNormal.vz",      'f',    &amp;(SS.sv.e.actNormal.vz)       },
    { 'e',  "Entity.actDistance",       'f',    &amp;(SS.sv.e.actDistance)        },
    { 'e',  "Entity.actVisible",        'b',    &amp;(SS.sv.e.actVisible),        },


    { 'c',  "Constraint.h.v",           'x',    &amp;(SS.sv.c.h.v)                },
    { 'c',  "Constraint.type",          'd',    &amp;(SS.sv.c.type)               },
    { 'c',  "Constraint.group.v",       'x',    &amp;(SS.sv.c.group.v)            },
    { 'c',  "Constraint.workplane.v",   'x',    &amp;(SS.sv.c.workplane.v)        },
    { 'c',  "Constraint.valA",          'f',    &amp;(SS.sv.c.valA)               },
    { 'c',  "Constraint.valP.v",        'x',    &amp;(SS.sv.c.valP.v)             },
    { 'c',  "Constraint.ptA.v",         'x',    &amp;(SS.sv.c.ptA.v)              },
    { 'c',  "Constraint.ptB.v",         'x',    &amp;(SS.sv.c.ptB.v)              },
    { 'c',  "Constraint.entityA.v",     'x',    &amp;(SS.sv.c.entityA.v)          },
    { 'c',  "Constraint.entityB.v",     'x',    &amp;(SS.sv.c.entityB.v)          },
    { 'c',  "Constraint.entityC.v",     'x',    &amp;(SS.sv.c.entityC.v)          },
    { 'c',  "Constraint.entityD.v",     'x',    &amp;(SS.sv.c.entityD.v)          },
    { 'c',  "Constraint.other",         'b',    &amp;(SS.sv.c.other)              },
    { 'c',  "Constraint.other2",        'b',    &amp;(SS.sv.c.other2)             },
    { 'c',  "Constraint.reference",     'b',    &amp;(SS.sv.c.reference)          },
    { 'c',  "Constraint.comment",       'S',    &amp;(SS.sv.c.comment)            },
    { 'c',  "Constraint.disp.offset.x", 'f',    &amp;(SS.sv.c.disp.offset.x)      },
    { 'c',  "Constraint.disp.offset.y", 'f',    &amp;(SS.sv.c.disp.offset.y)      },
    { 'c',  "Constraint.disp.offset.z", 'f',    &amp;(SS.sv.c.disp.offset.z)      },
    { 'c',  "Constraint.disp.style",    'x',    &amp;(SS.sv.c.disp.style)         },

    { 's',  "Style.h.v",                'x',    &amp;(SS.sv.s.h.v)                },
    { 's',  "Style.name",               'S',    &amp;(SS.sv.s.name)               },
    { 's',  "Style.width",              'f',    &amp;(SS.sv.s.width)              },
    { 's',  "Style.widthAs",            'd',    &amp;(SS.sv.s.widthAs)            },
    { 's',  "Style.textHeight",         'f',    &amp;(SS.sv.s.textHeight)         },
    { 's',  "Style.textHeightAs",       'd',    &amp;(SS.sv.s.textHeightAs)       },
    { 's',  "Style.textAngle",          'f',    &amp;(SS.sv.s.textAngle)          },
    { 's',  "Style.textOrigin",         'x',    &amp;(SS.sv.s.textOrigin)         },
    { 's',  "Style.color",              'c',    &amp;(SS.sv.s.color)              },
    { 's',  "Style.fillColor",          'c',    &amp;(SS.sv.s.fillColor)          },
    { 's',  "Style.filled",             'b',    &amp;(SS.sv.s.filled)             },
    { 's',  "Style.visible",            'b',    &amp;(SS.sv.s.visible)            },
    { 's',  "Style.exportable",         'b',    &amp;(SS.sv.s.exportable)         },
    { 's',  "Style.stippleType",        'd',    &amp;(SS.sv.s.stippleType)        },
    { 's',  "Style.stippleScale",       'f',    &amp;(SS.sv.s.stippleScale)       },

    { 0, NULL, 0, NULL }
};

struct SAVEDptr {
    EntityMap      &amp;M() { return *((EntityMap *)this); }
    std::string    &amp;S() { return *((std::string *)this); }
    Platform::Path &amp;P() { return *((Platform::Path *)this); }
    bool      &amp;b() { return *((bool *)this); }
    RgbaColor &amp;c() { return *((RgbaColor *)this); }
    int       &amp;d() { return *((int *)this); }
    double    &amp;f() { return *((double *)this); }
    uint32_t  &amp;x() { return *((uint32_t *)this); }
};

</t>
<t tx="leo.20191228122644.117">void SolveSpaceUI::SaveUsingTable(const Platform::Path &amp;filename, int type) {
    int i;
    for(i = 0; SAVED[i].type != 0; i++) {
        if(SAVED[i].type != type) continue;

        int fmt = SAVED[i].fmt;
        SAVEDptr *p = (SAVEDptr *)SAVED[i].ptr;
        // Any items that aren't specified are assumed to be zero
        if(fmt == 'S' &amp;&amp; p-&gt;S().empty())          continue;
        if(fmt == 'P' &amp;&amp; p-&gt;P().IsEmpty())        continue;
        if(fmt == 'd' &amp;&amp; p-&gt;d() == 0)             continue;
        if(fmt == 'f' &amp;&amp; EXACT(p-&gt;f() == 0.0))    continue;
        if(fmt == 'x' &amp;&amp; p-&gt;x() == 0)             continue;
        if(fmt == 'i')                            continue;

        fprintf(fh, "%s=", SAVED[i].desc);
        switch(fmt) {
            case 'S': fprintf(fh, "%s",    p-&gt;S().c_str());       break;
            case 'b': fprintf(fh, "%d",    p-&gt;b() ? 1 : 0);       break;
            case 'c': fprintf(fh, "%08x",  p-&gt;c().ToPackedInt()); break;
            case 'd': fprintf(fh, "%d",    p-&gt;d());               break;
            case 'f': fprintf(fh, "%.20f", p-&gt;f());               break;
            case 'x': fprintf(fh, "%08x",  p-&gt;x());               break;

            case 'P': {
                if(!p-&gt;P().IsEmpty()) {
                    Platform::Path relativePath = p-&gt;P().RelativeTo(filename.Parent());
                    ssassert(!relativePath.IsEmpty(), "Cannot relativize path");
                    fprintf(fh, "%s", relativePath.ToPortable().c_str());
                }
                break;
            }

            case 'M': {
                fprintf(fh, "{\n");
                // Sort the mapping, since EntityMap is not deterministic.
                std::vector&lt;std::pair&lt;EntityKey, EntityId&gt;&gt; sorted(p-&gt;M().begin(), p-&gt;M().end());
                std::sort(sorted.begin(), sorted.end(),
                    [](std::pair&lt;EntityKey, EntityId&gt; &amp;a, std::pair&lt;EntityKey, EntityId&gt; &amp;b) {
                        return a.second.v &lt; b.second.v;
                    });
                for(auto it : sorted) {
                    fprintf(fh, "    %d %08x %d\n",
                            it.second.v, it.first.input.v, it.first.copyNumber);
                }
                fprintf(fh, "}");
                break;
            }

            case 'i': break;

            default: ssassert(false, "Unexpected value format");
        }
        fprintf(fh, "\n");
    }
}

</t>
<t tx="leo.20191228122644.118">bool SolveSpaceUI::SaveToFile(const Platform::Path &amp;filename) {
    // Make sure all the entities are regenerated up to date, since they will be exported.
    SS.ScheduleShowTW();
    SS.GenerateAll(SolveSpaceUI::Generate::ALL);

    for(Group &amp;g : SK.group) {
        if(g.type != Group::Type::LINKED) continue;

        if(g.linkFile.RelativeTo(filename).IsEmpty()) {
            Error("This sketch links the sketch '%s'; it can only be saved "
                  "on the same volume.", g.linkFile.raw.c_str());
            return false;
        }
    }

    fh = OpenFile(filename, "wb");
    if(!fh) {
        Error("Couldn't write to file '%s'", filename.raw.c_str());
        return false;
    }

    fprintf(fh, "%s\n\n\n", VERSION_STRING);

    int i, j;
    for(auto &amp;g : SK.group) {
        sv.g = g;
        SaveUsingTable(filename, 'g');
        fprintf(fh, "AddGroup\n\n");
    }

    for(auto &amp;p : SK.param) {
        sv.p = p;
        SaveUsingTable(filename, 'p');
        fprintf(fh, "AddParam\n\n");
    }

    for(auto &amp;r : SK.request) {
        sv.r = r;
        SaveUsingTable(filename, 'r');
        fprintf(fh, "AddRequest\n\n");
    }

    for(auto &amp;e : SK.entity) {
        e.CalculateNumerical(/*forExport=*/true);
        sv.e = e;
        SaveUsingTable(filename, 'e');
        fprintf(fh, "AddEntity\n\n");
    }

    for(auto &amp;c : SK.constraint) {
        sv.c = c;
        SaveUsingTable(filename, 'c');
        fprintf(fh, "AddConstraint\n\n");
    }

    for(auto &amp;s : SK.style) {
        sv.s = s;
        if(sv.s.h.v &gt;= Style::FIRST_CUSTOM) {
            SaveUsingTable(filename, 's');
            fprintf(fh, "AddStyle\n\n");
        }
    }

    // A group will have either a mesh or a shell, but not both; but the code
    // to print either of those just does nothing if the mesh/shell is empty.

    Group *g = SK.GetGroup(*SK.groupOrder.Last());
    SMesh *m = &amp;g-&gt;runningMesh;
    for(i = 0; i &lt; m-&gt;l.n; i++) {
        STriangle *tr = &amp;(m-&gt;l[i]);
        fprintf(fh, "Triangle %08x %08x "
                "%.20f %.20f %.20f  %.20f %.20f %.20f  %.20f %.20f %.20f\n",
            tr-&gt;meta.face, tr-&gt;meta.color.ToPackedInt(),
            CO(tr-&gt;a), CO(tr-&gt;b), CO(tr-&gt;c));
    }

    SShell *s = &amp;g-&gt;runningShell;
    SSurface *srf;
    for(srf = s-&gt;surface.First(); srf; srf = s-&gt;surface.NextAfter(srf)) {
        fprintf(fh, "Surface %08x %08x %08x %d %d\n",
            srf-&gt;h.v, srf-&gt;color.ToPackedInt(), srf-&gt;face, srf-&gt;degm, srf-&gt;degn);
        for(i = 0; i &lt;= srf-&gt;degm; i++) {
            for(j = 0; j &lt;= srf-&gt;degn; j++) {
                fprintf(fh, "SCtrl %d %d %.20f %.20f %.20f Weight %20.20f\n",
                    i, j, CO(srf-&gt;ctrl[i][j]), srf-&gt;weight[i][j]);
            }
        }

        STrimBy *stb;
        for(stb = srf-&gt;trim.First(); stb; stb = srf-&gt;trim.NextAfter(stb)) {
            fprintf(fh, "TrimBy %08x %d %.20f %.20f %.20f  %.20f %.20f %.20f\n",
                stb-&gt;curve.v, stb-&gt;backwards ? 1 : 0,
                CO(stb-&gt;start), CO(stb-&gt;finish));
        }

        fprintf(fh, "AddSurface\n");
    }
    SCurve *sc;
    for(sc = s-&gt;curve.First(); sc; sc = s-&gt;curve.NextAfter(sc)) {
        fprintf(fh, "Curve %08x %d %d %08x %08x\n",
            sc-&gt;h.v,
            sc-&gt;isExact ? 1 : 0, sc-&gt;exact.deg,
            sc-&gt;surfA.v, sc-&gt;surfB.v);

        if(sc-&gt;isExact) {
            for(i = 0; i &lt;= sc-&gt;exact.deg; i++) {
                fprintf(fh, "CCtrl %d %.20f %.20f %.20f Weight %.20f\n",
                    i, CO(sc-&gt;exact.ctrl[i]), sc-&gt;exact.weight[i]);
            }
        }
        SCurvePt *scpt;
        for(scpt = sc-&gt;pts.First(); scpt; scpt = sc-&gt;pts.NextAfter(scpt)) {
            fprintf(fh, "CurvePt %d %.20f %.20f %.20f\n",
                scpt-&gt;vertex ? 1 : 0, CO(scpt-&gt;p));
        }

        fprintf(fh, "AddCurve\n");
    }

    fclose(fh);

    return true;
}

</t>
<t tx="leo.20191228122644.119">void SolveSpaceUI::LoadUsingTable(const Platform::Path &amp;filename, char *key, char *val) {
    int i;
    for(i = 0; SAVED[i].type != 0; i++) {
        if(strcmp(SAVED[i].desc, key)==0) {
            SAVEDptr *p = (SAVEDptr *)SAVED[i].ptr;
            unsigned int u = 0;
            switch(SAVED[i].fmt) {
                case 'S': p-&gt;S() = val;                     break;
                case 'b': p-&gt;b() = (atoi(val) != 0);        break;
                case 'd': p-&gt;d() = atoi(val);               break;
                case 'f': p-&gt;f() = atof(val);               break;
                case 'x': sscanf(val, "%x", &amp;u); p-&gt;x()= u; break;

                case 'P': {
                    Platform::Path path = Platform::Path::FromPortable(val);
                    if(!path.IsEmpty()) {
                        p-&gt;P() = filename.Parent().Join(path).Expand();
                    }
                    break;
                }

                case 'c':
                    sscanf(val, "%x", &amp;u);
                    p-&gt;c() = RgbaColor::FromPackedInt(u);
                    break;

                case 'M': {
                    p-&gt;M().clear();
                    for(;;) {
                        EntityKey ek;
                        EntityId ei;
                        char line2[1024];
                        if (fgets(line2, (int)sizeof(line2), fh) == NULL)
                            break;
                        if(sscanf(line2, "%d %x %d", &amp;(ei.v), &amp;(ek.input.v),
                                                     &amp;(ek.copyNumber)) == 3) {
                            if(ei.v == Entity::NO_ENTITY.v) {
                                // Commit bd84bc1a mistakenly introduced code that would remap
                                // some entities to NO_ENTITY. This was fixed in commit bd84bc1a,
                                // but files created meanwhile are corrupt, and can cause crashes.
                                //
                                // To fix this, we skip any such remaps when loading; they will be
                                // recreated on the next regeneration. Any resulting orphans will
                                // be pruned in the usual way, recovering to a well-defined state.
                                continue;
                            }
                            p-&gt;M().insert({ ek, ei });
                        } else {
                            break;
                        }
                    }
                    break;
                }

                case 'i': break;

                default: ssassert(false, "Unexpected value format");
            }
            break;
        }
    }
    if(SAVED[i].type == 0) {
        fileLoadError = true;
    }
}

</t>
<t tx="leo.20191228122644.12">void SolveSpaceUI::ExportAsPngTo(const Platform::Path &amp;filename) {
    screenshotFile = filename;
    // The rest of the work is done in the next redraw.
    GW.Invalidate();
}
</t>
<t tx="leo.20191228122644.120">bool SolveSpaceUI::LoadFromFile(const Platform::Path &amp;filename, bool canCancel) {
    allConsistent = false;
    fileLoadError = false;

    fh = OpenFile(filename, "rb");
    if(!fh) {
        Error("Couldn't read from file '%s'", filename.raw.c_str());
        return false;
    }

    ClearExisting();

    sv = {};
    sv.g.scale = 1; // default is 1, not 0; so legacy files need this
    Style::FillDefaultStyle(&amp;sv.s);

    char line[1024];
    while(fgets(line, (int)sizeof(line), fh)) {
        char *s = strchr(line, '\n');
        if(s) *s = '\0';
        // We should never get files with \r characters in them, but mailers
        // will sometimes mangle attachments.
        s = strchr(line, '\r');
        if(s) *s = '\0';

        if(*line == '\0') continue;

        char *e = strchr(line, '=');
        if(e) {
            *e = '\0';
            char *key = line, *val = e+1;
            LoadUsingTable(filename, key, val);
        } else if(strcmp(line, "AddGroup")==0) {
            // legacy files have a spurious dependency between linked groups
            // and their parent groups, remove
            if(sv.g.type == Group::Type::LINKED)
                sv.g.opA.v = 0;

            SK.group.Add(&amp;(sv.g));
            sv.g = {};
            sv.g.scale = 1; // default is 1, not 0; so legacy files need this
        } else if(strcmp(line, "AddParam")==0) {
            // params are regenerated, but we want to preload the values
            // for initial guesses
            SK.param.Add(&amp;(sv.p));
            sv.p = {};
        } else if(strcmp(line, "AddEntity")==0) {
            // entities are regenerated
        } else if(strcmp(line, "AddRequest")==0) {
            SK.request.Add(&amp;(sv.r));
            sv.r = {};
        } else if(strcmp(line, "AddConstraint")==0) {
            SK.constraint.Add(&amp;(sv.c));
            sv.c = {};
        } else if(strcmp(line, "AddStyle")==0) {
            SK.style.Add(&amp;(sv.s));
            sv.s = {};
            Style::FillDefaultStyle(&amp;sv.s);
        } else if(strcmp(line, VERSION_STRING)==0) {
            // do nothing, version string
        } else if(StrStartsWith(line, "Triangle ")      ||
                  StrStartsWith(line, "Surface ")       ||
                  StrStartsWith(line, "SCtrl ")         ||
                  StrStartsWith(line, "TrimBy ")        ||
                  StrStartsWith(line, "Curve ")         ||
                  StrStartsWith(line, "CCtrl ")         ||
                  StrStartsWith(line, "CurvePt ")       ||
                  strcmp(line, "AddSurface")==0         ||
                  strcmp(line, "AddCurve")==0)
        {
            // ignore the mesh or shell, since we regenerate that
        } else {
            fileLoadError = true;
        }
    }

    fclose(fh);

    if(fileLoadError) {
        Error(_("Unrecognized data in file. This file may be corrupt, or "
                "from a newer version of the program."));
        // At least leave the program in a non-crashing state.
        if(SK.group.IsEmpty()) {
            NewFile();
        }
    }
    if(!ReloadAllLinked(filename, canCancel)) {
        return false;
    }
    UpgradeLegacyData();

    return true;
}

</t>
<t tx="leo.20191228122644.121">void SolveSpaceUI::UpgradeLegacyData() {
    for(Request &amp;r : SK.request) {
        switch(r.type) {
            // TTF text requests saved in versions prior to 3.0 only have two
            // reference points (origin and origin plus v); version 3.0 adds two
            // more points, and if we don't do anything, then they will appear
            // at workplane origin, and the solver will mess up the sketch if
            // it is not fully constrained.
            case Request::Type::TTF_TEXT: {
                IdList&lt;Entity,hEntity&gt; entity = {};
                IdList&lt;Param,hParam&gt;   param = {};
                r.Generate(&amp;entity, &amp;param);

                // If we didn't load all of the entities and params that this
                // request would generate, then add them now, so that we can
                // force them to their appropriate positions.
                for(Param &amp;p : param) {
                    if(SK.param.FindByIdNoOops(p.h) != NULL) continue;
                    SK.param.Add(&amp;p);
                }
                bool allPointsExist = true;
                for(Entity &amp;e : entity) {
                    if(SK.entity.FindByIdNoOops(e.h) != NULL) continue;
                    SK.entity.Add(&amp;e);
                    allPointsExist = false;
                }

                if(!allPointsExist) {
                    Entity *text = entity.FindById(r.h.entity(0));
                    Entity *b = entity.FindById(text-&gt;point[2]);
                    Entity *c = entity.FindById(text-&gt;point[3]);
                    ExprVector bex, cex;
                    text-&gt;RectGetPointsExprs(&amp;bex, &amp;cex);
                    b-&gt;PointForceParamTo(bex.Eval());
                    c-&gt;PointForceParamTo(cex.Eval());
                }
                entity.Clear();
                param.Clear();
                break;
            }

            default:
                break;
        }
    }

    // Constraints saved in versions prior to 3.0 never had any params;
    // version 3.0 introduced params to constraints to avoid the hairy ball problem,
    // so force them where they belong.
    IdList&lt;Param,hParam&gt; oldParam = {};
    SK.param.DeepCopyInto(&amp;oldParam);
    SS.GenerateAll(SolveSpaceUI::Generate::REGEN);

    @others
}

</t>
<t tx="leo.20191228122644.122">auto AllParamsExistFor = [&amp;](Constraint &amp;c) {
    IdList&lt;Param,hParam&gt; param = {};
    c.Generate(&amp;param);
    bool allParamsExist = true;
    for(Param &amp;p : param) {
        if(oldParam.FindByIdNoOops(p.h) != NULL) continue;
        allParamsExist = false;
        break;
    }
    param.Clear();
    return allParamsExist;
};

for(Constraint &amp;c : SK.constraint) {
    switch(c.type) {
        case Constraint::Type::PT_ON_LINE: {
            if(AllParamsExistFor(c)) continue;

            EntityBase *eln = SK.GetEntity(c.entityA);
            EntityBase *ea = SK.GetEntity(eln-&gt;point[0]);
            EntityBase *eb = SK.GetEntity(eln-&gt;point[1]);
            EntityBase *ep = SK.GetEntity(c.ptA);

            ExprVector exp = ep-&gt;PointGetExprsInWorkplane(c.workplane);
            ExprVector exa = ea-&gt;PointGetExprsInWorkplane(c.workplane);
            ExprVector exb = eb-&gt;PointGetExprsInWorkplane(c.workplane);
            ExprVector exba = exb.Minus(exa);
            Param *p = SK.GetParam(c.h.param(0));
            p-&gt;val = exba.Dot(exp.Minus(exa))-&gt;Eval() / exba.Dot(exba)-&gt;Eval();
            break;
        }

        case Constraint::Type::CUBIC_LINE_TANGENT: {
            if(AllParamsExistFor(c)) continue;

            EntityBase *cubic = SK.GetEntity(c.entityA);
            EntityBase *line  = SK.GetEntity(c.entityB);

            ExprVector a;
            if(c.other) {
                a = cubic-&gt;CubicGetFinishTangentExprs();
            } else {
                a = cubic-&gt;CubicGetStartTangentExprs();
            }

            ExprVector b = line-&gt;VectorGetExprs();

            Param *param = SK.GetParam(c.h.param(0));
            param-&gt;val = a.Dot(b)-&gt;Eval() / b.Dot(b)-&gt;Eval();
            break;
        }

        case Constraint::Type::SAME_ORIENTATION: {
            if(AllParamsExistFor(c)) continue;

            EntityBase *an = SK.GetEntity(c.entityA);
            EntityBase *bn = SK.GetEntity(c.entityB);

            ExprVector a = an-&gt;NormalExprsN();
            ExprVector b = bn-&gt;NormalExprsN();

            Param *param = SK.GetParam(c.h.param(0));
            param-&gt;val = a.Dot(b)-&gt;Eval() / b.Dot(b)-&gt;Eval();
            break;
        }

        case Constraint::Type::PARALLEL: {
            if(AllParamsExistFor(c)) continue;

            EntityBase *ea = SK.GetEntity(c.entityA),
                       *eb = SK.GetEntity(c.entityB);
            ExprVector a = ea-&gt;VectorGetExprsInWorkplane(c.workplane);
            ExprVector b = eb-&gt;VectorGetExprsInWorkplane(c.workplane);

            Param *param = SK.GetParam(c.h.param(0));
            param-&gt;val = a.Dot(b)-&gt;Eval() / b.Dot(b)-&gt;Eval();
            break;
        }

        default:
            break;
    }
}
oldParam.Clear();
</t>
<t tx="leo.20191228122644.123">bool SolveSpaceUI::LoadEntitiesFromFile(const Platform::Path &amp;filename, EntityList *le,
                                        SMesh *m, SShell *sh)
{
    SSurface srf = {};
    SCurve crv = {};

    fh = OpenFile(filename, "rb");
    if(!fh) return false;

    le-&gt;Clear();
    sv = {};

    char line[1024];
    while(fgets(line, (int)sizeof(line), fh)) {
        char *s = strchr(line, '\n');
        if(s) *s = '\0';
        // We should never get files with \r characters in them, but mailers
        // will sometimes mangle attachments.
        s = strchr(line, '\r');
        if(s) *s = '\0';

        if(*line == '\0') continue;

        char *e = strchr(line, '=');
        if(e) {
            *e = '\0';
            char *key = line, *val = e+1;
            LoadUsingTable(filename, key, val);
        } else if(strcmp(line, "AddGroup")==0) {
            // These get allocated whether we want them or not.
            sv.g.remap.clear();
        } else if(strcmp(line, "AddParam")==0) {

        } else if(strcmp(line, "AddEntity")==0) {
            le-&gt;Add(&amp;(sv.e));
            sv.e = {};
        } else if(strcmp(line, "AddRequest")==0) {

        } else if(strcmp(line, "AddConstraint")==0) {

        } else if(strcmp(line, "AddStyle")==0) {
            // Linked file contains a style that we don't have yet,
            // so import it.
            if (SK.style.FindByIdNoOops(sv.s.h) == nullptr) {
                SK.style.Add(&amp;(sv.s));
            }
            sv.s = {};
            Style::FillDefaultStyle(&amp;sv.s);
        } else if(strcmp(line, VERSION_STRING)==0) {

        } else if(StrStartsWith(line, "Triangle ")) {
            STriangle tr = {};
            unsigned int rgba = 0;
            if(sscanf(line, "Triangle %x %x  "
                             "%lf %lf %lf  %lf %lf %lf  %lf %lf %lf",
                &amp;(tr.meta.face), &amp;rgba,
                &amp;(tr.a.x), &amp;(tr.a.y), &amp;(tr.a.z),
                &amp;(tr.b.x), &amp;(tr.b.y), &amp;(tr.b.z),
                &amp;(tr.c.x), &amp;(tr.c.y), &amp;(tr.c.z)) != 11) {
                ssassert(false, "Unexpected Triangle format");
            }
            tr.meta.color = RgbaColor::FromPackedInt((uint32_t)rgba);
            m-&gt;AddTriangle(&amp;tr);
        } else if(StrStartsWith(line, "Surface ")) {
            unsigned int rgba = 0;
            if(sscanf(line, "Surface %x %x %x %d %d",
                &amp;(srf.h.v), &amp;rgba, &amp;(srf.face),
                &amp;(srf.degm), &amp;(srf.degn)) != 5) {
                ssassert(false, "Unexpected Surface format");
            }
            srf.color = RgbaColor::FromPackedInt((uint32_t)rgba);
        } else if(StrStartsWith(line, "SCtrl ")) {
            int i, j;
            Vector c;
            double w;
            if(sscanf(line, "SCtrl %d %d %lf %lf %lf Weight %lf",
                                &amp;i, &amp;j, &amp;(c.x), &amp;(c.y), &amp;(c.z), &amp;w) != 6)
            {
                ssassert(false, "Unexpected SCtrl format");
            }
            srf.ctrl[i][j] = c;
            srf.weight[i][j] = w;
        } else if(StrStartsWith(line, "TrimBy ")) {
            STrimBy stb = {};
            int backwards;
            if(sscanf(line, "TrimBy %x %d  %lf %lf %lf  %lf %lf %lf",
                &amp;(stb.curve.v), &amp;backwards,
                &amp;(stb.start.x), &amp;(stb.start.y), &amp;(stb.start.z),
                &amp;(stb.finish.x), &amp;(stb.finish.y), &amp;(stb.finish.z)) != 8)
            {
                ssassert(false, "Unexpected TrimBy format");
            }
            stb.backwards = (backwards != 0);
            srf.trim.Add(&amp;stb);
        } else if(strcmp(line, "AddSurface")==0) {
            sh-&gt;surface.Add(&amp;srf);
            srf = {};
        } else if(StrStartsWith(line, "Curve ")) {
            int isExact;
            if(sscanf(line, "Curve %x %d %d %x %x",
                &amp;(crv.h.v),
                &amp;(isExact),
                &amp;(crv.exact.deg),
                &amp;(crv.surfA.v), &amp;(crv.surfB.v)) != 5)
            {
                ssassert(false, "Unexpected Curve format");
            }
            crv.isExact = (isExact != 0);
        } else if(StrStartsWith(line, "CCtrl ")) {
            int i;
            Vector c;
            double w;
            if(sscanf(line, "CCtrl %d %lf %lf %lf Weight %lf",
                                &amp;i, &amp;(c.x), &amp;(c.y), &amp;(c.z), &amp;w) != 5)
            {
                ssassert(false, "Unexpected CCtrl format");
            }
            crv.exact.ctrl[i] = c;
            crv.exact.weight[i] = w;
        } else if(StrStartsWith(line, "CurvePt ")) {
            SCurvePt scpt;
            int vertex;
            if(sscanf(line, "CurvePt %d %lf %lf %lf",
                &amp;vertex,
                &amp;(scpt.p.x), &amp;(scpt.p.y), &amp;(scpt.p.z)) != 4)
            {
                ssassert(false, "Unexpected CurvePt format");
            }
            scpt.vertex = (vertex != 0);
            crv.pts.Add(&amp;scpt);
        } else if(strcmp(line, "AddCurve")==0) {
            sh-&gt;curve.Add(&amp;crv);
            crv = {};
        } else ssassert(false, "Unexpected operation");
    }

    fclose(fh);
    return true;
}

</t>
<t tx="leo.20191228122644.124">static Platform::MessageDialog::Response LocateImportedFile(const Platform::Path &amp;filename,
                                                            bool canCancel) {
    Platform::MessageDialogRef dialog = CreateMessageDialog(SS.GW.window);

    using Platform::MessageDialog;
    dialog-&gt;SetType(MessageDialog::Type::QUESTION);
    dialog-&gt;SetTitle(C_("title", "Missing File"));
    dialog-&gt;SetMessage(ssprintf(C_("dialog", "The linked file “%s” is not present."),
                                filename.raw.c_str()));
    dialog-&gt;SetDescription(C_("dialog", "Do you want to locate it manually?\n\n"
                                        "If you decline, any geometry that depends on "
                                        "the missing file will be permanently removed."));
    dialog-&gt;AddButton(C_("button", "&amp;Yes"), MessageDialog::Response::YES,
                      /*isDefault=*/true);
    dialog-&gt;AddButton(C_("button", "&amp;No"), MessageDialog::Response::NO);
    if(canCancel) {
        dialog-&gt;AddButton(C_("button", "&amp;Cancel"), MessageDialog::Response::CANCEL);
    }

    // FIXME(async): asyncify this call
    return dialog-&gt;RunModal();
}

</t>
<t tx="leo.20191228122644.125">bool SolveSpaceUI::ReloadAllLinked(const Platform::Path &amp;saveFile, bool canCancel) {
    Platform::SettingsRef settings = Platform::GetSettings();

    std::map&lt;Platform::Path, Platform::Path, Platform::PathLess&gt; linkMap;

    allConsistent = false;

    for(Group &amp;g : SK.group) {
        if(g.type != Group::Type::LINKED) continue;

        g.impEntity.Clear();
        g.impMesh.Clear();
        g.impShell.Clear();

        // If we prompted for this specific file before, don't ask again.
        if(linkMap.count(g.linkFile)) {
            g.linkFile = linkMap[g.linkFile];
        }

try_again:
        if(LoadEntitiesFromFile(g.linkFile, &amp;g.impEntity, &amp;g.impMesh, &amp;g.impShell)) {
            // We loaded the data, good. Now import its dependencies as well.
            for(Entity &amp;e : g.impEntity) {
                if(e.type != Entity::Type::IMAGE) continue;
                if(!ReloadLinkedImage(g.linkFile, &amp;e.file, canCancel)) {
                    return false;
                }
            }
        } else if(linkMap.count(g.linkFile) == 0) {
            // The file was moved; prompt the user for its new location.
            switch(LocateImportedFile(g.linkFile.RelativeTo(saveFile), canCancel)) {
                case Platform::MessageDialog::Response::YES: {
                    Platform::FileDialogRef dialog = Platform::CreateOpenFileDialog(SS.GW.window);
                    dialog-&gt;AddFilters(Platform::SolveSpaceModelFileFilters);
                    dialog-&gt;ThawChoices(settings, "LinkSketch");
                    if(dialog-&gt;RunModal()) {
                        dialog-&gt;FreezeChoices(settings, "LinkSketch");
                        linkMap[g.linkFile] = dialog-&gt;GetFilename();
                        g.linkFile = dialog-&gt;GetFilename();
                        goto try_again;
                    } else {
                        if(canCancel) return false;
                        break;
                    }
                }

                case Platform::MessageDialog::Response::NO:
                    linkMap[g.linkFile].Clear();
                    // Geometry will be pruned by GenerateAll().
                    break;

                case Platform::MessageDialog::Response::CANCEL:
                    return false;

                default:
                    ssassert(false, "Unexpected dialog response");
            }
        } else {
            // User was already asked to and refused to locate a missing linked file.
        }
    }

    for(Request &amp;r : SK.request) {
        if(r.type != Request::Type::IMAGE) continue;

        if(!ReloadLinkedImage(saveFile, &amp;r.file, canCancel)) {
            return false;
        }
    }

    return true;
}

</t>
<t tx="leo.20191228122644.126">bool SolveSpaceUI::ReloadLinkedImage(const Platform::Path &amp;saveFile,
                                     Platform::Path *filename, bool canCancel) {
    Platform::SettingsRef settings = Platform::GetSettings();

    std::shared_ptr&lt;Pixmap&gt; pixmap;
    bool promptOpenFile = false;
    if(filename-&gt;IsEmpty()) {
        // We're prompting the user for a new image.
        promptOpenFile = true;
    } else {
        auto image = SS.images.find(*filename);
        if(image != SS.images.end()) return true;

        pixmap = Pixmap::ReadPng(*filename);
        if(pixmap == NULL) {
            // The file was moved; prompt the user for its new location.
            switch(LocateImportedFile(filename-&gt;RelativeTo(saveFile), canCancel)) {
                case Platform::MessageDialog::Response::YES:
                    promptOpenFile = true;
                    break;

                case Platform::MessageDialog::Response::NO:
                    // We don't know where the file is, record it as absent.
                    break;

                case Platform::MessageDialog::Response::CANCEL:
                    return false;

                default:
                    ssassert(false, "Unexpected dialog response");
            }
        }
    }

    if(promptOpenFile) {
        Platform::FileDialogRef dialog = Platform::CreateOpenFileDialog(SS.GW.window);
        dialog-&gt;AddFilters(Platform::RasterFileFilters);
        dialog-&gt;ThawChoices(settings, "LinkImage");
        if(dialog-&gt;RunModal()) {
            dialog-&gt;FreezeChoices(settings, "LinkImage");
            *filename = dialog-&gt;GetFilename();
            pixmap = Pixmap::ReadPng(*filename);
            if(pixmap == NULL) {
                Error("The image '%s' is corrupted.", filename-&gt;raw.c_str());
            }
            // We know where the file is now, good.
        } else if(canCancel) {
            return false;
        }
    }

    // We loaded the data, good.
    SS.images[*filename] = pixmap;
    return true;
}
</t>
<t tx="leo.20191228122644.127">@path ./src/
//-----------------------------------------------------------------------------
// Generate our model based on its parametric description, by solving each
// sketch, generating surfaces from the resulting entities, performing any
// requested surface operations (e.g. Booleans) with our model so far, and
// then repeating this process for each subsequent group.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122644.128">void SolveSpaceUI::MarkGroupDirtyByEntity(hEntity he) {
    Entity *e = SK.GetEntity(he);
    MarkGroupDirty(e-&gt;group);
}

</t>
<t tx="leo.20191228122644.129">void SolveSpaceUI::MarkGroupDirty(hGroup hg, bool onlyThis) {
    bool go = false;
    for(auto const &amp;gh : SK.groupOrder) {
        Group *g = SK.GetGroup(gh);
        if(g-&gt;h == hg) {
            go = true;
        }
        if(go) {
            g-&gt;clean = false;
            if(onlyThis) break;
        }
    }
    unsaved = true;
    ScheduleGenerateAll();
}

</t>
<t tx="leo.20191228122644.13">@path ./src/
//-----------------------------------------------------------------------------
// Export a STEP file describing our ratpoly shell.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
}

@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122644.130">bool SolveSpaceUI::PruneOrphans() {

    @others
}

</t>
<t tx="leo.20191228122644.131">auto r = std::find_if(SK.request.begin(), SK.request.end(),
                      [&amp;](Request &amp;r) { return !GroupExists(r.group); });
if(r != SK.request.end()) {
    (deleted.requests)++;
    SK.request.RemoveById(r-&gt;h);
    return true;
}

</t>
<t tx="leo.20191228122644.132">auto c = std::find_if(SK.constraint.begin(), SK.constraint.end(),
                      [&amp;](Constraint &amp;c) { return !GroupExists(c.group); });
if(c != SK.constraint.end()) {
    (deleted.constraints)++;
    (deleted.nonTrivialConstraints)++;
    SK.constraint.RemoveById(c-&gt;h);
    return true;
}
return false;
</t>
<t tx="leo.20191228122644.133">bool SolveSpaceUI::GroupsInOrder(hGroup before, hGroup after) {
    if(before.v == 0) return true;
    if(after.v  == 0) return true;
    if(!GroupExists(before)) return false;
    if(!GroupExists(after)) return false;
    int beforep = SK.GetGroup(before)-&gt;order;
    int afterp = SK.GetGroup(after)-&gt;order;
    if(beforep &gt;= afterp) return false;
    return true;
}

</t>
<t tx="leo.20191228122644.134">bool SolveSpaceUI::GroupExists(hGroup hg) {
    // A nonexistent group is not acceptable
    return SK.group.FindByIdNoOops(hg) ? true : false;
}
</t>
<t tx="leo.20191228122644.135">bool SolveSpaceUI::EntityExists(hEntity he) {
    // A nonexstient entity is acceptable, though, usually just means it
    // doesn't apply.
    if(he == Entity::NO_ENTITY) return true;
    return SK.entity.FindByIdNoOops(he) ? true : false;
}

</t>
<t tx="leo.20191228122644.136">bool SolveSpaceUI::PruneGroups(hGroup hg) {
    Group *g = SK.GetGroup(hg);
    if(GroupsInOrder(g-&gt;opA, hg) &amp;&amp;
       EntityExists(g-&gt;predef.origin) &amp;&amp;
       EntityExists(g-&gt;predef.entityB) &amp;&amp;
       EntityExists(g-&gt;predef.entityC))
    {
        return false;
    }
    (deleted.groups)++;
    SK.group.RemoveById(g-&gt;h);
    return true;
}

</t>
<t tx="leo.20191228122644.137">bool SolveSpaceUI::PruneRequests(hGroup hg) {
    @others
}

</t>
<t tx="leo.20191228122644.138">auto e = std::find_if(SK.entity.begin(), SK.entity.end(),
                      [&amp;](Entity &amp;e) { return e.group == hg &amp;&amp; !EntityExists(e.workplane); });
if(e != SK.entity.end()) {
    (deleted.requests)++;
    SK.entity.RemoveById(e-&gt;h);
    return true;
}
return false;
</t>
<t tx="leo.20191228122644.139">bool SolveSpaceUI::PruneConstraints(hGroup hg) {
    @others
}

</t>
<t tx="leo.20191228122644.14">void StepFileWriter::WriteHeader() {
    fprintf(f,
"ISO-10303-21;\n"
"HEADER;\n"
"\n"
"FILE_DESCRIPTION((''), '2;1');\n"
"\n"
"FILE_NAME(\n"
"    'output_file',\n"
"    '2009-06-07T17:44:47-07:00',\n"
"    (''),\n"
"    (''),\n"
"    'SolveSpace',\n"
"    '',\n"
"    ''\n"
");\n"
"\n"
"FILE_SCHEMA (('CONFIG_CONTROL_DESIGN'));\n"
"ENDSEC;\n"
"\n"
"DATA;\n"
"\n"
"/**********************************************************\n"
" * This defines the units and tolerances for the file. It\n"
" * is always the same, independent of the actual data.\n"
" **********************************************************/\n"
"#158=(\n"
"LENGTH_UNIT()\n"
"NAMED_UNIT(*)\n"
"SI_UNIT(.MILLI.,.METRE.)\n"
");\n"
"#161=(\n"
"NAMED_UNIT(*)\n"
"PLANE_ANGLE_UNIT()\n"
"SI_UNIT($,.RADIAN.)\n"
");\n"
"#166=(\n"
"NAMED_UNIT(*)\n"
"SI_UNIT($,.STERADIAN.)\n"
"SOLID_ANGLE_UNIT()\n"
");\n"
"#167=UNCERTAINTY_MEASURE_WITH_UNIT(LENGTH_MEASURE(0.001),#158,\n"
"'DISTANCE_ACCURACY_VALUE',\n"
"'string');\n"
"#168=(\n"
"GEOMETRIC_REPRESENTATION_CONTEXT(3)\n"
"GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT((#167))\n"
"GLOBAL_UNIT_ASSIGNED_CONTEXT((#166,#161,#158))\n"
"REPRESENTATION_CONTEXT('ID1','3D')\n"
");\n"
"#169=SHAPE_REPRESENTATION('',(#170),#168);\n"
"#170=AXIS2_PLACEMENT_3D('',#173,#171,#172);\n"
"#171=DIRECTION('',(0.,0.,1.));\n"
"#172=DIRECTION('',(1.,0.,0.));\n"
"#173=CARTESIAN_POINT('',(0.,0.,0.));\n"
"\n"
    );

    // Start the ID somewhere beyond the header IDs.
    id = 200;
}
void StepFileWriter::WriteProductHeader() {
    fprintf(f,
        "#175 = SHAPE_DEFINITION_REPRESENTATION(#176, #169);\n"
        "#176 = PRODUCT_DEFINITION_SHAPE('Version', 'Test Part', #177);\n"
        "#177 = PRODUCT_DEFINITION('Version', 'Test Part', #182, #178);\n"
        "#178 = DESIGN_CONTEXT('3D Mechanical Parts', #181, 'design');\n"
        "#179 = PRODUCT('1', 'Product', 'Test Part', (#180));\n"
        "#180 = MECHANICAL_CONTEXT('3D Mechanical Parts', #181, 'mechanical');\n"
        "#181 = APPLICATION_CONTEXT(\n"
        "'configuration controlled 3d designs of mechanical parts and assemblies');\n"
        "#182 = PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE('Version',\n"
        "'Test Part', #179, .MADE.);\n"
        "\n"
        );
}
int StepFileWriter::ExportCurve(SBezier *sb) {
    int i, ret = id;

    fprintf(f, "#%d=(\n", ret);
    fprintf(f, "BOUNDED_CURVE()\n");
    fprintf(f, "B_SPLINE_CURVE(%d,(", sb-&gt;deg);
    for(i = 0; i &lt;= sb-&gt;deg; i++) {
        fprintf(f, "#%d", ret + i + 1);
        if(i != sb-&gt;deg) fprintf(f, ",");
    }
    fprintf(f, "),.UNSPECIFIED.,.F.,.F.)\n");
    fprintf(f, "B_SPLINE_CURVE_WITH_KNOTS((%d,%d),",
        (sb-&gt;deg + 1), (sb-&gt; deg + 1));
    fprintf(f, "(0.000,1.000),.UNSPECIFIED.)\n");
    fprintf(f, "CURVE()\n");
    fprintf(f, "GEOMETRIC_REPRESENTATION_ITEM()\n");
    fprintf(f, "RATIONAL_B_SPLINE_CURVE((");
    for(i = 0; i &lt;= sb-&gt;deg; i++) {
        fprintf(f, "%.10f", sb-&gt;weight[i]);
        if(i != sb-&gt;deg) fprintf(f, ",");
    }
    fprintf(f, "))\n");
    fprintf(f, "REPRESENTATION_ITEM('')\n);\n");

    for(i = 0; i &lt;= sb-&gt;deg; i++) {
        fprintf(f, "#%d=CARTESIAN_POINT('',(%.10f,%.10f,%.10f));\n",
            id + 1 + i,
            CO(sb-&gt;ctrl[i]));
    }
    fprintf(f, "\n");

    id = ret + 1 + (sb-&gt;deg + 1);
    return ret;
}

int StepFileWriter::ExportCurveLoop(SBezierLoop *loop, bool inner) {
    ssassert(loop-&gt;l.n &gt;= 1, "Expected at least one loop");

    List&lt;int&gt; listOfTrims = {};

    SBezier *sb = loop-&gt;l.Last();

    // Generate "exactly closed" contours, with the same vertex id for the
    // finish of a previous edge and the start of the next one. So we need
    // the finish of the last Bezier in the loop before we start our process.
    fprintf(f, "#%d=CARTESIAN_POINT('',(%.10f,%.10f,%.10f));\n",
        id, CO(sb-&gt;Finish()));
    fprintf(f, "#%d=VERTEX_POINT('',#%d);\n", id+1, id);
    int lastFinish = id + 1, prevFinish = lastFinish;
    id += 2;

    for(sb = loop-&gt;l.First(); sb; sb = loop-&gt;l.NextAfter(sb)) {
        int curveId = ExportCurve(sb);

        int thisFinish;
        if(loop-&gt;l.NextAfter(sb) != NULL) {
            fprintf(f, "#%d=CARTESIAN_POINT('',(%.10f,%.10f,%.10f));\n",
                id, CO(sb-&gt;Finish()));
            fprintf(f, "#%d=VERTEX_POINT('',#%d);\n", id+1, id);
            thisFinish = id + 1;
            id += 2;
        } else {
            thisFinish = lastFinish;
        }

        fprintf(f, "#%d=EDGE_CURVE('',#%d,#%d,#%d,%s);\n",
            id, prevFinish, thisFinish, curveId, ".T.");
        fprintf(f, "#%d=ORIENTED_EDGE('',*,*,#%d,.T.);\n",
            id+1, id);

        int oe = id+1;
        listOfTrims.Add(&amp;oe);
        id += 2;

        prevFinish = thisFinish;
    }

    fprintf(f, "#%d=EDGE_LOOP('',(", id);
    int *oe;
    for(oe = listOfTrims.First(); oe; oe = listOfTrims.NextAfter(oe)) {
        fprintf(f, "#%d", *oe);
        if(listOfTrims.NextAfter(oe) != NULL) fprintf(f, ",");
    }
    fprintf(f, "));\n");

    int fb = id + 1;
        fprintf(f, "#%d=%s('',#%d,.T.);\n",
            fb, inner ? "FACE_BOUND" : "FACE_OUTER_BOUND", id);

    id += 2;
    listOfTrims.Clear();

    return fb;
}

void StepFileWriter::ExportSurface(SSurface *ss, SBezierList *sbl) {
    int i, j, srfid = id;

    // First, we create the untrimmed surface. We always specify a rational
    // B-spline surface (in fact, just a Bezier surface).
    fprintf(f, "#%d=(\n", srfid);
    fprintf(f, "BOUNDED_SURFACE()\n");
    fprintf(f, "B_SPLINE_SURFACE(%d,%d,(", ss-&gt;degm, ss-&gt;degn);
    for(i = 0; i &lt;= ss-&gt;degm; i++) {
        fprintf(f, "(");
        for(j = 0; j &lt;= ss-&gt;degn; j++) {
            fprintf(f, "#%d", srfid + 1 + j + i*(ss-&gt;degn + 1));
            if(j != ss-&gt;degn) fprintf(f, ",");
        }
        fprintf(f, ")");
        if(i != ss-&gt;degm) fprintf(f, ",");
    }
    fprintf(f, "),.UNSPECIFIED.,.F.,.F.,.F.)\n");
    fprintf(f, "B_SPLINE_SURFACE_WITH_KNOTS((%d,%d),(%d,%d),",
        (ss-&gt;degm + 1), (ss-&gt;degm + 1),
        (ss-&gt;degn + 1), (ss-&gt;degn + 1));
    fprintf(f, "(0.000,1.000),(0.000,1.000),.UNSPECIFIED.)\n");
    fprintf(f, "GEOMETRIC_REPRESENTATION_ITEM()\n");
    fprintf(f, "RATIONAL_B_SPLINE_SURFACE((");
    for(i = 0; i &lt;= ss-&gt;degm; i++) {
        fprintf(f, "(");
        for(j = 0; j &lt;= ss-&gt;degn; j++) {
            fprintf(f, "%.10f", ss-&gt;weight[i][j]);
            if(j != ss-&gt;degn) fprintf(f, ",");
        }
        fprintf(f, ")");
        if(i != ss-&gt;degm) fprintf(f, ",");
    }
    fprintf(f, "))\n");
    fprintf(f, "REPRESENTATION_ITEM('')\n");
    fprintf(f, "SURFACE()\n");
    fprintf(f, ");\n");

    // The control points for the untrimmed surface.
    for(i = 0; i &lt;= ss-&gt;degm; i++) {
        for(j = 0; j &lt;= ss-&gt;degn; j++) {
            fprintf(f, "#%d=CARTESIAN_POINT('',(%.10f,%.10f,%.10f));\n",
                srfid + 1 + j + i*(ss-&gt;degn + 1),
                CO(ss-&gt;ctrl[i][j]));
        }
    }
    fprintf(f, "\n");

    id = srfid + 1 + (ss-&gt;degm + 1)*(ss-&gt;degn + 1);

    // Now we do the trim curves. We must group each outer loop separately
    // along with its inner faces, so do that now.
    SBezierLoopSetSet sblss = {};
    SPolygon spxyz = {};
    bool allClosed;
    SEdge notClosedAt;
    // We specify a surface, so it doesn't check for coplanarity; and we
    // don't want it to give us any open contours. The polygon and chord
    // tolerance are required, because they are used to calculate the
    // contour directions and determine inner vs. outer contours.
    sblss.FindOuterFacesFrom(sbl, &amp;spxyz, ss,
                             SS.ExportChordTolMm(),
                             &amp;allClosed, &amp;notClosedAt,
                             NULL, NULL,
                             NULL);

    // So in our list of SBezierLoopSet, each set contains at least one loop
    // (the outer boundary), plus any inner loops associated with that outer
    // loop.
    SBezierLoopSet *sbls;
    for(sbls = sblss.l.First(); sbls; sbls = sblss.l.NextAfter(sbls)) {
        SBezierLoop *loop = sbls-&gt;l.First();

        List&lt;int&gt; listOfLoops = {};
        // Create the face outer boundary from the outer loop.
        int fob = ExportCurveLoop(loop, /*inner=*/false);
        listOfLoops.Add(&amp;fob);

        // And create the face inner boundaries from any inner loops that
        // lie within this contour.
        loop = sbls-&gt;l.NextAfter(loop);
        for(; loop; loop = sbls-&gt;l.NextAfter(loop)) {
            int fib = ExportCurveLoop(loop, /*inner=*/true);
            listOfLoops.Add(&amp;fib);
        }

        // And now create the face that corresponds to this outer loop
        // and all of its holes.
        int advFaceId = id;
        fprintf(f, "#%d=ADVANCED_FACE('',(", advFaceId);
        int *fb;
        for(fb = listOfLoops.First(); fb; fb = listOfLoops.NextAfter(fb)) {
            fprintf(f, "#%d", *fb);
            if(listOfLoops.NextAfter(fb) != NULL) fprintf(f, ",");
        }

        fprintf(f, "),#%d,.T.);\n", srfid);
        fprintf(f, "\n");
        advancedFaces.Add(&amp;advFaceId);

        id++;
        listOfLoops.Clear();
    }
    sblss.Clear();
    spxyz.Clear();
</t>
<t tx="leo.20191228122644.140">auto c = std::find_if(SK.constraint.begin(), SK.constraint.end(), [&amp;](Constraint &amp;c) {
    if(c.group != hg)
        return false;

    if(EntityExists(c.workplane) &amp;&amp;
       EntityExists(c.ptA) &amp;&amp;
       EntityExists(c.ptB) &amp;&amp;
       EntityExists(c.entityA) &amp;&amp;
       EntityExists(c.entityB) &amp;&amp;
       EntityExists(c.entityC) &amp;&amp;
       EntityExists(c.entityD)) {
        return false;
    }
    return true;
});

if(c != SK.constraint.end()) {
    (deleted.constraints)++;
    if(c-&gt;type != Constraint::Type::POINTS_COINCIDENT &amp;&amp;
       c-&gt;type != Constraint::Type::HORIZONTAL &amp;&amp;
       c-&gt;type != Constraint::Type::VERTICAL) {
        (deleted.nonTrivialConstraints)++;
    }

    SK.constraint.RemoveById(c-&gt;h);
    return true;
}
return false;
</t>
<t tx="leo.20191228122644.141">void SolveSpaceUI::GenerateAll(Generate type, bool andFindFree, bool genForBBox) {
    int first = 0, last = 0, i;

    uint64_t startMillis = GetMilliseconds(),
             endMillis;

    SK.groupOrder.Clear();
    for(auto &amp;g : SK.group) { SK.groupOrder.Add(&amp;g.h); }
    std::sort(SK.groupOrder.begin(), SK.groupOrder.end(),
        [](const hGroup &amp;ha, const hGroup &amp;hb) {
            return SK.GetGroup(ha)-&gt;order &lt; SK.GetGroup(hb)-&gt;order;
        });

    switch(type) {
        case Generate::DIRTY: {
            first = INT_MAX;
            last  = 0;

            // Start from the first dirty group, and solve until the active group,
            // since all groups after the active group are hidden.
            // Not using range-for because we're tracking the indices.
            for(i = 0; i &lt; SK.groupOrder.n; i++) {
                Group *g = SK.GetGroup(SK.groupOrder[i]);
                if((!g-&gt;clean) || !g-&gt;IsSolvedOkay()) {
                    first = min(first, i);
                }
                if(g-&gt;h == SS.GW.activeGroup) {
                    last = i;
                }
            }
            if(first == INT_MAX || last == 0) {
                // All clean; so just regenerate the entities, and don't solve anything.
                first = -1;
                last  = -1;
            } else {
                SS.nakedEdges.Clear();
            }
            break;
        }

        case Generate::ALL:
            first = 0;
            last  = INT_MAX;
            break;

        case Generate::REGEN:
            first = -1;
            last  = -1;
            break;

        case Generate::UNTIL_ACTIVE: {
            for(i = 0; i &lt; SK.groupOrder.n; i++) {
                if(SK.groupOrder[i] == SS.GW.activeGroup)
                    break;
            }

            first = 0;
            last  = i;
            break;
        }
    }

    // If we're generating entities for display, first we need to find
    // the bounding box to turn relative chord tolerance to absolute.
    if(!SS.exportMode &amp;&amp; !genForBBox) {
        GenerateAll(type, andFindFree, /*genForBBox=*/true);
        BBox box = SK.CalculateEntityBBox(/*includeInvisibles=*/true);
        Vector size = box.maxp.Minus(box.minp);
        double maxSize = std::max({ size.x, size.y, size.z });
        chordTolCalculated = maxSize * chordTol / 100.0;
    }

    // Remove any requests or constraints that refer to a nonexistent
    // group; can check those immediately, since we know what the list
    // of groups should be.
    while(PruneOrphans())
        ;

    // Don't lose our numerical guesses when we regenerate.
    IdList&lt;Param,hParam&gt; prev = {};
    SK.param.MoveSelfInto(&amp;prev);
    SK.param.ReserveMore(prev.n);
    int oldEntityCount = SK.entity.n;
    SK.entity.Clear();
    SK.entity.ReserveMore(oldEntityCount);

    // Not using range-for because we're using the index inside the loop.
    for(i = 0; i &lt; SK.groupOrder.n; i++) {
        Group *g = SK.GetGroup(SK.groupOrder[i]);

        // The group may depend on entities or other groups, to define its
        // workplane geometry or for its operands. Those must already exist
        // in a previous group, so check them before generating.
        if(PruneGroups(g-&gt;h))
            goto pruned;

        for(auto &amp;req : SK.request) {
            Request *r = &amp;req;
            if(r-&gt;group != g-&gt;h) continue;

            r-&gt;Generate(&amp;(SK.entity), &amp;(SK.param));
        }
        for(auto &amp;con : SK.constraint) {
            Constraint *c = &amp;con;
            if(c-&gt;group != g-&gt;h) continue;

            c-&gt;Generate(&amp;(SK.param));
        }
        g-&gt;Generate(&amp;(SK.entity), &amp;(SK.param));

        // The requests and constraints depend on stuff in this or the
        // previous group, so check them after generating.
        if(PruneRequests(g-&gt;h) || PruneConstraints(g-&gt;h))
            goto pruned;

        // Use the previous values for params that we've seen before, as
        // initial guesses for the solver.
        for(auto &amp;p : SK.param) {
            Param *newp = &amp;p;
            if(newp-&gt;known) continue;

            Param *prevp = prev.FindByIdNoOops(newp-&gt;h);
            if(prevp) {
                newp-&gt;val = prevp-&gt;val;
                newp-&gt;free = prevp-&gt;free;
            }
        }

        if(g-&gt;h == Group::HGROUP_REFERENCES) {
            ForceReferences();
            g-&gt;solved.how = SolveResult::OKAY;
            g-&gt;clean = true;
        } else {
            // this i is an index in groupOrder
            if(i &gt;= first &amp;&amp; i &lt;= last) {
                // The group falls inside the range, so really solve it,
                // and then regenerate the mesh based on the solved stuff.
                if(genForBBox) {
                    SolveGroupAndReport(g-&gt;h, andFindFree);
                    g-&gt;GenerateLoops();
                } else {
                    g-&gt;GenerateShellAndMesh();
                    g-&gt;clean = true;
                }
            } else {
                // The group falls outside the range, so just assume that
                // it's good wherever we left it. The mesh is unchanged,
                // and the parameters must be marked as known.
                for(auto &amp;p : SK.param) {
                    Param *newp = &amp;p;

                    Param *prevp = prev.FindByIdNoOops(newp-&gt;h);
                    if(prevp) newp-&gt;known = true;
                }
            }
        }
    }

    // And update any reference dimensions with their new values
    for(auto &amp;con : SK.constraint) {
        Constraint *c = &amp;con;
        if(c-&gt;reference) {
            c-&gt;ModifyToSatisfy();
        }
    }

    // Make sure the point that we're tracing exists.
    if(traced.point.v &amp;&amp; !SK.entity.FindByIdNoOops(traced.point)) {
        traced.point = Entity::NO_ENTITY;
    }
    // And if we're tracing a point, add its new value to the path
    if(traced.point.v) {
        Entity *pt = SK.GetEntity(traced.point);
        traced.path.AddPoint(pt-&gt;PointGetNum());
    }

    prev.Clear();
    GW.Invalidate();

    // Remove nonexistent selection items, for same reason we waited till
    // the end to put up a dialog box.
    GW.ClearNonexistentSelectionItems();

    if(deleted.requests &gt; 0 || deleted.constraints &gt; 0 || deleted.groups &gt; 0) {
        // All sorts of interesting things could have happened; for example,
        // the active group or active workplane could have been deleted. So
        // clear all that out.
        if(deleted.groups &gt; 0) {
            SS.TW.ClearSuper();
        }
        ScheduleShowTW();
        GW.ClearSuper();

        // People get annoyed if I complain whenever they delete any request,
        // and I otherwise will, since those always come with pt-coincident
        // constraints.
        if(deleted.requests &gt; 0 || deleted.nonTrivialConstraints &gt; 0 ||
           deleted.groups &gt; 0)
        {
            // Don't display any errors until we've regenerated fully. The
            // sketch is not necessarily in a consistent state until we've
            // pruned any orphaned etc. objects, and the message loop for the
            // messagebox could allow us to repaint and crash. But now we must
            // be fine.
            Message("Additional sketch elements were deleted, because they "
                    "depend on the element that was just deleted explicitly. "
                    "These include: \n"
                    "     %d request%s\n"
                    "     %d constraint%s\n"
                    "     %d group%s"
                    "%s",
                       deleted.requests, deleted.requests == 1 ? "" : "s",
                       deleted.constraints, deleted.constraints == 1 ? "" : "s",
                       deleted.groups, deleted.groups == 1 ? "" : "s",
                       undo.cnt &gt; 0 ? "\n\nChoose Edit -&gt; Undo to undelete all elements." : "");
        }

        deleted = {};
    }

    FreeAllTemporary();
    allConsistent = true;
    SS.GW.persistentDirty = true;
    SS.centerOfMass.dirty = true;

    endMillis = GetMilliseconds();

    if(endMillis - startMillis &gt; 30) {
        const char *typeStr = "";
        switch(type) {
            case Generate::DIRTY:           typeStr = "DIRTY";        break;
            case Generate::ALL:             typeStr = "ALL";          break;
            case Generate::REGEN:           typeStr = "REGEN";        break;
            case Generate::UNTIL_ACTIVE:    typeStr = "UNTIL_ACTIVE"; break;
        }
        if(endMillis)
        dbp("Generate::%s%s took %lld ms",
            typeStr,
            (genForBBox ? " (for bounding box)" : ""),
            GetMilliseconds() - startMillis);
    }

    return;

pruned:
    // Restore the numerical guesses
    SK.param.Clear();
    prev.MoveSelfInto(&amp;(SK.param));
    // Try again
    GenerateAll(type, andFindFree, genForBBox);
}

</t>
<t tx="leo.20191228122644.142">void SolveSpaceUI::ForceReferences() {
    // Force the values of the parameters that define the three reference
    // coordinate systems.
    @others
}

</t>
<t tx="leo.20191228122644.143">static const struct {
    hRequest    hr;
    Quaternion  q;
} Quat[] = {
    { Request::HREQUEST_REFERENCE_XY, { 1,    0,    0,    0,   } },
    { Request::HREQUEST_REFERENCE_YZ, { 0.5,  0.5,  0.5,  0.5, } },
    { Request::HREQUEST_REFERENCE_ZX, { 0.5, -0.5, -0.5, -0.5, } },
};
for(int i = 0; i &lt; 3; i++) {
    hRequest hr = Quat[i].hr;
    Entity *wrkpl = SK.GetEntity(hr.entity(0));
    // The origin for our coordinate system, always zero
    Entity *origin = SK.GetEntity(wrkpl-&gt;point[0]);
    origin-&gt;PointForceTo(Vector::From(0, 0, 0));
    origin-&gt;construction = true;
    SK.GetParam(origin-&gt;param[0])-&gt;known = true;
    SK.GetParam(origin-&gt;param[1])-&gt;known = true;
    SK.GetParam(origin-&gt;param[2])-&gt;known = true;
    // The quaternion that defines the rotation, from the table.
    Entity *normal = SK.GetEntity(wrkpl-&gt;normal);
    normal-&gt;NormalForceTo(Quat[i].q);
    SK.GetParam(normal-&gt;param[0])-&gt;known = true;
    SK.GetParam(normal-&gt;param[1])-&gt;known = true;
    SK.GetParam(normal-&gt;param[2])-&gt;known = true;
    SK.GetParam(normal-&gt;param[3])-&gt;known = true;
}
</t>
<t tx="leo.20191228122644.144">void SolveSpaceUI::UpdateCenterOfMass() {
    SMesh *m = &amp;(SK.GetGroup(SS.GW.activeGroup)-&gt;displayMesh);
    SS.centerOfMass.position = m-&gt;GetCenterOfMass();
    SS.centerOfMass.dirty = false;
}

</t>
<t tx="leo.20191228122644.145">void SolveSpaceUI::MarkDraggedParams() {
    sys.dragged.Clear();

    for(int i = -1; i &lt; SS.GW.pending.points.n; i++) {
        hEntity hp;
        if(i == -1) {
            hp = SS.GW.pending.point;
        } else {
            hp = SS.GW.pending.points[i];
        }
        if(!hp.v) continue;

        // The pending point could be one in a group that has not yet
        // been processed, in which case the lookup will fail; but
        // that's not an error.
        Entity *pt = SK.entity.FindByIdNoOops(hp);
        if(pt) {
            switch(pt-&gt;type) {
                case Entity::Type::POINT_N_TRANS:
                case Entity::Type::POINT_IN_3D:
                case Entity::Type::POINT_N_ROT_AXIS_TRANS:
                    sys.dragged.Add(&amp;(pt-&gt;param[0]));
                    sys.dragged.Add(&amp;(pt-&gt;param[1]));
                    sys.dragged.Add(&amp;(pt-&gt;param[2]));
                    break;

                case Entity::Type::POINT_IN_2D:
                    sys.dragged.Add(&amp;(pt-&gt;param[0]));
                    sys.dragged.Add(&amp;(pt-&gt;param[1]));
                    break;

                default: // Only the entities above can be dragged.
                    break;
            }
        }
    }
    if(SS.GW.pending.circle.v) {
        Entity *circ = SK.entity.FindByIdNoOops(SS.GW.pending.circle);
        if(circ) {
            Entity *dist = SK.GetEntity(circ-&gt;distance);
            switch(dist-&gt;type) {
                case Entity::Type::DISTANCE:
                    sys.dragged.Add(&amp;(dist-&gt;param[0]));
                    break;

                default: // Only the entities above can be dragged.
                    break;
            }
        }
    }
    if(SS.GW.pending.normal.v) {
        Entity *norm = SK.entity.FindByIdNoOops(SS.GW.pending.normal);
        if(norm) {
            switch(norm-&gt;type) {
                case Entity::Type::NORMAL_IN_3D:
                    sys.dragged.Add(&amp;(norm-&gt;param[0]));
                    sys.dragged.Add(&amp;(norm-&gt;param[1]));
                    sys.dragged.Add(&amp;(norm-&gt;param[2]));
                    sys.dragged.Add(&amp;(norm-&gt;param[3]));
                    break;

                default: // Only the entities above can be dragged.
                    break;
            }
        }
    }
}

</t>
<t tx="leo.20191228122644.146">void SolveSpaceUI::SolveGroupAndReport(hGroup hg, bool andFindFree) {
    SolveGroup(hg, andFindFree);

    Group *g = SK.GetGroup(hg);
    @others
}

</t>
<t tx="leo.20191228122644.147">bool isOkay = g-&gt;solved.how == SolveResult::OKAY ||
              (g-&gt;allowRedundant &amp;&amp; g-&gt;solved.how == SolveResult::REDUNDANT_OKAY);
if(!isOkay || (isOkay &amp;&amp; !g-&gt;IsSolvedOkay())) {
    TextWindow::ReportHowGroupSolved(g-&gt;h);
}
</t>
<t tx="leo.20191228122644.148">void SolveSpaceUI::WriteEqSystemForGroup(hGroup hg) {
    // Clear out the system to be solved.
    sys.entity.Clear();
    sys.param.Clear();
    sys.eq.Clear();
    // And generate all the params for requests in this group
    for(auto &amp;req : SK.request) {
        Request *r = &amp;req;
        if(r-&gt;group != hg) continue;

        r-&gt;Generate(&amp;(sys.entity), &amp;(sys.param));
    }
    for(auto &amp;con : SK.constraint) {
        Constraint *c = &amp;con;
        if(c-&gt;group != hg) continue;

        c-&gt;Generate(&amp;(sys.param));
    }
    // And for the group itself
    Group *g = SK.GetGroup(hg);
    g-&gt;Generate(&amp;(sys.entity), &amp;(sys.param));
    // Set the initial guesses for all the params
    for(auto &amp;param : sys.param) {
        Param *p = &amp;param;
        p-&gt;known = false;
        p-&gt;val = SK.GetParam(p-&gt;h)-&gt;val;
    }

    MarkDraggedParams();
}

</t>
<t tx="leo.20191228122644.149">void SolveSpaceUI::SolveGroup(hGroup hg, bool andFindFree) {
    WriteEqSystemForGroup(hg);
    Group *g = SK.GetGroup(hg);
    g-&gt;solved.remove.Clear();
    SolveResult how = sys.Solve(g, NULL,
                                   &amp;(g-&gt;solved.dof),
                                   &amp;(g-&gt;solved.remove),
                                   /*andFindBad=*/!g-&gt;allowRedundant,
                                   /*andFindFree=*/andFindFree,
                                   /*forceDofCheck=*/!g-&gt;dofCheckOk);
    if(how == SolveResult::OKAY) {
        g-&gt;dofCheckOk = true;
    }
    g-&gt;solved.how = how;
    FreeAllTemporary();
}

SolveResult SolveSpaceUI::TestRankForGroup(hGroup hg, int *rank) {
    WriteEqSystemForGroup(hg);
    Group *g = SK.GetGroup(hg);
    SolveResult result = sys.SolveRank(g, rank);
    FreeAllTemporary();
    return result;
}

</t>
<t tx="leo.20191228122644.15">void StepFileWriter::WriteFooter() {
    fprintf(f,
"\n"
"ENDSEC;\n"
"\n"
"END-ISO-10303-21;\n"
        );
}

</t>
<t tx="leo.20191228122644.150">bool SolveSpaceUI::ActiveGroupsOkay() {
    for(int i = 0; i &lt; SK.groupOrder.n; i++) {
        Group *g = SK.GetGroup(SK.groupOrder[i]);
        if(!g-&gt;IsSolvedOkay())
            return false;
        if(g-&gt;h == SS.GW.activeGroup)
            break;
    }
    return true;
}

</t>
<t tx="leo.20191228122644.16">void StepFileWriter::ExportSurfacesTo(const Platform::Path &amp;filename) {
    Group *g = SK.GetGroup(SS.GW.activeGroup);
    SShell *shell = &amp;(g-&gt;runningShell);

    if(shell-&gt;surface.IsEmpty()) {
        Error("The model does not contain any surfaces to export.%s",
              !g-&gt;runningMesh.l.IsEmpty()
                  ? "\n\nThe model does contain triangles from a mesh, but "
                    "a triangle mesh cannot be exported as a STEP file. Try "
                    "File -&gt; Export Mesh... instead."
                  : "");
        return;
    }

    f = OpenFile(filename, "wb");
    if(!f) {
        Error("Couldn't write to '%s'", filename.raw.c_str());
        return;
    }

    WriteHeader();
    WriteProductHeader();

    advancedFaces = {};

    SSurface *ss;
    for(ss = shell-&gt;surface.First(); ss; ss = shell-&gt;surface.NextAfter(ss)) {
        if(ss-&gt;trim.IsEmpty())
            continue;

        // Get all of the loops of Beziers that trim our surface (with each
        // Bezier split so that we use the section as t goes from 0 to 1), and
        // the piecewise linearization of those loops in xyz space.
        SBezierList sbl = {};
        ss-&gt;MakeSectionEdgesInto(shell, NULL, &amp;sbl);

        // Apply the export scale factor.
        ss-&gt;ScaleSelfBy(1.0/SS.exportScale);
        sbl.ScaleSelfBy(1.0/SS.exportScale);

        ExportSurface(ss, &amp;sbl);

        sbl.Clear();
    }

    fprintf(f, "#%d=CLOSED_SHELL('',(", id);
    int *af;
    for(af = advancedFaces.First(); af; af = advancedFaces.NextAfter(af)) {
        fprintf(f, "#%d", *af);
        if(advancedFaces.NextAfter(af) != NULL) fprintf(f, ",");
    }
    fprintf(f, "));\n");
    fprintf(f, "#%d=MANIFOLD_SOLID_BREP('brep',#%d);\n", id+1, id);
    fprintf(f, "#%d=ADVANCED_BREP_SHAPE_REPRESENTATION('',(#%d,#170),#168);\n",
        id+2, id+1);
    fprintf(f, "#%d=SHAPE_REPRESENTATION_RELATIONSHIP($,$,#169,#%d);\n",
        id+3, id+2);

    WriteFooter();

    fclose(f);
    advancedFaces.Clear();
}

</t>
<t tx="leo.20191228122644.17">void StepFileWriter::WriteWireframe() {
    fprintf(f, "#%d=GEOMETRIC_CURVE_SET('curves',(", id);
    int *c;
    for(c = curves.First(); c; c = curves.NextAfter(c)) {
        fprintf(f, "#%d", *c);
        if(curves.NextAfter(c) != NULL) fprintf(f, ",");
    }
    fprintf(f, "));\n");
    fprintf(f, "#%d=GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION"
                    "('',(#%d,#170),#168);\n", id+1, id);
    fprintf(f, "#%d=SHAPE_REPRESENTATION_RELATIONSHIP($,$,#169,#%d);\n",
        id+2, id+1);

    id += 3;
    curves.Clear();
}

</t>
<t tx="leo.20191228122644.18">@path ./src/
//-----------------------------------------------------------------------------
// The file format-specific stuff for all of the 2d vector output formats.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include &lt;libdxfrw.h&gt;
#include "solvespace.h"

//-----------------------------------------------------------------------------
// Routines for DXF export
//-----------------------------------------------------------------------------
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122644.19">class DxfWriteInterface : public DRW_Interface {
public:
    DxfFileWriter *writer;
    dxfRW         *dxf;

    std::set&lt;std::string&gt; messages;

    @others
};

</t>
<t tx="leo.20191228122644.2">void VectorFileWriter::OutputLinesAndMesh(SBezierLoopSetSet *sblss, SMesh *sm) {
    STriangle *tr;
    SBezier *b;

    // First calculate the bounding box.
    ptMin = Vector::From(VERY_POSITIVE, VERY_POSITIVE, VERY_POSITIVE);
    ptMax = Vector::From(VERY_NEGATIVE, VERY_NEGATIVE, VERY_NEGATIVE);
    if(sm) {
        for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
            (tr-&gt;a).MakeMaxMin(&amp;ptMax, &amp;ptMin);
            (tr-&gt;b).MakeMaxMin(&amp;ptMax, &amp;ptMin);
            (tr-&gt;c).MakeMaxMin(&amp;ptMax, &amp;ptMin);
        }
    }
    if(sblss) {
        SBezierLoopSet *sbls;
        for(sbls = sblss-&gt;l.First(); sbls; sbls = sblss-&gt;l.NextAfter(sbls)) {
            SBezierLoop *sbl;
            for(sbl = sbls-&gt;l.First(); sbl; sbl = sbls-&gt;l.NextAfter(sbl)) {
                for(b = sbl-&gt;l.First(); b; b = sbl-&gt;l.NextAfter(b)) {
                    for(int i = 0; i &lt;= b-&gt;deg; i++) {
                        (b-&gt;ctrl[i]).MakeMaxMin(&amp;ptMax, &amp;ptMin);
                    }
                }
            }
        }
    }

    // And now we compute the canvas size.
    double s = 1.0 / SS.exportScale;
    if(SS.exportCanvasSizeAuto) {
        // It's based on the calculated bounding box; we grow it along each
        // boundary by the specified amount.
        ptMin.x -= s*SS.exportMargin.left;
        ptMax.x += s*SS.exportMargin.right;
        ptMin.y -= s*SS.exportMargin.bottom;
        ptMax.y += s*SS.exportMargin.top;
    } else {
        ptMin.x = -(s*SS.exportCanvas.dx);
        ptMin.y = -(s*SS.exportCanvas.dy);
        ptMax.x = ptMin.x + (s*SS.exportCanvas.width);
        ptMax.y = ptMin.y + (s*SS.exportCanvas.height);
    }

    StartFile();
    if(sm &amp;&amp; SS.exportShadedTriangles) {
        for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
            Triangle(tr);
        }
    }
    if(sblss) {
        SBezierLoopSet *sbls;
        for(sbls = sblss-&gt;l.First(); sbls; sbls = sblss-&gt;l.NextAfter(sbls)) {
            SBezierLoop *sbl;
            sbl = sbls-&gt;l.First();
            if(!sbl) continue;
            b = sbl-&gt;l.First();
            if(!b || !Style::Exportable(b-&gt;auxA)) continue;

            hStyle hs = { (uint32_t)b-&gt;auxA };
            Style *stl = Style::Get(hs);
            double lineWidth   = Style::WidthMm(b-&gt;auxA)*s;
            RgbaColor strokeRgb = Style::Color(hs, /*forExport=*/true);
            RgbaColor fillRgb   = Style::FillColor(hs, /*forExport=*/true);

            StartPath(strokeRgb, lineWidth, stl-&gt;filled, fillRgb, hs);
            for(sbl = sbls-&gt;l.First(); sbl; sbl = sbls-&gt;l.NextAfter(sbl)) {
                for(b = sbl-&gt;l.First(); b; b = sbl-&gt;l.NextAfter(b)) {
                    Bezier(b);
                }
            }
            FinishPath(strokeRgb, lineWidth, stl-&gt;filled, fillRgb, hs);
        }
    }
    FinishAndCloseFile();
}

</t>
<t tx="leo.20191228122644.20">static DRW_Coord toCoord(const Vector &amp;v) {
    return DRW_Coord(v.x, v.y, v.z);
}

Vector xfrm(Vector v) {
    return writer-&gt;Transform(v);
}

</t>
<t tx="leo.20191228122644.21">void writeTextstyles() override {
    DRW_Textstyle ts;
    ts.name = "unicode";
    ts.font = "unicode";
    dxf-&gt;writeTextstyle(&amp;ts);
}

</t>
<t tx="leo.20191228122644.22">void writeLayers() override {
    DRW_Layer layer;

    layer.name = "dimensions";
    dxf-&gt;writeLayer(&amp;layer);
    layer.name = "text";
    dxf-&gt;writeLayer(&amp;layer);

    std::set&lt;uint32_t&gt; usedStyles;

    for(DxfFileWriter::BezierPath &amp;path : writer-&gt;paths) {
        for(SBezier *sb : path.beziers) {
            usedStyles.insert((uint32_t)sb-&gt;auxA);
        }
    }

    for(uint32_t v : usedStyles) {
        Style *s = Style::Get(hStyle{v});
        layer.name = s-&gt;DescriptionString();
        dxf-&gt;writeLayer(&amp;layer);
    }
}

</t>
<t tx="leo.20191228122644.23">void writeLTypes() override {
    for(uint32_t i = 0; i &lt;= (uint32_t)StipplePattern::LAST; i++) {
        StipplePattern st = (StipplePattern)i;
        DRW_LType type;
        // LibreCAD requires the line type to have one of these exact names,
        // or otherwise it overwrites it with its own (continuous) style.
        type.name = DxfFileWriter::lineTypeName(st);
        double sw = 1.0;
        switch(st) {
            case StipplePattern::CONTINUOUS:
                break;

            case StipplePattern::SHORT_DASH:
                type.path.push_back(sw);
                type.path.push_back(-sw * 2.0);
                break;

            case StipplePattern::DASH:
                type.path.push_back(sw);
                type.path.push_back(-sw);
                break;

            case StipplePattern::LONG_DASH:
                type.path.push_back(sw * 2.0);
                type.path.push_back(-sw);
                break;

            case StipplePattern::DASH_DOT:
                type.path.push_back(sw);
                type.path.push_back(-sw);
                type.path.push_back(0.0);
                type.path.push_back(-sw);
                break;

            case StipplePattern::DOT:
                type.path.push_back(sw);
                type.path.push_back(0.0);
                break;

            case StipplePattern::DASH_DOT_DOT:
                type.path.push_back(sw);
                type.path.push_back(-sw);
                type.path.push_back(0.0);
                type.path.push_back(-sw);
                type.path.push_back(0.0);
                type.path.push_back(-sw);
                break;

            case StipplePattern::FREEHAND:
            case StipplePattern::ZIGZAG:
                // Not implemented; exported as continuous.
                break;
        }
        dxf-&gt;writeLineType(&amp;type);
    }
}

</t>
<t tx="leo.20191228122644.24">void writePolylines() {
    PolylineBuilder builder;

    for(DxfFileWriter::BezierPath &amp;path : writer-&gt;paths) {
        for(SBezier *sb : path.beziers) {
            if(sb-&gt;deg != 1) continue;
            builder.AddEdge(sb-&gt;ctrl[0], sb-&gt;ctrl[1], (uint32_t)sb-&gt;auxA);
        }
    }

    DRW_Polyline polyline;

    @others
}

</t>
<t tx="leo.20191228122644.25">auto startFunc = [&amp;](PolylineBuilder::Vertex *start,
                     PolylineBuilder::Vertex *next,
                     PolylineBuilder::Edge *e) {
    hStyle hs = { e-&gt;kind };
    polyline = {};
    assignEntityDefaults(&amp;polyline, hs);

    if(!(EXACT(start-&gt;pos.z == 0.0) &amp;&amp; EXACT(next-&gt;pos.z == 0.0))) {
        polyline.flags |= 8 /* 3d polyline */;
    }
    polyline.vertlist.push_back(
        new DRW_Vertex(start-&gt;pos.x, start-&gt;pos.y, start-&gt;pos.z, 0.0));
    polyline.vertlist.push_back(
        new DRW_Vertex(next-&gt;pos.x, next-&gt;pos.y, next-&gt;pos.z, 0.0));
};

</t>
<t tx="leo.20191228122644.26">auto nextFunc = [&amp;](PolylineBuilder::Vertex *next, PolylineBuilder::Edge *e) {
    if(!EXACT(next-&gt;pos.z == 0.0)) {
        polyline.flags |= 8 /* 3d polyline */;
    }
    polyline.vertlist.push_back(
        new DRW_Vertex(next-&gt;pos.x, next-&gt;pos.y, next-&gt;pos.z, 0.0));
};

</t>
<t tx="leo.20191228122644.27">auto endFunc = [&amp;]() {
    dxf-&gt;writePolyline(&amp;polyline);
};

</t>
<t tx="leo.20191228122644.28">auto aloneFunc = [&amp;](PolylineBuilder::Edge *e) {
    hStyle hs = { e-&gt;kind };
    writeLine(e-&gt;a-&gt;pos, e-&gt;b-&gt;pos, hs);
};

builder.Generate(startFunc, nextFunc, aloneFunc, endFunc);
</t>
<t tx="leo.20191228122644.29">void writeEntities() override {
    writePolylines();

    for(DxfFileWriter::BezierPath &amp;path : writer-&gt;paths) {
        for(SBezier *sb : path.beziers) {
            if(sb-&gt;deg == 1) continue;
            writeBezier(sb);
        }
    }

    if(writer-&gt;constraint) {
        Constraint *c;
        for(c = writer-&gt;constraint-&gt;First(); c; c = writer-&gt;constraint-&gt;NextAfter(c)) {
            if(!writer-&gt;NeedToOutput(c)) continue;
            switch(c-&gt;type) {
                case Constraint::Type::PT_PT_DISTANCE: {
                    Vector ap = SK.GetEntity(c-&gt;ptA)-&gt;PointGetNum();
                    Vector bp = SK.GetEntity(c-&gt;ptB)-&gt;PointGetNum();
                    Vector ref = ((ap.Plus(bp)).ScaledBy(0.5)).Plus(c-&gt;disp.offset);
                    writeAlignedDimension(xfrm(ap),  xfrm(bp), xfrm(ref),
                                          xfrm(ref), c-&gt;Label(), c-&gt;GetStyle(), c-&gt;valA);
                    break;
                }

                case Constraint::Type::PT_LINE_DISTANCE: {
                    Vector pt = SK.GetEntity(c-&gt;ptA)-&gt;PointGetNum();
                    Entity *line = SK.GetEntity(c-&gt;entityA);
                    Vector lA = SK.GetEntity(line-&gt;point[0])-&gt;PointGetNum();
                    Vector lB = SK.GetEntity(line-&gt;point[1])-&gt;PointGetNum();
                    Vector dl = lB.Minus(lA);

                    Vector closest = pt.ClosestPointOnLine(lA, dl);

                    if(pt.Equals(closest)) break;

                    Vector ref = ((closest.Plus(pt)).ScaledBy(0.5)).Plus(c-&gt;disp.offset);
                    Vector refClosest = ref.ClosestPointOnLine(lA, dl);

                    double ddl = dl.Dot(dl);
                    if(fabs(ddl) &gt; LENGTH_EPS * LENGTH_EPS) {
                        double t = refClosest.Minus(lA).Dot(dl) / ddl;
                        if(t &lt; 0.0) {
                            refClosest = lA;
                        } else if(t &gt; 1.0) {
                            refClosest = lB;
                        }
                    }

                    Vector xdl = xfrm(lB).Minus(xfrm(lA));
                    writeLinearDimension(xfrm(pt), xfrm(refClosest), xfrm(ref),
                                         xfrm(ref), c-&gt;Label(),
                                         atan2(xdl.y, xdl.x) / PI * 180.0 + 90.0, 0.0,
                                         c-&gt;GetStyle(), c-&gt;valA);
                    break;
                }

                case Constraint::Type::DIAMETER: {
                    Entity *circle = SK.GetEntity(c-&gt;entityA);
                    Vector center = SK.GetEntity(circle-&gt;point[0])-&gt;PointGetNum();
                    Quaternion q = SK.GetEntity(circle-&gt;normal)-&gt;NormalGetNum();
                    Vector n = q.RotationN().WithMagnitude(1);
                    double r = circle-&gt;CircleGetRadiusNum();

                    Vector ref = center.Plus(c-&gt;disp.offset);
                    // Force the label into the same plane as the circle.
                    ref = ref.Minus(n.ScaledBy(n.Dot(ref) - n.Dot(center)));

                    Vector rad = ref.Minus(center).WithMagnitude(r);
                    if(/*isRadius*/c-&gt;other) {
                        writeRadialDimension(
                            xfrm(center), xfrm(center.Plus(rad)),
                            xfrm(ref), c-&gt;Label(), c-&gt;GetStyle(), c-&gt;valA);
                    } else {
                        writeDiametricDimension(
                            xfrm(center.Minus(rad)), xfrm(center.Plus(rad)),
                            xfrm(ref), c-&gt;Label(), c-&gt;GetStyle(), c-&gt;valA);
                    }
                    break;
                }

                case Constraint::Type::ANGLE: {
                    Entity *a = SK.GetEntity(c-&gt;entityA);
                    Entity *b = SK.GetEntity(c-&gt;entityB);

                    Vector a0 = a-&gt;VectorGetStartPoint();
                    Vector b0 = b-&gt;VectorGetStartPoint();
                    Vector da = a-&gt;VectorGetNum();
                    Vector db = b-&gt;VectorGetNum();
                    if(/*otherAngle*/c-&gt;other) {
                        a0 = a0.Plus(da);
                        da = da.ScaledBy(-1);
                    }

                    bool skew = false;
                    Vector ref = c-&gt;disp.offset;
                    Vector pi = Vector::AtIntersectionOfLines(a0, a0.Plus(da), b0, b0.Plus(db),
                                                              &amp;skew);
                    if(!skew) ref = pi.Plus(c-&gt;disp.offset);

                    Vector norm = da.Cross(db);
                    Vector dna = norm.Cross(da).WithMagnitude(1.0);

                    double thetaf = acos(da.DirectionCosineWith(db));

                    // Calculate median
                    Vector m = da.WithMagnitude(1.0).ScaledBy(cos(thetaf/2)).Plus(
                               dna.ScaledBy(sin(thetaf/2)));
                    Vector rm = ref.Minus(pi);

                    // Test which side we have to place an arc
                    if(m.Dot(rm) &lt; 0) {
                        da = da.ScaledBy(-1); dna = dna.ScaledBy(-1);
                        db = db.ScaledBy(-1);
                    }

                    Vector bisect = da.WithMagnitude(1.0).ScaledBy(cos(thetaf / 2.0)).Plus(
                                    dna.ScaledBy(sin(thetaf / 2.0)));

                    ref = pi.Plus(bisect.WithMagnitude(c-&gt;disp.offset.Magnitude()));

                    // Get lines again to write exact line.
                    a0 = a-&gt;VectorGetStartPoint();
                    b0 = b-&gt;VectorGetStartPoint();
                    da = a-&gt;VectorGetNum();
                    db = b-&gt;VectorGetNum();

                    writeAngularDimension(
                        xfrm(a0), xfrm(a0.Plus(da)), xfrm(b0), xfrm(b0.Plus(db)), xfrm(ref),
                        xfrm(ref), c-&gt;Label(), c-&gt;GetStyle(), c-&gt;valA);
                    break;
                }

                case Constraint::Type::COMMENT: {
                    Style *st = SK.style.FindById(c-&gt;GetStyle());
                    writeText(xfrm(c-&gt;disp.offset), c-&gt;Label(),
                              Style::TextHeight(c-&gt;GetStyle()) / SS.GW.scale,
                              st-&gt;textAngle, st-&gt;textOrigin, c-&gt;GetStyle());
                    break;
                }

                default:
                    // Other types of constraints do not have a DXF dimension equivalent.
                    break;
            }
        }
    }
}

</t>
<t tx="leo.20191228122644.3">void VectorFileWriter::BezierAsPwl(SBezier *sb) {
    List&lt;Vector&gt; lv = {};
    sb-&gt;MakePwlInto(&amp;lv, SS.ExportChordTolMm());

    for(int i = 1; i &lt; lv.n; i++) {
        SBezier sb = SBezier::From(lv[i-1], lv[i]);
        Bezier(&amp;sb);
    }
    lv.Clear();
}

</t>
<t tx="leo.20191228122644.30">int findDxfColor(const RgbaColor &amp;src) {
    int best = 0;
    double minDist = VERY_POSITIVE;
    Vector srcv = Vector::From(src.redF(), src.greenF(), src.blueF());
    for(int i = 1; i &lt; 256; i++) {
        RgbaColor dst = RGBi(DRW::dxfColors[i][0], DRW::dxfColors[i][1], DRW::dxfColors[i][2]);
        Vector dstv = Vector::From(dst.redF(), dst.greenF(), dst.blueF());
        double dist = srcv.Minus(dstv).Magnitude();
        if(dist &lt; minDist || best == 0) {
            best = i;
            minDist = dist;
        }
    }
    return best;
}

</t>
<t tx="leo.20191228122644.31">void assignEntityDefaults(DRW_Entity *entity, hStyle hs) {
    Style *s = Style::Get(hs);
    RgbaColor color = Style::Color(hs, /*forExport=*/true);
    entity-&gt;color24 = color.ToPackedIntBGRA();
    entity-&gt;color = findDxfColor(color);
    entity-&gt;layer = s-&gt;DescriptionString();
    entity-&gt;lineType = DxfFileWriter::lineTypeName(s-&gt;stippleType);
    entity-&gt;ltypeScale = Style::StippleScaleMm(s-&gt;h);
    entity-&gt;setWidthMm(Style::WidthMm(hs.v));

    if(s-&gt;stippleType == StipplePattern::FREEHAND) {
        messages.insert(_("freehand lines were replaced with continuous lines"));
    } else if(s-&gt;stippleType == StipplePattern::ZIGZAG) {
        messages.insert(_("zigzag lines were replaced with continuous lines"));
    }
}

</t>
<t tx="leo.20191228122644.32">void assignDimensionDefaults(DRW_Dimension *dimension, hStyle hs) {
    assignEntityDefaults(dimension, hs);
    dimension-&gt;layer = "dimensions";
}

</t>
<t tx="leo.20191228122644.33">void writeLine(const Vector &amp;p0, const Vector &amp;p1, hStyle hs) {
    DRW_Line line;
    assignEntityDefaults(&amp;line, hs);
    line.basePoint = toCoord(p0);
    line.secPoint = toCoord(p1);
    dxf-&gt;writeLine(&amp;line);
}

</t>
<t tx="leo.20191228122644.34">void writeArc(const Vector &amp;c, double r, double sa, double ea, hStyle hs) {
    DRW_Arc arc;
    assignEntityDefaults(&amp;arc, hs);
    arc.radious = r;
    arc.basePoint = toCoord(c);
    arc.staangle = sa;
    arc.endangle = ea;
    dxf-&gt;writeArc(&amp;arc);
}

</t>
<t tx="leo.20191228122644.35">void writeBezierAsPwl(SBezier *sb) {
    List&lt;Vector&gt; lv = {};
    sb-&gt;MakePwlInto(&amp;lv, SS.ExportChordTolMm());
    hStyle hs = { (uint32_t)sb-&gt;auxA };
    DRW_Polyline polyline;
    assignEntityDefaults(&amp;polyline, hs);
    for(int i = 0; i &lt; lv.n; i++) {
        Vector *v = &amp;lv[i];
        DRW_Vertex *vertex = new DRW_Vertex(v-&gt;x, v-&gt;y, v-&gt;z, 0.0);
        polyline.vertlist.push_back(vertex);
    }
    dxf-&gt;writePolyline(&amp;polyline);
    lv.Clear();
}

</t>
<t tx="leo.20191228122644.36">void makeKnotsFor(DRW_Spline *spline) {
    // QCad/LibreCAD require this for some reason.
    if(spline-&gt;degree == 3) {
        spline-&gt;nknots = 8;
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(1.0);
        spline-&gt;knotslist.push_back(1.0);
        spline-&gt;knotslist.push_back(1.0);
        spline-&gt;knotslist.push_back(1.0);
    } else if(spline-&gt;degree == 2) {
        spline-&gt;nknots = 6;
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(0.0);
        spline-&gt;knotslist.push_back(1.0);
        spline-&gt;knotslist.push_back(1.0);
        spline-&gt;knotslist.push_back(1.0);
    } else ssassert(false, "Unexpected degree of spline");
}

</t>
<t tx="leo.20191228122644.37">void writeSpline(SBezier *sb) {
    bool isRational = sb-&gt;IsRational();
    hStyle hs = { (uint32_t)sb-&gt;auxA };
    DRW_Spline spline;
    assignEntityDefaults(&amp;spline, hs);
    spline.flags = (isRational) ? 0x04 : 0x08;
    spline.degree = sb-&gt;deg;
    spline.ncontrol = sb-&gt;deg + 1;
    makeKnotsFor(&amp;spline);
    for(int i = 0; i &lt;= sb-&gt;deg; i++) {
        spline.controllist.push_back(
            new DRW_Coord(sb-&gt;ctrl[i].x, sb-&gt;ctrl[i].y, sb-&gt;ctrl[i].z));
        if(isRational) spline.weightlist.push_back(sb-&gt;weight[i]);
    }
    dxf-&gt;writeSpline(&amp;spline);
}

</t>
<t tx="leo.20191228122644.38">void writeBezier(SBezier *sb) {
    hStyle hs = { (uint32_t)sb-&gt;auxA };
    Vector c;
    Vector n = Vector::From(0.0, 0.0, 1.0);
    double r;

    if(sb-&gt;deg == 1) {
        // Line
        writeLine(sb-&gt;ctrl[0], sb-&gt;ctrl[1], hs);
    } else if(sb-&gt;IsInPlane(n, 0) &amp;&amp; sb-&gt;IsCircle(n, &amp;c, &amp;r)) {
        // Circle perpendicular to camera
        double theta0 = atan2(sb-&gt;ctrl[0].y - c.y, sb-&gt;ctrl[0].x - c.x);
        double theta1 = atan2(sb-&gt;ctrl[2].y - c.y, sb-&gt;ctrl[2].x - c.x);
        double dtheta = WRAP_SYMMETRIC(theta1 - theta0, 2.0 * PI);
        if(dtheta &lt; 0.0) swap(theta0, theta1);

        writeArc(c, r, theta0, theta1, hs);
    } else if(sb-&gt;IsRational()) {
        // Rational bezier
        // We'd like to export rational beziers exactly, but the resulting DXF
        // files can only be read by AutoCAD; LibreCAD/QCad simply do not
        // implement the feature. So, export as piecewise linear for compatibility.
        writeBezierAsPwl(sb);
    } else {
        // Any other curve
        writeSpline(sb);
    }
}

</t>
<t tx="leo.20191228122644.39">void writeAlignedDimension(Vector def1, Vector def2, Vector dimp,
                           Vector textp, const std::string &amp;text, hStyle hs, double actual) {
    DRW_DimAligned dim;
    assignDimensionDefaults(&amp;dim, hs);
    dim.setDef1Point(toCoord(def1));
    dim.setDef2Point(toCoord(def2));
    dim.setDimPoint(toCoord(dimp));
    dim.setTextPoint(toCoord(textp));
    dim.setText(text);
    dim.setActualMeasurement(actual);
    dxf-&gt;writeDimension(&amp;dim);
}

</t>
<t tx="leo.20191228122644.4">void VectorFileWriter::BezierAsNonrationalCubic(SBezier *sb, int depth) {
    Vector t0 = sb-&gt;TangentAt(0), t1 = sb-&gt;TangentAt(1);
    // The curve is correct, and the first derivatives are correct, at the
    // endpoints.
    SBezier bnr = SBezier::From(
                        sb-&gt;Start(),
                        sb-&gt;Start().Plus(t0.ScaledBy(1.0/3)),
                        sb-&gt;Finish().Minus(t1.ScaledBy(1.0/3)),
                        sb-&gt;Finish());

    double tol = SS.ExportChordTolMm();
    // Arbitrary choice, but make it a little finer than pwl tolerance since
    // it should be easier to achieve that with the smooth curves.
    tol /= 2;

    bool closeEnough = true;
    int i;
    for(i = 1; i &lt;= 3; i++) {
        double t = i/4.0;
        Vector p0 = sb-&gt;PointAt(t),
               pn = bnr.PointAt(t);
        double d = (p0.Minus(pn)).Magnitude();
        if(d &gt; tol) {
            closeEnough = false;
        }
    }

    if(closeEnough || depth &gt; 3) {
        Bezier(&amp;bnr);
    } else {
        SBezier bef, aft;
        sb-&gt;SplitAt(0.5, &amp;bef, &amp;aft);
        BezierAsNonrationalCubic(&amp;bef, depth+1);
        BezierAsNonrationalCubic(&amp;aft, depth+1);
    }
}

//-----------------------------------------------------------------------------
// Export a triangle mesh, in the requested format.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122644.40">void writeLinearDimension(Vector def1, Vector def2, Vector dimp,
                          Vector textp, const std::string &amp;text,
                          double angle, double oblique, hStyle hs, double actual) {
    DRW_DimLinear dim;
    assignDimensionDefaults(&amp;dim, hs);
    dim.setDef1Point(toCoord(def1));
    dim.setDef2Point(toCoord(def2));
    dim.setDimPoint(toCoord(dimp));
    dim.setTextPoint(toCoord(textp));
    dim.setText(text);
    dim.setAngle(angle);
    dim.setOblique(oblique);
    dim.setActualMeasurement(actual);
    dxf-&gt;writeDimension(&amp;dim);
}

</t>
<t tx="leo.20191228122644.41">void writeRadialDimension(Vector center, Vector radius,
                          Vector textp, const std::string &amp;text, hStyle hs, double actual) {
    DRW_DimRadial dim;
    assignDimensionDefaults(&amp;dim, hs);
    dim.setCenterPoint(toCoord(center));
    dim.setDiameterPoint(toCoord(radius));
    dim.setTextPoint(toCoord(textp));
    dim.setText(text);
    dim.setActualMeasurement(actual);
    dxf-&gt;writeDimension(&amp;dim);
}

</t>
<t tx="leo.20191228122644.42">void writeDiametricDimension(Vector def1, Vector def2,
                             Vector textp, const std::string &amp;text, hStyle hs, double actual) {
    DRW_DimDiametric dim;
    assignDimensionDefaults(&amp;dim, hs);
    dim.setDiameter1Point(toCoord(def1));
    dim.setDiameter2Point(toCoord(def2));
    dim.setTextPoint(toCoord(textp));
    dim.setText(text);
    dim.setActualMeasurement(actual);
    dxf-&gt;writeDimension(&amp;dim);
}

</t>
<t tx="leo.20191228122644.43">void writeAngularDimension(Vector fl1, Vector fl2, Vector sl1, Vector sl2, Vector dimp,
                           Vector textp, const std::string &amp;text, hStyle hs, double actual) {
    DRW_DimAngular dim;
    assignDimensionDefaults(&amp;dim, hs);
    dim.setFirstLine1(toCoord(fl1));
    dim.setFirstLine2(toCoord(fl2));
    dim.setSecondLine1(toCoord(sl1));
    dim.setSecondLine2(toCoord(sl2));
    dim.setDimPoint(toCoord(dimp));
    dim.setTextPoint(toCoord(textp));
    dim.setText(text);
    dim.setActualMeasurement(actual * PI / 180.0);
    dxf-&gt;writeDimension(&amp;dim);
}

</t>
<t tx="leo.20191228122644.44">void writeText(Vector textp, const std::string &amp;text,
               double height, double angle, Style::TextOrigin origin, hStyle hs) {
    DRW_Text txt;
    assignEntityDefaults(&amp;txt, hs);
    txt.layer = "text";
    txt.style = "unicode";
    txt.basePoint = toCoord(textp);
    txt.secPoint = txt.basePoint;
    txt.text = text;
    txt.height = height;
    txt.angle = angle;
    txt.alignH = DRW_Text::HCenter;
    if((uint32_t)origin &amp; (uint32_t)Style::TextOrigin::LEFT) {
        txt.alignH = DRW_Text::HLeft;
    } else if((uint32_t)origin &amp; (uint32_t)Style::TextOrigin::RIGHT) {
        txt.alignH = DRW_Text::HRight;
    }
    txt.alignV = DRW_Text::VMiddle;
    if((uint32_t)origin &amp; (uint32_t)Style::TextOrigin::TOP) {
        txt.alignV = DRW_Text::VTop;
    } else if((uint32_t)origin &amp; (uint32_t)Style::TextOrigin::BOT) {
        txt.alignV = DRW_Text::VBaseLine;
    }
    dxf-&gt;writeText(&amp;txt);
}
</t>
<t tx="leo.20191228122644.45">bool DxfFileWriter::OutputConstraints(IdList&lt;Constraint,hConstraint&gt; *constraint) {
    this-&gt;constraint = constraint;
    return true;
}

</t>
<t tx="leo.20191228122644.46">void DxfFileWriter::StartFile() {
    paths.clear();
}

</t>
<t tx="leo.20191228122644.47">void DxfFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                              bool filled, RgbaColor fillRgb, hStyle hs)
{
    BezierPath path = {};
    paths.push_back(path);
}
</t>
<t tx="leo.20191228122644.48">void DxfFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                               bool filled, RgbaColor fillRgb, hStyle hs)
{
}

</t>
<t tx="leo.20191228122644.49">void DxfFileWriter::Triangle(STriangle *tr) {
}

</t>
<t tx="leo.20191228122644.5">void SolveSpaceUI::ExportMeshTo(const Platform::Path &amp;filename) {
    SS.exportMode = true;
    GenerateAll(Generate::ALL);

    Group *g = SK.GetGroup(SS.GW.activeGroup);
    g-&gt;GenerateDisplayItems();

    SMesh *m = &amp;(SK.GetGroup(SS.GW.activeGroup)-&gt;displayMesh);
    if(m-&gt;IsEmpty()) {
        Error(_("Active group mesh is empty; nothing to export."));
        return;
    }

    FILE *f = OpenFile(filename, "wb");
    if(!f) {
        Error("Couldn't write to '%s'", filename.raw.c_str());
        return;
    }
    ShowNakedEdges(/*reportOnlyWhenNotOkay=*/true);
    if(filename.HasExtension("stl")) {
        ExportMeshAsStlTo(f, m);
    } else if(filename.HasExtension("obj")) {
        Platform::Path mtlFilename = filename.WithExtension("mtl");
        FILE *fMtl = OpenFile(mtlFilename, "wb");
        if(!fMtl) {
            Error("Couldn't write to '%s'", filename.raw.c_str());
            return;
        }

        fprintf(f, "mtllib %s\n", mtlFilename.FileName().c_str());
        ExportMeshAsObjTo(f, fMtl, m);

        fclose(fMtl);
    } else if(filename.HasExtension("q3do")) {
        ExportMeshAsQ3doTo(f, m);
    } else if(filename.HasExtension("js") ||
              filename.HasExtension("html")) {
        SOutlineList *e = &amp;(SK.GetGroup(SS.GW.activeGroup)-&gt;displayOutlines);
        ExportMeshAsThreeJsTo(f, filename, m, e);
    } else if(filename.HasExtension("wrl")) {
        ExportMeshAsVrmlTo(f, filename, m);
    } else {
        Error("Can't identify output file type from file extension of "
              "filename '%s'; try .stl, .obj, .js, .html.", filename.raw.c_str());
    }

    fclose(f);

    SS.justExportedInfo.showOrigin = false;
    SS.justExportedInfo.draw = true;
    GW.Invalidate();
}

//-----------------------------------------------------------------------------
// Export the mesh as an STL file; it should always be vertex-to-vertex and
// not self-intersecting, so not much to do.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122644.50">void DxfFileWriter::Bezier(SBezier *sb) {
    paths.back().beziers.push_back(sb);
}

</t>
<t tx="leo.20191228122644.51">void DxfFileWriter::FinishAndCloseFile() {
    dxfRW dxf;

    DxfWriteInterface interface = {};
    interface.writer = this;
    interface.dxf    = &amp;dxf;

    std::stringstream stream;
    dxf.write(stream, &amp;interface, DRW::AC1021, /*bin=*/false);
    paths.clear();
    constraint = NULL;

    if(!WriteFile(filename, stream.str())) {
        Error("Couldn't write to '%s'", filename.raw.c_str());
        return;
    }

    if(!interface.messages.empty()) {
        std::string text = _("Some aspects of the drawing have no DXF equivalent and "
                             "were not exported:\n");
        for(const std::string &amp;message : interface.messages) {
            text += " * " + message + "\n";
        }
        Message(text.c_str());
    }
}

</t>
<t tx="leo.20191228122644.52">bool DxfFileWriter::NeedToOutput(Constraint *c) {
    switch(c-&gt;type) {
        case Constraint::Type::PT_PT_DISTANCE:
        case Constraint::Type::PT_LINE_DISTANCE:
        case Constraint::Type::DIAMETER:
        case Constraint::Type::ANGLE:
        case Constraint::Type::COMMENT:
            return c-&gt;IsVisible();

        default: // See writeEntities().
            break;
    }
    return false;
}

</t>
<t tx="leo.20191228122644.53">const char *DxfFileWriter::lineTypeName(StipplePattern stippleType) {
    switch(stippleType) {
        case StipplePattern::CONTINUOUS:   return "CONTINUOUS";
        case StipplePattern::SHORT_DASH:   return "DASHED";
        case StipplePattern::DASH:         return "DASHED";
        case StipplePattern::LONG_DASH:    return "DASHEDX2";
        case StipplePattern::DASH_DOT:     return "DASHDOT";
        case StipplePattern::DASH_DOT_DOT: return "DIVIDE";
        case StipplePattern::DOT:          return "DOT";

        case StipplePattern::FREEHAND:
        case StipplePattern::ZIGZAG:
            /* no corresponding DXF line type */
           break;
    }

    return "CONTINUOUS";
}

//-----------------------------------------------------------------------------
// Routines for EPS output
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122644.54">static std::string MakeStipplePattern(StipplePattern pattern, double scale, char delimiter,
                                      bool inkscapeWorkaround = false) {
    scale /= 2.0;

    // Inkscape ignores all elements that are exactly zero instead of drawing
    // them as dots.
    double zero = inkscapeWorkaround ? 1e-6 : 0;

    std::string result;
    switch(pattern) {
        case StipplePattern::CONTINUOUS:
            return "";

        case StipplePattern::SHORT_DASH:
            result = ssprintf("%.3f_%.3f", scale, scale * 2.0);
            break;
        case StipplePattern::DASH:
            result = ssprintf("%.3f_%.3f", scale, scale);
            break;
        case StipplePattern::DASH_DOT:
            result = ssprintf("%.3f_%.3f_%.6f_%.3f",
                              scale, scale * 0.5, zero, scale * 0.5);
            break;
        case StipplePattern::DASH_DOT_DOT:
            result = ssprintf("%.3f_%.3f_%.6f_%.3f_%.6f_%.3f",
                              scale, scale * 0.5, zero,
                              scale * 0.5, scale * 0.5, zero);
            break;
        case StipplePattern::DOT:
            result = ssprintf("%.6f_%.3f", zero, scale * 0.5);
            break;
        case StipplePattern::LONG_DASH:
            result = ssprintf("%.3f_%.3f", scale * 2.0, scale * 0.5);
            break;

        case StipplePattern::FREEHAND:
        case StipplePattern::ZIGZAG:
            ssassert(false, "Freehand and zigzag export not implemented");
    }
    std::replace(result.begin(), result.end(), '_', delimiter);
    return result;
}

</t>
<t tx="leo.20191228122644.55">void EpsFileWriter::StartFile() {
    fprintf(f,
"%%!PS-Adobe-2.0\r\n"
"%%%%Creator: SolveSpace\r\n"
"%%%%Title: title\r\n"
"%%%%Pages: 0\r\n"
"%%%%PageOrder: Ascend\r\n"
"%%%%BoundingBox: 0 0 %d %d\r\n"
"%%%%HiResBoundingBox: 0 0 %.3f %.3f\r\n"
"%%%%EndComments\r\n"
"\r\n"
"gsave\r\n"
"\r\n",
            (int)ceil(MmToPts(ptMax.x - ptMin.x)),
            (int)ceil(MmToPts(ptMax.y - ptMin.y)),
            MmToPts(ptMax.x - ptMin.x),
            MmToPts(ptMax.y - ptMin.y));
}

</t>
<t tx="leo.20191228122644.56">void EpsFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                              bool filled, RgbaColor fillRgb, hStyle hs)
{
    fprintf(f, "newpath\r\n");
    prevPt = Vector::From(VERY_POSITIVE, VERY_POSITIVE, VERY_POSITIVE);
}
</t>
<t tx="leo.20191228122644.57">void EpsFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                               bool filled, RgbaColor fillRgb, hStyle hs)
{
    StipplePattern pattern = Style::PatternType(hs);
    double stippleScale = MmToPts(Style::StippleScaleMm(hs));

    fprintf(f, "    %.3f setlinewidth\r\n"
               "    %.3f %.3f %.3f setrgbcolor\r\n"
               "    1 setlinejoin\r\n"  // rounded
               "    1 setlinecap\r\n"   // rounded
               "    [%s] 0 setdash\r\n"
               "    gsave stroke grestore\r\n",
        MmToPts(lineWidth),
        strokeRgb.redF(), strokeRgb.greenF(), strokeRgb.blueF(),
        MakeStipplePattern(pattern, stippleScale, ' ').c_str());
    if(filled) {
        fprintf(f, "    %.3f %.3f %.3f setrgbcolor\r\n"
                   "    gsave fill grestore\r\n",
            fillRgb.redF(), fillRgb.greenF(), fillRgb.blueF());
    }
}

</t>
<t tx="leo.20191228122644.58">void EpsFileWriter::MaybeMoveTo(Vector st, Vector fi) {
    if(!prevPt.Equals(st)) {
        fprintf(f, "    %.3f %.3f moveto\r\n",
            MmToPts(st.x - ptMin.x), MmToPts(st.y - ptMin.y));
    }
    prevPt = fi;
}

</t>
<t tx="leo.20191228122644.59">void EpsFileWriter::Triangle(STriangle *tr) {
    fprintf(f,
"%.3f %.3f %.3f setrgbcolor\r\n"
"newpath\r\n"
"    %.3f %.3f moveto\r\n"
"    %.3f %.3f lineto\r\n"
"    %.3f %.3f lineto\r\n"
"    closepath\r\n"
"gsave fill grestore\r\n",
            tr-&gt;meta.color.redF(), tr-&gt;meta.color.greenF(), tr-&gt;meta.color.blueF(),
            MmToPts(tr-&gt;a.x - ptMin.x), MmToPts(tr-&gt;a.y - ptMin.y),
            MmToPts(tr-&gt;b.x - ptMin.x), MmToPts(tr-&gt;b.y - ptMin.y),
            MmToPts(tr-&gt;c.x - ptMin.x), MmToPts(tr-&gt;c.y - ptMin.y));

    // same issue with cracks, stroke it to avoid them
    double sw = max(ptMax.x - ptMin.x, ptMax.y - ptMin.y) / 1000;
    fprintf(f,
"1 setlinejoin\r\n"
"1 setlinecap\r\n"
"%.3f setlinewidth\r\n"
"gsave stroke grestore\r\n",
            MmToPts(sw));
}

</t>
<t tx="leo.20191228122644.6">void SolveSpaceUI::ExportMeshAsStlTo(FILE *f, SMesh *sm) {
    char str[80] = {};
    strcpy(str, "STL exported mesh");
    fwrite(str, 1, 80, f);

    uint32_t n = sm-&gt;l.n;
    fwrite(&amp;n, 4, 1, f);

    double s = SS.exportScale;
    int i;
    for(i = 0; i &lt; sm-&gt;l.n; i++) {
        STriangle *tr = &amp;(sm-&gt;l[i]);
        Vector n = tr-&gt;Normal().WithMagnitude(1);
        float w;
        w = (float)n.x;           fwrite(&amp;w, 4, 1, f);
        w = (float)n.y;           fwrite(&amp;w, 4, 1, f);
        w = (float)n.z;           fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;a.x)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;a.y)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;a.z)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;b.x)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;b.y)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;b.z)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;c.x)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;c.y)/s); fwrite(&amp;w, 4, 1, f);
        w = (float)((tr-&gt;c.z)/s); fwrite(&amp;w, 4, 1, f);
        fputc(0, f);
        fputc(0, f);
    }
}

//-----------------------------------------------------------------------------
// Export the mesh as a Q3DO (https://github.com/q3k/q3d) file.
//-----------------------------------------------------------------------------

#include "q3d_object_generated.h"
</t>
<t tx="leo.20191228122644.60">void EpsFileWriter::Bezier(SBezier *sb) {
    Vector c, n = Vector::From(0, 0, 1);
    double r;
    if(sb-&gt;deg == 1) {
        MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[1]);
        fprintf(f,     "    %.3f %.3f lineto\r\n",
                MmToPts(sb-&gt;ctrl[1].x - ptMin.x),
                MmToPts(sb-&gt;ctrl[1].y - ptMin.y));
    } else if(sb-&gt;IsCircle(n, &amp;c, &amp;r)) {
        Vector p0 = sb-&gt;ctrl[0], p1 = sb-&gt;ctrl[2];
        double theta0 = atan2(p0.y - c.y, p0.x - c.x),
        MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[3]);
        fprintf(f,
"    %.3f %.3f %.3f %.3f %.3f %.3f curveto\r\n",
            MmToPts(sb-&gt;ctrl[1].x - ptMin.x), MmToPts(sb-&gt;ctrl[1].y - ptMin.y),
            MmToPts(sb-&gt;ctrl[2].x - ptMin.x), MmToPts(sb-&gt;ctrl[2].y - ptMin.y),
            MmToPts(sb-&gt;ctrl[3].x - ptMin.x), MmToPts(sb-&gt;ctrl[3].y - ptMin.y));
    } else {
        BezierAsNonrationalCubic(sb);
    }
}

</t>
<t tx="leo.20191228122644.61">void EpsFileWriter::FinishAndCloseFile() {
    fprintf(f,
"\r\n"
"grestore\r\n"
"\r\n");
    fclose(f);
}

//-----------------------------------------------------------------------------
// Routines for PDF output, some extra complexity because we have to generate
// a correct xref table.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122644.62">void PdfFileWriter::StartFile() {
    if((ptMax.x - ptMin.x) &gt; 200*25.4 ||
       (ptMax.y - ptMin.y) &gt; 200*25.4)
    {
        Message(_("PDF page size exceeds 200 by 200 inches; many viewers may "
                  "reject this file."));
    }

    fprintf(f,
"%%PDF-1.1\r\n"
"%%%c%c%c%c\r\n",
        0xe2, 0xe3, 0xcf, 0xd3);

    xref[1] = (uint32_t)ftell(f);
    fprintf(f,
"1 0 obj\r\n"
"  &lt;&lt; /Type /Catalog\r\n"
"     /Outlines 2 0 R\r\n"
"     /Pages 3 0 R\r\n"
"  &gt;&gt;\r\n"
"endobj\r\n");

    xref[2] = (uint32_t)ftell(f);
    fprintf(f,
"2 0 obj\r\n"
"  &lt;&lt; /Type /Outlines\r\n"
"     /Count 0\r\n"
"  &gt;&gt;\r\n"
"endobj\r\n");

    xref[3] = (uint32_t)ftell(f);
    fprintf(f,
"3 0 obj\r\n"
"  &lt;&lt; /Type /Pages\r\n"
"     /Kids [4 0 R]\r\n"
"     /Count 1\r\n"
"  &gt;&gt;\r\n"
"endobj\r\n");

    xref[4] = (uint32_t)ftell(f);
    fprintf(f,
"4 0 obj\r\n"
"  &lt;&lt; /Type /Page\r\n"
"     /Parent 3 0 R\r\n"
"     /MediaBox [0 0 %.3f %.3f]\r\n"
"     /Contents 5 0 R\r\n"
"     /Resources &lt;&lt; /ProcSet 7 0 R\r\n"
"                   /Font &lt;&lt; /F1 8 0 R &gt;&gt;\r\n"
"                &gt;&gt;\r\n"
"  &gt;&gt;\r\n"
"endobj\r\n",
            MmToPts(ptMax.x - ptMin.x),
            MmToPts(ptMax.y - ptMin.y));

    xref[5] = (uint32_t)ftell(f);
    fprintf(f,
"5 0 obj\r\n"
"  &lt;&lt; /Length 6 0 R &gt;&gt;\r\n"
"stream\r\n");
    bodyStart = (uint32_t)ftell(f);
}

</t>
<t tx="leo.20191228122644.63">void PdfFileWriter::FinishAndCloseFile() {
    uint32_t bodyEnd = (uint32_t)ftell(f);

    fprintf(f,
"endstream\r\n"
"endobj\r\n");

    xref[6] = (uint32_t)ftell(f);
    fprintf(f,
"6 0 obj\r\n"
"  %d\r\n"
"endobj\r\n",
        bodyEnd - bodyStart);

    xref[7] = (uint32_t)ftell(f);
    fprintf(f,
"7 0 obj\r\n"
"  [/PDF /Text]\r\n"
"endobj\r\n");

    xref[8] = (uint32_t)ftell(f);
    fprintf(f,
"8 0 obj\r\n"
"  &lt;&lt; /Type /Font\r\n"
"     /Subtype /Type1\r\n"
"     /Name /F1\r\n"
"     /BaseFont /Helvetica\r\n"
"     /Encoding /WinAnsiEncoding\r\n"
"  &gt;&gt;\r\n"
"endobj\r\n");

    xref[9] = (uint32_t)ftell(f);
    fprintf(f,
"9 0 obj\r\n"
"  &lt;&lt; /Creator (SolveSpace)\r\n"
"  &gt;&gt;\r\n");

    uint32_t xrefStart = (uint32_t)ftell(f);
    fprintf(f,
"xref\r\n"
"0 10\r\n"
"0000000000 65535 f\r\n");

    int i;
    for(i = 1; i &lt;= 9; i++) {
        fprintf(f, "%010d %05d n\r\n", xref[i], 0);
    }

    fprintf(f,
"\r\n"
"trailer\r\n"
"  &lt;&lt; /Size 10\r\n"
"     /Root 1 0 R\r\n"
"     /Info 9 0 R\r\n"
"  &gt;&gt;\r\n"
"startxref\r\n"
"%d\r\n"
"%%%%EOF\r\n",
        xrefStart);

    fclose(f);

}

</t>
<t tx="leo.20191228122644.64">void PdfFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                              bool filled, RgbaColor fillRgb, hStyle hs)
{
    StipplePattern pattern = Style::PatternType(hs);
    double stippleScale = MmToPts(Style::StippleScaleMm(hs));

    fprintf(f, "1 J 1 j " // round endcaps and joins
               "%.3f w [%s] 0 d "
               "%.3f %.3f %.3f RG\r\n",
        MmToPts(lineWidth),
        MakeStipplePattern(pattern, stippleScale, ' ').c_str(),
        strokeRgb.redF(), strokeRgb.greenF(), strokeRgb.blueF());
    if(filled) {
        fprintf(f, "%.3f %.3f %.3f rg\r\n",
            fillRgb.redF(), fillRgb.greenF(), fillRgb.blueF());
    }

    prevPt = Vector::From(VERY_POSITIVE, VERY_POSITIVE, VERY_POSITIVE);
}
</t>
<t tx="leo.20191228122644.65">void PdfFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                               bool filled, RgbaColor fillRgb, hStyle hs)
{
    if(filled) {
        fprintf(f, "b\r\n");
    } else {
        fprintf(f, "S\r\n");
    }
}

</t>
<t tx="leo.20191228122644.66">void PdfFileWriter::MaybeMoveTo(Vector st, Vector fi) {
    if(!prevPt.Equals(st)) {
        fprintf(f, "%.3f %.3f m\r\n",
            MmToPts(st.x - ptMin.x), MmToPts(st.y - ptMin.y));
    }
    prevPt = fi;
}

</t>
<t tx="leo.20191228122644.67">void PdfFileWriter::Triangle(STriangle *tr) {
    double sw = max(ptMax.x - ptMin.x, ptMax.y - ptMin.y) / 1000;

    fprintf(f,
"1 J 1 j\r\n"
"%.3f %.3f %.3f RG\r\n"
"%.3f %.3f %.3f rg\r\n"
"%.3f w\r\n"
"%.3f %.3f m\r\n"
"%.3f %.3f l\r\n"
"%.3f %.3f l\r\n"
"b\r\n",
            tr-&gt;meta.color.redF(), tr-&gt;meta.color.greenF(), tr-&gt;meta.color.blueF(),
            tr-&gt;meta.color.redF(), tr-&gt;meta.color.greenF(), tr-&gt;meta.color.blueF(),
            MmToPts(sw),
            MmToPts(tr-&gt;a.x - ptMin.x), MmToPts(tr-&gt;a.y - ptMin.y),
            MmToPts(tr-&gt;b.x - ptMin.x), MmToPts(tr-&gt;b.y - ptMin.y),
            MmToPts(tr-&gt;c.x - ptMin.x), MmToPts(tr-&gt;c.y - ptMin.y));
}

</t>
<t tx="leo.20191228122644.68">void PdfFileWriter::Bezier(SBezier *sb) {
    if(sb-&gt;deg == 1) {
        MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[1]);
        fprintf(f,
"%.3f %.3f l\r\n",
            MmToPts(sb-&gt;ctrl[1].x - ptMin.x), MmToPts(sb-&gt;ctrl[1].y - ptMin.y));
    } else if(sb-&gt;deg == 3 &amp;&amp; !sb-&gt;IsRational()) {
        MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[3]);
        fprintf(f,
"%.3f %.3f %.3f %.3f %.3f %.3f c\r\n",
            MmToPts(sb-&gt;ctrl[1].x - ptMin.x), MmToPts(sb-&gt;ctrl[1].y - ptMin.y),
            MmToPts(sb-&gt;ctrl[2].x - ptMin.x), MmToPts(sb-&gt;ctrl[2].y - ptMin.y),
            MmToPts(sb-&gt;ctrl[3].x - ptMin.x), MmToPts(sb-&gt;ctrl[3].y - ptMin.y));
    } else {
        BezierAsNonrationalCubic(sb);
    }
}

//-----------------------------------------------------------------------------
// Routines for SVG output
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122644.69">void SvgFileWriter::StartFile() {
    fprintf(f,
"&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.0//EN\" "
    "\"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd\"&gt;\r\n"
"&lt;svg xmlns=\"http://www.w3.org/2000/svg\"  "
    "xmlns:xlink=\"http://www.w3.org/1999/xlink\" "
    "width='%.3fmm' height='%.3fmm' "
    "viewBox=\"0 0 %.3f %.3f\"&gt;\r\n"
"\r\n"
"&lt;title&gt;Exported SVG&lt;/title&gt;\r\n"
"\r\n",
        (ptMax.x - ptMin.x), (ptMax.y - ptMin.y),
        (ptMax.x - ptMin.x), (ptMax.y - ptMin.y));

    fprintf(f, "&lt;style&gt;&lt;![CDATA[\r\n");
    fprintf(f, "polygon {\r\n");
    fprintf(f, "shape-rendering:crispEdges;\r\n");
    // crispEdges turns of anti-aliasing, which tends to cause hairline
    // cracks between triangles; but there still is some cracking, so
    // specify a stroke width too, hope for around a pixel
    double sw = max(ptMax.x - ptMin.x, ptMax.y - ptMin.y) / 1000;
    fprintf(f, "stroke-width:%f;\r\n", sw);
    fprintf(f, "}\r\n");
    for(auto &amp;style : SK.style) {
        Style *s = &amp;style;

        RgbaColor strokeRgb = Style::Color(s-&gt;h, /*forExport=*/true);
        StipplePattern pattern = Style::PatternType(s-&gt;h);
        double stippleScale = Style::StippleScaleMm(s-&gt;h);

        fprintf(f, ".s%x {\r\n", s-&gt;h.v);
        fprintf(f, "stroke:#%02x%02x%02x;\r\n", strokeRgb.red, strokeRgb.green, strokeRgb.blue);
        // don't know why we have to take a half of the width
        fprintf(f, "stroke-width:%f;\r\n", Style::WidthMm(s-&gt;h.v) / 2.0);
        fprintf(f, "stroke-linecap:round;\r\n");
        fprintf(f, "stroke-linejoin:round;\r\n");
        std::string patternStr = MakeStipplePattern(pattern, stippleScale, ',',
                                                    /*inkscapeWorkaround=*/true);
        if(!patternStr.empty()) {
            fprintf(f, "stroke-dasharray:%s;\r\n", patternStr.c_str());
        }
        fprintf(f, "fill:none;\r\n");
        fprintf(f, "}\r\n");
    }
    fprintf(f, "]]&gt;&lt;/style&gt;\r\n");
}

</t>
<t tx="leo.20191228122644.7">void SolveSpaceUI::ExportMeshAsQ3doTo(FILE *f, SMesh *sm) {
    flatbuffers::FlatBufferBuilder builder(1024);
    double s = SS.exportScale;

    // Create a material for every colour used, keep note of triangles belonging to color/material.
    std::map&lt;RgbaColor, flatbuffers::Offset&lt;q3d::Material&gt;, RgbaColorCompare&gt; materials;
    std::map&lt;RgbaColor, std::vector&lt;flatbuffers::Offset&lt;q3d::Triangle&gt;&gt;, RgbaColorCompare&gt; materialTriangles;
    for (const STriangle &amp;t : sm-&gt;l) {
        auto color = t.meta.color;
        if (materials.find(color) == materials.end()) {
            auto name = builder.CreateString(ssprintf("Color #%02x%02x%02x%02x", color.red, color.green, color.blue, color.alpha));
            auto co = q3d::CreateColor(builder, color.red, color.green, color.blue, color.alpha);
            auto mo = q3d::CreateMaterial(builder, name, co);
            materials.emplace(color, mo);
        }

        Vector faceNormal = t.Normal();
        auto a = q3d::Vector3(t.a.x/s, t.a.y/s, t.a.z/s);
        auto b = q3d::Vector3(t.b.x/s, t.b.y/s, t.b.z/s);
        auto c = q3d::Vector3(t.c.x/s, t.c.y/s, t.c.z/s);
        auto fn = q3d::Vector3(faceNormal.x, faceNormal.y, faceNormal.x);
        auto n1 = q3d::Vector3(t.normals[0].x, t.normals[0].y, t.normals[0].z);
        auto n2 = q3d::Vector3(t.normals[1].x, t.normals[1].y, t.normals[1].z);
        auto n3 = q3d::Vector3(t.normals[2].x, t.normals[2].y, t.normals[2].z);
        auto tri = q3d::CreateTriangle(builder, &amp;a, &amp;b, &amp;c, &amp;fn, &amp;n1, &amp;n2, &amp;n3);
        materialTriangles[color].push_back(tri);
    }

    // Build all meshes sorted by material.
    std::vector&lt;flatbuffers::Offset&lt;q3d::Mesh&gt;&gt; meshes;
    for (auto &amp;it : materials) {
        auto &amp;mato = it.second;
        auto to = builder.CreateVector(materialTriangles[it.first]);
        auto mo = q3d::CreateMesh(builder, to, mato);
        meshes.push_back(mo);
    }

    auto mo = builder.CreateVector(meshes);
    auto o = q3d::CreateObject(builder, mo);
    q3d::FinishObjectBuffer(builder, o);
    fwrite(builder.GetBufferPointer(), builder.GetSize(), 1, f);
}

//-----------------------------------------------------------------------------
// Export the mesh as Wavefront OBJ format. This requires us to reduce all the
// identical vertices to the same identifier, so do that first.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122644.70">void SvgFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                              bool filled, RgbaColor fillRgb, hStyle hs)
{
    fprintf(f, "&lt;path d='");
    prevPt = Vector::From(VERY_POSITIVE, VERY_POSITIVE, VERY_POSITIVE);
}
</t>
<t tx="leo.20191228122644.71">void SvgFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                               bool filled, RgbaColor fillRgb, hStyle hs)
{
    std::string fill;
    if(filled) {
        fill = ssprintf("fill='#%02x%02x%02x'",
            fillRgb.red, fillRgb.green, fillRgb.blue);
    }
    std::string cls = ssprintf("s%x", hs.v);
    fprintf(f, "' class='%s' %s/&gt;\r\n", cls.c_str(), fill.c_str());
}

</t>
<t tx="leo.20191228122644.72">void SvgFileWriter::MaybeMoveTo(Vector st, Vector fi) {
    // SVG uses a coordinate system with the origin at top left, +y down
    if(!prevPt.Equals(st)) {
        fprintf(f, "M%.3f %.3f ", (st.x - ptMin.x), (ptMax.y - st.y));
    }
    prevPt = fi;
}

</t>
<t tx="leo.20191228122644.73">void SvgFileWriter::Triangle(STriangle *tr) {
    fprintf(f,
"&lt;polygon points='%.3f,%.3f %.3f,%.3f %.3f,%.3f' "
    "stroke='#%02x%02x%02x' "
    "fill='#%02x%02x%02x'/&gt;\r\n",
            (tr-&gt;a.x - ptMin.x), (ptMax.y - tr-&gt;a.y),
            (tr-&gt;b.x - ptMin.x), (ptMax.y - tr-&gt;b.y),
            (tr-&gt;c.x - ptMin.x), (ptMax.y - tr-&gt;c.y),
            tr-&gt;meta.color.red, tr-&gt;meta.color.green, tr-&gt;meta.color.blue,
            tr-&gt;meta.color.red, tr-&gt;meta.color.green, tr-&gt;meta.color.blue);
}

</t>
<t tx="leo.20191228122644.74">void SvgFileWriter::Bezier(SBezier *sb) {
    Vector c, n = Vector::From(0, 0, 1);
    double r;
    if(sb-&gt;deg == 1) {
        MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[1]);
        fprintf(f, "L%.3f,%.3f ",
            (sb-&gt;ctrl[1].x - ptMin.x), (ptMax.y - sb-&gt;ctrl[1].y));
    } else if(sb-&gt;IsCircle(n, &amp;c, &amp;r)) {
        Vector p0 = sb-&gt;ctrl[0], p1 = sb-&gt;ctrl[2];
        double theta0 = atan2(p0.y - c.y, p0.x - c.x),
                        (dtheta &lt; 0) ? 1 : 0,
                        p1.x - ptMin.x, ptMax.y - p1.y);
    } else if(!sb-&gt;IsRational()) {
        if(sb-&gt;deg == 2) {
            MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[2]);
            fprintf(f, "Q%.3f,%.3f %.3f,%.3f ",
                sb-&gt;ctrl[1].x - ptMin.x, ptMax.y - sb-&gt;ctrl[1].y,
                sb-&gt;ctrl[2].x - ptMin.x, ptMax.y - sb-&gt;ctrl[2].y);
        } else if(sb-&gt;deg == 3) {
            MaybeMoveTo(sb-&gt;ctrl[0], sb-&gt;ctrl[3]);
            fprintf(f, "C%.3f,%.3f %.3f,%.3f %.3f,%.3f ",
                sb-&gt;ctrl[1].x - ptMin.x, ptMax.y - sb-&gt;ctrl[1].y,
                sb-&gt;ctrl[2].x - ptMin.x, ptMax.y - sb-&gt;ctrl[2].y,
                sb-&gt;ctrl[3].x - ptMin.x, ptMax.y - sb-&gt;ctrl[3].y);
        }
    } else {
        BezierAsNonrationalCubic(sb);
    }
}

</t>
<t tx="leo.20191228122644.75">void SvgFileWriter::FinishAndCloseFile() {
    fprintf(f, "\r\n&lt;/svg&gt;\r\n");
    fclose(f);
}

//-----------------------------------------------------------------------------
// Routines for HPGL output
//-----------------------------------------------------------------------------
double HpglFileWriter::MmToHpglUnits(double mm) {
    return mm*40;
}

</t>
<t tx="leo.20191228122644.76">void HpglFileWriter::StartFile() {
    fprintf(f, "IN;\r\n");
    fprintf(f, "SP1;\r\n");
}

</t>
<t tx="leo.20191228122644.77">void HpglFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                               bool filled, RgbaColor fillRgb, hStyle hs)
{
}
</t>
<t tx="leo.20191228122644.78">void HpglFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                                bool filled, RgbaColor fillRgb, hStyle hs)
{
}

</t>
<t tx="leo.20191228122644.79">void HpglFileWriter::Triangle(STriangle *tr) {
}

</t>
<t tx="leo.20191228122644.8">void SolveSpaceUI::ExportMeshAsObjTo(FILE *fObj, FILE *fMtl, SMesh *sm) {
    std::map&lt;RgbaColor, std::string, RgbaColorCompare&gt; colors;
    for(const STriangle &amp;t : sm-&gt;l) {
        RgbaColor color = t.meta.color;
        if(colors.find(color) == colors.end()) {
            std::string id = ssprintf("h%02x%02x%02x",
                                      color.red,
                                      color.green,
                                      color.blue);
            colors.emplace(color, id);
        }
        for(int i = 0; i &lt; 3; i++) {
            fprintf(fObj, "v %.10f %.10f %.10f\n",
                    CO(t.vertices[i].ScaledBy(1 / SS.exportScale)));
        }
    }

    for(auto &amp;it : colors) {
        fprintf(fMtl, "newmtl %s\n",
                it.second.c_str());
        fprintf(fMtl, "Kd %.3f %.3f %.3f\n",
                it.first.redF(), it.first.greenF(), it.first.blueF());
    }

    for(const STriangle &amp;t : sm-&gt;l) {
        for(int i = 0; i &lt; 3; i++) {
            Vector n = t.normals[i].WithMagnitude(1.0);
            fprintf(fObj, "vn %.10f %.10f %.10f\n",
                    CO(n));
        }
    }

    RgbaColor currentColor = {};
    for(int i = 0; i &lt; sm-&gt;l.n; i++) {
        const STriangle &amp;t = sm-&gt;l[i];
        if(!currentColor.Equals(t.meta.color)) {
            currentColor = t.meta.color;
            fprintf(fObj, "usemtl %s\n", colors[currentColor].c_str());
        }

        fprintf(fObj, "f %d//%d %d//%d %d//%d\n",
                i * 3 + 1, i * 3 + 1,
                i * 3 + 2, i * 3 + 2,
                i * 3 + 3, i * 3 + 3);
    }
}

//-----------------------------------------------------------------------------
// Export the mesh as a JavaScript script, which is compatible with Three.js.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122644.80">void HpglFileWriter::Bezier(SBezier *sb) {
    if(sb-&gt;deg == 1) {
        fprintf(f, "PU%d,%d;\r\n",
            (int)MmToHpglUnits(sb-&gt;ctrl[0].x),
            (int)MmToHpglUnits(sb-&gt;ctrl[0].y));
        fprintf(f, "PD%d,%d;\r\n",
            (int)MmToHpglUnits(sb-&gt;ctrl[1].x),
            (int)MmToHpglUnits(sb-&gt;ctrl[1].y));
    } else {
        BezierAsPwl(sb);
    }
}

</t>
<t tx="leo.20191228122644.81">void HpglFileWriter::FinishAndCloseFile() {
    fclose(f);
}

//-----------------------------------------------------------------------------
// Routines for G Code output. Slightly complicated by our ability to generate
// multiple passes, and to specify the feeds and depth; those parameters get
// set in the configuration screen.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122644.82">void GCodeFileWriter::StartFile() {
    sel = {};
}
</t>
<t tx="leo.20191228122644.83">void GCodeFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                                bool filled, RgbaColor fillRgb, hStyle hs)
{
}
</t>
<t tx="leo.20191228122644.84">void GCodeFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                                 bool filled, RgbaColor fillRgb, hStyle hs)
{
}
</t>
<t tx="leo.20191228122644.85">void GCodeFileWriter::Triangle(STriangle *tr) {
}

</t>
<t tx="leo.20191228122644.86">void GCodeFileWriter::Bezier(SBezier *sb) {
    if(sb-&gt;deg == 1) {
        sel.AddEdge(sb-&gt;ctrl[0], sb-&gt;ctrl[1]);
    } else {
        BezierAsPwl(sb);
    }
}

</t>
<t tx="leo.20191228122644.87">void GCodeFileWriter::FinishAndCloseFile() {
    SPolygon sp = {};
    sel.AssemblePolygon(&amp;sp, NULL);

    int i;
    for(i = 0; i &lt; SS.gCode.passes; i++) {
        double depth = (SS.gCode.depth / SS.gCode.passes)*(i+1);

        SContour *sc;
        for(sc = sp.l.First(); sc; sc = sp.l.NextAfter(sc)) {
            if(sc-&gt;l.n &lt; 2) continue;

            SPoint *pt = sc-&gt;l.First();
            fprintf(f, "G00 X%s Y%s\r\n",
                    SS.MmToString(pt-&gt;p.x).c_str(), SS.MmToString(pt-&gt;p.y).c_str());
            fprintf(f, "G01 Z%s F%s\r\n",
                    SS.MmToString(depth).c_str(), SS.MmToString(SS.gCode.plungeFeed).c_str());

            pt = sc-&gt;l.NextAfter(pt);
            for(; pt; pt = sc-&gt;l.NextAfter(pt)) {
                fprintf(f, "G01 X%s Y%s F%s\r\n",
                        SS.MmToString(pt-&gt;p.x).c_str(), SS.MmToString(pt-&gt;p.y).c_str(),
                        SS.MmToString(SS.gCode.feed).c_str());
            }
            // Move up to a clearance plane 5mm above the work.
            fprintf(f, "G00 Z%s\r\n",
                    SS.MmToString(SS.gCode.depth &lt; 0 ? +5 : -5).c_str());
        }
    }

    sp.Clear();
    sel.Clear();
    fclose(f);
}


//-----------------------------------------------------------------------------
// Routine for STEP output; just a wrapper around the general STEP stuff that
// can also be used for surfaces or 3d curves.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122644.88">void Step2dFileWriter::StartFile() {
    sfw = {};
    sfw.f = f;
    sfw.WriteHeader();
}

</t>
<t tx="leo.20191228122644.89">void Step2dFileWriter::Triangle(STriangle *tr) {
}

</t>
<t tx="leo.20191228122644.9">void SolveSpaceUI::ExportMeshAsThreeJsTo(FILE *f, const Platform::Path &amp;filename,
                                         SMesh *sm, SOutlineList *sol)
{
    SPointList spl = {};
    STriangle *tr;
    Vector bndl, bndh;
    const char htmlbegin[] = R"(
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
)";
    const char htmlend[] = R"(

    // A default three.js viewer with OrthographicTrackballControls is
    // generated as a comment preceding the data.

    // x bounds should be the range of x or y, whichever
    // is larger, before aspect ratio correction is applied.
    // y bounds should be the range of x or y, whichever is
    // larger. No aspect ratio correction is applied.
    // Near plane should be 1.
    // Camera's z-position should be the range of z + 1 or the larger of
    // the x or y bounds, whichever is larger.
    // Far plane should be at least twice as much as the camera's
    // z-position.
    // Edge projection bias should be about 1/500 of the far plane's distance.
    // Further corrections will be applied to the z-position and far plane in
    // the default viewer, but the defaults are fine for a model which
    // only rotates about the world origin.

    sm-&gt;GetBounding(&amp;bndh, &amp;bndl);
    double largerBoundXY = max((bndh.x - bndl.x), (bndh.y - bndl.y));
    double largerBoundZ = max(largerBoundXY, (bndh.z - bndl.z + 1));

    std::string basename = filename.FileStem();
    for(size_t i = 0; i &lt; basename.length(); i++) {
        if(!(isalnum(basename[i]) || ((unsigned)basename[i] &gt;= 0x80))) {
            basename[i] = '_';
        }
    }

    if(filename.HasExtension("html")) {
        fprintf(f, htmlbegin,
                LoadStringFromGzip("threejs/three-r76.js.gz").c_str(),
                LoadStringFromGzip("threejs/hammer-2.0.8.js.gz").c_str(),
                LoadString("threejs/SolveSpaceControls.js").c_str());
    }

    fprintf(f, "var solvespace_model_%s = {\n"
               "  bounds: {\n"
               "    x: %f, y: %f, near: %f, far: %f, z: %f, edgeBias: %f\n"
               "  },\n",
            basename.c_str(),
            largerBoundXY,
            largerBoundXY,
            1.0,
            largerBoundZ * 2,
            largerBoundZ,
            largerBoundZ / 250);

    // Output lighting information.
    fputs("  lights: {\n"
          "    d: [\n", f);

    // Directional.
    int lightCount;
    for(lightCount = 0; lightCount &lt; 2; lightCount++) {
        fprintf(f, "      {\n"
                   "        intensity: %f, direction: [%f, %f, %f]\n"
                   "      },\n",
                SS.lightIntensity[lightCount],
                CO(SS.lightDir[lightCount]));
    }

    // Global Ambience.
    fprintf(f, "    ],\n"
               "    a: %f\n", SS.ambientIntensity);

    for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
        spl.IncrementTagFor(tr-&gt;a);
        spl.IncrementTagFor(tr-&gt;b);
        spl.IncrementTagFor(tr-&gt;c);
    }

    // Output all the vertices.
    SPoint *sp;
    fputs("  },\n"
          "  points: [\n", f);
    for(sp = spl.l.First(); sp; sp = spl.l.NextAfter(sp)) {
        fprintf(f, "    [%f, %f, %f],\n",
                sp-&gt;p.x / SS.exportScale,
                sp-&gt;p.y / SS.exportScale,
                sp-&gt;p.z / SS.exportScale);
    }

    fputs("  ],\n"
          "  faces: [\n", f);
    // And now all the triangular faces, in terms of those vertices.
    // This time we count from zero.
    for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
        fprintf(f, "    [%d, %d, %d],\n",
                spl.IndexForPoint(tr-&gt;a),
                spl.IndexForPoint(tr-&gt;b),
                spl.IndexForPoint(tr-&gt;c));
    }

    // Output face normals.
    fputs("  ],\n"
          "  normals: [\n", f);
    for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
        fprintf(f, "    [[%f, %f, %f], [%f, %f, %f], [%f, %f, %f]],\n",
                CO(tr-&gt;an), CO(tr-&gt;bn), CO(tr-&gt;cn));
    }

    fputs("  ],\n"
          "  colors: [\n", f);
    // Output triangle colors.
    for(tr = sm-&gt;l.First(); tr; tr = sm-&gt;l.NextAfter(tr)) {
        fprintf(f, "    0x%x,\n", tr-&gt;meta.color.ToARGB32());
    }

    fputs("  ],\n"
          "  edges: [\n", f);
    // Output edges. Assume user's model colors do not obscure white edges.
    for(const SOutline &amp;so : sol-&gt;l) {
        if(so.tag == 0) continue;
        fprintf(f, "    [[%f, %f, %f], [%f, %f, %f]],\n",
                so.a.x / SS.exportScale,
                so.a.y / SS.exportScale,
                so.a.z / SS.exportScale,
                so.b.x / SS.exportScale,
                so.b.y / SS.exportScale,
                so.b.z / SS.exportScale);
    }

    fputs("  ]\n};\n", f);

    if(filename.HasExtension("html")) {
        fprintf(f, htmlend,
                basename.c_str(),
                SS.GW.scale,
                CO(SS.GW.offset),
                CO(SS.GW.projUp),
                CO(SS.GW.projRight));
    }

    spl.Clear();
}

//-----------------------------------------------------------------------------
// Export the mesh as a VRML text file / WRL.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122644.90">void Step2dFileWriter::StartPath(RgbaColor strokeRgb, double lineWidth,
                                 bool filled, RgbaColor fillRgb, hStyle hs)
{
}
</t>
<t tx="leo.20191228122644.91">void Step2dFileWriter::FinishPath(RgbaColor strokeRgb, double lineWidth,
                                  bool filled, RgbaColor fillRgb, hStyle hs)
{
}

</t>
<t tx="leo.20191228122644.92">void Step2dFileWriter::Bezier(SBezier *sb) {
    int c = sfw.ExportCurve(sb);
    sfw.curves.Add(&amp;c);
}

</t>
<t tx="leo.20191228122644.93">void Step2dFileWriter::FinishAndCloseFile() {
    sfw.WriteWireframe();
    sfw.WriteFooter();
    fclose(f);
}

</t>
<t tx="leo.20191228122644.94">@path ./src/
//-----------------------------------------------------------------------------
// The symbolic algebra system used to write our constraint equations;
// routines to build expressions in software or from a user-provided string,
// and to compute the partial derivatives that we'll use when write our
// Jacobian matrix.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

ExprVector ExprVector::From(Expr *x, Expr *y, Expr *z) {
    ExprVector r = { x, y, z};
    return r;
}

ExprVector ExprVector::From(Vector vn) {
    ExprVector ve;
    ve.x = Expr::From(vn.x);
    ve.y = Expr::From(vn.y);
    ve.z = Expr::From(vn.z);
    return ve;
}

ExprVector ExprVector::From(hParam x, hParam y, hParam z) {
    ExprVector ve;
    ve.x = Expr::From(x);
    ve.y = Expr::From(y);
    ve.z = Expr::From(z);
    return ve;
}

ExprVector ExprVector::From(double x, double y, double z) {
    ExprVector ve;
    ve.x = Expr::From(x);
    ve.y = Expr::From(y);
    ve.z = Expr::From(z);
    return ve;
}

ExprVector ExprVector::Minus(ExprVector b) const {
    ExprVector r;
    r.x = x-&gt;Minus(b.x);
    r.y = y-&gt;Minus(b.y);
    r.z = z-&gt;Minus(b.z);
    return r;
}

ExprVector ExprVector::Plus(ExprVector b) const {
    ExprVector r;
    r.x = x-&gt;Plus(b.x);
    r.y = y-&gt;Plus(b.y);
    r.z = z-&gt;Plus(b.z);
    return r;
}

Expr *ExprVector::Dot(ExprVector b) const {
    Expr *r;
    r =         x-&gt;Times(b.x);
    r = r-&gt;Plus(y-&gt;Times(b.y));
    r = r-&gt;Plus(z-&gt;Times(b.z));
    return r;
}

ExprVector ExprVector::Cross(ExprVector b) const {
    ExprVector r;
    r.x = (y-&gt;Times(b.z))-&gt;Minus(z-&gt;Times(b.y));
    r.y = (z-&gt;Times(b.x))-&gt;Minus(x-&gt;Times(b.z));
    r.z = (x-&gt;Times(b.y))-&gt;Minus(y-&gt;Times(b.x));
    return r;
}

ExprVector ExprVector::ScaledBy(Expr *s) const {
    ExprVector r;
    r.x = x-&gt;Times(s);
    r.y = y-&gt;Times(s);
    r.z = z-&gt;Times(s);
    return r;
}

ExprVector ExprVector::WithMagnitude(Expr *s) const {
    Expr *m = Magnitude();
    return ScaledBy(s-&gt;Div(m));
}

Expr *ExprVector::Magnitude() const {
    Expr *r;
    r =         x-&gt;Square();
    r = r-&gt;Plus(y-&gt;Square());
    r = r-&gt;Plus(z-&gt;Square());
    return r-&gt;Sqrt();
}

Vector ExprVector::Eval() const {
    Vector r;
    r.x = x-&gt;Eval();
    r.y = y-&gt;Eval();
    r.z = z-&gt;Eval();
    return r;
}

ExprQuaternion ExprQuaternion::From(hParam w, hParam vx, hParam vy, hParam vz) {
    ExprQuaternion q;
    q.w  = Expr::From(w);
    q.vx = Expr::From(vx);
    q.vy = Expr::From(vy);
    q.vz = Expr::From(vz);
    return q;
}

ExprQuaternion ExprQuaternion::From(Expr *w, Expr *vx, Expr *vy, Expr *vz)
{
    ExprQuaternion q;
    q.w = w;
    q.vx = vx;
    q.vy = vy;
    q.vz = vz;
    return q;
}

ExprQuaternion ExprQuaternion::From(Quaternion qn) {
    ExprQuaternion qe;
    qe.w = Expr::From(qn.w);
    qe.vx = Expr::From(qn.vx);
    qe.vy = Expr::From(qn.vy);
    qe.vz = Expr::From(qn.vz);
    return qe;
}

ExprVector ExprQuaternion::RotationU() const {
    ExprVector u;
    Expr *two = Expr::From(2);

    u.x = w-&gt;Square();
    u.x = (u.x)-&gt;Plus(vx-&gt;Square());
    u.x = (u.x)-&gt;Minus(vy-&gt;Square());
    u.x = (u.x)-&gt;Minus(vz-&gt;Square());

    u.y = two-&gt;Times(w-&gt;Times(vz));
    u.y = (u.y)-&gt;Plus(two-&gt;Times(vx-&gt;Times(vy)));

    u.z = two-&gt;Times(vx-&gt;Times(vz));
    u.z = (u.z)-&gt;Minus(two-&gt;Times(w-&gt;Times(vy)));

    return u;
}

ExprVector ExprQuaternion::RotationV() const {
    ExprVector v;
    Expr *two = Expr::From(2);

    v.x = two-&gt;Times(vx-&gt;Times(vy));
    v.x = (v.x)-&gt;Minus(two-&gt;Times(w-&gt;Times(vz)));

    v.y = w-&gt;Square();
    v.y = (v.y)-&gt;Minus(vx-&gt;Square());
    v.y = (v.y)-&gt;Plus(vy-&gt;Square());
    v.y = (v.y)-&gt;Minus(vz-&gt;Square());

    v.z = two-&gt;Times(w-&gt;Times(vx));
    v.z = (v.z)-&gt;Plus(two-&gt;Times(vy-&gt;Times(vz)));

    return v;
}

ExprVector ExprQuaternion::RotationN() const {
    ExprVector n;
    Expr *two = Expr::From(2);

    n.x =              two-&gt;Times( w-&gt;Times(vy));
    n.x = (n.x)-&gt;Plus (two-&gt;Times(vx-&gt;Times(vz)));

    n.y =              two-&gt;Times(vy-&gt;Times(vz));
    n.y = (n.y)-&gt;Minus(two-&gt;Times( w-&gt;Times(vx)));

    n.z =               w-&gt;Square();
    n.z = (n.z)-&gt;Minus(vx-&gt;Square());
    n.z = (n.z)-&gt;Minus(vy-&gt;Square());
    n.z = (n.z)-&gt;Plus (vz-&gt;Square());

    return n;
}

ExprVector ExprQuaternion::Rotate(ExprVector p) const {
    // Express the point in the new basis
    return (RotationU().ScaledBy(p.x)).Plus(
            RotationV().ScaledBy(p.y)).Plus(
            RotationN().ScaledBy(p.z));
}

ExprQuaternion ExprQuaternion::Times(ExprQuaternion b) const {
    Expr *sa = w, *sb = b.w;
    ExprVector va = { vx, vy, vz };
    ExprVector vb = { b.vx, b.vy, b.vz };

    ExprQuaternion r;
    r.w = (sa-&gt;Times(sb))-&gt;Minus(va.Dot(vb));
    ExprVector vr = vb.ScaledBy(sa).Plus(
                    va.ScaledBy(sb).Plus(
                    va.Cross(vb)));
    r.vx = vr.x;
    r.vy = vr.y;
    r.vz = vr.z;
    return r;
}

Expr *ExprQuaternion::Magnitude() const {
    return ((w -&gt;Square())-&gt;Plus(
            (vx-&gt;Square())-&gt;Plus(
            (vy-&gt;Square())-&gt;Plus(
            (vz-&gt;Square())))))-&gt;Sqrt();
}


Expr *Expr::From(hParam p) {
    Expr *r = AllocExpr();
    r-&gt;op = Op::PARAM;
    r-&gt;parh = p;
    return r;
}

Expr *Expr::From(double v) {
    // Statically allocate common constants.
    // Note: this is only valid because AllocExpr() uses AllocTemporary(),
    // and Expr* is never explicitly freed.

    if(v == 0.0) {
        static Expr zero(0.0);
        return &amp;zero;
    }

    if(v == 1.0) {
        static Expr one(1.0);
        return &amp;one;
    }

    if(v == -1.0) {
        static Expr mone(-1.0);
        return &amp;mone;
    }

    if(v == 0.5) {
        static Expr half(0.5);
        return &amp;half;
    }

    if(v == -0.5) {
        static Expr mhalf(-0.5);
        return &amp;mhalf;
    }

    Expr *r = AllocExpr();
    r-&gt;op = Op::CONSTANT;
    r-&gt;v = v;
    return r;
}

Expr *Expr::AnyOp(Op newOp, Expr *b) {
    Expr *r = AllocExpr();
    r-&gt;op = newOp;
    r-&gt;a = this;
    r-&gt;b = b;
    return r;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122644.95">int Expr::Children() const {
    switch(op) {
        case Op::PARAM:
        case Op::PARAM_PTR:
        case Op::CONSTANT:
        case Op::VARIABLE:
            return 0;

        case Op::PLUS:
        case Op::MINUS:
        case Op::TIMES:
        case Op::DIV:
            return 2;

        case Op::NEGATE:
        case Op::SQRT:
        case Op::SQUARE:
        case Op::SIN:
        case Op::COS:
        case Op::ASIN:
        case Op::ACOS:
            return 1;
    }
    ssassert(false, "Unexpected operation");
}

</t>
<t tx="leo.20191228122644.96">int Expr::Nodes() const {
    switch(Children()) {
        case 0: return 1;
        case 1: return 1 + a-&gt;Nodes();
        case 2: return 1 + a-&gt;Nodes() + b-&gt;Nodes();
        default: ssassert(false, "Unexpected children count");
    }
}

Expr *Expr::DeepCopy() const {
    Expr *n = AllocExpr();
    *n = *this;
    int c = n-&gt;Children();
    if(c &gt; 0) n-&gt;a = a-&gt;DeepCopy();
    if(c &gt; 1) n-&gt;b = b-&gt;DeepCopy();
    return n;
}

Expr *Expr::DeepCopyWithParamsAsPointers(IdList&lt;Param,hParam&gt; *firstTry,
    IdList&lt;Param,hParam&gt; *thenTry) const
{
    Expr *n = AllocExpr();
    if(op == Op::PARAM) {
        // A param that is referenced by its hParam gets rewritten to go
        // straight in to the parameter table with a pointer, or simply
        // into a constant if it's already known.
        Param *p = firstTry-&gt;FindByIdNoOops(parh);
        if(!p) p = thenTry-&gt;FindById(parh);
        if(p-&gt;known) {
            n-&gt;op = Op::CONSTANT;
            n-&gt;v = p-&gt;val;
        } else {
            n-&gt;op = Op::PARAM_PTR;
            n-&gt;parp = p;
        }
        return n;
    }

    *n = *this;
    int c = n-&gt;Children();
    if(c &gt; 0) n-&gt;a = a-&gt;DeepCopyWithParamsAsPointers(firstTry, thenTry);
    if(c &gt; 1) n-&gt;b = b-&gt;DeepCopyWithParamsAsPointers(firstTry, thenTry);
    return n;
}

double Expr::Eval() const {
    switch(op) {
        case Op::PARAM:         return SK.GetParam(parh)-&gt;val;
        case Op::PARAM_PTR:     return parp-&gt;val;

        case Op::CONSTANT:      return v;
        case Op::VARIABLE:      ssassert(false, "Not supported yet");

        case Op::PLUS:          return a-&gt;Eval() + b-&gt;Eval();
        case Op::MINUS:         return a-&gt;Eval() - b-&gt;Eval();
        case Op::TIMES:         return a-&gt;Eval() * b-&gt;Eval();
        case Op::DIV:           return a-&gt;Eval() / b-&gt;Eval();

        case Op::NEGATE:        return -(a-&gt;Eval());
        case Op::SQRT:          return sqrt(a-&gt;Eval());
        case Op::SQUARE:        { double r = a-&gt;Eval(); return r*r; }
        case Op::SIN:           return sin(a-&gt;Eval());
        case Op::COS:           return cos(a-&gt;Eval());
        case Op::ACOS:          return acos(a-&gt;Eval());
        case Op::ASIN:          return asin(a-&gt;Eval());
    }
    ssassert(false, "Unexpected operation");
}

Expr *Expr::PartialWrt(hParam p) const {
    Expr *da, *db;

    switch(op) {
        case Op::PARAM_PTR: return From(p == parp-&gt;h ? 1 : 0);
        case Op::PARAM:     return From(p == parh ? 1 : 0);

        case Op::CONSTANT:  return From(0.0);
        case Op::VARIABLE:  ssassert(false, "Not supported yet");

        case Op::PLUS:      return (a-&gt;PartialWrt(p))-&gt;Plus(b-&gt;PartialWrt(p));
        case Op::MINUS:     return (a-&gt;PartialWrt(p))-&gt;Minus(b-&gt;PartialWrt(p));

        case Op::TIMES:
            da = a-&gt;PartialWrt(p);
            db = b-&gt;PartialWrt(p);
            return (a-&gt;Times(db))-&gt;Plus(b-&gt;Times(da));

        case Op::DIV:
            da = a-&gt;PartialWrt(p);
            db = b-&gt;PartialWrt(p);
            return ((da-&gt;Times(b))-&gt;Minus(a-&gt;Times(db)))-&gt;Div(b-&gt;Square());

        case Op::SQRT:
            return (From(0.5)-&gt;Div(a-&gt;Sqrt()))-&gt;Times(a-&gt;PartialWrt(p));

        case Op::SQUARE:
            return (From(2.0)-&gt;Times(a))-&gt;Times(a-&gt;PartialWrt(p));

        case Op::NEGATE:    return (a-&gt;PartialWrt(p))-&gt;Negate();
        case Op::SIN:       return (a-&gt;Cos())-&gt;Times(a-&gt;PartialWrt(p));
        case Op::COS:       return ((a-&gt;Sin())-&gt;Times(a-&gt;PartialWrt(p)))-&gt;Negate();

        case Op::ASIN:
            return (From(1)-&gt;Div((From(1)-&gt;Minus(a-&gt;Square()))-&gt;Sqrt()))
                        -&gt;Times(a-&gt;PartialWrt(p));
        case Op::ACOS:
            return (From(-1)-&gt;Div((From(1)-&gt;Minus(a-&gt;Square()))-&gt;Sqrt()))
                        -&gt;Times(a-&gt;PartialWrt(p));
    }
    ssassert(false, "Unexpected operation");
}

uint64_t Expr::ParamsUsed() const {
    uint64_t r = 0;
    if(op == Op::PARAM)     r |= ((uint64_t)1 &lt;&lt; (parh.v % 61));
    if(op == Op::PARAM_PTR) r |= ((uint64_t)1 &lt;&lt; (parp-&gt;h.v % 61));

    int c = Children();
    if(c &gt;= 1)          r |= a-&gt;ParamsUsed();
    if(c &gt;= 2)          r |= b-&gt;ParamsUsed();
    return r;
}

</t>
<t tx="leo.20191228122644.97">bool Expr::DependsOn(hParam p) const {
    if(op == Op::PARAM)     return (parh    == p);
    if(op == Op::PARAM_PTR) return (parp-&gt;h == p);

    int c = Children();
    if(c == 1)          return a-&gt;DependsOn(p);
    if(c == 2)          return a-&gt;DependsOn(p) || b-&gt;DependsOn(p);
    return false;
}

</t>
<t tx="leo.20191228122644.98">bool Expr::Tol(double a, double b) {
    return fabs(a - b) &lt; 0.001;
}
Expr *Expr::FoldConstants() {
    Expr *n = AllocExpr();
    *n = *this;

    int c = Children();
    if(c &gt;= 1) n-&gt;a = a-&gt;FoldConstants();
    if(c &gt;= 2) n-&gt;b = b-&gt;FoldConstants();

    switch(op) {
        case Op::PARAM_PTR:
        case Op::PARAM:
        case Op::CONSTANT:
        case Op::VARIABLE:
            break;

        case Op::MINUS:
        case Op::TIMES:
        case Op::DIV:
        case Op::PLUS:
            // If both ops are known, then we can evaluate immediately
            if(n-&gt;a-&gt;op == Op::CONSTANT &amp;&amp; n-&gt;b-&gt;op == Op::CONSTANT) {
                double nv = n-&gt;Eval();
                n-&gt;op = Op::CONSTANT;
                n-&gt;v = nv;
                break;
            }
            // x + 0 = 0 + x = x
            if(op == Op::PLUS &amp;&amp; n-&gt;b-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;b-&gt;v, 0)) {
                *n = *(n-&gt;a); break;
            }
            if(op == Op::PLUS &amp;&amp; n-&gt;a-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;a-&gt;v, 0)) {
                *n = *(n-&gt;b); break;
            }
            // 1*x = x*1 = x
            if(op == Op::TIMES &amp;&amp; n-&gt;b-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;b-&gt;v, 1)) {
                *n = *(n-&gt;a); break;
            }
            if(op == Op::TIMES &amp;&amp; n-&gt;a-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;a-&gt;v, 1)) {
                *n = *(n-&gt;b); break;
            }
            // 0*x = x*0 = 0
            if(op == Op::TIMES &amp;&amp; n-&gt;b-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;b-&gt;v, 0)) {
                n-&gt;op = Op::CONSTANT; n-&gt;v = 0; break;
            }
            if(op == Op::TIMES &amp;&amp; n-&gt;a-&gt;op == Op::CONSTANT &amp;&amp; Tol(n-&gt;a-&gt;v, 0)) {
                n-&gt;op = Op::CONSTANT; n-&gt;v = 0; break;
            }

            break;

        case Op::SQRT:
        case Op::SQUARE:
        case Op::NEGATE:
        case Op::SIN:
        case Op::COS:
        case Op::ASIN:
        case Op::ACOS:
            if(n-&gt;a-&gt;op == Op::CONSTANT) {
                double nv = n-&gt;Eval();
                n-&gt;op = Op::CONSTANT;
                n-&gt;v = nv;
            }
            break;
    }
    return n;
}

</t>
<t tx="leo.20191228122644.99">void Expr::Substitute(hParam oldh, hParam newh) {
    ssassert(op != Op::PARAM_PTR, "Expected an expression that refer to params via handles");

    if(op == Op::PARAM &amp;&amp; parh == oldh) {
        parh = newh;
    }
    int c = Children();
    if(c &gt;= 1) a-&gt;Substitute(oldh, newh);
    if(c &gt;= 2) b-&gt;Substitute(oldh, newh);
}

//-----------------------------------------------------------------------------
// If the expression references only one parameter that appears in pl, then
// return that parameter. If no param is referenced, then return NO_PARAMS.
// If multiple params are referenced, then return MULTIPLE_PARAMS.
//-----------------------------------------------------------------------------
const hParam Expr::NO_PARAMS       = { 0 };
const hParam Expr::MULTIPLE_PARAMS = { 1 };
hParam Expr::ReferencedParams(ParamList *pl) const {
    if(op == Op::PARAM) {
        if(pl-&gt;FindByIdNoOops(parh)) {
            return parh;
        } else {
            return NO_PARAMS;
        }
    }
    ssassert(op != Op::PARAM_PTR, "Expected an expression that refer to params via handles");

    int c = Children();
    if(c == 0) {
        return NO_PARAMS;
    } else if(c == 1) {
        return a-&gt;ReferencedParams(pl);
    } else if(c == 2) {
        hParam pa, pb;
        pa = a-&gt;ReferencedParams(pl);
        pb = b-&gt;ReferencedParams(pl);
        if(pa == NO_PARAMS) {
            return pb;
        } else if(pb == NO_PARAMS) {
            return pa;
        } else if(pa == pb) {
            return pa; // either, doesn't matter
        } else {
            return MULTIPLE_PARAMS;
        }
    } else ssassert(false, "Unexpected children count");
}


//-----------------------------------------------------------------------------
// Routines to pretty-print an expression. Mostly for debugging.
//-----------------------------------------------------------------------------

std::string Expr::Print() const {
    char c;
    switch(op) {
        case Op::PARAM:     return ssprintf("param(%08x)", parh.v);
        case Op::PARAM_PTR: return ssprintf("param(p%08x)", parp-&gt;h.v);

        case Op::CONSTANT:  return ssprintf("%.3f", v);
        case Op::VARIABLE:  return "(var)";

        case Op::PLUS:      c = '+'; goto p;
        case Op::MINUS:     c = '-'; goto p;
        case Op::TIMES:     c = '*'; goto p;
        case Op::DIV:       c = '/'; goto p;
p:
            return "(" + a-&gt;Print() + " " + c + " " + b-&gt;Print() + ")";
            break;

        case Op::NEGATE:    return "(- " + a-&gt;Print() + ")";
        case Op::SQRT:      return "(sqrt " + a-&gt;Print() + ")";
        case Op::SQUARE:    return "(square " + a-&gt;Print() + ")";
        case Op::SIN:       return "(sin " + a-&gt;Print() + ")";
        case Op::COS:       return "(cos " + a-&gt;Print() + ")";
        case Op::ASIN:      return "(asin " + a-&gt;Print() + ")";
        case Op::ACOS:      return "(acos " + a-&gt;Print() + ")";
    }
    ssassert(false, "Unexpected operation");
}


//-----------------------------------------------------------------------------
// A parser; convert a string to an expression. Infix notation, with the
// usual shift/reduce approach. I had great hopes for user-entered eq
// constraints, but those don't seem very useful, so right now this is just
// to provide calculator type functionality wherever numbers are entered.
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122645.1">@path ./src/
//-----------------------------------------------------------------------------
// Top-level implementation of the program's main window, in which a graphical
// representation of the model is drawn and edited by the user.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

typedef void MenuHandler(Command id);
using MenuKind = Platform::MenuItem::Indicator;
struct MenuEntry {
    int          level;          // 0 == on menu bar, 1 == one level down
    const char  *label;          // or NULL for a separator
    Command      cmd;            // command ID
    int          accel;          // keyboard accelerator
    MenuKind     kind;
    MenuHandler *fn;
};

#define mView (&amp;GraphicsWindow::MenuView)
#define mEdit (&amp;GraphicsWindow::MenuEdit)
#define mClip (&amp;GraphicsWindow::MenuClipboard)
#define mReq  (&amp;GraphicsWindow::MenuRequest)
#define mCon  (&amp;Constraint::MenuConstrain)
#define mFile (&amp;SolveSpaceUI::MenuFile)
#define mGrp  (&amp;Group::MenuGroup)
#define mAna  (&amp;SolveSpaceUI::MenuAnalyze)
#define mHelp (&amp;SolveSpaceUI::MenuHelp)
#define SHIFT_MASK 0x100
#define CTRL_MASK  0x200
#define FN_MASK    0x400

#define S     SHIFT_MASK
#define C     CTRL_MASK
#define F     FN_MASK
#define KN    MenuKind::NONE
#define KC    MenuKind::CHECK_MARK
#define KR    MenuKind::RADIO_MARK
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122645.10">void GraphicsWindow::AnimateOnto(Quaternion quatf, Vector offsetf) {
    // Get our initial orientation and translation.
    Quaternion quat0 = Quaternion::From(projRight, projUp);
    Vector offset0 = offset;

    // Make sure we take the shorter of the two possible paths.
    double mp = (quatf.Minus(quat0)).Magnitude();
    double mm = (quatf.Plus(quat0)).Magnitude();
    if(mp &gt; mm) {
        quatf = quatf.ScaledBy(-1);
        mp = mm;
    }
    double mo = (offset0.Minus(offsetf)).Magnitude()*scale;

    // Animate transition, unless it's a tiny move.
    int64_t t0 = GetMilliseconds();
    @others
}

</t>
<t tx="leo.20191228122645.100">void addPoint(const DRW_Point &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    checkCoord(data.basePoint);
}

</t>
<t tx="leo.20191228122645.101">void addLine(const DRW_Line &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    checkCoord(data.basePoint);
    checkCoord(data.secPoint);
}

</t>
<t tx="leo.20191228122645.102">void addArc(const DRW_Arc &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    checkCoord(data.basePoint);
}

</t>
<t tx="leo.20191228122645.103">void addCircle(const DRW_Circle &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    checkCoord(data.basePoint);
}

</t>
<t tx="leo.20191228122645.104">void addPolyline(const DRW_Polyline &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    for(size_t i = 0; i &lt; data.vertlist.size(); i++) {
        checkCoord(data.vertlist[i]-&gt;basePoint);
    }
}

</t>
<t tx="leo.20191228122645.105">void addSpline(const DRW_Spline *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(data-&gt;degree != 3) return;
    for(int i = 0; i &lt; 4; i++) {
        checkCoord(*data-&gt;controllist[i]);
    }
}

</t>
<t tx="leo.20191228122645.106">void addInsert(const DRW_Insert &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    checkCoord(data.basePoint);
}

</t>
<t tx="leo.20191228122645.107">void addMText(const DRW_MText &amp;data) override {
    if(data.space != DRW::ModelSpace) return;

    DRW_MText text = data;
    text.secPoint = text.basePoint;
    addText(text);
}

</t>
<t tx="leo.20191228122645.108">void addText(const DRW_Text &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    checkCoord(data.basePoint);
    checkCoord(data.secPoint);
}

</t>
<t tx="leo.20191228122645.109">void addDimAlign(const DRW_DimAligned *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    checkCoord(data-&gt;getDef1Point());
    checkCoord(data-&gt;getDef2Point());
    checkCoord(data-&gt;getTextPoint());
}

</t>
<t tx="leo.20191228122645.11">int32_t dt = (mp &lt; 0.01 &amp;&amp; mo &lt; 10) ? (-20) :
                 (int32_t)(100 + 1000*mp + 0.4*mo);
// Don't ever animate for longer than 2000 ms; we can get absurdly
// long translations (as measured in pixels) if the user zooms out, moves,
// and then zooms in again.
if(dt &gt; 2000) dt = 2000;
Quaternion dq = quatf.Times(quat0.Inverse());

if(!animateTimer) {
    animateTimer = Platform::CreateTimer();
}
animateTimer-&gt;onTimeout = [=] {
    int64_t tn = GetMilliseconds();
    if((tn - t0) &lt; dt) {
        animateTimer-&gt;RunAfterNextFrame();

        double s = (tn - t0)/((double)dt);
        offset = (offset0.ScaledBy(1 - s)).Plus(offsetf.ScaledBy(s));
        Quaternion quat = (dq.ToThe(s)).Times(quat0).WithMagnitude(1);

        projRight = quat.RotationU();
        projUp    = quat.RotationV();
    } else {
        projRight = quatf.RotationU();
        projUp    = quatf.RotationV();
        offset    = offsetf;
    }
    window-&gt;Invalidate();
};
animateTimer-&gt;RunAfterNextFrame();
</t>
<t tx="leo.20191228122645.110">void addDimLinear(const DRW_DimLinear *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    checkCoord(data-&gt;getDef1Point());
    checkCoord(data-&gt;getDef2Point());
    checkCoord(data-&gt;getTextPoint());
}

</t>
<t tx="leo.20191228122645.111">void addDimAngular(const DRW_DimAngular *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    checkCoord(data-&gt;getFirstLine1());
    checkCoord(data-&gt;getFirstLine2());
    checkCoord(data-&gt;getSecondLine1());
    checkCoord(data-&gt;getSecondLine2());
    checkCoord(data-&gt;getTextPoint());
}

</t>
<t tx="leo.20191228122645.112">void addDimRadial(const DRW_DimRadial *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    checkCoord(data-&gt;getCenterPoint());
    checkCoord(data-&gt;getDiameterPoint());
    checkCoord(data-&gt;getTextPoint());
}

</t>
<t tx="leo.20191228122645.113">void addDimDiametric(const DRW_DimDiametric *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    checkCoord(data-&gt;getDiameter1Point());
    checkCoord(data-&gt;getDiameter2Point());
    checkCoord(data-&gt;getTextPoint());
}

</t>
<t tx="leo.20191228122645.114">void addDimAngular3P(const DRW_DimAngular3p *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    DRW_DimAngular dim = *static_cast&lt;const DRW_Dimension *&gt;(data);

    dim.setFirstLine1(data-&gt;getVertexPoint());
    dim.setFirstLine2(data-&gt;getFirstLine());
    dim.setSecondLine1(data-&gt;getVertexPoint());
    dim.setSecondLine2(data-&gt;getSecondLine());
    addDimAngular(&amp;dim);
}

</t>
<t tx="leo.20191228122645.115">void checkCoord(const DRW_Coord &amp;coord) {
    if(fabs(coord.z) &gt; LENGTH_EPS) {
        is3d = true;
    }
}
</t>
<t tx="leo.20191228122645.116">static void
ImportDwgDxf(const Platform::Path &amp;filename,
             const std::function&lt;bool(const std::string &amp;data, DRW_Interface *intf)&gt; &amp;read) {
    std::string fileType = ToUpper(filename.Extension());

    std::string data;
    if(!ReadFile(filename, &amp;data)) {
        Error("Couldn't read from '%s'", filename.raw.c_str());
        return;
    }

    bool asConstruction = true;
    if(SS.GW.LockedInWorkplane()) {
        DxfCheck3D checker = {};
        read(data, &amp;checker);
        if(checker.is3d) {
            Message("This %s file contains entities with non-zero Z coordinate; "
                    "the entire file will be imported as construction entities in 3d.",
                    fileType.c_str());
            SS.GW.SetWorkplaneFreeIn3d();
            SS.GW.EnsureValidActives();
        } else {
            asConstruction = false;
        }
    }

    SS.UndoRemember();

    DxfImport importer = {};
    importer.asConstruction = asConstruction;
    importer.clearBlockTransform();
    if(!read(data, &amp;importer)) {
        Error("Corrupted %s file.", fileType.c_str());
        return;
    }
    if(importer.unknownEntities &gt; 0) {
        Message("%u %s entities of unknown type were ignored.",
                importer.unknownEntities, fileType.c_str());
    }
}

</t>
<t tx="leo.20191228122645.117">void ImportDxf(const Platform::Path &amp;filename) {
    ImportDwgDxf(filename, [](const std::string &amp;data, DRW_Interface *intf) {
        std::stringstream stream(data);
        return dxfRW().read(stream, intf, /*ext=*/false);
    });
}

</t>
<t tx="leo.20191228122645.118">void ImportDwg(const Platform::Path &amp;filename) {
    ImportDwgDxf(filename, [](const std::string &amp;data, DRW_Interface *intf) {
        std::stringstream stream(data);
        return dwgR().read(stream, intf, /*ext=*/false);
    });
}

}
</t>
<t tx="leo.20191228122645.119">@path ./src/
//-----------------------------------------------------------------------------
// A library wrapper around SolveSpace, to permit someone to use its constraint
// solver without coupling their program too much to SolveSpace's internals.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"
#define EXPORT_DLL
#include &lt;slvs.h&gt;

Sketch SolveSpace::SK = {};
static System SYS;

static int IsInit = 0;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122645.12">void GraphicsWindow::HandlePointForZoomToFit(Vector p, Point2d *pmax, Point2d *pmin,
                                             double *wmin, bool usePerspective,
                                             const Camera &amp;camera)
{
    double w;
    Vector pp = camera.ProjectPoint4(p, &amp;w);
    // If usePerspective is true, then we calculate a perspective projection of the point.
    // If not, then we do a parallel projection regardless of the current
    // scale factor.
    if(usePerspective) {
        pp = pp.ScaledBy(1.0/w);
    }

    pmax-&gt;x = max(pmax-&gt;x, pp.x);
    pmax-&gt;y = max(pmax-&gt;y, pp.y);
    pmin-&gt;x = min(pmin-&gt;x, pp.x);
    pmin-&gt;y = min(pmin-&gt;y, pp.y);
    *wmin = min(*wmin, w);
}
</t>
<t tx="leo.20191228122645.120">void SolveSpace::Platform::FatalError(const std::string &amp;message) {
    fprintf(stderr, "%s", message.c_str());
    abort();
}

</t>
<t tx="leo.20191228122645.121">void Group::GenerateEquations(IdList&lt;Equation,hEquation&gt; *) {
    // Nothing to do for now.
}

</t>
<t tx="leo.20191228122645.122">extern "C" {

@others
} /* extern "C" */
</t>
<t tx="leo.20191228122645.123">void Slvs_QuaternionU(double qw, double qx, double qy, double qz,
                         double *x, double *y, double *z)
{
    Quaternion q = Quaternion::From(qw, qx, qy, qz);
    Vector v = q.RotationU();
    *x = v.x;
    *y = v.y;
    *z = v.z;
}

</t>
<t tx="leo.20191228122645.124">void Slvs_QuaternionV(double qw, double qx, double qy, double qz,
                         double *x, double *y, double *z)
{
    Quaternion q = Quaternion::From(qw, qx, qy, qz);
    Vector v = q.RotationV();
    *x = v.x;
    *y = v.y;
    *z = v.z;
}

</t>
<t tx="leo.20191228122645.125">void Slvs_QuaternionN(double qw, double qx, double qy, double qz,
                         double *x, double *y, double *z)
{
    Quaternion q = Quaternion::From(qw, qx, qy, qz);
    Vector v = q.RotationN();
    *x = v.x;
    *y = v.y;
    *z = v.z;
}

</t>
<t tx="leo.20191228122645.126">void Slvs_MakeQuaternion(double ux, double uy, double uz,
                         double vx, double vy, double vz,
                         double *qw, double *qx, double *qy, double *qz)
{
    Vector u = Vector::From(ux, uy, uz),
           v = Vector::From(vx, vy, vz);
    Quaternion q = Quaternion::From(u, v);
    *qw = q.w;
    *qx = q.vx;
    *qy = q.vy;
    *qz = q.vz;
}

</t>
<t tx="leo.20191228122645.127">void Slvs_Solve(Slvs_System *ssys, Slvs_hGroup shg)
{
    if(!IsInit) {
        InitPlatform(0, NULL);
        IsInit = 1;
    }

    int i;
    for(i = 0; i &lt; ssys-&gt;params; i++) {
        Slvs_Param *sp = &amp;(ssys-&gt;param[i]);
        Param p = {};

        p.h.v = sp-&gt;h;
        p.val = sp-&gt;val;
        SK.param.Add(&amp;p);
        if(sp-&gt;group == shg) {
            SYS.param.Add(&amp;p);
        }
    }

    for(i = 0; i &lt; ssys-&gt;entities; i++) {
        Slvs_Entity *se = &amp;(ssys-&gt;entity[i]);
        EntityBase e = {};

        switch(se-&gt;type) {
case SLVS_E_POINT_IN_3D:        e.type = Entity::Type::POINT_IN_3D; break;
case SLVS_E_POINT_IN_2D:        e.type = Entity::Type::POINT_IN_2D; break;
case SLVS_E_NORMAL_IN_3D:       e.type = Entity::Type::NORMAL_IN_3D; break;
case SLVS_E_NORMAL_IN_2D:       e.type = Entity::Type::NORMAL_IN_2D; break;
case SLVS_E_DISTANCE:           e.type = Entity::Type::DISTANCE; break;
case SLVS_E_WORKPLANE:          e.type = Entity::Type::WORKPLANE; break;
case SLVS_E_LINE_SEGMENT:       e.type = Entity::Type::LINE_SEGMENT; break;
case SLVS_E_CUBIC:              e.type = Entity::Type::CUBIC; break;
case SLVS_E_CIRCLE:             e.type = Entity::Type::CIRCLE; break;
case SLVS_E_ARC_OF_CIRCLE:      e.type = Entity::Type::ARC_OF_CIRCLE; break;

default: dbp("bad entity type %d", se-&gt;type); return;
        }
        e.h.v           = se-&gt;h;
        e.group.v       = se-&gt;group;
        e.workplane.v   = se-&gt;wrkpl;
        e.point[0].v    = se-&gt;point[0];
        e.point[1].v    = se-&gt;point[1];
        e.point[2].v    = se-&gt;point[2];
        e.point[3].v    = se-&gt;point[3];
        e.normal.v      = se-&gt;normal;
        e.distance.v    = se-&gt;distance;
        e.param[0].v    = se-&gt;param[0];
        e.param[1].v    = se-&gt;param[1];
        e.param[2].v    = se-&gt;param[2];
        e.param[3].v    = se-&gt;param[3];

        SK.entity.Add(&amp;e);
    }
    IdList&lt;Param, hParam&gt; params = {};
    for(i = 0; i &lt; ssys-&gt;constraints; i++) {
        Slvs_Constraint *sc = &amp;(ssys-&gt;constraint[i]);
        ConstraintBase c = {};

        Constraint::Type t;
        switch(sc-&gt;type) {
case SLVS_C_POINTS_COINCIDENT:  t = Constraint::Type::POINTS_COINCIDENT; break;
case SLVS_C_PT_PT_DISTANCE:     t = Constraint::Type::PT_PT_DISTANCE; break;
case SLVS_C_PT_PLANE_DISTANCE:  t = Constraint::Type::PT_PLANE_DISTANCE; break;
case SLVS_C_PT_LINE_DISTANCE:   t = Constraint::Type::PT_LINE_DISTANCE; break;
case SLVS_C_PT_FACE_DISTANCE:   t = Constraint::Type::PT_FACE_DISTANCE; break;
case SLVS_C_PT_IN_PLANE:        t = Constraint::Type::PT_IN_PLANE; break;
case SLVS_C_PT_ON_LINE:         t = Constraint::Type::PT_ON_LINE; break;
case SLVS_C_PT_ON_FACE:         t = Constraint::Type::PT_ON_FACE; break;
case SLVS_C_EQUAL_LENGTH_LINES: t = Constraint::Type::EQUAL_LENGTH_LINES; break;
case SLVS_C_LENGTH_RATIO:       t = Constraint::Type::LENGTH_RATIO; break;
case SLVS_C_EQ_LEN_PT_LINE_D:   t = Constraint::Type::EQ_LEN_PT_LINE_D; break;
case SLVS_C_EQ_PT_LN_DISTANCES: t = Constraint::Type::EQ_PT_LN_DISTANCES; break;
case SLVS_C_EQUAL_ANGLE:        t = Constraint::Type::EQUAL_ANGLE; break;
case SLVS_C_EQUAL_LINE_ARC_LEN: t = Constraint::Type::EQUAL_LINE_ARC_LEN; break;
case SLVS_C_LENGTH_DIFFERENCE:  t = Constraint::Type::LENGTH_DIFFERENCE; break;
case SLVS_C_SYMMETRIC:          t = Constraint::Type::SYMMETRIC; break;
case SLVS_C_SYMMETRIC_HORIZ:    t = Constraint::Type::SYMMETRIC_HORIZ; break;
case SLVS_C_SYMMETRIC_VERT:     t = Constraint::Type::SYMMETRIC_VERT; break;
case SLVS_C_SYMMETRIC_LINE:     t = Constraint::Type::SYMMETRIC_LINE; break;
case SLVS_C_AT_MIDPOINT:        t = Constraint::Type::AT_MIDPOINT; break;
case SLVS_C_HORIZONTAL:         t = Constraint::Type::HORIZONTAL; break;
case SLVS_C_VERTICAL:           t = Constraint::Type::VERTICAL; break;
case SLVS_C_DIAMETER:           t = Constraint::Type::DIAMETER; break;
case SLVS_C_PT_ON_CIRCLE:       t = Constraint::Type::PT_ON_CIRCLE; break;
case SLVS_C_SAME_ORIENTATION:   t = Constraint::Type::SAME_ORIENTATION; break;
case SLVS_C_ANGLE:              t = Constraint::Type::ANGLE; break;
case SLVS_C_PARALLEL:           t = Constraint::Type::PARALLEL; break;
case SLVS_C_PERPENDICULAR:      t = Constraint::Type::PERPENDICULAR; break;
case SLVS_C_ARC_LINE_TANGENT:   t = Constraint::Type::ARC_LINE_TANGENT; break;
case SLVS_C_CUBIC_LINE_TANGENT: t = Constraint::Type::CUBIC_LINE_TANGENT; break;
case SLVS_C_EQUAL_RADIUS:       t = Constraint::Type::EQUAL_RADIUS; break;
case SLVS_C_PROJ_PT_DISTANCE:   t = Constraint::Type::PROJ_PT_DISTANCE; break;
case SLVS_C_WHERE_DRAGGED:      t = Constraint::Type::WHERE_DRAGGED; break;
case SLVS_C_CURVE_CURVE_TANGENT:t = Constraint::Type::CURVE_CURVE_TANGENT; break;

default: dbp("bad constraint type %d", sc-&gt;type); return;
        }

        c.type = t;

        c.h.v           = sc-&gt;h;
        c.group.v       = sc-&gt;group;
        c.workplane.v   = sc-&gt;wrkpl;
        c.valA          = sc-&gt;valA;
        c.ptA.v         = sc-&gt;ptA;
        c.ptB.v         = sc-&gt;ptB;
        c.entityA.v     = sc-&gt;entityA;
        c.entityB.v     = sc-&gt;entityB;
        c.entityC.v     = sc-&gt;entityC;
        c.entityD.v     = sc-&gt;entityD;
        c.other         = (sc-&gt;other) ? true : false;
        c.other2        = (sc-&gt;other2) ? true : false;

        c.Generate(&amp;params);
        if(!params.IsEmpty()) {
            for(Param &amp;p : params) {
                p.h = SK.param.AddAndAssignId(&amp;p);
                c.valP = p.h;
                SYS.param.Add(&amp;p);
            }
            params.Clear();
            c.ModifyToSatisfy();
        }

        SK.constraint.Add(&amp;c);
    }

    for(i = 0; i &lt; (int)arraylen(ssys-&gt;dragged); i++) {
        if(ssys-&gt;dragged[i]) {
            hParam hp = { ssys-&gt;dragged[i] };
            SYS.dragged.Add(&amp;hp);
        }
    }

    Group g = {};
    g.h.v = shg;

    List&lt;hConstraint&gt; bad = {};

    // Now we're finally ready to solve!
    bool andFindBad = ssys-&gt;calculateFaileds ? true : false;
    SolveResult how = SYS.Solve(&amp;g, NULL, &amp;(ssys-&gt;dof), &amp;bad, andFindBad, /*andFindFree=*/false);

    switch(how) {
        case SolveResult::OKAY:
            ssys-&gt;result = SLVS_RESULT_OKAY;
            break;

        case SolveResult::DIDNT_CONVERGE:
            ssys-&gt;result = SLVS_RESULT_DIDNT_CONVERGE;
            break;

        case SolveResult::REDUNDANT_DIDNT_CONVERGE:
        case SolveResult::REDUNDANT_OKAY:
            ssys-&gt;result = SLVS_RESULT_INCONSISTENT;
            break;

        case SolveResult::TOO_MANY_UNKNOWNS:
            ssys-&gt;result = SLVS_RESULT_TOO_MANY_UNKNOWNS;
            break;
    }

    // Write the new parameter values back to our caller.
    for(i = 0; i &lt; ssys-&gt;params; i++) {
        Slvs_Param *sp = &amp;(ssys-&gt;param[i]);
        hParam hp = { sp-&gt;h };
        sp-&gt;val = SK.GetParam(hp)-&gt;val;
    }

    if(ssys-&gt;failed) {
        // Copy over any the list of problematic constraints.
        for(i = 0; i &lt; ssys-&gt;faileds &amp;&amp; i &lt; bad.n; i++) {
            ssys-&gt;failed[i] = bad[i].v;
        }
        ssys-&gt;faileds = bad.n;
    }

    bad.Clear();
    SYS.param.Clear();
    SYS.entity.Clear();
    SYS.eq.Clear();
    SYS.dragged.Clear();

    SK.param.Clear();
    SK.entity.Clear();
    SK.constraint.Clear();

    FreeAllTemporary();
}

</t>
<t tx="leo.20191228122645.128">@path ./src/
//-----------------------------------------------------------------------------
// Operations on triangle meshes, like our mesh Booleans using the BSP, and
// the stuff to check for watertightness.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

#include &lt;set&gt;

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122645.129">void SMesh::Clear() {
    l.Clear();
}

</t>
<t tx="leo.20191228122645.13">void GraphicsWindow::LoopOverPoints(const std::vector&lt;Entity *&gt; &amp;entities,
                                    const std::vector&lt;Constraint *&gt; &amp;constraints,
                                    const std::vector&lt;hEntity&gt; &amp;faces,
                                    Point2d *pmax, Point2d *pmin, double *wmin,
                                    bool usePerspective, bool includeMesh,
                                    const Camera &amp;camera) {

    for(Entity *e : entities) {
        if(e-&gt;IsPoint()) {
            HandlePointForZoomToFit(e-&gt;PointGetNum(), pmax, pmin, wmin, usePerspective, camera);
        } else if(e-&gt;type == Entity::Type::CIRCLE) {
            // Lots of entities can extend outside the bbox of their points,
            // but circles are particularly bad. We want to get things halfway
            // reasonable without the mesh, because a zoom to fit is used to
            // set the zoom level to set the chord tol.
            double r = e-&gt;CircleGetRadiusNum();
            Vector c = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
            Quaternion q = SK.GetEntity(e-&gt;normal)-&gt;NormalGetNum();
            for(int j = 0; j &lt; 4; j++) {
                Vector p = (j == 0) ? (c.Plus(q.RotationU().ScaledBy( r))) :
                           (j == 1) ? (c.Plus(q.RotationU().ScaledBy(-r))) :
                           (j == 2) ? (c.Plus(q.RotationV().ScaledBy( r))) :
                                      (c.Plus(q.RotationV().ScaledBy(-r)));
                HandlePointForZoomToFit(p, pmax, pmin, wmin, usePerspective, camera);
            }
        } else {
            // We have to iterate children points, because we can select entities without points
            for(int i = 0; i &lt; MAX_POINTS_IN_ENTITY; i++) {
                if(e-&gt;point[i].v == 0) break;
                Vector p = SK.GetEntity(e-&gt;point[i])-&gt;PointGetNum();
                HandlePointForZoomToFit(p, pmax, pmin, wmin, usePerspective, camera);
            }
        }
    }

    for(Constraint *c : constraints) {
        std::vector&lt;Vector&gt; refs;
        c-&gt;GetReferencePoints(camera, &amp;refs);
        for(Vector p : refs) {
            HandlePointForZoomToFit(p, pmax, pmin, wmin, usePerspective, camera);
        }
    }

    if(!includeMesh &amp;&amp; faces.empty()) return;

    Group *g = SK.GetGroup(activeGroup);
    g-&gt;GenerateDisplayItems();
    for(int i = 0; i &lt; g-&gt;displayMesh.l.n; i++) {
        STriangle *tr = &amp;(g-&gt;displayMesh.l[i]);
        if(!includeMesh) {
            bool found = false;
            for(const hEntity &amp;face : faces) {
                if(face.v != tr-&gt;meta.face) continue;
                found = true;
                break;
            }
            if(!found) continue;
        }
        HandlePointForZoomToFit(tr-&gt;a, pmax, pmin, wmin, usePerspective, camera);
        HandlePointForZoomToFit(tr-&gt;b, pmax, pmin, wmin, usePerspective, camera);
        HandlePointForZoomToFit(tr-&gt;c, pmax, pmin, wmin, usePerspective, camera);
    }
    if(!includeMesh) return;
    for(int i = 0; i &lt; g-&gt;polyLoops.l.n; i++) {
        SContour *sc = &amp;(g-&gt;polyLoops.l[i]);
        for(int j = 0; j &lt; sc-&gt;l.n; j++) {
            HandlePointForZoomToFit(sc-&gt;l[j].p, pmax, pmin, wmin, usePerspective, camera);
        }
    }
}
</t>
<t tx="leo.20191228122645.130">void SMesh::AddTriangle(STriMeta meta, Vector n, Vector a, Vector b, Vector c) {
    Vector ab = b.Minus(a), bc = c.Minus(b);
    Vector np = ab.Cross(bc);
    if(np.Magnitude() &lt; 1e-10) {
        // ugh; gl sometimes tesselates to collinear triangles
        return;
    }
    if(np.Dot(n) &gt; 0) {
        AddTriangle(meta, a, b, c);
    } else {
        AddTriangle(meta, c, b, a);
    }
}
</t>
<t tx="leo.20191228122645.131">void SMesh::AddTriangle(STriMeta meta, Vector a, Vector b, Vector c) {
    STriangle t = {};
    t.meta = meta;
    t.a = a;
    t.b = b;
    t.c = c;
    AddTriangle(&amp;t);
}
</t>
<t tx="leo.20191228122645.132">void SMesh::AddTriangle(const STriangle *st) {
    l.Add(st);
}

</t>
<t tx="leo.20191228122645.133">void SMesh::DoBounding(Vector v, Vector *vmax, Vector *vmin) const {
    vmax-&gt;x = max(vmax-&gt;x, v.x);
    vmax-&gt;y = max(vmax-&gt;y, v.y);
    vmax-&gt;z = max(vmax-&gt;z, v.z);

    vmin-&gt;x = min(vmin-&gt;x, v.x);
    vmin-&gt;y = min(vmin-&gt;y, v.y);
    vmin-&gt;z = min(vmin-&gt;z, v.z);
}
</t>
<t tx="leo.20191228122645.134">void SMesh::GetBounding(Vector *vmax, Vector *vmin) const {
    int i;
    *vmin = Vector::From( 1e12,  1e12,  1e12);
    *vmax = Vector::From(-1e12, -1e12, -1e12);
    for(i = 0; i &lt; l.n; i++) {
        const STriangle *st = &amp;(l[i]);
        DoBounding(st-&gt;a, vmax, vmin);
        DoBounding(st-&gt;b, vmax, vmin);
        DoBounding(st-&gt;c, vmax, vmin);
    }
}

//----------------------------------------------------------------------------
// Report the edges of the boundary of the region(s) of our mesh that lie
// within the plane n dot p = d.
//----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122645.135">void SMesh::MakeEdgesInPlaneInto(SEdgeList *sel, Vector n, double d) {
    SMesh m = {};
    m.MakeFromCopyOf(this);

    // Delete all triangles in the mesh that do not lie in our export plane.
    m.l.ClearTags();
    int i;
    for(i = 0; i &lt; m.l.n; i++) {
        STriangle *tr = &amp;(m.l[i]);

        if((fabs(n.Dot(tr-&gt;a) - d) &gt;= LENGTH_EPS) ||
           (fabs(n.Dot(tr-&gt;b) - d) &gt;= LENGTH_EPS) ||
           (fabs(n.Dot(tr-&gt;c) - d) &gt;= LENGTH_EPS))
        {
            tr-&gt;tag  = 1;
        }
    }
    m.l.RemoveTagged();

    // Select the naked edges in our resulting open mesh.
    SKdNode *root = SKdNode::From(&amp;m);
    root-&gt;SnapToMesh(&amp;m);
    root-&gt;MakeCertainEdgesInto(sel, EdgeKind::NAKED_OR_SELF_INTER,
                               /*coplanarIsInter=*/false, NULL, NULL);

    m.Clear();
}

</t>
<t tx="leo.20191228122645.136">void SMesh::MakeOutlinesInto(SOutlineList *sol, EdgeKind edgeKind) {
    SKdNode *root = SKdNode::From(this);
    root-&gt;MakeOutlinesInto(sol, edgeKind);
}

//-----------------------------------------------------------------------------
// When we are called, all of the triangles from l[start] to the end must
// be coplanar. So we try to find a set of fewer triangles that covers the
// exact same area, in order to reduce the number of triangles in the mesh.
// We use this after a triangle has been split against the BSP.
//
// This is really ugly code; basically it just pastes things together to
// form convex polygons, merging collinear edges when possible, then
// triangulates the convex poly.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122645.137">void SMesh::Simplify(int start) {
    int maxTriangles = (l.n - start) + 10;

    STriMeta meta = l[start].meta;

    STriangle *tout = (STriangle *)MemAlloc(maxTriangles*sizeof(*tout));
    int toutc = 0;

    Vector n = Vector::From(0, 0, 0);
    Vector *conv = (Vector *)MemAlloc(maxTriangles*3*sizeof(*conv));
    int convc = 0;

    int start0 = start;

    int i, j;
    for(i = start; i &lt; l.n; i++) {
        STriangle *tr = &amp;(l[i]);
        if(tr-&gt;MinAltitude() &lt; LENGTH_EPS) {
            tr-&gt;tag = 1;
        } else {
            tr-&gt;tag = 0;
        }
    }

    for(;;) {
        bool didAdd;
        convc = 0;
        for(i = start; i &lt; l.n; i++) {
            STriangle *tr = &amp;(l[i]);
            if(tr-&gt;tag) continue;

            tr-&gt;tag = 1;
            n = (tr-&gt;Normal()).WithMagnitude(1);
            conv[convc++] = tr-&gt;a;
            conv[convc++] = tr-&gt;b;
            conv[convc++] = tr-&gt;c;

            start = i+1;
            break;
        }
        if(i &gt;= l.n) break;

        do {
            didAdd = false;

            for(j = 0; j &lt; convc; j++) {
                Vector a = conv[WRAP((j-1), convc)],
                       b = conv[j],
                       d = conv[WRAP((j+1), convc)],
                       e = conv[WRAP((j+2), convc)];

                Vector c;
                for(i = start; i &lt; l.n; i++) {
                    STriangle *tr = &amp;(l[i]);
                    if(tr-&gt;tag) continue;

                    if((tr-&gt;a).Equals(d) &amp;&amp; (tr-&gt;b).Equals(b)) {
                        c = tr-&gt;c;
                    } else if((tr-&gt;b).Equals(d) &amp;&amp; (tr-&gt;c).Equals(b)) {
                        c = tr-&gt;a;
                    } else if((tr-&gt;c).Equals(d) &amp;&amp; (tr-&gt;a).Equals(b)) {
                        c = tr-&gt;b;
                    } else {
                        continue;
                    }
                    // The vertex at C must be convex; but the others must
                    // be tested
                    Vector ab = b.Minus(a);
                    Vector bc = c.Minus(b);
                    Vector cd = d.Minus(c);
                    Vector de = e.Minus(d);

                    double bDot = (ab.Cross(bc)).Dot(n);
                    double dDot = (cd.Cross(de)).Dot(n);

                    bDot /= min(ab.Magnitude(), bc.Magnitude());
                    dDot /= min(cd.Magnitude(), de.Magnitude());

                    if(fabs(bDot) &lt; LENGTH_EPS &amp;&amp; fabs(dDot) &lt; LENGTH_EPS) {
                        conv[WRAP((j+1), convc)] = c;
                        // and remove the vertex at j, which is a dup
                        std::move(conv+j+1, conv+convc, conv+j);
                        convc--;
                    } else if(fabs(bDot) &lt; LENGTH_EPS &amp;&amp; dDot &gt; 0) {
                        conv[j] = c;
                    } else if(fabs(dDot) &lt; LENGTH_EPS &amp;&amp; bDot &gt; 0) {
                        conv[WRAP((j+1), convc)] = c;
                    } else if(bDot &gt; 0 &amp;&amp; dDot &gt; 0) {
                        // conv[j] is unchanged, conv[j+1] goes to [j+2]
                        std::move_backward(conv+j+1, conv+convc, conv+convc+1);
                        conv[j+1] = c;
                        convc++;
                    } else {
                        continue;
                    }

                    didAdd = true;
                    tr-&gt;tag = 1;
                    break;
                }
            }
        } while(didAdd);

        // I need to debug why this is required; sometimes the above code
        // still generates a convex polygon
        for(i = 0; i &lt; convc; i++) {
            Vector a = conv[WRAP((i-1), convc)],
                   b = conv[i],
                   c = conv[WRAP((i+1), convc)];
            Vector ab = b.Minus(a);
            Vector bc = c.Minus(b);
            double bDot = (ab.Cross(bc)).Dot(n);
            bDot /= min(ab.Magnitude(), bc.Magnitude());

            if(bDot &lt; 0) return; // XXX, shouldn't happen
        }

        for(i = 0; i &lt; convc - 2; i++) {
            STriangle tr = STriangle::From(meta, conv[0], conv[i+1], conv[i+2]);
            if(tr.MinAltitude() &gt; LENGTH_EPS) {
                tout[toutc++] = tr;
            }
        }
    }

    l.n = start0;
    for(i = 0; i &lt; toutc; i++) {
        AddTriangle(&amp;(tout[i]));
    }
    MemFree(tout);
    MemFree(conv);
}

</t>
<t tx="leo.20191228122645.138">void SMesh::AddAgainstBsp(SMesh *srcm, SBsp3 *bsp3) {
    int i;

    for(i = 0; i &lt; srcm-&gt;l.n; i++) {
        STriangle *st = &amp;(srcm-&gt;l[i]);
        int pn = l.n;
        atLeastOneDiscarded = false;
        SBsp3::InsertOrCreate(bsp3, st, this);
        if(!atLeastOneDiscarded &amp;&amp; (l.n != (pn+1))) {
            l.n = pn;
            if(flipNormal) {
                AddTriangle(st-&gt;meta, st-&gt;c, st-&gt;b, st-&gt;a);
            } else {
                AddTriangle(st-&gt;meta, st-&gt;a, st-&gt;b, st-&gt;c);
            }
        }
        if(l.n - pn &gt; 1) {
            Simplify(pn);
        }
    }
}

</t>
<t tx="leo.20191228122645.139">void SMesh::MakeFromUnionOf(SMesh *a, SMesh *b) {
    SBsp3 *bspa = SBsp3::FromMesh(a);
    SBsp3 *bspb = SBsp3::FromMesh(b);

    flipNormal = false;
    keepCoplanar = false;
    AddAgainstBsp(b, bspa);

    flipNormal = false;
    keepCoplanar = true;
    AddAgainstBsp(a, bspb);
}

</t>
<t tx="leo.20191228122645.14">void GraphicsWindow::ZoomToFit(bool includingInvisibles, bool useSelection) {
    if(!window) return;

    scale = ZoomToFit(GetCamera(), includingInvisibles, useSelection);
}
double GraphicsWindow::ZoomToFit(const Camera &amp;camera,
</t>
<t tx="leo.20191228122645.140">void SMesh::MakeFromDifferenceOf(SMesh *a, SMesh *b) {
    SBsp3 *bspa = SBsp3::FromMesh(a);
    SBsp3 *bspb = SBsp3::FromMesh(b);

    flipNormal = true;
    keepCoplanar = true;
    AddAgainstBsp(b, bspa);

    flipNormal = false;
    keepCoplanar = false;
    AddAgainstBsp(a, bspb);
}

</t>
<t tx="leo.20191228122645.141">void SMesh::MakeFromCopyOf(SMesh *a) {
    ssassert(this != a, "Can't make from copy of self");
    for(int i = 0; i &lt; a-&gt;l.n; i++) {
        AddTriangle(&amp;(a-&gt;l[i]));
    }
}

</t>
<t tx="leo.20191228122645.142">void SMesh::MakeFromAssemblyOf(SMesh *a, SMesh *b) {
    MakeFromCopyOf(a);
    MakeFromCopyOf(b);
}

</t>
<t tx="leo.20191228122645.143">void SMesh::MakeFromTransformationOf(SMesh *a, Vector trans,
                                     Quaternion q, double scale)
{
    STriangle *tr;
    for(tr = a-&gt;l.First(); tr; tr = a-&gt;l.NextAfter(tr)) {
        STriangle tt = *tr;
        tt.a = (tt.a).ScaledBy(scale);
        tt.b = (tt.b).ScaledBy(scale);
        tt.c = (tt.c).ScaledBy(scale);
        if(scale &lt; 0) {
            // The mirroring would otherwise turn a closed mesh inside out.
            swap(tt.a, tt.b);
        }
        tt.a = (q.Rotate(tt.a)).Plus(trans);
        tt.b = (q.Rotate(tt.b)).Plus(trans);
        tt.c = (q.Rotate(tt.c)).Plus(trans);
        AddTriangle(&amp;tt);
    }
}

bool SMesh::IsEmpty() const { return (l.IsEmpty()); }

uint32_t SMesh::FirstIntersectionWith(Point2d mp) const {
    Vector rayPoint = SS.GW.UnProjectPoint3(Vector::From(mp.x, mp.y, 0.0));
    Vector rayDir = SS.GW.UnProjectPoint3(Vector::From(mp.x, mp.y, 1.0)).Minus(rayPoint);

    uint32_t face = 0;
    double faceT = VERY_NEGATIVE;
    for(int i = 0; i &lt; l.n; i++) {
        const STriangle &amp;tr = l[i];
        if(tr.meta.face == 0) continue;

        double t;
        if(!tr.Raytrace(rayPoint, rayDir, &amp;t, NULL)) continue;
        if(t &gt; faceT) {
            face  = tr.meta.face;
            faceT = t;
        }
    }

    return face;
}

Vector SMesh::GetCenterOfMass() const {
    Vector center = {};
    double vol = 0.0;
    for(int i = 0; i &lt; l.n; i++) {
        const STriangle &amp;tr = l[i];
        double tvol = tr.SignedVolume();
        center = center.Plus(tr.a.Plus(tr.b.Plus(tr.c)).ScaledBy(tvol / 4.0));
        vol += tvol;
    }
    return center.ScaledBy(1.0 / vol);
}

STriangleLl *STriangleLl::Alloc()
    { return (STriangleLl *)AllocTemporary(sizeof(STriangleLl)); }
SKdNode *SKdNode::Alloc()
    { return (SKdNode *)AllocTemporary(sizeof(SKdNode)); }

SKdNode *SKdNode::From(SMesh *m) {
    int i;
    STriangle *tra = (STriangle *)AllocTemporary((m-&gt;l.n) * sizeof(*tra));

    for(i = 0; i &lt; m-&gt;l.n; i++) {
        tra[i] = m-&gt;l[i];
    }

    srand(0);
    int n = m-&gt;l.n;
    while(n &gt; 1) {
        int k = rand() % n;
        n--;
        swap(tra[k], tra[n]);
    }

    STriangleLl *tll = NULL;
    for(i = 0; i &lt; m-&gt;l.n; i++) {
        STriangleLl *tn = STriangleLl::Alloc();
        tn-&gt;tri = &amp;(tra[i]);
        tn-&gt;next = tll;
        tll = tn;
    }

    return SKdNode::From(tll);
}

SKdNode *SKdNode::From(STriangleLl *tll) {
    int which = 0;
    SKdNode *ret = Alloc();

    int i;
    int gtc[3] = { 0, 0, 0 }, ltc[3] = { 0, 0, 0 }, allc = 0;
    double badness[3] = { 0, 0, 0 };
    double split[3] = { 0, 0, 0 };

    if(!tll) {
        goto leaf;
    }

    for(i = 0; i &lt; 3; i++) {
        int tcnt = 0;
        STriangleLl *ll;
        for(ll = tll; ll; ll = ll-&gt;next) {
            split[i] += (ll-&gt;tri-&gt;a).Element(i);
            split[i] += (ll-&gt;tri-&gt;b).Element(i);
            split[i] += (ll-&gt;tri-&gt;c).Element(i);
            tcnt++;
        }
        split[i] /= (tcnt*3);

        for(ll = tll; ll; ll = ll-&gt;next) {
            STriangle *tr = ll-&gt;tri;

</t>
<t tx="leo.20191228122645.144">        double a = (tr-&gt;a).Element(i),
               b = (tr-&gt;b).Element(i),
               c = (tr-&gt;c).Element(i);

        if(a &lt; split[i] + KDTREE_EPS ||
           b &lt; split[i] + KDTREE_EPS ||
           c &lt; split[i] + KDTREE_EPS)
        {
            ltc[i]++;
        }
        if(a &gt; split[i] - KDTREE_EPS ||
           b &gt; split[i] - KDTREE_EPS ||
           c &gt; split[i] - KDTREE_EPS)
        {
            gtc[i]++;
        }
        if(i == 0) allc++;
    }
    badness[i] = pow((double)ltc[i], 4) + pow((double)gtc[i], 4);
}
if(badness[0] &lt; badness[1] &amp;&amp; badness[0] &lt; badness[2]) {
    which = 0;
} else if(badness[1] &lt; badness[2]) {
    which = 1;
} else {
    which = 2;
}

if(allc &lt; 3 || allc == gtc[which] || allc == ltc[which]) {
    goto leaf;
}

STriangleLl *ll;
STriangleLl *lgt, *llt; lgt = llt = NULL;
for(ll = tll; ll; ll = ll-&gt;next) {
    STriangle *tr = ll-&gt;tri;

</t>
<t tx="leo.20191228122645.145">        double a = (tr-&gt;a).Element(which),
               b = (tr-&gt;b).Element(which),
               c = (tr-&gt;c).Element(which);

        if(a &lt; split[which] + KDTREE_EPS ||
           b &lt; split[which] + KDTREE_EPS ||
           c &lt; split[which] + KDTREE_EPS)
        {
            STriangleLl *n = STriangleLl::Alloc();
            *n = *ll;
            n-&gt;next = llt;
            llt = n;
        }
        if(a &gt; split[which] - KDTREE_EPS ||
           b &gt; split[which] - KDTREE_EPS ||
           c &gt; split[which] - KDTREE_EPS)
        {
            STriangleLl *n = STriangleLl::Alloc();
            *n = *ll;
            n-&gt;next = lgt;
            lgt = n;
        }
    }

    ret-&gt;which = which;
    ret-&gt;c = split[which];
    ret-&gt;gt = SKdNode::From(lgt);
    ret-&gt;lt = SKdNode::From(llt);
    return ret;

leaf:
    ret-&gt;tris = tll;
    return ret;
}

</t>
<t tx="leo.20191228122645.146">void SKdNode::ClearTags() const {
    if(gt &amp;&amp; lt) {
        gt-&gt;ClearTags();
        lt-&gt;ClearTags();
    } else {
        STriangleLl *ll;
        for(ll = tris; ll; ll = ll-&gt;next) {
            ll-&gt;tri-&gt;tag = 0;
        }
    }
}

</t>
<t tx="leo.20191228122645.147">void SKdNode::AddTriangle(STriangle *tr) {
    if(gt &amp;&amp; lt) {
        @others
}

</t>
<t tx="leo.20191228122645.148">    double ta = (tr-&gt;a).Element(which),
           tb = (tr-&gt;b).Element(which),
           tc = (tr-&gt;c).Element(which);
    if(ta &lt; c + KDTREE_EPS ||
       tb &lt; c + KDTREE_EPS ||
       tc &lt; c + KDTREE_EPS)
    {
        lt-&gt;AddTriangle(tr);
    }
    if(ta &gt; c - KDTREE_EPS ||
       tb &gt; c - KDTREE_EPS ||
       tc &gt; c - KDTREE_EPS)
    {
        gt-&gt;AddTriangle(tr);
    }
} else {
    STriangleLl *tn = STriangleLl::Alloc();
    tn-&gt;tri = tr;
    tn-&gt;next = tris;
    tris = tn;
}
</t>
<t tx="leo.20191228122645.149">void SKdNode::MakeMeshInto(SMesh *m) const {
    if(gt) gt-&gt;MakeMeshInto(m);
    if(lt) lt-&gt;MakeMeshInto(m);

    STriangleLl *ll;
    for(ll = tris; ll; ll = ll-&gt;next) {
        if(ll-&gt;tri-&gt;tag) continue;

        m-&gt;AddTriangle(ll-&gt;tri);
        ll-&gt;tri-&gt;tag = 1;
    }
}

</t>
<t tx="leo.20191228122645.15">                                 bool includingInvisibles, bool useSelection) {
    std::vector&lt;Entity *&gt; entities;
    std::vector&lt;Constraint *&gt; constraints;
    std::vector&lt;hEntity&gt; faces;

    if(useSelection) {
        for(int i = 0; i &lt; selection.n; i++) {
            Selection *s = &amp;selection[i];
            if(s-&gt;entity.v != 0) {
                Entity *e = SK.entity.FindById(s-&gt;entity);
                if(e-&gt;IsFace()) {
                    faces.push_back(e-&gt;h);
                    continue;
                }
                entities.push_back(e);
            }
            if(s-&gt;constraint.v != 0) {
                Constraint *c = SK.constraint.FindById(s-&gt;constraint);
                constraints.push_back(c);
            }
        }
    }

    bool selectionUsed = !entities.empty() || !constraints.empty() || !faces.empty();

    if(!selectionUsed) {
        for(Entity &amp;e : SK.entity) {
            // we don't want to handle separate points, because we will iterate them inside entities.
            if(e.IsPoint()) continue;
            if(!includingInvisibles &amp;&amp; !e.IsVisible()) continue;
            entities.push_back(&amp;e);
        }

        for(Constraint &amp;c : SK.constraint) {
            if(!c.IsVisible()) continue;
            constraints.push_back(&amp;c);
        }
    }

    // On the first run, ignore perspective.
    Point2d pmax = { -1e12, -1e12 }, pmin = { 1e12, 1e12 };
    double wmin = 1;
    LoopOverPoints(entities, constraints, faces, &amp;pmax, &amp;pmin, &amp;wmin,
                   /*usePerspective=*/false, /*includeMesh=*/!selectionUsed,
                   camera);

    double xm = (pmax.x + pmin.x)/2, ym = (pmax.y + pmin.y)/2;
    double dx = pmax.x - pmin.x, dy = pmax.y - pmin.y;

    offset = offset.Plus(projRight.ScaledBy(-xm)).Plus(
                         projUp.   ScaledBy(-ym));

    // And based on this, we calculate the scale and offset
    double scale;
    if(EXACT(dx == 0 &amp;&amp; dy == 0)) {
        scale = 5;
    } else {
        double scalex = 1e12, scaley = 1e12;
        if(EXACT(dx != 0)) scalex = 0.9*camera.width /dx;
        if(EXACT(dy != 0)) scaley = 0.9*camera.height/dy;
        scale = min(scalex, scaley);

        scale = min(300.0, scale);
        scale = max(0.003, scale);
    }

    // Then do another run, considering the perspective.
    pmax.x = -1e12; pmax.y = -1e12;
    pmin.x =  1e12; pmin.y =  1e12;
    wmin = 1;
    LoopOverPoints(entities, constraints, faces, &amp;pmax, &amp;pmin, &amp;wmin,
                   /*usePerspective=*/true, /*includeMesh=*/!selectionUsed,
                   camera);

    // Adjust the scale so that no points are behind the camera
    if(wmin &lt; 0.1) {
        double k = camera.tangent;
        // w = 1+k*scale*z
        double zmin = (wmin - 1)/(k*scale);
        // 0.1 = 1 + k*scale*zmin
        // (0.1 - 1)/(k*zmin) = scale
        scale = min(scale, (0.1 - 1)/(k*zmin));
    }

    return scale;
}

</t>
<t tx="leo.20191228122645.150">void SKdNode::ListTrianglesInto(std::vector&lt;STriangle *&gt; *tl) const {
    if(gt) gt-&gt;ListTrianglesInto(tl);
    if(lt) lt-&gt;ListTrianglesInto(tl);

    STriangleLl *ll;
    for(ll = tris; ll; ll = ll-&gt;next) {
        if(ll-&gt;tri-&gt;tag) continue;

        tl-&gt;push_back(ll-&gt;tri);
        ll-&gt;tri-&gt;tag = 1;
    }
}

//-----------------------------------------------------------------------------
// If any triangles in the mesh have an edge that goes through v (but not
// a vertex at v), then split those triangles so that they now have a vertex
// there. The existing triangle is modified, and the new triangle appears
// in extras.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122645.151">void SKdNode::SnapToVertex(Vector v, SMesh *extras) {
    if(gt &amp;&amp; lt) {
        double vc = v.Element(which);
        if(vc &lt; c + KDTREE_EPS) {
            lt-&gt;SnapToVertex(v, extras);
        }
        if(vc &gt; c - KDTREE_EPS) {
            gt-&gt;SnapToVertex(v, extras);
        }
        // Nothing bad happens if the triangle to be split appears in both
        // branches; the first call will split the triangle, so that the
        // second call will do nothing, because the modified triangle will
        // already contain v
    } else {
        STriangleLl *ll;
        for(ll = tris; ll; ll = ll-&gt;next) {
            STriangle *tr = ll-&gt;tri;

            // Do a cheap bbox test first
            int k;
            bool mightHit = true;

            for(k = 0; k &lt; 3; k++) {
                double trA = (tr-&gt;a).Element(k);
                double trB = (tr-&gt;b).Element(k);
                double trC = (tr-&gt;c).Element(k);
                double vk = v.Element(k);
                if(trA &lt; vk - KDTREE_EPS &amp;&amp;
                   trB &lt; vk - KDTREE_EPS &amp;&amp;
                   trC &lt; vk - KDTREE_EPS)
                {
                    mightHit = false;
                    break;
                }
                if(trA &gt; vk + KDTREE_EPS &amp;&amp;
                   trB &gt; vk + KDTREE_EPS &amp;&amp;
                   trC &gt; vk + KDTREE_EPS)
                {
                    mightHit = false;
                    break;
                }
            }
            if(!mightHit) continue;

            if(tr-&gt;a.Equals(v)) { tr-&gt;a = v; continue; }
            if(tr-&gt;b.Equals(v)) { tr-&gt;b = v; continue; }
            if(tr-&gt;c.Equals(v)) { tr-&gt;c = v; continue; }

            if(tr-&gt;IsDegenerate()) {
                continue;
            }

            if(v.OnLineSegment(tr-&gt;a, tr-&gt;b)) {
                STriangle nt = STriangle::From(tr-&gt;meta, tr-&gt;a, v, tr-&gt;c);
                extras-&gt;AddTriangle(&amp;nt);
                tr-&gt;a = v;
                continue;
            }
            if(v.OnLineSegment(tr-&gt;b, tr-&gt;c)) {
                STriangle nt = STriangle::From(tr-&gt;meta, tr-&gt;b, v, tr-&gt;a);
                extras-&gt;AddTriangle(&amp;nt);
                tr-&gt;b = v;
                continue;
            }
            if(v.OnLineSegment(tr-&gt;c, tr-&gt;a)) {
                STriangle nt = STriangle::From(tr-&gt;meta, tr-&gt;c, v, tr-&gt;b);
                extras-&gt;AddTriangle(&amp;nt);
                tr-&gt;c = v;
                continue;
            }
        }
    }
}

//-----------------------------------------------------------------------------
// Snap to each vertex of each triangle of the given mesh. If the given mesh
// is identical to the mesh used to make this kd tree, then the result should
// be a vertex-to-vertex mesh.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122645.152">void SKdNode::SnapToMesh(SMesh *m) {
    int i, j, k;
    for(i = 0; i &lt; m-&gt;l.n; i++) {
        STriangle *tr = &amp;(m-&gt;l[i]);
        if(tr-&gt;IsDegenerate()) {
            continue;
        }
        for(j = 0; j &lt; 3; j++) {
            Vector v = tr-&gt;vertices[j];

            SMesh extra = {};
            SnapToVertex(v, &amp;extra);

            for(k = 0; k &lt; extra.l.n; k++) {
                STriangle *tra = (STriangle *)AllocTemporary(sizeof(*tra));
                *tra = extra.l[k];
                AddTriangle(tra);
            }
            extra.Clear();
        }
    }
}

//-----------------------------------------------------------------------------
// For all the edges in sel, split them against the given triangle, and test
// them for occlusion. sel is both our input and our output. tag indicates
// whether an edge is occluded.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122645.153">void SKdNode::SplitLinesAgainstTriangle(SEdgeList *sel, STriangle *tr) const {
    SEdgeList seln = {};

    Vector tn = tr-&gt;Normal().WithMagnitude(1);
    double td = tn.Dot(tr-&gt;a);

    // Consider front-facing triangles only.
    if(tn.z &gt; LENGTH_EPS) {
        // If the edge crosses our triangle's plane, then split into above
        // and below parts. Note that we must preserve auxA, which contains
        // the style associated with this line, as well as the tag, which
        // contains the occlusion status.
        SEdge *se;
        for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
            @others
}

//-----------------------------------------------------------------------------
// Given an edge orig, occlusion test it against our mesh. We output an edge
// list in sel, where only invisible portions of the edge are tagged.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122645.154">    double da = (se-&gt;a).Dot(tn) - td,
           db = (se-&gt;b).Dot(tn) - td;
    if((da &lt; -LENGTH_EPS &amp;&amp; db &gt; LENGTH_EPS) ||
       (db &lt; -LENGTH_EPS &amp;&amp; da &gt; LENGTH_EPS))
    {
        Vector m = Vector::AtIntersectionOfPlaneAndLine(
                                tn, td,
                                se-&gt;a, se-&gt;b, NULL);
        seln.AddEdge(m, se-&gt;b, se-&gt;auxA, 0, se-&gt;tag);
        se-&gt;b = m;
    }
}
for(se = seln.l.First(); se; se = seln.l.NextAfter(se)) {
    sel-&gt;AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA, 0, se-&gt;tag);
}
seln.Clear();

for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
    Vector pt = ((se-&gt;a).Plus(se-&gt;b)).ScaledBy(0.5);
    if(pt.Dot(tn) - td &gt; -LENGTH_EPS) {
        // Edge is in front of or on our plane (remember, tn.z &gt; 0)
        // so it is exempt from further splitting
        se-&gt;auxB = 1;
    } else {
        // Edge is behind our plane, needs further splitting
        se-&gt;auxB = 0;
    }
}

// Considering only the (x, y) coordinates, split the edge against our
// triangle.
Point2d a = (tr-&gt;a).ProjectXy(),
        b = (tr-&gt;b).ProjectXy(),
        c = (tr-&gt;c).ProjectXy();

Point2d n[3] = { (b.Minus(a)).Normal().WithMagnitude(1),
                 (c.Minus(b)).Normal().WithMagnitude(1),
                 (a.Minus(c)).Normal().WithMagnitude(1)  };

</t>
<t tx="leo.20191228122645.155">double d[3] = { n[0].Dot(b),
                n[1].Dot(c),
                n[2].Dot(a)  };

// Split all of the edges where they intersect the triangle edges
int i;
for(i = 0; i &lt; 3; i++) {
    for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
        if(se-&gt;auxB) continue;

        Point2d ap = (se-&gt;a).ProjectXy(),
                bp = (se-&gt;b).ProjectXy();
</t>
<t tx="leo.20191228122645.156">            double da = n[i].Dot(ap) - d[i],
                   db = n[i].Dot(bp) - d[i];
            if((da &lt; -LENGTH_EPS &amp;&amp; db &gt; LENGTH_EPS) ||
               (db &lt; -LENGTH_EPS &amp;&amp; da &gt; LENGTH_EPS))
            {
                double dab = (db - da);
                Vector spl = ((se-&gt;a).ScaledBy( db/dab)).Plus(
                              (se-&gt;b).ScaledBy(-da/dab));
                seln.AddEdge(spl, se-&gt;b, se-&gt;auxA, 0, se-&gt;tag);
                se-&gt;b = spl;
            }
        }
        for(se = seln.l.First(); se; se = seln.l.NextAfter(se)) {
            // The split pieces are all behind the triangle, since only
            // edges behind the triangle got split. So their auxB is 0.
            sel-&gt;AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA, 0, se-&gt;tag);
        }
        seln.Clear();
    }

    for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
        bool occluded;
        if(se-&gt;auxB) {
            // Lies above or on the triangle plane, so triangle doesn't
            // occlude it.
            occluded = false;
        } else {
            // Test the segment to see if it lies outside the triangle
            // (i.e., outside wrt at least one edge), and keep it only
            // then.
            Point2d pt = ((se-&gt;a).Plus(se-&gt;b).ScaledBy(0.5)).ProjectXy();
            occluded = true;
            for(i = 0; i &lt; 3; i++) {
                // If the test point lies on the boundary of our triangle,
                // then we still discard the edge.
                if(n[i].Dot(pt) - d[i] &gt; LENGTH_EPS) occluded = false;
            }
        }

        if(occluded) {
            se-&gt;tag = 1;
        }
    }
}
</t>
<t tx="leo.20191228122645.157">void SKdNode::OcclusionTestLine(SEdge orig, SEdgeList *sel, int cnt) const {
    if(gt &amp;&amp; lt) {
        @others
}

//-----------------------------------------------------------------------------
// Search the mesh for a triangle with an edge from b to a (i.e., the mate
// for the edge from a to b), and increment info-&gt;count each time that we
// find one. If a triangle is found, then report whether it is front- or
// back-facing using info-&gt;frontFacing. And regardless of whether a mate is
// found, report whether the edge intersects the mesh with info-&gt;intersectsMesh;
// if coplanarIsInter then we count the edge as intersecting if it's coplanar
// with a triangle in the mesh, otherwise not.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122645.158">    double ac = (orig.a).Element(which),
           bc = (orig.b).Element(which);
    // We can ignore triangles that are separated in x or y, but triangles
    // that are separated in z may still contribute
    if(ac &lt; c + KDTREE_EPS ||
       bc &lt; c + KDTREE_EPS ||
       which == 2)
    {
        lt-&gt;OcclusionTestLine(orig, sel, cnt);
    }
    if(ac &gt; c - KDTREE_EPS ||
       bc &gt; c - KDTREE_EPS ||
       which == 2)
    {
        gt-&gt;OcclusionTestLine(orig, sel, cnt);
    }
} else {
    STriangleLl *ll;
    for(ll = tris; ll; ll = ll-&gt;next) {
        STriangle *tr = ll-&gt;tri;

        if(tr-&gt;tag == cnt) continue;

        SplitLinesAgainstTriangle(sel, tr);
        tr-&gt;tag = cnt;
    }
}
</t>
<t tx="leo.20191228122645.159">void SKdNode::FindEdgeOn(Vector a, Vector b, int cnt, bool coplanarIsInter,
                         EdgeOnInfo *info) const
{
    if(gt &amp;&amp; lt) {
        @others
}

</t>
<t tx="leo.20191228122645.16">void GraphicsWindow::MenuView(Command id) {
    switch(id) {
        case Command::ZOOM_IN:
            SS.GW.scale *= 1.2;
            SS.ScheduleShowTW();
            break;

        case Command::ZOOM_OUT:
            SS.GW.scale /= 1.2;
            SS.ScheduleShowTW();
            break;

        case Command::ZOOM_TO_FIT:
            SS.GW.ZoomToFit(/*includingInvisibles=*/false, /*useSelection=*/true);
            SS.ScheduleShowTW();
            break;

        case Command::SHOW_GRID:
            SS.GW.showSnapGrid = !SS.GW.showSnapGrid;
            SS.GW.EnsureValidActives();
            SS.GW.Invalidate();
            if(SS.GW.showSnapGrid &amp;&amp; !SS.GW.LockedInWorkplane()) {
                Message(_("No workplane is active, so the grid will not appear."));
            }
            break;

        case Command::PERSPECTIVE_PROJ:
            SS.usePerspectiveProj = !SS.usePerspectiveProj;
            SS.GW.EnsureValidActives();
            SS.GW.Invalidate();
            if(SS.cameraTangent &lt; 1e-6) {
                Error(_("The perspective factor is set to zero, so the view will "
                        "always be a parallel projection.\n\n"
                        "For a perspective projection, modify the perspective "
                        "factor in the configuration screen. A value around 0.3 "
                        "is typical."));
            }
            break;

        case Command::ONTO_WORKPLANE:
            if(SS.GW.LockedInWorkplane()) {
                SS.GW.AnimateOntoWorkplane();
                break;
            }  // if not in 2d mode use ORTHO logic
            // fallthrough
        case Command::NEAREST_ORTHO:
        case Command::NEAREST_ISO: {
            @others
}

</t>
<t tx="leo.20191228122645.160">    double ac = a.Element(which),
           bc = b.Element(which);
    if(ac &lt; c + KDTREE_EPS ||
       bc &lt; c + KDTREE_EPS)
    {
        lt-&gt;FindEdgeOn(a, b, cnt, coplanarIsInter, info);
    }
    if(ac &gt; c - KDTREE_EPS ||
       bc &gt; c - KDTREE_EPS)
    {
        gt-&gt;FindEdgeOn(a, b, cnt, coplanarIsInter, info);
    }
    return;
}

// We are a leaf node; so we iterate over all the triangles in our
// linked list.
STriangleLl *ll;
for(ll = tris; ll; ll = ll-&gt;next) {
    STriangle *tr = ll-&gt;tri;

    if(tr-&gt;tag == cnt) continue;

    // Test if this triangle matches up with the given edge
    if((a.Equals(tr-&gt;b) &amp;&amp; b.Equals(tr-&gt;a)) ||
       (a.Equals(tr-&gt;c) &amp;&amp; b.Equals(tr-&gt;b)) ||
       (a.Equals(tr-&gt;a) &amp;&amp; b.Equals(tr-&gt;c)))
    {
        info-&gt;count++;
        // Record whether this triangle is front- or back-facing.
        if(tr-&gt;Normal().z &gt; LENGTH_EPS) {
            info-&gt;frontFacing = true;
        } else {
            info-&gt;frontFacing = false;
        }
        // Record the triangle
        info-&gt;tr = tr;
        // And record which vertices a and b correspond to
        info-&gt;ai = a.Equals(tr-&gt;a) ? 0 : (a.Equals(tr-&gt;b) ? 1 : 2);
        info-&gt;bi = b.Equals(tr-&gt;a) ? 0 : (b.Equals(tr-&gt;b) ? 1 : 2);
    } else if(((a.Equals(tr-&gt;a) &amp;&amp; b.Equals(tr-&gt;b)) ||
               (a.Equals(tr-&gt;b) &amp;&amp; b.Equals(tr-&gt;c)) ||
               (a.Equals(tr-&gt;c) &amp;&amp; b.Equals(tr-&gt;a))))
    {
        // It's an edge of this triangle, okay.
    } else {
        // Check for self-intersection
        Vector n = (tr-&gt;Normal()).WithMagnitude(1);
        double d = (tr-&gt;a).Dot(n);
        double pa = a.Dot(n) - d, pb = b.Dot(n) - d;
        // It's an intersection if neither point lies in-plane,
        // and the edge crosses the plane (should handle in-plane
        // intersections separately but don't yet).
        if((pa &lt; -LENGTH_EPS || pa &gt; LENGTH_EPS) &amp;&amp;
           (pb &lt; -LENGTH_EPS || pb &gt; LENGTH_EPS) &amp;&amp;
           (pa*pb &lt; 0))
        {
            // The edge crosses the plane of the triangle; now see if
            // it crosses inside the triangle.
            if(tr-&gt;ContainsPointProjd(b.Minus(a), a)) {
                if(coplanarIsInter) {
                    info-&gt;intersectsMesh = true;
                } else {
                    Vector p = Vector::AtIntersectionOfPlaneAndLine(
                                            n, d, a, b, NULL);
                    Vector ta = tr-&gt;a,
                           tb = tr-&gt;b,
                           tc = tr-&gt;c;
                    if((p.DistanceToLine(ta, tb.Minus(ta)) &lt; LENGTH_EPS) ||
                       (p.DistanceToLine(tb, tc.Minus(tb)) &lt; LENGTH_EPS) ||
                       (p.DistanceToLine(tc, ta.Minus(tc)) &lt; LENGTH_EPS))
                    {
                        // Intersection lies on edge. This happens when
                        // our edge is from a triangle coplanar with
                        // another triangle in the mesh. We don't test
                        // the edge against triangles whose plane contains
                        // that edge, but we do end up testing against
                        // the coplanar triangle's neighbours, which we
                        // will intersect on their edges.
                    } else {
                        info-&gt;intersectsMesh = true;
                    }
                }
            }
        }
    }

    // Ensure that we don't count this triangle twice if it appears
    // in two buckets of the kd tree.
    tr-&gt;tag = cnt;
}
</t>
<t tx="leo.20191228122645.161">static bool CheckAndAddTrianglePair(std::set&lt;std::pair&lt;STriangle *, STriangle *&gt;&gt; *pairs,
                                    STriangle *a, STriangle *b)
{
    if(pairs-&gt;find(std::make_pair(a, b)) != pairs-&gt;end() ||
       pairs-&gt;find(std::make_pair(b, a)) != pairs-&gt;end())
        return true;

    pairs-&gt;emplace(a, b);
    return false;
}

//-----------------------------------------------------------------------------
// Pick certain classes of edges out from our mesh. These might be:
//    * naked edges (i.e., edges with no anti-parallel neighbor) and self-
//      intersecting edges (i.e., edges that cross another triangle)
//    * turning edges (i.e., edges where a front-facing triangle joins
//      a back-facing triangle)
//    * emphasized edges (i.e., edges where a triangle from one face joins
//      a triangle from a different face)
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122645.162">void SKdNode::MakeCertainEdgesInto(SEdgeList *sel, EdgeKind how, bool coplanarIsInter,
                                   bool *inter, bool *leaky, int auxA) const
{
    if(inter) *inter = false;
    if(leaky) *leaky = false;

    std::vector&lt;STriangle *&gt; tris;
    ClearTags();
    ListTrianglesInto(&amp;tris);

    std::set&lt;std::pair&lt;STriangle *, STriangle *&gt;&gt; edgeTris;
    int cnt = 1234;
    for(STriangle *tr : tris) {
        for(int j = 0; j &lt; 3; j++) {
            Vector a = tr-&gt;vertices[j];
            Vector b = tr-&gt;vertices[(j + 1) % 3];

            SKdNode::EdgeOnInfo info = {};
            FindEdgeOn(a, b, cnt, coplanarIsInter, &amp;info);

            switch(how) {
                case EdgeKind::NAKED_OR_SELF_INTER:
                    if(info.count != 1) {
                        sel-&gt;AddEdge(a, b, auxA);
                        if(leaky) *leaky = true;
                    }
                    if(info.intersectsMesh) {
                        sel-&gt;AddEdge(a, b, auxA);
                        if(inter) *inter = true;
                    }
                    break;

                case EdgeKind::SELF_INTER:
                    if(info.intersectsMesh) {
                        sel-&gt;AddEdge(a, b, auxA);
                        if(inter) *inter = true;
                    }
                    break;

                case EdgeKind::TURNING:
                    if((tr-&gt;Normal().z &lt; LENGTH_EPS) &amp;&amp;
                       (info.count == 1) &amp;&amp;
                       info.frontFacing)
                    {
                        if(CheckAndAddTrianglePair(&amp;edgeTris, tr, info.tr))
                            break;
                        // This triangle is back-facing (or on edge), and
                        // this edge has exactly one mate, and that mate is
                        // front-facing. So this is a turning edge.
                        sel-&gt;AddEdge(a, b, auxA);
                    }
                    break;

                case EdgeKind::EMPHASIZED:
                    if(info.count == 1 &amp;&amp; tr-&gt;meta.face != info.tr-&gt;meta.face) {
                        if(CheckAndAddTrianglePair(&amp;edgeTris, tr, info.tr))
                            break;
                        // The two triangles that join at this edge come from
                        // different faces; either really different faces,
                        // or one is from a face and the other is zero (i.e.,
                        // not from a face).
                        sel-&gt;AddEdge(a, b, auxA);
                    }
                    break;

                case EdgeKind::SHARP:
                    if(info.count == 1) {
                        Vector na0 = tr-&gt;normals[j].WithMagnitude(1.0);
                        Vector nb0 = tr-&gt;normals[(j + 1) % 3].WithMagnitude(1.0);
                        Vector na1 = info.tr-&gt;normals[info.ai].WithMagnitude(1.0);
                        Vector nb1 = info.tr-&gt;normals[info.bi].WithMagnitude(1.0);
                        if(!((na0.Equals(na1) &amp;&amp; nb0.Equals(nb1)) ||
                             (na0.Equals(nb1) &amp;&amp; nb0.Equals(na1)))) {
                            if(CheckAndAddTrianglePair(&amp;edgeTris, tr, info.tr))
                                break;
                            // The two triangles that join at this edge meet at a sharp
                            // angle. This implies they come from different faces.
                            sel-&gt;AddEdge(a, b, auxA);
                        }
                    }
                    break;
            }

            cnt++;
        }
    }
}

</t>
<t tx="leo.20191228122645.163">void SKdNode::MakeOutlinesInto(SOutlineList *sol, EdgeKind edgeKind) const
{
    std::vector&lt;STriangle *&gt; tris;
    ClearTags();
    ListTrianglesInto(&amp;tris);

    std::set&lt;std::pair&lt;STriangle *, STriangle *&gt;&gt; edgeTris;
    int cnt = 1234;
    for(STriangle *tr : tris) {
        for(int j = 0; j &lt; 3; j++) {
            Vector a = tr-&gt;vertices[j];
            Vector b = tr-&gt;vertices[(j + 1) % 3];

            SKdNode::EdgeOnInfo info = {};
            FindEdgeOn(a, b, cnt, /*coplanarIsInter=*/false, &amp;info);
            cnt++;
            if(info.count != 1) continue;
            if(CheckAndAddTrianglePair(&amp;edgeTris, tr, info.tr))
                continue;

            int tag = 0;
            switch(edgeKind) {
                case EdgeKind::EMPHASIZED:
                    if(tr-&gt;meta.face != info.tr-&gt;meta.face) {
                        tag = 1;
                    }
                    break;

                case EdgeKind::SHARP: {
                        Vector na0 = tr-&gt;normals[j].WithMagnitude(1.0);
                        Vector nb0 = tr-&gt;normals[(j + 1) % 3].WithMagnitude(1.0);
                        Vector na1 = info.tr-&gt;normals[info.ai].WithMagnitude(1.0);
                        Vector nb1 = info.tr-&gt;normals[info.bi].WithMagnitude(1.0);
                        if(!((na0.Equals(na1) &amp;&amp; nb0.Equals(nb1)) ||
                             (na0.Equals(nb1) &amp;&amp; nb0.Equals(na1)))) {
                            tag = 1;
                        }
                    }
                    break;

                default:
                    ssassert(false, "Unexpected edge kind");
            }

            Vector nl = tr-&gt;Normal().WithMagnitude(1.0);
            Vector nr = info.tr-&gt;Normal().WithMagnitude(1.0);

            // We don't add edges with the same left and right
            // normals because they can't produce outlines.
            if(tag == 0 &amp;&amp; nl.Equals(nr)) continue;
            sol-&gt;AddEdge(a, b, nl, nr, tag);
        }
    }
}

</t>
<t tx="leo.20191228122645.164">bool SOutline::IsVisible(Vector projDir) const {
    double ldot = nl.Dot(projDir);
    double rdot = nr.Dot(projDir);
    return (ldot &gt; -LENGTH_EPS) == (rdot &lt; LENGTH_EPS) ||
           (rdot &gt; -LENGTH_EPS) == (ldot &lt; LENGTH_EPS);
}

</t>
<t tx="leo.20191228122645.165">void SOutlineList::Clear() {
    l.Clear();
}

</t>
<t tx="leo.20191228122645.166">void SOutlineList::AddEdge(Vector a, Vector b, Vector nl, Vector nr, int tag) {
    SOutline so = {};
    so.a   = a;
    so.b   = b;
    so.nl  = nl;
    so.nr  = nr;
    so.tag = tag;
    l.Add(&amp;so);
}

</t>
<t tx="leo.20191228122645.167">void SOutlineList::ListTaggedInto(SEdgeList *el, int auxA, int auxB) {
    for(const SOutline &amp;so : l) {
        if(so.tag == 0) continue;
        el-&gt;AddEdge(so.a, so.b, auxA, auxB);
    }
}

</t>
<t tx="leo.20191228122645.168">void SOutlineList::MakeFromCopyOf(SOutlineList *sol) {
    for(SOutline *so = sol-&gt;l.First(); so; so = sol-&gt;l.NextAfter(so)) {
        l.Add(so);
    }
}

</t>
<t tx="leo.20191228122645.169">void SMesh::PrecomputeTransparency() {
    std::sort(l.begin(), l.end(),
              [&amp;](const STriangle &amp;sta, const STriangle &amp;stb) {
        RgbaColor colora = sta.meta.color,
                  colorb = stb.meta.color;
        @others
}

double SMesh::CalculateVolume() const {
    double vol = 0;
    for(STriangle tr : l) {
        // Translate to place vertex A at (x, y, 0)
        Vector trans = Vector::From(tr.a.x, tr.a.y, 0);
        tr.a = (tr.a).Minus(trans);
        tr.b = (tr.b).Minus(trans);
        tr.c = (tr.c).Minus(trans);

        // Rotate to place vertex B on the y-axis. Depending on
        // whether the triangle is CW or CCW, C is either to the
        // right or to the left of the y-axis. This handles the
        // sign of our normal.
        Vector u = Vector::From(-tr.b.y, tr.b.x, 0);
        u = u.WithMagnitude(1);
        Vector v = Vector::From(tr.b.x, tr.b.y, 0);
        v = v.WithMagnitude(1);
        Vector n = Vector::From(0, 0, 1);

        tr.a = (tr.a).DotInToCsys(u, v, n);
        tr.b = (tr.b).DotInToCsys(u, v, n);
        tr.c = (tr.c).DotInToCsys(u, v, n);

        n = tr.Normal().WithMagnitude(1);

        // Triangles on edge don't contribute
        if(fabs(n.z) &lt; LENGTH_EPS) continue;

        // The plane has equation p dot n = a dot n
        double d = (tr.a).Dot(n);
        // nx*x + ny*y + nz*z = d
        // nz*z = d - nx*x - ny*y
        double A = -n.x/n.z, B = -n.y/n.z, C = d/n.z;

        double mac = tr.c.y/tr.c.x, mbc = (tr.c.y - tr.b.y)/tr.c.x;
        double xc = tr.c.x, yb = tr.b.y;

        // I asked Maple for
        //    int(int(A*x + B*y +C, y=mac*x..(mbc*x + yb)), x=0..xc);
        double integral =
    return vol;
}

double SMesh::CalculateSurfaceArea(const std::vector&lt;uint32_t&gt; &amp;faces) const {
    double area = 0.0;
    for(uint32_t f : faces) {
        for(const STriangle &amp;t : l) {
            if(f != t.meta.face) continue;
            area += t.Area();
        }
    }
    return area;
}
</t>
<t tx="leo.20191228122645.17">static const Vector ortho[3] = {
    Vector::From(1, 0, 0),
    Vector::From(0, 1, 0),
    Vector::From(0, 0, 1)
};
double sqrt2 = sqrt(2.0), sqrt6 = sqrt(6.0);
Quaternion quat0 = Quaternion::From(SS.GW.projRight, SS.GW.projUp);
Quaternion quatf = quat0;
double dmin = 1e10;

// There are 24 possible views; 3*2*2*2
int i, j, negi, negj;
for(i = 0; i &lt; 3; i++) {
    for(j = 0; j &lt; 3; j++) {
        if(i == j) continue;
        for(negi = 0; negi &lt; 2; negi++) {
            for(negj = 0; negj &lt; 2; negj++) {
                Vector ou = ortho[i], ov = ortho[j];
                if(negi) ou = ou.ScaledBy(-1);
                if(negj) ov = ov.ScaledBy(-1);
                Vector on = ou.Cross(ov);

                Vector u, v;
                if(id == Command::NEAREST_ORTHO || id == Command::ONTO_WORKPLANE) {
                    u = ou;
                    v = ov;
                } else {
                    u =
                        ou.ScaledBy(1/sqrt2).Plus(
                        on.ScaledBy(-1/sqrt2));
                    v =
                        ou.ScaledBy(-1/sqrt6).Plus(
                        ov.ScaledBy(2/sqrt6).Plus(
                        on.ScaledBy(-1/sqrt6)));
                }

                Quaternion quatt = Quaternion::From(u, v);
</t>
<t tx="leo.20191228122645.170">        bool opaquea = colora.IsEmpty() || colora.alpha == 255,
             opaqueb = colorb.IsEmpty() || colorb.alpha == 255;

        if(!opaquea || !opaqueb) isTransparent = true;
        return (opaquea != opaqueb &amp;&amp; opaquea == true);
    });
}

void SMesh::RemoveDegenerateTriangles() {
    for(auto &amp;tr : l) {
        tr.tag = (int)tr.IsDegenerate();
    }
    l.RemoveTagged();
</t>
<t tx="leo.20191228122645.18">                        double d = min(
                            (quatt.Minus(quat0)).Magnitude(),
                            (quatt.Plus(quat0)).Magnitude());
                        if(d &lt; dmin) {
                            dmin = d;
                            quatf = quatt;
                        }
                    }
                }
            }
        }

        SS.GW.AnimateOnto(quatf, SS.GW.offset);
        break;
    }

    case Command::CENTER_VIEW:
        SS.GW.GroupSelection();
        if(SS.GW.gs.n == 1 &amp;&amp; SS.GW.gs.points == 1) {
            Quaternion quat0;
            // Offset is the selected point, quaternion is same as before
            Vector pt = SK.GetEntity(SS.GW.gs.point[0])-&gt;PointGetNum();
            quat0 = Quaternion::From(SS.GW.projRight, SS.GW.projUp);
            SS.GW.ClearSelection();
            SS.GW.AnimateOnto(quat0, pt.ScaledBy(-1));
        } else {
            Error(_("Select a point; this point will become the center "
                    "of the view on screen."));
        }
        break;

    case Command::SHOW_TOOLBAR:
        SS.showToolbar = !SS.showToolbar;
        SS.GW.EnsureValidActives();
        SS.GW.Invalidate();
        break;

    case Command::SHOW_TEXT_WND:
        SS.GW.showTextWindow = !SS.GW.showTextWindow;
        SS.GW.EnsureValidActives();
        break;

    case Command::UNITS_INCHES:
        SS.viewUnits = Unit::INCHES;
        SS.ScheduleShowTW();
        SS.GW.EnsureValidActives();
        break;

    case Command::UNITS_MM:
        SS.viewUnits = Unit::MM;
        SS.ScheduleShowTW();
        SS.GW.EnsureValidActives();
        break;

    case Command::UNITS_METERS:
        SS.viewUnits = Unit::METERS;
        SS.ScheduleShowTW();
        SS.GW.EnsureValidActives();
        break;

    case Command::FULL_SCREEN:
        SS.GW.window-&gt;SetFullScreen(!SS.GW.window-&gt;IsFullScreen());
        SS.GW.EnsureValidActives();
        break;

    default: ssassert(false, "Unexpected menu ID");
}
SS.GW.Invalidate();
</t>
<t tx="leo.20191228122645.19">void GraphicsWindow::EnsureValidActives() {
    bool change = false;
    // The active group must exist, and not be the references.
    Group *g = SK.group.FindByIdNoOops(activeGroup);
    if((!g) || (g-&gt;h == Group::HGROUP_REFERENCES)) {
        // Not using range-for because this is used to find an index.
        int i;
        for(i = 0; i &lt; SK.groupOrder.n; i++) {
            if(SK.groupOrder[i] != Group::HGROUP_REFERENCES) {
                break;
            }
        }
        if(i &gt;= SK.groupOrder.n) {
            // This can happen if the user deletes all the groups in the
            // sketch. It's difficult to prevent that, because the last
            // group might have been deleted automatically, because it failed
            // a dependency. There needs to be something, so create a plane
            // drawing group and activate that. They should never be able
            // to delete the references, though.
            activeGroup = SS.CreateDefaultDrawingGroup();
            // We've created the default group, but not the workplane entity;
            // do it now so that drawing mode isn't switched to "Free in 3d".
            SS.GenerateAll(SolveSpaceUI::Generate::ALL);
        } else {
            activeGroup = SK.groupOrder[i];
        }
        SK.GetGroup(activeGroup)-&gt;Activate();
        change = true;
    }

    // The active coordinate system must also exist.
    if(LockedInWorkplane()) {
        Entity *e = SK.entity.FindByIdNoOops(ActiveWorkplane());
        if(e) {
            hGroup hgw = e-&gt;group;
            if(hgw != activeGroup &amp;&amp; SS.GroupsInOrder(activeGroup, hgw)) {
                // The active workplane is in a group that comes after the
                // active group; so any request or constraint will fail.
                SetWorkplaneFreeIn3d();
                change = true;
            }
        } else {
            SetWorkplaneFreeIn3d();
            change = true;
        }
    }

    if(!window) return;

    // And update the checked state for various menus
    bool locked = LockedInWorkplane();
    in3dMenuItem-&gt;SetActive(!locked);
    inWorkplaneMenuItem-&gt;SetActive(locked);

    SS.UndoEnableMenus();

    switch(SS.viewUnits) {
        case Unit::MM:
        case Unit::METERS:
        case Unit::INCHES:
            break;
        default:
            SS.viewUnits = Unit::MM;
            break;
    }
    unitsMmMenuItem-&gt;SetActive(SS.viewUnits == Unit::MM);
    unitsMetersMenuItem-&gt;SetActive(SS.viewUnits == Unit::METERS);
    unitsInchesMenuItem-&gt;SetActive(SS.viewUnits == Unit::INCHES);

    if(SS.TW.window) SS.TW.window-&gt;SetVisible(SS.GW.showTextWindow);
    showTextWndMenuItem-&gt;SetActive(SS.GW.showTextWindow);

    showGridMenuItem-&gt;SetActive(SS.GW.showSnapGrid);
    perspectiveProjMenuItem-&gt;SetActive(SS.usePerspectiveProj);
    showToolbarMenuItem-&gt;SetActive(SS.showToolbar);
    fullScreenMenuItem-&gt;SetActive(SS.GW.window-&gt;IsFullScreen());

    if(change) SS.ScheduleShowTW();
}

</t>
<t tx="leo.20191228122645.2">const MenuEntry Menu[] = {
//lv label                              cmd                        accel    kind
{ 0, N_("&amp;File"),                       Command::NONE,             0,       KN, NULL   },
{ 1, N_("&amp;New"),                        Command::NEW,              C|'n',   KN, mFile  },
{ 1, N_("&amp;Open..."),                    Command::OPEN,             C|'o',   KN, mFile  },
{ 1, N_("Open &amp;Recent"),                Command::OPEN_RECENT,      0,       KN, mFile  },
{ 1, N_("&amp;Save"),                       Command::SAVE,             C|'s',   KN, mFile  },
{ 1, N_("Save &amp;As..."),                 Command::SAVE_AS,          0,       KN, mFile  },
{ 1,  NULL,                             Command::NONE,             0,       KN, NULL   },
{ 1, N_("Export &amp;Image..."),            Command::EXPORT_IMAGE,     0,       KN, mFile  },
{ 1, N_("Export 2d &amp;View..."),          Command::EXPORT_VIEW,      0,       KN, mFile  },
{ 1, N_("Export 2d &amp;Section..."),       Command::EXPORT_SECTION,   0,       KN, mFile  },
{ 1, N_("Export 3d &amp;Wireframe..."),     Command::EXPORT_WIREFRAME, 0,       KN, mFile  },
{ 1, N_("Export Triangle &amp;Mesh..."),    Command::EXPORT_MESH,      0,       KN, mFile  },
{ 1, N_("Export &amp;Surfaces..."),         Command::EXPORT_SURFACES,  0,       KN, mFile  },
{ 1, N_("Im&amp;port..."),                  Command::IMPORT,           0,       KN, mFile  },
#ifndef __APPLE__
{ 1,  NULL,                             Command::NONE,             0,       KN, NULL   },
{ 1, N_("E&amp;xit"),                       Command::EXIT,             C|'q',   KN, mFile  },
#endif

{ 0, N_("&amp;Edit"),                       Command::NONE,             0,       KN, NULL   },
{ 1, N_("&amp;Undo"),                       Command::UNDO,             C|'z',   KN, mEdit  },
{ 1, N_("&amp;Redo"),                       Command::REDO,             C|'y',   KN, mEdit  },
{ 1, N_("Re&amp;generate All"),             Command::REGEN_ALL,        ' ',     KN, mEdit  },
{ 1,  NULL,                             Command::NONE,             0,       KN, NULL   },
{ 1, N_("Snap Selection to &amp;Grid"),     Command::SNAP_TO_GRID,     '.',     KN, mEdit  },
{ 1, N_("Rotate Imported &amp;90°"),        Command::ROTATE_90,        '9',     KN, mEdit  },
{ 1,  NULL,                             Command::NONE,             0,       KN, NULL   },
{ 1, N_("Cu&amp;t"),                        Command::CUT,              C|'x',   KN, mClip  },
{ 1, N_("&amp;Copy"),                       Command::COPY,             C|'c',   KN, mClip  },
{ 1, N_("&amp;Paste"),                      Command::PASTE,            C|'v',   KN, mClip  },
{ 1, N_("Paste &amp;Transformed..."),       Command::PASTE_TRANSFORM,  C|'t',   KN, mClip  },
{ 1, N_("&amp;Delete"),                     Command::DELETE,           '\x7f',  KN, mClip  },
{ 1,  NULL,                             Command::NONE,             0,       KN, NULL   },
{ 1, N_("Select &amp;Edge Chain"),          Command::SELECT_CHAIN,     C|'e',   KN, mEdit  },
{ 1, N_("Select &amp;All"),                 Command::SELECT_ALL,       C|'a',   KN, mEdit  },
{ 1, N_("&amp;Unselect All"),               Command::UNSELECT_ALL,     '\x1b',  KN, mEdit  },

{ 0, N_("&amp;View"),                       Command::NONE,             0,       KN, mView  },
{ 1, N_("Zoom &amp;In"),                    Command::ZOOM_IN,          '+',     KN, mView  },
{ 1, N_("Zoom &amp;Out"),                   Command::ZOOM_OUT,         '-',     KN, mView  },
{ 1, N_("Zoom To &amp;Fit"),                Command::ZOOM_TO_FIT,      'f',     KN, mView  },
{ 1,  NULL,                             Command::NONE,             0,       KN, NULL   },
{ 1, N_("Align View to &amp;Workplane"),    Command::ONTO_WORKPLANE,   'w',     KN, mView  },
{ 1, N_("Nearest &amp;Ortho View"),         Command::NEAREST_ORTHO,    F|2,     KN, mView  },
{ 1, N_("Nearest &amp;Isometric View"),     Command::NEAREST_ISO,      F|3,     KN, mView  },
{ 1, N_("&amp;Center View At Point"),       Command::CENTER_VIEW,      F|4,     KN, mView  },
{ 1,  NULL,                             Command::NONE,             0,       KN, NULL   },
{ 1, N_("Show Snap &amp;Grid"),             Command::SHOW_GRID,        '&gt;',     KC, mView  },
{ 1, N_("Use &amp;Perspective Projection"), Command::PERSPECTIVE_PROJ, '`',     KC, mView  },
{ 1, N_("Dimension &amp;Units"),            Command::NONE,             0,       KN, NULL  },
{ 2, N_("Dimensions in &amp;Millimeters"),  Command::UNITS_MM,         0,       KR, mView },
{ 2, N_("Dimensions in M&amp;eters"),       Command::UNITS_METERS,     0,       KR, mView },
{ 2, N_("Dimensions in &amp;Inches"),       Command::UNITS_INCHES,     0,       KR, mView },
{ 1,  NULL,                             Command::NONE,             0,       KN, NULL   },
{ 1, N_("Show &amp;Toolbar"),               Command::SHOW_TOOLBAR,     0,       KC, mView  },
{ 1, N_("Show Property Bro&amp;wser"),      Command::SHOW_TEXT_WND,    '\t',    KC, mView  },
{ 1,  NULL,                             Command::NONE,             0,       KN, NULL   },
{ 1, N_("&amp;Full Screen"),                Command::FULL_SCREEN,      C|F|11,  KC, mView  },

{ 0, N_("&amp;New Group"),                  Command::NONE,             0,       KN, mGrp   },
{ 1, N_("Sketch In &amp;3d"),               Command::GROUP_3D,         S|'3',   KN, mGrp   },
{ 1, N_("Sketch In New &amp;Workplane"),    Command::GROUP_WRKPL,      S|'w',   KN, mGrp   },
{ 1, NULL,                              Command::NONE,             0,       KN, NULL   },
{ 1, N_("Step &amp;Translating"),           Command::GROUP_TRANS,      S|'t',   KN, mGrp   },
{ 1, N_("Step &amp;Rotating"),              Command::GROUP_ROT,        S|'r',   KN, mGrp   },
{ 1, NULL,                              Command::NONE,             0,       KN, NULL   },
{ 1, N_("E&amp;xtrude"),                    Command::GROUP_EXTRUDE,    S|'x',   KN, mGrp   },
{ 1, N_("&amp;Helix"),                      Command::GROUP_HELIX,      S|'h',   KN, mGrp   },
{ 1, N_("&amp;Lathe"),                      Command::GROUP_LATHE,      S|'l',   KN, mGrp   },
{ 1, N_("Re&amp;volve"),                    Command::GROUP_REVOLVE,    S|'v',   KN, mGrp   },
{ 1, NULL,                              Command::NONE,             0,       KN, NULL   },
{ 1, N_("Link / Assemble..."),          Command::GROUP_LINK,       S|'i',   KN, mGrp   },
{ 1, N_("Link Recent"),                 Command::GROUP_RECENT,     0,       KN, mGrp   },

{ 0, N_("&amp;Sketch"),                     Command::NONE,             0,       KN, mReq   },
{ 1, N_("In &amp;Workplane"),               Command::SEL_WORKPLANE,    '2',     KR, mReq   },
{ 1, N_("Anywhere In &amp;3d"),             Command::FREE_IN_3D,       '3',     KR, mReq   },
{ 1, NULL,                              Command::NONE,             0,       KN, NULL   },
{ 1, N_("Datum &amp;Point"),                Command::DATUM_POINT,      'p',     KN, mReq   },
{ 1, N_("&amp;Workplane"),                  Command::WORKPLANE,        0,       KN, mReq   },
{ 1, NULL,                              Command::NONE,             0,       KN, NULL   },
{ 1, N_("Line &amp;Segment"),               Command::LINE_SEGMENT,     's',     KN, mReq   },
{ 1, N_("C&amp;onstruction Line Segment"),  Command::CONSTR_SEGMENT,   S|'s',   KN, mReq   },
{ 1, N_("&amp;Rectangle"),                  Command::RECTANGLE,        'r',     KN, mReq   },
{ 1, N_("&amp;Circle"),                     Command::CIRCLE,           'c',     KN, mReq   },
{ 1, N_("&amp;Arc of a Circle"),            Command::ARC,              'a',     KN, mReq   },
{ 1, N_("&amp;Bezier Cubic Spline"),        Command::CUBIC,            'b',     KN, mReq   },
{ 1, NULL,                              Command::NONE,             0,       KN, NULL   },
{ 1, N_("&amp;Text in TrueType Font"),      Command::TTF_TEXT,         't',     KN, mReq   },
{ 1, N_("&amp;Image"),                      Command::IMAGE,            0,       KN, mReq   },
{ 1, NULL,                              Command::NONE,             0,       KN, NULL   },
{ 1, N_("To&amp;ggle Construction"),        Command::CONSTRUCTION,     'g',     KN, mReq   },
{ 1, N_("Tangent &amp;Arc at Point"),       Command::TANGENT_ARC,      S|'a',   KN, mReq   },
{ 1, N_("Split Curves at &amp;Intersection"), Command::SPLIT_CURVES,   'i',     KN, mReq   },

{ 0, N_("&amp;Constrain"),                  Command::NONE,             0,       KN, mCon   },
{ 1, N_("&amp;Distance / Diameter"),        Command::DISTANCE_DIA,     'd',     KN, mCon   },
{ 1, N_("Re&amp;ference Dimension"),        Command::REF_DISTANCE,     S|'d',   KN, mCon   },
{ 1, N_("A&amp;ngle"),                      Command::ANGLE,            'n',     KN, mCon   },
{ 1, N_("Reference An&amp;gle"),            Command::REF_ANGLE,        S|'n',   KN, mCon   },
{ 1, N_("Other S&amp;upplementary Angle"),  Command::OTHER_ANGLE,      'u',     KN, mCon   },
{ 1, N_("Toggle R&amp;eference Dim"),       Command::REFERENCE,        'e',     KN, mCon   },
{ 1, NULL,                              Command::NONE,             0,       KN, NULL   },
{ 1, N_("&amp;Horizontal"),                 Command::HORIZONTAL,       'h',     KN, mCon   },
{ 1, N_("&amp;Vertical"),                   Command::VERTICAL,         'v',     KN, mCon   },
{ 1, NULL,                              Command::NONE,             0,       KN, NULL   },
{ 1, N_("&amp;On Point / Curve / Plane"),   Command::ON_ENTITY,        'o',     KN, mCon   },
{ 1, N_("E&amp;qual Length / Radius / Angle"), Command::EQUAL,         'q',     KN, mCon   },
{ 1, N_("Length Ra&amp;tio"),               Command::RATIO,            'z',     KN, mCon   },
{ 1, N_("Length Diff&amp;erence"),          Command::DIFFERENCE,       'j',     KN, mCon   },
{ 1, N_("At &amp;Midpoint"),                Command::AT_MIDPOINT,      'm',     KN, mCon   },
{ 1, N_("S&amp;ymmetric"),                  Command::SYMMETRIC,        'y',     KN, mCon   },
{ 1, N_("Para&amp;llel / Tangent"),         Command::PARALLEL,         'l',     KN, mCon   },
{ 1, N_("&amp;Perpendicular"),              Command::PERPENDICULAR,    '[',     KN, mCon   },
{ 1, N_("Same Orient&amp;ation"),           Command::ORIENTED_SAME,    'x',     KN, mCon   },
{ 1, N_("Lock Point Where &amp;Dragged"),   Command::WHERE_DRAGGED,    ']',     KN, mCon   },
{ 1, NULL,                              Command::NONE,             0,       KN, NULL   },
{ 1, N_("Comment"),                     Command::COMMENT,          ';',     KN, mCon   },

{ 0, N_("&amp;Analyze"),                    Command::NONE,             0,       KN, mAna   },
{ 1, N_("Measure &amp;Volume"),             Command::VOLUME,           C|S|'v', KN, mAna   },
{ 1, N_("Measure A&amp;rea"),               Command::AREA,             C|S|'a', KN, mAna   },
{ 1, N_("Measure &amp;Perimeter"),          Command::PERIMETER,        C|S|'p', KN, mAna   },
{ 1, N_("Show &amp;Interfering Parts"),     Command::INTERFERENCE,     C|S|'i', KN, mAna   },
{ 1, N_("Show &amp;Naked Edges"),           Command::NAKED_EDGES,      C|S|'n', KN, mAna   },
{ 1, N_("Show &amp;Center of Mass"),        Command::CENTER_OF_MASS,   C|S|'c', KN, mAna   },
{ 1, NULL,                              Command::NONE,             0,       KN, NULL   },
{ 1, N_("Show &amp;Underconstrained Points"), Command::SHOW_DOF,       C|S|'f', KN, mAna   },
{ 1, NULL,                              Command::NONE,             0,       KN, NULL   },
{ 1, N_("&amp;Trace Point"),                Command::TRACE_PT,         C|S|'t', KN, mAna   },
{ 1, N_("&amp;Stop Tracing..."),            Command::STOP_TRACING,     C|S|'s', KN, mAna   },
{ 1, N_("Step &amp;Dimension..."),          Command::STEP_DIM,         C|S|'d', KN, mAna   },

{ 0, N_("&amp;Help"),                       Command::NONE,             0,       KN, mHelp  },
{ 1, N_("&amp;Language"),                   Command::LOCALE,           0,       KN, mHelp  },
{ 1, N_("&amp;Website / Manual"),           Command::WEBSITE,          0,       KN, mHelp  },
#ifndef __APPLE__
{ 1, N_("&amp;About"),                      Command::ABOUT,            0,       KN, mHelp  },
#endif
{ -1, 0,                                Command::NONE,             0,       KN, NULL   }
};
#undef S
#undef C
#undef F
#undef KN
#undef KC
#undef KR

</t>
<t tx="leo.20191228122645.20">void GraphicsWindow::SetWorkplaneFreeIn3d() {
    SK.GetGroup(activeGroup)-&gt;activeWorkplane = Entity::FREE_IN_3D;
}
hEntity GraphicsWindow::ActiveWorkplane() {
    Group *g = SK.group.FindByIdNoOops(activeGroup);
    if(g) {
        return g-&gt;activeWorkplane;
    } else {
        return Entity::FREE_IN_3D;
    }
}
</t>
<t tx="leo.20191228122645.21">bool GraphicsWindow::LockedInWorkplane() {
    return (SS.GW.ActiveWorkplane() != Entity::FREE_IN_3D);
}

</t>
<t tx="leo.20191228122645.22">void GraphicsWindow::ForceTextWindowShown() {
    if(!showTextWindow) {
        showTextWindow = true;
        showTextWndMenuItem-&gt;SetActive(true);
        SS.TW.window-&gt;SetVisible(true);
    }
}

</t>
<t tx="leo.20191228122645.23">void GraphicsWindow::DeleteTaggedRequests() {
    // Rewrite any point-coincident constraints that were affected by this
    // deletion.
    Request *r;
    for(r = SK.request.First(); r; r = SK.request.NextAfter(r)) {
        if(!r-&gt;tag) continue;
        FixConstraintsForRequestBeingDeleted(r-&gt;h);
    }
    // and then delete the tagged requests.
    SK.request.RemoveTagged();

    // An edit might be in progress for the just-deleted item. So
    // now it's not.
    window-&gt;HideEditor();
    SS.TW.HideEditControl();
    // And clear out the selection, which could contain that item.
    ClearSuper();
    // And regenerate to get rid of what it generates, plus anything
    // that references it (since the regen code checks for that).
    SS.GenerateAll(SolveSpaceUI::Generate::ALL);
    EnsureValidActives();
    SS.ScheduleShowTW();
}

Vector GraphicsWindow::SnapToGrid(Vector p) {
    if(!LockedInWorkplane()) return p;

    EntityBase *wrkpl = SK.GetEntity(ActiveWorkplane()),
               *norm  = wrkpl-&gt;Normal();
    Vector wo = SK.GetEntity(wrkpl-&gt;point[0])-&gt;PointGetNum(),
           wu = norm-&gt;NormalU(),
           wv = norm-&gt;NormalV(),
           wn = norm-&gt;NormalN();

    Vector pp = (p.Minus(wo)).DotInToCsys(wu, wv, wn);
    pp.x = floor((pp.x / SS.gridSpacing) + 0.5)*SS.gridSpacing;
    pp.y = floor((pp.y / SS.gridSpacing) + 0.5)*SS.gridSpacing;
    pp.z = 0;

    return pp.ScaleOutOfCsys(wu, wv, wn).Plus(wo);
}

</t>
<t tx="leo.20191228122645.24">void GraphicsWindow::MenuEdit(Command id) {
    switch(id) {
        case Command::UNSELECT_ALL:
            SS.GW.GroupSelection();
            // If there's nothing selected to de-select, and no operation
            // to cancel, then perhaps they want to return to the home
            // screen in the text window.
            if(SS.GW.gs.n               == 0 &amp;&amp;
               SS.GW.gs.constraints     == 0 &amp;&amp;
               SS.GW.pending.operation  == Pending::NONE)
            {
                if(!(SS.TW.window-&gt;IsEditorVisible() ||
                     SS.GW.window-&gt;IsEditorVisible()))
                {
                    if(SS.TW.shown.screen == TextWindow::Screen::STYLE_INFO) {
                        SS.TW.GoToScreen(TextWindow::Screen::LIST_OF_STYLES);
                    } else {
                        SS.TW.ClearSuper();
                    }
                }
            }
            SS.GW.ClearSuper();
            SS.TW.HideEditControl();
            SS.nakedEdges.Clear();
            SS.justExportedInfo.draw = false;
            SS.centerOfMass.draw = false;
            // This clears the marks drawn to indicate which points are
            // still free to drag.
            Param *p;
            for(p = SK.param.First(); p; p = SK.param.NextAfter(p)) {
                p-&gt;free = false;
            }
            if(SS.exportMode) {
                SS.exportMode = false;
                SS.GenerateAll(SolveSpaceUI::Generate::ALL);
            }
            SS.GW.persistentDirty = true;
            break;

        case Command::SELECT_ALL: {
            Entity *e;
            for(e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
                if(e-&gt;group != SS.GW.activeGroup) continue;
                if(e-&gt;IsFace() || e-&gt;IsDistance()) continue;
                if(!e-&gt;IsVisible()) continue;

                SS.GW.MakeSelected(e-&gt;h);
            }
            SS.GW.Invalidate();
            SS.ScheduleShowTW();
            break;
        }

        case Command::SELECT_CHAIN: {
            Entity *e;
            int newlySelected = 0;
            bool didSomething;
            do {
                didSomething = false;
                for(e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
                    if(e-&gt;group != SS.GW.activeGroup) continue;
                    if(!e-&gt;HasEndpoints()) continue;
                    if(!e-&gt;IsVisible()) continue;

                    Vector st = e-&gt;EndpointStart(),
                           fi = e-&gt;EndpointFinish();

                    bool onChain = false, alreadySelected = false;
                    List&lt;Selection&gt; *ls = &amp;(SS.GW.selection);
                    for(Selection *s = ls-&gt;First(); s; s = ls-&gt;NextAfter(s)) {
                        if(!s-&gt;entity.v) continue;
                        if(s-&gt;entity == e-&gt;h) {
                            alreadySelected = true;
                            continue;
                        }
                        Entity *se = SK.GetEntity(s-&gt;entity);
                        if(!se-&gt;HasEndpoints()) continue;

                        Vector sst = se-&gt;EndpointStart(),
                               sfi = se-&gt;EndpointFinish();

                        if(sst.Equals(st) || sst.Equals(fi) ||
                           sfi.Equals(st) || sfi.Equals(fi))
                        {
                            onChain = true;
                        }
                    }
                    if(onChain &amp;&amp; !alreadySelected) {
                        SS.GW.MakeSelected(e-&gt;h);
                        newlySelected++;
                        didSomething = true;
                    }
                }
            } while(didSomething);
            SS.GW.Invalidate();
            SS.ScheduleShowTW();
            if(newlySelected == 0) {
                Error(_("No additional entities share endpoints with the selected entities."));
            }
            break;
        }

        case Command::ROTATE_90: {
            SS.GW.GroupSelection();
            Entity *e = NULL;
            if(SS.GW.gs.n == 1 &amp;&amp; SS.GW.gs.points == 1) {
                e = SK.GetEntity(SS.GW.gs.point[0]);
            } else if(SS.GW.gs.n == 1 &amp;&amp; SS.GW.gs.entities == 1) {
                e = SK.GetEntity(SS.GW.gs.entity[0]);
            }
            SS.GW.ClearSelection();

            hGroup hg = e ? e-&gt;group : SS.GW.activeGroup;
            Group *g = SK.GetGroup(hg);
            if(g-&gt;type != Group::Type::LINKED) {
                Error(_("To use this command, select a point or other "
                        "entity from an linked part, or make a link "
                        "group the active group."));
                break;
            }

            SS.UndoRemember();
            // Rotate by ninety degrees about the coordinate axis closest
            // to the screen normal.
            Vector norm = SS.GW.projRight.Cross(SS.GW.projUp);
            norm = norm.ClosestOrtho();
            norm = norm.WithMagnitude(1);
            Quaternion qaa = Quaternion::From(norm, PI/2);

            g-&gt;TransformImportedBy(Vector::From(0, 0, 0), qaa);

            // and regenerate as necessary.
            SS.MarkGroupDirty(hg);
            break;
        }

        case Command::SNAP_TO_GRID: {
            if(!SS.GW.LockedInWorkplane()) {
                Error(_("No workplane is active. Activate a workplane "
                        "(with Sketch -&gt; In Workplane) to define the plane "
                        "for the snap grid."));
                break;
            }
            SS.GW.GroupSelection();
            if(SS.GW.gs.points == 0 &amp;&amp; SS.GW.gs.constraintLabels == 0) {
                Error(_("Can't snap these items to grid; select points, "
                        "text comments, or constraints with a label. "
                        "To snap a line, select its endpoints."));
                break;
            }
            SS.UndoRemember();

            List&lt;Selection&gt; *ls = &amp;(SS.GW.selection);
            for(Selection *s = ls-&gt;First(); s; s = ls-&gt;NextAfter(s)) {
                if(s-&gt;entity.v) {
                    hEntity hp = s-&gt;entity;
                    Entity *ep = SK.GetEntity(hp);
                    if(!ep-&gt;IsPoint()) continue;

                    Vector p = ep-&gt;PointGetNum();
                    ep-&gt;PointForceTo(SS.GW.SnapToGrid(p));
                    SS.GW.pending.points.Add(&amp;hp);
                    SS.MarkGroupDirty(ep-&gt;group);
                } else if(s-&gt;constraint.v) {
                    Constraint *c = SK.GetConstraint(s-&gt;constraint);
                    std::vector&lt;Vector&gt; refs;
                    c-&gt;GetReferencePoints(SS.GW.GetCamera(), &amp;refs);
                    c-&gt;disp.offset = c-&gt;disp.offset.Plus(SS.GW.SnapToGrid(refs[0]).Minus(refs[0]));
                }
            }
            // Regenerate, with these points marked as dragged so that they
            // get placed as close as possible to our snap grid.
            SS.GW.ClearPending();

            SS.GW.ClearSelection();
            SS.GW.Invalidate();
            break;
        }

        case Command::UNDO:
            SS.UndoUndo();
            break;

        case Command::REDO:
            SS.UndoRedo();
            break;

        case Command::REGEN_ALL:
            SS.images.clear();
            SS.ReloadAllLinked(SS.saveFile);
            SS.GenerateAll(SolveSpaceUI::Generate::UNTIL_ACTIVE);
            SS.ScheduleShowTW();
            break;

        default: ssassert(false, "Unexpected menu ID");
    }
}

</t>
<t tx="leo.20191228122645.25">void GraphicsWindow::MenuRequest(Command id) {
    const char *s;
    switch(id) {
        case Command::SEL_WORKPLANE: {
            SS.GW.GroupSelection();
            Group *g = SK.GetGroup(SS.GW.activeGroup);

            if(SS.GW.gs.n == 1 &amp;&amp; SS.GW.gs.workplanes == 1) {
                // A user-selected workplane
                g-&gt;activeWorkplane = SS.GW.gs.entity[0];
            } else if(g-&gt;type == Group::Type::DRAWING_WORKPLANE) {
                // The group's default workplane
                g-&gt;activeWorkplane = g-&gt;h.entity(0);
                MessageAndRun([] {
                    // Align the view with the selected workplane
                    SS.GW.ClearSuper();
                    SS.GW.AnimateOntoWorkplane();
                }, _("No workplane selected. Activating default workplane "
                     "for this group."));
            } else {
                Error(_("No workplane is selected, and the active group does "
                        "not have a default workplane. Try selecting a "
                        "workplane, or activating a sketch-in-new-workplane "
                        "group."));
            }
            break;
        }
        case Command::FREE_IN_3D:
            SS.GW.SetWorkplaneFreeIn3d();
            SS.GW.EnsureValidActives();
            SS.ScheduleShowTW();
            SS.GW.Invalidate();
            break;

        case Command::TANGENT_ARC:
            SS.GW.GroupSelection();
            if(SS.GW.gs.n == 1 &amp;&amp; SS.GW.gs.points == 1) {
                SS.GW.MakeTangentArc();
            } else if(SS.GW.gs.n != 0) {
                Error(_("Bad selection for tangent arc at point. Select a "
                        "single point, or select nothing to set up arc "
                        "parameters."));
            } else {
                SS.TW.GoToScreen(TextWindow::Screen::TANGENT_ARC);
                SS.GW.ForceTextWindowShown();
                SS.ScheduleShowTW();
                SS.GW.Invalidate(); // repaint toolbar
            }
            break;

        case Command::ARC: s = _("click point on arc (draws anti-clockwise)"); goto c;
        case Command::DATUM_POINT: s = _("click to place datum point"); goto c;
        case Command::LINE_SEGMENT: s = _("click first point of line segment"); goto c;
        case Command::CONSTR_SEGMENT:
            s = _("click first point of construction line segment"); goto c;
        case Command::CUBIC: s = _("click first point of cubic segment"); goto c;
        case Command::CIRCLE: s = _("click center of circle"); goto c;
        case Command::WORKPLANE: s = _("click origin of workplane"); goto c;
        case Command::RECTANGLE: s = _("click one corner of rectangle"); goto c;
        case Command::TTF_TEXT: s = _("click top left of text"); goto c;
        case Command::IMAGE:
            if(!SS.ReloadLinkedImage(SS.saveFile, &amp;SS.GW.pending.filename,
                                     /*canCancel=*/true)) {
                return;
            }
            s = _("click top left of image"); goto c;
c:
            SS.GW.pending.operation = GraphicsWindow::Pending::COMMAND;
            SS.GW.pending.command = id;
            SS.GW.pending.description = s;
            SS.ScheduleShowTW();
            SS.GW.Invalidate(); // repaint toolbar
            break;

        case Command::CONSTRUCTION: {
            SS.GW.GroupSelection();
            if(SS.GW.gs.entities == 0) {
                Error(_("No entities are selected. Select entities before "
                        "trying to toggle their construction state."));
                break;
            }
            SS.UndoRemember();
            int i;
            for(i = 0; i &lt; SS.GW.gs.entities; i++) {
                hEntity he = SS.GW.gs.entity[i];
                if(!he.isFromRequest()) continue;
                Request *r = SK.GetRequest(he.request());
                r-&gt;construction = !(r-&gt;construction);
                SS.MarkGroupDirty(r-&gt;group);
            }
            SS.GW.ClearSelection();
            break;
        }

        case Command::SPLIT_CURVES:
            SS.GW.SplitLinesOrCurves();
            break;

        default: ssassert(false, "Unexpected menu ID");
    }
}

</t>
<t tx="leo.20191228122645.26">void GraphicsWindow::ClearSuper() {
    if(window) window-&gt;HideEditor();
    ClearPending();
    ClearSelection();
    hover.Clear();
    EnsureValidActives();
}

</t>
<t tx="leo.20191228122645.27">void GraphicsWindow::ToggleBool(bool *v) {
    *v = !*v;

    // The faces are shown as special stippling on the shaded triangle mesh,
    // so not meaningful to show them and hide the shaded.
    if(!showShaded) showFaces = false;

    // If the mesh or edges were previously hidden, they haven't been generated,
    // and if we are going to show them, we need to generate them first.
    Group *g = SK.GetGroup(SS.GW.activeGroup);
    if(*v &amp;&amp; (g-&gt;displayOutlines.l.IsEmpty() &amp;&amp; (v == &amp;showEdges || v == &amp;showOutlines))) {
        SS.GenerateAll(SolveSpaceUI::Generate::UNTIL_ACTIVE);
    }

    Invalidate(/*clearPersistent=*/true);
    SS.ScheduleShowTW();
}

</t>
<t tx="leo.20191228122645.28">bool GraphicsWindow::SuggestLineConstraint(hRequest request, Constraint::Type *type) {
    if(!(LockedInWorkplane() &amp;&amp; SS.automaticLineConstraints))
        return false;

    Entity *ptA = SK.GetEntity(request.entity(1)),
           *ptB = SK.GetEntity(request.entity(2));

    Expr *au, *av, *bu, *bv;

    ptA-&gt;PointGetExprsInWorkplane(ActiveWorkplane(), &amp;au, &amp;av);
    ptB-&gt;PointGetExprsInWorkplane(ActiveWorkplane(), &amp;bu, &amp;bv);

    double du = au-&gt;Minus(bu)-&gt;Eval();
    double dv = av-&gt;Minus(bv)-&gt;Eval();

    const double TOLERANCE_RATIO = 0.02;
    if(fabs(dv) &gt; LENGTH_EPS &amp;&amp; fabs(du / dv) &lt; TOLERANCE_RATIO) {
        *type = Constraint::Type::VERTICAL;
        return true;
    } else if(fabs(du) &gt; LENGTH_EPS &amp;&amp; fabs(dv / du) &lt; TOLERANCE_RATIO) {
        *type = Constraint::Type::HORIZONTAL;
        return true;
    }
    return false;
}
</t>
<t tx="leo.20191228122645.29">@path ./src/
//-----------------------------------------------------------------------------
// Implementation of the Group class, which represents a set of entities and
// constraints that are solved together, in some cases followed by another
// operation, like to extrude surfaces from the entities or to step and
// repeat them parametrically.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

const hParam   Param::NO_PARAM = { 0 };
#define NO_PARAM (Param::NO_PARAM)

const hGroup Group::HGROUP_REFERENCES = { 1 };

//-----------------------------------------------------------------------------
// The group structure includes pointers to other dynamically-allocated
// memory. This clears and frees them all.
//-----------------------------------------------------------------------------
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122645.3">void GraphicsWindow::ActivateCommand(Command cmd) {
    for(int i = 0; Menu[i].level &gt;= 0; i++) {
        if(cmd == Menu[i].cmd) {
            (Menu[i].fn)((Command)Menu[i].cmd);
            break;
        }
    }
}

Platform::KeyboardEvent GraphicsWindow::AcceleratorForCommand(Command cmd) {
    int rawAccel = 0;
    for(int i = 0; Menu[i].level &gt;= 0; i++) {
        if(cmd == Menu[i].cmd) {
            rawAccel = Menu[i].accel;
            break;
        }
    }

    Platform::KeyboardEvent accel = {};
    accel.type = Platform::KeyboardEvent::Type::PRESS;
    if(rawAccel &amp; SHIFT_MASK) {
        accel.shiftDown = true;
    }
    if(rawAccel &amp; CTRL_MASK) {
        accel.controlDown = true;
    }
    if(rawAccel &amp; FN_MASK) {
        accel.key = Platform::KeyboardEvent::Key::FUNCTION;
        accel.num = rawAccel &amp; 0xff;
    } else {
        accel.key = Platform::KeyboardEvent::Key::CHARACTER;
        accel.chr = (char)(rawAccel &amp; 0xff);
    }

    return accel;
}

</t>
<t tx="leo.20191228122645.30">void Group::Clear() {
    polyLoops.Clear();
    bezierLoops.Clear();
    bezierOpens.Clear();
    thisMesh.Clear();
    runningMesh.Clear();
    thisShell.Clear();
    runningShell.Clear();
    displayMesh.Clear();
    displayOutlines.Clear();
    impMesh.Clear();
    impShell.Clear();
    impEntity.Clear();
    // remap is the only one that doesn't get recreated when we regen
    remap.clear();
}

</t>
<t tx="leo.20191228122645.31">void Group::AddParam(IdList&lt;Param,hParam&gt; *param, hParam hp, double v) {
    Param pa = {};
    pa.h = hp;
    pa.val = v;

    param-&gt;Add(&amp;pa);
}

</t>
<t tx="leo.20191228122645.32">bool Group::IsVisible() {
    if(!visible) return false;
    Group *active = SK.GetGroup(SS.GW.activeGroup);
    if(order &gt; active-&gt;order) return false;
    return true;
}

size_t Group::GetNumConstraints() {
    return std::count_if(SK.constraint.begin(), SK.constraint.end(),
                         [&amp;](Constraint const &amp;c) { return c.group == h; });
}

Vector Group::ExtrusionGetVector() {
    return Vector::From(h.param(0), h.param(1), h.param(2));
}

</t>
<t tx="leo.20191228122645.33">void Group::ExtrusionForceVectorTo(const Vector &amp;v) {
    SK.GetParam(h.param(0))-&gt;val = v.x;
    SK.GetParam(h.param(1))-&gt;val = v.y;
    SK.GetParam(h.param(2))-&gt;val = v.z;
}

</t>
<t tx="leo.20191228122645.34">void Group::MenuGroup(Command id)  {
    MenuGroup(id, Platform::Path());
}

</t>
<t tx="leo.20191228122645.35">void Group::MenuGroup(Command id, Platform::Path linkFile) {
    Platform::SettingsRef settings = Platform::GetSettings();

    Group g = {};
    g.visible = true;
    g.color = RGBi(100, 100, 100);
    g.scale = 1;
    g.linkFile = linkFile;

    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;

    switch(id) {
        case Command::GROUP_3D:
            g.type = Type::DRAWING_3D;
            g.name = C_("group-name", "sketch-in-3d");
            break;

        case Command::GROUP_WRKPL:
            g.type = Type::DRAWING_WORKPLANE;
            g.name = C_("group-name", "sketch-in-plane");
            if(gs.points == 1 &amp;&amp; gs.n == 1) {
                g.subtype = Subtype::WORKPLANE_BY_POINT_ORTHO;

                Vector u = SS.GW.projRight, v = SS.GW.projUp;
                u = u.ClosestOrtho();
                v = v.Minus(u.ScaledBy(v.Dot(u)));
                v = v.ClosestOrtho();

                g.predef.q = Quaternion::From(u, v);
                g.predef.origin = gs.point[0];
            } else if(gs.points == 1 &amp;&amp; gs.lineSegments == 2 &amp;&amp; gs.n == 3) {
                g.subtype = Subtype::WORKPLANE_BY_LINE_SEGMENTS;

                g.predef.origin = gs.point[0];
                g.predef.entityB = gs.entity[0];
                g.predef.entityC = gs.entity[1];

                Vector ut = SK.GetEntity(g.predef.entityB)-&gt;VectorGetNum();
                Vector vt = SK.GetEntity(g.predef.entityC)-&gt;VectorGetNum();
                ut = ut.WithMagnitude(1);
                vt = vt.WithMagnitude(1);

                if(fabs(SS.GW.projUp.Dot(vt)) &lt; fabs(SS.GW.projUp.Dot(ut))) {
                    swap(ut, vt);
                    g.predef.swapUV = true;
                }
                if(SS.GW.projRight.Dot(ut) &lt; 0) g.predef.negateU = true;
                if(SS.GW.projUp.   Dot(vt) &lt; 0) g.predef.negateV = true;
            } else if(gs.workplanes == 1 &amp;&amp; gs.n == 1) {
                if(gs.entity[0].isFromRequest()) {
                    Entity *wrkpl = SK.GetEntity(gs.entity[0]);
                    Entity *normal = SK.GetEntity(wrkpl-&gt;normal);
                    g.subtype = Subtype::WORKPLANE_BY_POINT_ORTHO;
                    g.predef.origin = wrkpl-&gt;point[0];
                    g.predef.q = normal-&gt;NormalGetNum();
                } else {
                    Group *wrkplg = SK.GetGroup(gs.entity[0].group());
                    g.subtype = wrkplg-&gt;subtype;
                    g.predef.origin = wrkplg-&gt;predef.origin;
                    if(wrkplg-&gt;subtype == Subtype::WORKPLANE_BY_LINE_SEGMENTS) {
                        g.predef.entityB = wrkplg-&gt;predef.entityB;
                        g.predef.entityC = wrkplg-&gt;predef.entityC;
                        g.predef.swapUV = wrkplg-&gt;predef.swapUV;
                        g.predef.negateU = wrkplg-&gt;predef.negateU;
                        g.predef.negateV = wrkplg-&gt;predef.negateV;
                    } else if(wrkplg-&gt;subtype == Subtype::WORKPLANE_BY_POINT_ORTHO) {
                        g.predef.q = wrkplg-&gt;predef.q;
                    } else ssassert(false, "Unexpected workplane subtype");
                }
            } else {
                Error(_("Bad selection for new sketch in workplane. This "
                        "group can be created with:\n\n"
                        "    * a point (through the point, orthogonal to coordinate axes)\n"
                        "    * a point and two line segments (through the point, "
                               "parallel to the lines)\n"
                        "    * a workplane (copy of the workplane)\n"));
                return;
            }
            break;

        case Command::GROUP_EXTRUDE:
            if(!SS.GW.LockedInWorkplane()) {
                Error(_("Activate a workplane (Sketch -&gt; In Workplane) before "
                        "extruding. The sketch will be extruded normal to the "
                        "workplane."));
                return;
            }
            g.type = Type::EXTRUDE;
            g.opA = SS.GW.activeGroup;
            g.predef.entityB = SS.GW.ActiveWorkplane();
            g.subtype = Subtype::ONE_SIDED;
            g.name = C_("group-name", "extrude");
            break;

        case Command::GROUP_LATHE:
            if(!SS.GW.LockedInWorkplane()) {
                Error(_("Lathe operation can only be applied to planar sketches."));
                return;
            }
            if(gs.points == 1 &amp;&amp; gs.vectors == 1 &amp;&amp; gs.n == 2) {
                g.predef.origin = gs.point[0];
                g.predef.entityB = gs.vector[0];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.n == 1) {
                g.predef.origin = SK.GetEntity(gs.entity[0])-&gt;point[0];
                g.predef.entityB = gs.entity[0];
                // since a line segment is a vector
            } else {
                Error(_("Bad selection for new lathe group. This group can "
                        "be created with:\n\n"
                        "    * a point and a line segment or normal "
                                 "(revolved about an axis parallel to line / "
                                 "normal, through point)\n"
                        "    * a line segment (revolved about line segment)\n"));
                return;
            }
            g.type = Type::LATHE;
            g.opA = SS.GW.activeGroup;
            g.name = C_("group-name", "lathe");
            break;

        case Command::GROUP_REVOLVE:
            if(!SS.GW.LockedInWorkplane()) {
                Error(_("Revolve operation can only be applied to planar sketches."));
                return;
            }
            if(gs.points == 1 &amp;&amp; gs.vectors == 1 &amp;&amp; gs.n == 2) {
                g.predef.origin  = gs.point[0];
                g.predef.entityB = gs.vector[0];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.n == 1) {
                g.predef.origin  = SK.GetEntity(gs.entity[0])-&gt;point[0];
                g.predef.entityB = gs.entity[0];
                // since a line segment is a vector
            } else {
                Error(_("Bad selection for new revolve group. This group can "
                        "be created with:\n\n"
                        "    * a point and a line segment or normal "
                                 "(revolved about an axis parallel to line / "
                                 "normal, through point)\n"
                        "    * a line segment (revolved about line segment)\n"));
                return;
            }
            g.type    = Type::REVOLVE;
            g.opA     = SS.GW.activeGroup;
            g.valA    = 2;
            g.subtype = Subtype::ONE_SIDED;
            g.name    = C_("group-name", "revolve");
            break;

        case Command::GROUP_HELIX:
            if(!SS.GW.LockedInWorkplane()) {
                Error(_("Helix operation can only be applied to planar sketches."));
                return;
            }
            if(gs.points == 1 &amp;&amp; gs.vectors == 1 &amp;&amp; gs.n == 2) {
                g.predef.origin  = gs.point[0];
                g.predef.entityB = gs.vector[0];
            } else if(gs.lineSegments == 1 &amp;&amp; gs.n == 1) {
                g.predef.origin  = SK.GetEntity(gs.entity[0])-&gt;point[0];
                g.predef.entityB = gs.entity[0];
                // since a line segment is a vector
            } else {
                Error(_("Bad selection for new helix group. This group can "
                        "be created with:\n\n"
                        "    * a point and a line segment or normal "
                                 "(revolved about an axis parallel to line / "
                                 "normal, through point)\n"
                        "    * a line segment (revolved about line segment)\n"));
                return;
            }
            g.type    = Type::HELIX;
            g.opA     = SS.GW.activeGroup;
            g.valA    = 2;
            g.subtype = Subtype::ONE_SIDED;
            g.name    = C_("group-name", "helix");
            break;

        case Command::GROUP_ROT: {
            if(gs.points == 1 &amp;&amp; gs.n == 1 &amp;&amp; SS.GW.LockedInWorkplane()) {
                g.predef.origin = gs.point[0];
                Entity *w = SK.GetEntity(SS.GW.ActiveWorkplane());
                g.predef.entityB = w-&gt;Normal()-&gt;h;
                g.activeWorkplane = w-&gt;h;
            } else if(gs.points == 1 &amp;&amp; gs.vectors == 1 &amp;&amp; gs.n == 2) {
                g.predef.origin = gs.point[0];
                g.predef.entityB = gs.vector[0];
            } else {
                Error(_("Bad selection for new rotation. This group can "
                        "be created with:\n\n"
                        "    * a point, while locked in workplane (rotate "
                              "in plane, about that point)\n"
                        "    * a point and a line or a normal (rotate about "
                              "an axis through the point, and parallel to "
                              "line / normal)\n"));
                return;
            }
            g.type = Type::ROTATE;
            g.opA = SS.GW.activeGroup;
            g.valA = 3;
            g.subtype = Subtype::ONE_SIDED;
            g.name = C_("group-name", "rotate");
            break;
        }

        case Command::GROUP_TRANS:
            g.type = Type::TRANSLATE;
            g.opA = SS.GW.activeGroup;
            g.valA = 3;
            g.subtype = Subtype::ONE_SIDED;
            g.predef.entityB = SS.GW.ActiveWorkplane();
            g.activeWorkplane = SS.GW.ActiveWorkplane();
            g.name = C_("group-name", "translate");
            break;

        case Command::GROUP_LINK: {
            g.type = Type::LINKED;
            g.meshCombine = CombineAs::ASSEMBLE;
            if(g.linkFile.IsEmpty()) {
                Platform::FileDialogRef dialog = Platform::CreateOpenFileDialog(SS.GW.window);
                dialog-&gt;AddFilters(Platform::SolveSpaceModelFileFilters);
                dialog-&gt;ThawChoices(settings, "LinkSketch");
                if(!dialog-&gt;RunModal()) return;
                dialog-&gt;FreezeChoices(settings, "LinkSketch");
                g.linkFile = dialog-&gt;GetFilename();
            }

            // Assign the default name of the group based on the name of
            // the linked file.
            g.name = g.linkFile.FileStem();
            for(size_t i = 0; i &lt; g.name.length(); i++) {
                if(!(isalnum(g.name[i]) || (unsigned)g.name[i] &gt;= 0x80)) {
                    // convert punctuation to dashes
                    g.name[i] = '-';
                }
            }
            break;
        }

        default: ssassert(false, "Unexpected menu ID");
    }

    // Copy color from the previous mesh-contributing group.
    if(g.IsMeshGroup() &amp;&amp; !SK.groupOrder.IsEmpty()) {
        Group *running = SK.GetRunningMeshGroupFor(SS.GW.activeGroup);
        if(running != NULL) {
            g.color = running-&gt;color;
        }
    }

    SS.GW.ClearSelection();
    SS.UndoRemember();

    bool afterActive = false;
    for(hGroup hg : SK.groupOrder) {
        Group *gi = SK.GetGroup(hg);
        if(afterActive)
            gi-&gt;order += 1;
        if(gi-&gt;h == SS.GW.activeGroup) {
            g.order = gi-&gt;order + 1;
            afterActive = true;
        }
    }

    SK.group.AddAndAssignId(&amp;g);
    Group *gg = SK.GetGroup(g.h);

    if(gg-&gt;type == Type::LINKED) {
        SS.ReloadAllLinked(SS.saveFile);
    }
    gg-&gt;clean = false;
    SS.GW.activeGroup = gg-&gt;h;
    SS.GenerateAll();
    if(gg-&gt;type == Type::DRAWING_WORKPLANE) {
        // Can't set the active workplane for this one until after we've
        // regenerated, because the workplane doesn't exist until then.
        gg-&gt;activeWorkplane = gg-&gt;h.entity(0);
    }
    gg-&gt;Activate();
    TextWindow::ScreenSelectGroup(0, gg-&gt;h.v);
    SS.GW.AnimateOntoWorkplane();
}

</t>
<t tx="leo.20191228122645.36">void Group::TransformImportedBy(Vector t, Quaternion q) {
    ssassert(type == Type::LINKED, "Expected a linked group");

    hParam tx, ty, tz, qw, qx, qy, qz;
    tx = h.param(0);
    ty = h.param(1);
    tz = h.param(2);
    qw = h.param(3);
    qx = h.param(4);
    qy = h.param(5);
    qz = h.param(6);

    Quaternion qg = Quaternion::From(qw, qx, qy, qz);
    qg = q.Times(qg);

    Vector tg = Vector::From(tx, ty, tz);
    tg = tg.Plus(t);

    SK.GetParam(tx)-&gt;val = tg.x;
    SK.GetParam(ty)-&gt;val = tg.y;
    SK.GetParam(tz)-&gt;val = tg.z;

    SK.GetParam(qw)-&gt;val = qg.w;
    SK.GetParam(qx)-&gt;val = qg.vx;
    SK.GetParam(qy)-&gt;val = qg.vy;
    SK.GetParam(qz)-&gt;val = qg.vz;
}

</t>
<t tx="leo.20191228122645.37">bool Group::IsForcedToMeshBySource() const {
    const Group *srcg = this;
    if(type == Type::TRANSLATE || type == Type::ROTATE) {
        // A step and repeat gets merged against the group's previous group,
        // not our own previous group.
        srcg = SK.GetGroup(opA);
        if(srcg-&gt;forceToMesh) return true;
    }
    Group *g = srcg-&gt;RunningMeshGroup();
    if(g == NULL) return false;
    return g-&gt;forceToMesh || g-&gt;IsForcedToMeshBySource();
}

</t>
<t tx="leo.20191228122645.38">bool Group::IsForcedToMesh() const {
    return forceToMesh || IsForcedToMeshBySource();
}

std::string Group::DescriptionString() {
    if(name.empty()) {
        return ssprintf("g%03x-%s", h.v, _("(unnamed)"));
    } else {
        return ssprintf("g%03x-%s", h.v, name.c_str());
    }
}

</t>
<t tx="leo.20191228122645.39">void Group::Activate() {
    if(type == Type::EXTRUDE || type == Type::LINKED || type == Type::LATHE ||
       type == Type::REVOLVE || type == Type::HELIX || type == Type::TRANSLATE || type == Type::ROTATE) {
        SS.GW.showFaces = true;
    } else {
        SS.GW.showFaces = false;
    }
    SS.MarkGroupDirty(h); // for good measure; shouldn't be needed
    SS.ScheduleShowTW();
}

</t>
<t tx="leo.20191228122645.4">bool GraphicsWindow::KeyboardEvent(Platform::KeyboardEvent event) {
    using Platform::KeyboardEvent;

    if(event.type == KeyboardEvent::Type::RELEASE)
        return true;

    if(event.key == KeyboardEvent::Key::CHARACTER) {
        if(event.chr == '\b') {
            // Treat backspace identically to escape.
            MenuEdit(Command::UNSELECT_ALL);
            return true;
        } else if(event.chr == '=') {
            // Treat = as +. This is specific to US (and US-compatible) keyboard layouts,
            // but makes zooming from keyboard much more usable on these.
            // Ideally we'd have a platform-independent way of binding to a particular
            // physical key regardless of shift status...
            MenuView(Command::ZOOM_IN);
            return true;
        }
    }

    // On some platforms, the OS does not handle some or all keyboard accelerators,
    // so handle them here.
    for(int i = 0; Menu[i].level &gt;= 0; i++) {
        if(AcceleratorForCommand(Menu[i].cmd).Equals(event)) {
            ActivateCommand(Menu[i].cmd);
            return true;
        }
    }

    return false;
}

</t>
<t tx="leo.20191228122645.40">void Group::Generate(IdList&lt;Entity,hEntity&gt; *entity,
                     IdList&lt;Param,hParam&gt; *param)
{
    Vector gn = (SS.GW.projRight).Cross(SS.GW.projUp);
    Vector gp = SS.GW.projRight.Plus(SS.GW.projUp);
    Vector gc = (SS.GW.offset).ScaledBy(-1);
    gn = gn.WithMagnitude(200/SS.GW.scale);
    gp = gp.WithMagnitude(200/SS.GW.scale);
    int a, i;
    switch(type) {
        case Type::DRAWING_3D:
            return;

        case Type::DRAWING_WORKPLANE: {
            Quaternion q;
            if(subtype == Subtype::WORKPLANE_BY_LINE_SEGMENTS) {
                Vector u = SK.GetEntity(predef.entityB)-&gt;VectorGetNum();
                Vector v = SK.GetEntity(predef.entityC)-&gt;VectorGetNum();
                u = u.WithMagnitude(1);
                Vector n = u.Cross(v);
                v = (n.Cross(u)).WithMagnitude(1);

                if(predef.swapUV) swap(u, v);
                if(predef.negateU) u = u.ScaledBy(-1);
                if(predef.negateV) v = v.ScaledBy(-1);
                q = Quaternion::From(u, v);
            } else if(subtype == Subtype::WORKPLANE_BY_POINT_ORTHO) {
                // Already given, numerically.
                q = predef.q;
            } else ssassert(false, "Unexpected workplane subtype");

            Entity normal = {};
            normal.type = Entity::Type::NORMAL_N_COPY;
            normal.numNormal = q;
            normal.point[0] = h.entity(2);
            normal.group = h;
            normal.h = h.entity(1);
            entity-&gt;Add(&amp;normal);

            Entity point = {};
            point.type = Entity::Type::POINT_N_COPY;
            point.numPoint = SK.GetEntity(predef.origin)-&gt;PointGetNum();
            point.construction = true;
            point.group = h;
            point.h = h.entity(2);
            entity-&gt;Add(&amp;point);

            Entity wp = {};
            wp.type = Entity::Type::WORKPLANE;
            wp.normal = normal.h;
            wp.point[0] = point.h;
            wp.group = h;
            wp.h = h.entity(0);
            entity-&gt;Add(&amp;wp);
            return;
        }

        case Type::EXTRUDE: {
            AddParam(param, h.param(0), gn.x);
            AddParam(param, h.param(1), gn.y);
            AddParam(param, h.param(2), gn.z);
            int ai, af;
            if(subtype == Subtype::ONE_SIDED) {
                ai = 0; af = 2;
            } else if(subtype == Subtype::TWO_SIDED) {
                ai = -1; af = 1;
            } else ssassert(false, "Unexpected extrusion subtype");

            // Get some arbitrary point in the sketch, that will be used
            // as a reference when defining top and bottom faces.
            hEntity pt = { 0 };
            // Not using range-for here because we're changing the size of entity in the loop.
            for(i = 0; i &lt; entity-&gt;n; i++) {
                Entity *e = &amp;(entity-&gt;Get(i));
                if(e-&gt;group != opA) continue;

                if(e-&gt;IsPoint()) pt = e-&gt;h;

                e-&gt;CalculateNumerical(/*forExport=*/false);
                hEntity he = e-&gt;h; e = NULL;
                // As soon as I call CopyEntity, e may become invalid! That
                // adds entities, which may cause a realloc.
                CopyEntity(entity, SK.GetEntity(he), ai, REMAP_BOTTOM,
                    h.param(0), h.param(1), h.param(2),
                    NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM,
                    CopyAs::N_TRANS);
                CopyEntity(entity, SK.GetEntity(he), af, REMAP_TOP,
                    h.param(0), h.param(1), h.param(2),
                    NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM,
                    CopyAs::N_TRANS);
                MakeExtrusionLines(entity, he);
            }
            // Remapped versions of that arbitrary point will be used to
            // provide points on the plane faces.
            MakeExtrusionTopBottomFaces(entity, pt);
            return;
        }

        case Type::LATHE: {
            Vector axis_pos = SK.GetEntity(predef.origin)-&gt;PointGetNum();
            Vector axis_dir = SK.GetEntity(predef.entityB)-&gt;VectorGetNum();

            // Remapped entity index.
            int ai = 1;

            // Not using range-for here because we're changing the size of entity in the loop.
            for(i = 0; i &lt; entity-&gt;n; i++) {
                Entity *e = &amp;(entity-&gt;Get(i));
                if(e-&gt;group != opA) continue;

                e-&gt;CalculateNumerical(/*forExport=*/false);
                hEntity he = e-&gt;h;

                // As soon as I call CopyEntity, e may become invalid! That
                // adds entities, which may cause a realloc.
                CopyEntity(entity, SK.GetEntity(predef.origin), 0, ai,
                    NO_PARAM, NO_PARAM, NO_PARAM,
                    NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM,
                    CopyAs::NUMERIC);

                CopyEntity(entity, SK.GetEntity(he), 0, REMAP_LATHE_START,
                    NO_PARAM, NO_PARAM, NO_PARAM,
                    NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM,
                    CopyAs::NUMERIC);

                CopyEntity(entity, SK.GetEntity(he), 0, REMAP_LATHE_END,
                    NO_PARAM, NO_PARAM, NO_PARAM,
                    NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM,
                    CopyAs::NUMERIC);

                MakeLatheCircles(entity, param, he, axis_pos, axis_dir, ai);
                MakeLatheSurfacesSelectable(entity, he, axis_dir);
                ai++;
            }
            return;
        }

        case Type::REVOLVE: {
            // this was borrowed from LATHE and ROTATE
            Vector axis_pos = SK.GetEntity(predef.origin)-&gt;PointGetNum();
            Vector axis_dir = SK.GetEntity(predef.entityB)-&gt;VectorGetNum();

            // The center of rotation
            AddParam(param, h.param(0), axis_pos.x);
            AddParam(param, h.param(1), axis_pos.y);
            AddParam(param, h.param(2), axis_pos.z);
            // The rotation quaternion
            AddParam(param, h.param(3), 30 * PI / 180);
            AddParam(param, h.param(4), axis_dir.x);
            AddParam(param, h.param(5), axis_dir.y);
            AddParam(param, h.param(6), axis_dir.z);

            int ai = 1;

            // Not using range-for here because we're changing the size of entity in the loop.
            for(i = 0; i &lt; entity-&gt;n; i++) {
                Entity *e = &amp;(entity-&gt;Get(i));
                if(e-&gt;group != opA)
                    continue;

                e-&gt;CalculateNumerical(/*forExport=*/false);
                hEntity he = e-&gt;h;

                CopyEntity(entity, SK.GetEntity(predef.origin), 0, ai, NO_PARAM, NO_PARAM,
                           NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM, CopyAs::NUMERIC);

                for(a = 0; a &lt; 2; a++) {
                    //! @todo is this check redundant?
                    Entity *e = &amp;(entity-&gt;Get(i));
                    if(e-&gt;group != opA)
                        continue;

                    e-&gt;CalculateNumerical(false);
                    CopyEntity(entity, e, a * 2 - (subtype == Subtype::ONE_SIDED ? 0 : 1),
                           (a == 1) ? REMAP_LATHE_END : REMAP_LATHE_START, h.param(0),
                           h.param(1), h.param(2), h.param(3), h.param(4), h.param(5),
                           h.param(6), NO_PARAM, CopyAs::N_ROT_AA);
                }
                // Arcs are not generated for revolve groups, for now, because our current arc
                // entity is not chiral, and dragging a revolve may break the arc by inverting it.
                // MakeLatheCircles(entity, param, he, axis_pos, axis_dir, ai);
                MakeLatheSurfacesSelectable(entity, he, axis_dir);
                ai++;
            }

            return;
        }

        case Type::HELIX:   {
            Vector axis_pos = SK.GetEntity(predef.origin)-&gt;PointGetNum();
            Vector axis_dir = SK.GetEntity(predef.entityB)-&gt;VectorGetNum();

            // The center of rotation
            AddParam(param, h.param(0), axis_pos.x);
            AddParam(param, h.param(1), axis_pos.y);
            AddParam(param, h.param(2), axis_pos.z);
            // The rotation quaternion
            AddParam(param, h.param(3), 30 * PI / 180);
            AddParam(param, h.param(4), axis_dir.x);
            AddParam(param, h.param(5), axis_dir.y);
            AddParam(param, h.param(6), axis_dir.z);
            // distance to translate along the rotation axis
            AddParam(param, h.param(7), 20);

            int ai = 1;

            // Not using range-for here because we're changing the size of entity in the loop.
            for(i = 0; i &lt; entity-&gt;n; i++) {
                Entity *e = &amp;(entity-&gt;Get(i));
                if((e-&gt;group.v != opA.v) &amp;&amp; !(e-&gt;h == predef.origin))
                    continue;

                e-&gt;CalculateNumerical(/*forExport=*/false);

                CopyEntity(entity, SK.GetEntity(predef.origin), 0, ai, NO_PARAM, NO_PARAM,
                           NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM, CopyAs::NUMERIC);

                for(a = 0; a &lt; 2; a++) {
                    Entity *e = &amp;(entity-&gt;Get(i));
                    e-&gt;CalculateNumerical(false);
                    CopyEntity(entity, e, a * 2 - (subtype == Subtype::ONE_SIDED ? 0 : 1),
                               (a == 1) ? REMAP_LATHE_END : REMAP_LATHE_START, h.param(0),
                               h.param(1), h.param(2), h.param(3), h.param(4), h.param(5),
                               h.param(6), h.param(7), CopyAs::N_ROT_AXIS_TRANS);
                }
                // For point entities on the axis, create a construction line
                e = &amp;(entity-&gt;Get(i));
                if(e-&gt;IsPoint()) {
                    Vector check = e-&gt;PointGetNum().Minus(axis_pos).Cross(axis_dir);
                    if (check.Dot(check) &lt; LENGTH_EPS) {
                        //! @todo isn't this the same as &amp;(ent[i])?
                        Entity *ep = SK.GetEntity(e-&gt;h);
                        Entity en = {};
                        // A point gets extruded to form a line segment
                        en.point[0] = Remap(ep-&gt;h, REMAP_LATHE_START);
                        en.point[1] = Remap(ep-&gt;h, REMAP_LATHE_END);
                        en.group = h;
                        en.construction = ep-&gt;construction;
                        en.style = ep-&gt;style;
                        en.h = Remap(ep-&gt;h, REMAP_PT_TO_LINE);
                        en.type = Entity::Type::LINE_SEGMENT;
                        entity-&gt;Add(&amp;en);
                    }
                }
                ai++;
            }
            return;
        }

        case Type::TRANSLATE: {
            // inherit meshCombine from source group
            Group *srcg = SK.GetGroup(opA);
            meshCombine = srcg-&gt;meshCombine;
            // The translation vector
            AddParam(param, h.param(0), gp.x);
            AddParam(param, h.param(1), gp.y);
            AddParam(param, h.param(2), gp.z);

            int n = (int)valA, a0 = 0;
            if(subtype == Subtype::ONE_SIDED &amp;&amp; skipFirst) {
                a0++; n++;
            }

            for(a = a0; a &lt; n; a++) {
                // Not using range-for here because we're changing the size of entity in the loop.
                for(i = 0; i &lt; entity-&gt;n; i++) {
                    Entity *e = &amp;(entity-&gt;Get(i));
                    if(e-&gt;group != opA) continue;

                    e-&gt;CalculateNumerical(/*forExport=*/false);
                    CopyEntity(entity, e,
                        a*2 - (subtype == Subtype::ONE_SIDED ? 0 : (n-1)),
                        (a == (n - 1)) ? REMAP_LAST : a,
                        h.param(0), h.param(1), h.param(2),
                        NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM, NO_PARAM,
                        CopyAs::N_TRANS);
                }
            }
            return;
        }
        case Type::ROTATE: {
            // inherit meshCombine from source group
            Group *srcg = SK.GetGroup(opA);
            meshCombine = srcg-&gt;meshCombine;
            // The center of rotation
            AddParam(param, h.param(0), gc.x);
            AddParam(param, h.param(1), gc.y);
            AddParam(param, h.param(2), gc.z);
            // The rotation quaternion
            AddParam(param, h.param(3), 30*PI/180);
            AddParam(param, h.param(4), gn.x);
            AddParam(param, h.param(5), gn.y);
            AddParam(param, h.param(6), gn.z);

            int n = (int)valA, a0 = 0;
            if(subtype == Subtype::ONE_SIDED &amp;&amp; skipFirst) {
                a0++; n++;
            }

            for(a = a0; a &lt; n; a++) {
                // Not using range-for here because we're changing the size of entity in the loop.
                for(i = 0; i &lt; entity-&gt;n; i++) {
                    Entity *e = &amp;(entity-&gt;Get(i));
                    if(e-&gt;group != opA) continue;

                    e-&gt;CalculateNumerical(/*forExport=*/false);
                    CopyEntity(entity, e,
                        a*2 - (subtype == Subtype::ONE_SIDED ? 0 : (n-1)),
                        (a == (n - 1)) ? REMAP_LAST : a,
                        h.param(0), h.param(1), h.param(2),
                        h.param(3), h.param(4), h.param(5), h.param(6), NO_PARAM,
                        CopyAs::N_ROT_AA);
                }
            }
            return;
        }
        case Type::LINKED:
            // The translation vector
            AddParam(param, h.param(0), gp.x);
            AddParam(param, h.param(1), gp.y);
            AddParam(param, h.param(2), gp.z);
            // The rotation quaternion
            AddParam(param, h.param(3), 1);
            AddParam(param, h.param(4), 0);
            AddParam(param, h.param(5), 0);
            AddParam(param, h.param(6), 0);

            // Not using range-for here because we're changing the size of entity in the loop.
            for(i = 0; i &lt; impEntity.n; i++) {
                Entity *ie = &amp;(impEntity[i]);
                CopyEntity(entity, ie, 0, 0,
                    h.param(0), h.param(1), h.param(2),
                    h.param(3), h.param(4), h.param(5), h.param(6), NO_PARAM,
                    CopyAs::N_ROT_TRANS);
            }
            return;
    }
    ssassert(false, "Unexpected group type");
}

</t>
<t tx="leo.20191228122645.41">bool Group::IsSolvedOkay() {
    return this-&gt;solved.how == SolveResult::OKAY ||
           (this-&gt;allowRedundant &amp;&amp; this-&gt;solved.how == SolveResult::REDUNDANT_OKAY);
}

</t>
<t tx="leo.20191228122645.42">void Group::AddEq(IdList&lt;Equation,hEquation&gt; *l, Expr *expr, int index) {
    Equation eq;
    eq.e = expr;
    eq.h = h.equation(index);
    l-&gt;Add(&amp;eq);
}

</t>
<t tx="leo.20191228122645.43">void Group::GenerateEquations(IdList&lt;Equation,hEquation&gt; *l) {
    if(type == Type::LINKED) {
        // Normalize the quaternion
        ExprQuaternion q = {
            Expr::From(h.param(3)),
            Expr::From(h.param(4)),
            Expr::From(h.param(5)),
            Expr::From(h.param(6)) };
        AddEq(l, (q.Magnitude())-&gt;Minus(Expr::From(1)), 0);
    } else if(type == Type::ROTATE || type == Type::REVOLVE || type == Type::HELIX) {
        // The axis and center of rotation are specified numerically
#define EC(x) (Expr::From(x))
#define EP(x) (Expr::From(h.param(x)))
        ExprVector orig = SK.GetEntity(predef.origin)-&gt;PointGetExprs();
        AddEq(l, (orig.x)-&gt;Minus(EP(0)), 0);
        AddEq(l, (orig.y)-&gt;Minus(EP(1)), 1);
        AddEq(l, (orig.z)-&gt;Minus(EP(2)), 2);
        // param 3 is the angle, which is free
        Vector axis = SK.GetEntity(predef.entityB)-&gt;VectorGetNum();
        axis = axis.WithMagnitude(1);
        AddEq(l, (EC(axis.x))-&gt;Minus(EP(4)), 3);
        AddEq(l, (EC(axis.y))-&gt;Minus(EP(5)), 4);
        AddEq(l, (EC(axis.z))-&gt;Minus(EP(6)), 5);
#undef EC
#undef EP
    } else if(type == Type::EXTRUDE) {
        if(predef.entityB != Entity::FREE_IN_3D) {
            // The extrusion path is locked along a line, normal to the
            // specified workplane.
            Entity *w = SK.GetEntity(predef.entityB);
            ExprVector u = w-&gt;Normal()-&gt;NormalExprsU();
            ExprVector v = w-&gt;Normal()-&gt;NormalExprsV();
            ExprVector extruden = {
                Expr::From(h.param(0)),
                Expr::From(h.param(1)),
                Expr::From(h.param(2)) };

            AddEq(l, u.Dot(extruden), 0);
            AddEq(l, v.Dot(extruden), 1);
        }
    } else if(type == Type::TRANSLATE) {
        if(predef.entityB != Entity::FREE_IN_3D) {
            Entity *w = SK.GetEntity(predef.entityB);
            ExprVector n = w-&gt;Normal()-&gt;NormalExprsN();
            ExprVector trans;
            trans = ExprVector::From(h.param(0), h.param(1), h.param(2));

            // The translation vector is parallel to the workplane
            AddEq(l, trans.Dot(n), 0);
        }
    }
}

hEntity Group::Remap(hEntity in, int copyNumber) {
    auto it = remap.find({ in, copyNumber });
    if(it == remap.end()) {
        std::tie(it, std::ignore) =
            remap.insert({ { in, copyNumber }, { (uint32_t)remap.size() + 1 } });
    }
    return h.entity(it-&gt;second.v);
}

</t>
<t tx="leo.20191228122645.44">void Group::MakeExtrusionLines(IdList&lt;Entity,hEntity&gt; *el, hEntity in) {
    Entity *ep = SK.GetEntity(in);

    Entity en = {};
    if(ep-&gt;IsPoint()) {
        // A point gets extruded to form a line segment
        en.point[0] = Remap(ep-&gt;h, REMAP_TOP);
        en.point[1] = Remap(ep-&gt;h, REMAP_BOTTOM);
        en.group = h;
        en.construction = ep-&gt;construction;
        en.style = ep-&gt;style;
        en.h = Remap(ep-&gt;h, REMAP_PT_TO_LINE);
        en.type = Entity::Type::LINE_SEGMENT;
        el-&gt;Add(&amp;en);
    } else if(ep-&gt;type == Entity::Type::LINE_SEGMENT) {
        // A line gets extruded to form a plane face; an endpoint of the
        // original line is a point in the plane, and the line is in the plane.
        Vector a = SK.GetEntity(ep-&gt;point[0])-&gt;PointGetNum();
        Vector b = SK.GetEntity(ep-&gt;point[1])-&gt;PointGetNum();
        Vector ab = b.Minus(a);

        en.param[0] = h.param(0);
        en.param[1] = h.param(1);
        en.param[2] = h.param(2);
        en.numPoint = a;
        en.numNormal = Quaternion::From(0, ab.x, ab.y, ab.z);

        en.group = h;
        en.construction = ep-&gt;construction;
        en.style = ep-&gt;style;
        en.h = Remap(ep-&gt;h, REMAP_LINE_TO_FACE);
        en.type = Entity::Type::FACE_XPROD;
        el-&gt;Add(&amp;en);
    }
}

</t>
<t tx="leo.20191228122645.45">void Group::MakeLatheCircles(IdList&lt;Entity,hEntity&gt; *el, IdList&lt;Param,hParam&gt; *param, hEntity in, Vector pt, Vector axis, int ai) {
    Entity *ep = SK.GetEntity(in);

    Entity en = {};
    if(ep-&gt;IsPoint()) {
        // A point gets revolved to form an arc.
        en.point[0] = Remap(predef.origin, ai);
        en.point[1] = Remap(ep-&gt;h, REMAP_LATHE_START);
        en.point[2] = Remap(ep-&gt;h, REMAP_LATHE_END);

        // Get arc center and point on arc.
        Entity *pc = SK.GetEntity(en.point[0]);
        Entity *pp = SK.GetEntity(en.point[1]);

        // Project arc point to the revolution axis and use it for arc center.
        double k = pp-&gt;numPoint.Minus(pt).Dot(axis) / axis.Dot(axis);
        pc-&gt;numPoint = pt.Plus(axis.ScaledBy(k));

        // Create arc entity.
        en.group = h;
        en.construction = ep-&gt;construction;
        en.style = ep-&gt;style;
        en.h = Remap(ep-&gt;h, REMAP_PT_TO_ARC);
        en.type = Entity::Type::ARC_OF_CIRCLE;

        // Generate a normal.
        Entity n = {};
        n.workplane = en.workplane;
        n.h = Remap(ep-&gt;h, REMAP_PT_TO_NORMAL);
        n.group = en.group;
        n.style = en.style;
        n.type = Entity::Type::NORMAL_N_COPY;

        // Create basis for the normal.
        Vector nu = pp-&gt;numPoint.Minus(pc-&gt;numPoint).WithMagnitude(1.0);
        Vector nv = nu.Cross(axis).WithMagnitude(1.0);
        n.numNormal = Quaternion::From(nv, nu);

        // The point determines where the normal gets displayed on-screen;
        // it's entirely cosmetic.
        n.point[0] = en.point[0];
        el-&gt;Add(&amp;n);
        en.normal = n.h;
        el-&gt;Add(&amp;en);
    }
}

</t>
<t tx="leo.20191228122645.46">void Group::MakeLatheSurfacesSelectable(IdList&lt;Entity, hEntity&gt; *el, hEntity in, Vector axis) {
    Entity *ep = SK.GetEntity(in);

    Entity en = {};
    if(ep-&gt;type == Entity::Type::LINE_SEGMENT) {
        // An axis-perpendicular line gets revolved to form a face.
        Vector a = SK.GetEntity(ep-&gt;point[0])-&gt;PointGetNum();
        Vector b = SK.GetEntity(ep-&gt;point[1])-&gt;PointGetNum();
        Vector u = b.Minus(a).WithMagnitude(1.0);

        // Check for perpendicularity: calculate cosine of the angle
        // between axis and line direction and check that
        // cos(angle) == 0 &lt;-&gt; angle == +-90 deg.
        if(fabs(u.Dot(axis) / axis.Magnitude()) &lt; ANGLE_COS_EPS) {
            en.param[0] = h.param(0);
            en.param[1] = h.param(1);
            en.param[2] = h.param(2);
            Vector v = axis.Cross(u).WithMagnitude(1.0);
            Vector n = u.Cross(v);
            en.numNormal = Quaternion::From(0, n.x, n.y, n.z);

            en.group = h;
            en.construction = ep-&gt;construction;
            en.style = ep-&gt;style;
            en.h = Remap(ep-&gt;h, REMAP_LINE_TO_FACE);
            en.type = Entity::Type::FACE_NORMAL_PT;
            en.point[0] = ep-&gt;point[0];
            el-&gt;Add(&amp;en);
        }
    }
}

</t>
<t tx="leo.20191228122645.47">void Group::MakeExtrusionTopBottomFaces(IdList&lt;Entity,hEntity&gt; *el, hEntity pt)
{
    if(pt.v == 0) return;
    Group *src = SK.GetGroup(opA);
    Vector n = src-&gt;polyLoops.normal;

    // When there is no loop normal (e.g. if the loop is broken), use normal of workplane
    // as fallback, to avoid breaking constraints depending on the faces.
    if(n.Equals(Vector::From(0.0, 0.0, 0.0)) &amp;&amp; src-&gt;type == Group::Type::DRAWING_WORKPLANE) {
        n = SK.GetEntity(src-&gt;h.entity(0))-&gt;Normal()-&gt;NormalN();
    }

    Entity en = {};
    en.type = Entity::Type::FACE_NORMAL_PT;
    en.group = h;

    en.numNormal = Quaternion::From(0, n.x, n.y, n.z);
    en.point[0] = Remap(pt, REMAP_TOP);
    en.h = Remap(Entity::NO_ENTITY, REMAP_TOP);
    el-&gt;Add(&amp;en);

    en.point[0] = Remap(pt, REMAP_BOTTOM);
    en.h = Remap(Entity::NO_ENTITY, REMAP_BOTTOM);
    el-&gt;Add(&amp;en);
}

</t>
<t tx="leo.20191228122645.48">void Group::CopyEntity(IdList&lt;Entity,hEntity&gt; *el,
                       Entity *ep, int timesApplied, int remap,
                       hParam dx, hParam dy, hParam dz,
                       hParam qw, hParam qvx, hParam qvy, hParam qvz, hParam dist,
                       CopyAs as)
{
    Entity en = {};
    en.type = ep-&gt;type;
    en.extraPoints = ep-&gt;extraPoints;
    en.h = Remap(ep-&gt;h, remap);
    en.timesApplied = timesApplied;
    en.group = h;
    en.construction = ep-&gt;construction;
    en.style = ep-&gt;style;
    en.str = ep-&gt;str;
    en.font = ep-&gt;font;
    en.file = ep-&gt;file;

    switch(ep-&gt;type) {
        case Entity::Type::WORKPLANE:
            // Don't copy these.
            return;

        case Entity::Type::POINT_N_COPY:
        case Entity::Type::POINT_N_TRANS:
        case Entity::Type::POINT_N_ROT_TRANS:
        case Entity::Type::POINT_N_ROT_AA:
        case Entity::Type::POINT_N_ROT_AXIS_TRANS:
        case Entity::Type::POINT_IN_3D:
        case Entity::Type::POINT_IN_2D:
            if(as == CopyAs::N_TRANS) {
                en.type = Entity::Type::POINT_N_TRANS;
                en.param[0] = dx;
                en.param[1] = dy;
                en.param[2] = dz;
            } else if(as == CopyAs::NUMERIC) {
                en.type = Entity::Type::POINT_N_COPY;
            } else {
                if(as == CopyAs::N_ROT_AA) {
                    en.type = Entity::Type::POINT_N_ROT_AA;
                } else if (as == CopyAs::N_ROT_AXIS_TRANS) {
                    en.type = Entity::Type::POINT_N_ROT_AXIS_TRANS;
                } else {
                    en.type = Entity::Type::POINT_N_ROT_TRANS;
                }
                en.param[0] = dx;
                en.param[1] = dy;
                en.param[2] = dz;
                en.param[3] = qw;
                en.param[4] = qvx;
                en.param[5] = qvy;
                en.param[6] = qvz;
                if (as ==  CopyAs::N_ROT_AXIS_TRANS) {
                    en.param[7] = dist;
                }
            }
            en.numPoint = (ep-&gt;actPoint).ScaledBy(scale);
            break;

        case Entity::Type::NORMAL_N_COPY:
        case Entity::Type::NORMAL_N_ROT:
        case Entity::Type::NORMAL_N_ROT_AA:
        case Entity::Type::NORMAL_IN_3D:
        case Entity::Type::NORMAL_IN_2D:
            if(as == CopyAs::N_TRANS || as == CopyAs::NUMERIC) {
                en.type = Entity::Type::NORMAL_N_COPY;
            } else {  // N_ROT_AXIS_TRANS probably doesn't warrant a new entity Type
                if(as == CopyAs::N_ROT_AA || as == CopyAs::N_ROT_AXIS_TRANS) {
                    en.type = Entity::Type::NORMAL_N_ROT_AA;
                } else {
                    en.type = Entity::Type::NORMAL_N_ROT;
                }
                en.param[0] = qw;
                en.param[1] = qvx;
                en.param[2] = qvy;
                en.param[3] = qvz;
            }
            en.numNormal = ep-&gt;actNormal;
            if(scale &lt; 0) en.numNormal = en.numNormal.Mirror();

            en.point[0] = Remap(ep-&gt;point[0], remap);
            break;

        case Entity::Type::DISTANCE_N_COPY:
        case Entity::Type::DISTANCE:
            en.type = Entity::Type::DISTANCE_N_COPY;
            en.numDistance = ep-&gt;actDistance*fabs(scale);
            break;

        case Entity::Type::FACE_NORMAL_PT:
        case Entity::Type::FACE_XPROD:
        case Entity::Type::FACE_N_ROT_TRANS:
        case Entity::Type::FACE_N_TRANS:
        case Entity::Type::FACE_N_ROT_AA:
            if(as == CopyAs::N_TRANS) {
                en.type = Entity::Type::FACE_N_TRANS;
                en.param[0] = dx;
                en.param[1] = dy;
                en.param[2] = dz;
            } else if (as == CopyAs::NUMERIC) {
                en.type = Entity::Type::FACE_NORMAL_PT;
            } else {
                if(as == CopyAs::N_ROT_AA || as == CopyAs::N_ROT_AXIS_TRANS) {
                    en.type = Entity::Type::FACE_N_ROT_AA;
                } else {
                    en.type = Entity::Type::FACE_N_ROT_TRANS;
                }
                en.param[0] = dx;
                en.param[1] = dy;
                en.param[2] = dz;
                en.param[3] = qw;
                en.param[4] = qvx;
                en.param[5] = qvy;
                en.param[6] = qvz;
            }
            en.numPoint  = (ep-&gt;actPoint).ScaledBy(scale);
            en.numNormal = (ep-&gt;actNormal).ScaledBy(scale);
            break;

        default: {
            int i, points;
            bool hasNormal, hasDistance;
            EntReqTable::GetEntityInfo(ep-&gt;type, ep-&gt;extraPoints,
                NULL, &amp;points, &amp;hasNormal, &amp;hasDistance);
            for(i = 0; i &lt; points; i++) {
                en.point[i] = Remap(ep-&gt;point[i], remap);
            }
            if(hasNormal)   en.normal   = Remap(ep-&gt;normal, remap);
            if(hasDistance) en.distance = Remap(ep-&gt;distance, remap);
            break;
        }
    }

    // If the entity came from an linked file where it was invisible then
    // ep-&gt;actiVisble will be false, and we should hide it. Or if the entity
    // came from a copy (e.g. step and repeat) of a force-hidden linked
    // entity, then we also want to hide it.
    en.forceHidden = (!ep-&gt;actVisible) || ep-&gt;forceHidden;

    el-&gt;Add(&amp;en);
}

</t>
<t tx="leo.20191228122645.49">@path ./src/
//-----------------------------------------------------------------------------
// Routines to generate our watertight brep shells from the operations
// and entities specified by the user in each group; templated to work either
// on an SShell of ratpoly surfaces or on an SMesh of triangles.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122645.5">void GraphicsWindow::PopulateMainMenu() {
    bool unique = false;
    Platform::MenuBarRef mainMenu = Platform::GetOrCreateMainMenu(&amp;unique);
    if(unique) mainMenu-&gt;Clear();

    Platform::MenuRef currentSubMenu;
    std::vector&lt;Platform::MenuRef&gt; subMenuStack;
    for(int i = 0; Menu[i].level &gt;= 0; i++) {
        while(Menu[i].level &gt; 0 &amp;&amp; Menu[i].level &lt;= (int)subMenuStack.size()) {
            currentSubMenu = subMenuStack.back();
            subMenuStack.pop_back();
        }

        if(Menu[i].label == NULL) {
            currentSubMenu-&gt;AddSeparator();
            continue;
        }

        std::string label = Translate(Menu[i].label);
        if(Menu[i].level == 0) {
            currentSubMenu = mainMenu-&gt;AddSubMenu(label);
        } else if(Menu[i].cmd == Command::OPEN_RECENT) {
            openRecentMenu = currentSubMenu-&gt;AddSubMenu(label);
        } else if(Menu[i].cmd == Command::GROUP_RECENT) {
            linkRecentMenu = currentSubMenu-&gt;AddSubMenu(label);
        } else if(Menu[i].cmd == Command::LOCALE) {
            Platform::MenuRef localeMenu = currentSubMenu-&gt;AddSubMenu(label);
            for(const Locale &amp;locale : Locales()) {
                localeMenu-&gt;AddItem(locale.displayName, [&amp;]() {
                    SetLocale(locale.Culture());
                    Platform::GetSettings()-&gt;FreezeString("Locale", locale.Culture());

                    SS.UpdateWindowTitles();
                    PopulateMainMenu();
                    EnsureValidActives();
                });
            }
        } else if(Menu[i].fn == NULL) {
            subMenuStack.push_back(currentSubMenu);
            currentSubMenu = currentSubMenu-&gt;AddSubMenu(label);
        } else {
            Platform::MenuItemRef menuItem = currentSubMenu-&gt;AddItem(label);
            menuItem-&gt;SetIndicator(Menu[i].kind);
            if(Menu[i].accel != 0) {
                menuItem-&gt;SetAccelerator(AcceleratorForCommand(Menu[i].cmd));
            }
            menuItem-&gt;onTrigger = std::bind(Menu[i].fn, Menu[i].cmd);

            if(Menu[i].cmd == Command::SHOW_GRID) {
                showGridMenuItem = menuItem;
            } else if(Menu[i].cmd == Command::PERSPECTIVE_PROJ) {
                perspectiveProjMenuItem = menuItem;
            } else if(Menu[i].cmd == Command::SHOW_TOOLBAR) {
                showToolbarMenuItem = menuItem;
            } else if(Menu[i].cmd == Command::SHOW_TEXT_WND) {
                showTextWndMenuItem = menuItem;
            } else if(Menu[i].cmd == Command::FULL_SCREEN) {
                fullScreenMenuItem = menuItem;
            } else if(Menu[i].cmd == Command::UNITS_MM) {
                unitsMmMenuItem = menuItem;
            } else if(Menu[i].cmd == Command::UNITS_METERS) {
                unitsMetersMenuItem = menuItem;
            } else if(Menu[i].cmd == Command::UNITS_INCHES) {
                unitsInchesMenuItem = menuItem;
            } else if(Menu[i].cmd == Command::SEL_WORKPLANE) {
                inWorkplaneMenuItem = menuItem;
            } else if(Menu[i].cmd == Command::FREE_IN_3D) {
                in3dMenuItem = menuItem;
            } else if(Menu[i].cmd == Command::UNDO) {
                undoMenuItem = menuItem;
            } else if(Menu[i].cmd == Command::REDO) {
                redoMenuItem = menuItem;
            }
        }
    }

    PopulateRecentFiles();
    SS.UndoEnableMenus();

    window-&gt;SetMenuBar(mainMenu);
}

</t>
<t tx="leo.20191228122645.50">void Group::AssembleLoops(bool *allClosed,
                          bool *allCoplanar,
                          bool *allNonZeroLen)
{
    SBezierList sbl = {};

    int i;
    for(auto &amp;e : SK.entity) {
        if(e.group != h)
            continue;
        if(e.construction)
            continue;
        if(e.forceHidden)
            continue;

        e.GenerateBezierCurves(&amp;sbl);
    }

    SBezier *sb;
    *allNonZeroLen = true;
    for(sb = sbl.l.First(); sb; sb = sbl.l.NextAfter(sb)) {
        for(i = 1; i &lt;= sb-&gt;deg; i++) {
            if(!(sb-&gt;ctrl[i]).Equals(sb-&gt;ctrl[0])) {
                break;
            }
        }
        if(i &gt; sb-&gt;deg) {
            // This is a zero-length edge.
            *allNonZeroLen = false;
            polyError.errorPointAt = sb-&gt;ctrl[0];
            goto done;
        }
    }

    // Try to assemble all these Beziers into loops. The closed loops go into
    // bezierLoops, with the outer loops grouped with their holes. The
    // leftovers, if any, go in bezierOpens.
    bezierLoops.FindOuterFacesFrom(&amp;sbl, &amp;polyLoops, NULL,
                                   SS.ChordTolMm(),
                                   allClosed, &amp;(polyError.notClosedAt),
                                   allCoplanar, &amp;(polyError.errorPointAt),
                                   &amp;bezierOpens);
    done:
    sbl.Clear();
}

</t>
<t tx="leo.20191228122645.51">void Group::GenerateLoops() {
    polyLoops.Clear();
    bezierLoops.Clear();
    bezierOpens.Clear();

    if(type == Type::DRAWING_3D || type == Type::DRAWING_WORKPLANE ||
       type == Type::ROTATE || type == Type::TRANSLATE || type == Type::LINKED)
    {
        bool allClosed = false, allCoplanar = false, allNonZeroLen = false;
        AssembleLoops(&amp;allClosed, &amp;allCoplanar, &amp;allNonZeroLen);
        if(!allNonZeroLen) {
            polyError.how = PolyError::ZERO_LEN_EDGE;
        } else if(!allCoplanar) {
            polyError.how = PolyError::NOT_COPLANAR;
        } else if(!allClosed) {
            polyError.how = PolyError::NOT_CLOSED;
        } else {
            polyError.how = PolyError::GOOD;
            // The self-intersecting check is kind of slow, so don't run it
            // unless requested.
            if(SS.checkClosedContour) {
                if(polyLoops.SelfIntersecting(&amp;(polyError.errorPointAt))) {
                    polyError.how = PolyError::SELF_INTERSECTING;
                }
            }
        }
    }
}

</t>
<t tx="leo.20191228122645.52">void SShell::RemapFaces(Group *g, int remap) {
    SSurface *ss;
    for(ss = surface.First(); ss; ss = surface.NextAfter(ss)){
        hEntity face = { ss-&gt;face };
        if(face == Entity::NO_ENTITY) continue;

        face = g-&gt;Remap(face, remap);
        ss-&gt;face = face.v;
    }
}

</t>
<t tx="leo.20191228122645.53">void SMesh::RemapFaces(Group *g, int remap) {
    STriangle *tr;
    for(tr = l.First(); tr; tr = l.NextAfter(tr)) {
        hEntity face = { tr-&gt;meta.face };
        if(face == Entity::NO_ENTITY) continue;

        face = g-&gt;Remap(face, remap);
        tr-&gt;meta.face = face.v;
    }
}

template&lt;class T&gt;
</t>
<t tx="leo.20191228122645.54">void Group::GenerateForStepAndRepeat(T *steps, T *outs, Group::CombineAs forWhat) {
    T workA, workB;
    workA = {};
    workB = {};
    T *soFar = &amp;workA, *scratch = &amp;workB;

    int n = (int)valA, a0 = 0;
    if(subtype == Subtype::ONE_SIDED &amp;&amp; skipFirst) {
        a0++; n++;
    }
    int a;
    for(a = a0; a &lt; n; a++) {
        int ap = a*2 - (subtype == Subtype::ONE_SIDED ? 0 : (n-1));
        int remap = (a == (n - 1)) ? REMAP_LAST : a;

        T transd = {};
        if(type == Type::TRANSLATE) {
            Vector trans = Vector::From(h.param(0), h.param(1), h.param(2));
            trans = trans.ScaledBy(ap);
            transd.MakeFromTransformationOf(steps,
                trans, Quaternion::IDENTITY, 1.0);
        } else {
            Vector trans = Vector::From(h.param(0), h.param(1), h.param(2));
            double theta = ap * SK.GetParam(h.param(3))-&gt;val;
            double c = cos(theta), s = sin(theta);
            Vector axis = Vector::From(h.param(4), h.param(5), h.param(6));
            Quaternion q = Quaternion::From(c, s*axis.x, s*axis.y, s*axis.z);
            // Rotation is centered at t; so A(x - t) + t = Ax + (t - At)
            transd.MakeFromTransformationOf(steps,
                trans.Minus(q.Rotate(trans)), q, 1.0);
        }

        // We need to rewrite any plane face entities to the transformed ones.
        transd.RemapFaces(this, remap);

        // And tack this transformed copy on to the return.
        if(soFar-&gt;IsEmpty()) {
            scratch-&gt;MakeFromCopyOf(&amp;transd);
        } else if (forWhat == CombineAs::ASSEMBLE) {
            scratch-&gt;MakeFromAssemblyOf(soFar, &amp;transd);
        } else {
            scratch-&gt;MakeFromUnionOf(soFar, &amp;transd);
        }

        swap(scratch, soFar);
        scratch-&gt;Clear();
        transd.Clear();
    }

    outs-&gt;Clear();
    *outs = *soFar;
}

template&lt;class T&gt;
</t>
<t tx="leo.20191228122645.55">void Group::GenerateForBoolean(T *prevs, T *thiss, T *outs, Group::CombineAs how) {
    // If this group contributes no new mesh, then our running mesh is the
    // same as last time, no combining required. Likewise if we have a mesh
    // but it's suppressed.
    if(thiss-&gt;IsEmpty() || suppress) {
        outs-&gt;MakeFromCopyOf(prevs);
        return;
    }

    // So our group's shell appears in thisShell. Combine this with the
    // previous group's shell, using the requested operation.
    if(how == CombineAs::UNION) {
        outs-&gt;MakeFromUnionOf(prevs, thiss);
    } else if(how == CombineAs::DIFFERENCE) {
        outs-&gt;MakeFromDifferenceOf(prevs, thiss);
    } else {
        outs-&gt;MakeFromAssemblyOf(prevs, thiss);
    }
}

</t>
<t tx="leo.20191228122645.56">void Group::GenerateShellAndMesh() {
    bool prevBooleanFailed = booleanFailed;
    booleanFailed = false;

    Group *srcg = this;

    thisShell.Clear();
    thisMesh.Clear();
    runningShell.Clear();
    runningMesh.Clear();

    // Don't attempt a lathe or extrusion unless the source section is good:
    // planar and not self-intersecting.
    bool haveSrc = true;
    if(type == Type::EXTRUDE || type == Type::LATHE || type == Type::REVOLVE) {
        Group *src = SK.GetGroup(opA);
        if(src-&gt;polyError.how != PolyError::GOOD) {
            haveSrc = false;
        }
    }

    if(type == Type::TRANSLATE || type == Type::ROTATE) {
        // A step and repeat gets merged against the group's previous group,
        // not our own previous group.
        srcg = SK.GetGroup(opA);

        if(!srcg-&gt;suppress) {
            if(!IsForcedToMesh()) {
                GenerateForStepAndRepeat&lt;SShell&gt;(&amp;(srcg-&gt;thisShell), &amp;thisShell, srcg-&gt;meshCombine);
            } else {
                SMesh prevm = {};
                prevm.MakeFromCopyOf(&amp;srcg-&gt;thisMesh);
                srcg-&gt;thisShell.TriangulateInto(&amp;prevm);
                GenerateForStepAndRepeat&lt;SMesh&gt; (&amp;prevm, &amp;thisMesh, srcg-&gt;meshCombine);
            }
        }
    } else if(type == Type::EXTRUDE &amp;&amp; haveSrc) {
        Group *src = SK.GetGroup(opA);
        Vector translate = Vector::From(h.param(0), h.param(1), h.param(2));

        Vector tbot, ttop;
        if(subtype == Subtype::ONE_SIDED) {
            tbot = Vector::From(0, 0, 0); ttop = translate.ScaledBy(2);
        } else {
            tbot = translate.ScaledBy(-1); ttop = translate.ScaledBy(1);
        }

        SBezierLoopSetSet *sblss = &amp;(src-&gt;bezierLoops);
        SBezierLoopSet *sbls;
        for(sbls = sblss-&gt;l.First(); sbls; sbls = sblss-&gt;l.NextAfter(sbls)) {
            int is = thisShell.surface.n;
            // Extrude this outer contour (plus its inner contours, if present)
            thisShell.MakeFromExtrusionOf(sbls, tbot, ttop, color);

            // And for any plane faces, annotate the model with the entity for
            // that face, so that the user can select them with the mouse.
            Vector onOrig = sbls-&gt;point;
            int i;
            // Not using range-for here because we're starting at a different place and using
            // indices for meaning.
            for(i = is; i &lt; thisShell.surface.n; i++) {
                SSurface *ss = &amp;(thisShell.surface[i]);
                hEntity face = Entity::NO_ENTITY;

                Vector p = ss-&gt;PointAt(0, 0),
                       n = ss-&gt;NormalAt(0, 0).WithMagnitude(1);
                double d = n.Dot(p);

                if(i == is || i == (is + 1)) {
                    // These are the top and bottom of the shell.
                    if(fabs((onOrig.Plus(ttop)).Dot(n) - d) &lt; LENGTH_EPS) {
                        face = Remap(Entity::NO_ENTITY, REMAP_TOP);
                        ss-&gt;face = face.v;
                    }
                    if(fabs((onOrig.Plus(tbot)).Dot(n) - d) &lt; LENGTH_EPS) {
                        face = Remap(Entity::NO_ENTITY, REMAP_BOTTOM);
                        ss-&gt;face = face.v;
                    }
                    continue;
                }

                // So these are the sides
                if(ss-&gt;degm != 1 || ss-&gt;degn != 1) continue;

                Entity *e;
                for(e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
                    if(e-&gt;group != opA) continue;
                    if(e-&gt;type != Entity::Type::LINE_SEGMENT) continue;

                    Vector a = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum(),
                           b = SK.GetEntity(e-&gt;point[1])-&gt;PointGetNum();
                    a = a.Plus(ttop);
                    b = b.Plus(ttop);
                    // Could get taken backwards, so check all cases.
                    if((a.Equals(ss-&gt;ctrl[0][0]) &amp;&amp; b.Equals(ss-&gt;ctrl[1][0])) ||
                       (b.Equals(ss-&gt;ctrl[0][0]) &amp;&amp; a.Equals(ss-&gt;ctrl[1][0])) ||
                       (a.Equals(ss-&gt;ctrl[0][1]) &amp;&amp; b.Equals(ss-&gt;ctrl[1][1])) ||
                       (b.Equals(ss-&gt;ctrl[0][1]) &amp;&amp; a.Equals(ss-&gt;ctrl[1][1])))
                    {
                        face = Remap(e-&gt;h, REMAP_LINE_TO_FACE);
                        ss-&gt;face = face.v;
                        break;
                    }
                }
            }
        }
    } else if(type == Type::LATHE &amp;&amp; haveSrc) {
        Group *src = SK.GetGroup(opA);

        Vector pt   = SK.GetEntity(predef.origin)-&gt;PointGetNum(),
               axis = SK.GetEntity(predef.entityB)-&gt;VectorGetNum();
        axis = axis.WithMagnitude(1);

        SBezierLoopSetSet *sblss = &amp;(src-&gt;bezierLoops);
        SBezierLoopSet *sbls;
        for(sbls = sblss-&gt;l.First(); sbls; sbls = sblss-&gt;l.NextAfter(sbls)) {
            thisShell.MakeFromRevolutionOf(sbls, pt, axis, color, this);
        }
    } else if(type == Type::REVOLVE &amp;&amp; haveSrc) {
        Group *src    = SK.GetGroup(opA);
        double anglef = SK.GetParam(h.param(3))-&gt;val * 4; // why the 4 is needed?
        double dists = 0, distf = 0;
        double angles = 0.0;
        if(subtype != Subtype::ONE_SIDED) {
            anglef *= 0.5;
            angles = -anglef;
        }
        Vector pt   = SK.GetEntity(predef.origin)-&gt;PointGetNum(),
               axis = SK.GetEntity(predef.entityB)-&gt;VectorGetNum();
        axis        = axis.WithMagnitude(1);

        SBezierLoopSetSet *sblss = &amp;(src-&gt;bezierLoops);
        SBezierLoopSet *sbls;
        for(sbls = sblss-&gt;l.First(); sbls; sbls = sblss-&gt;l.NextAfter(sbls)) {
            if(fabs(anglef - angles) &lt; 2 * PI) {
                thisShell.MakeFromHelicalRevolutionOf(sbls, pt, axis, color, this,
                                                      angles, anglef, dists, distf);
            } else {
                thisShell.MakeFromRevolutionOf(sbls, pt, axis, color, this);
            }
        }
    } else if(type == Type::HELIX &amp;&amp; haveSrc) {
        Group *src    = SK.GetGroup(opA);
        double anglef = SK.GetParam(h.param(3))-&gt;val * 4; // why the 4 is needed?
        double dists = 0, distf = 0;
        double angles = 0.0;
        distf = SK.GetParam(h.param(7))-&gt;val * 2; // dist is applied twice
        if(subtype != Subtype::ONE_SIDED) {
            anglef *= 0.5;
            angles = -anglef;
            distf *= 0.5;
            dists = -distf;
        }
        Vector pt   = SK.GetEntity(predef.origin)-&gt;PointGetNum(),
               axis = SK.GetEntity(predef.entityB)-&gt;VectorGetNum();
        axis        = axis.WithMagnitude(1);

        SBezierLoopSetSet *sblss = &amp;(src-&gt;bezierLoops);
        SBezierLoopSet *sbls;
        for(sbls = sblss-&gt;l.First(); sbls; sbls = sblss-&gt;l.NextAfter(sbls)) {
            thisShell.MakeFromHelicalRevolutionOf(sbls, pt, axis, color, this,
                                                  angles, anglef, dists, distf);
        }
    } else if(type == Type::LINKED) {
        // The imported shell or mesh are copied over, with the appropriate
        // transformation applied. We also must remap the face entities.
        Vector offset = {
            SK.GetParam(h.param(0))-&gt;val,
            SK.GetParam(h.param(1))-&gt;val,
            SK.GetParam(h.param(2))-&gt;val };
        Quaternion q = {
            SK.GetParam(h.param(3))-&gt;val,
            SK.GetParam(h.param(4))-&gt;val,
            SK.GetParam(h.param(5))-&gt;val,
            SK.GetParam(h.param(6))-&gt;val };

        thisMesh.MakeFromTransformationOf(&amp;impMesh, offset, q, scale);
        thisMesh.RemapFaces(this, 0);

        thisShell.MakeFromTransformationOf(&amp;impShell, offset, q, scale);
        thisShell.RemapFaces(this, 0);
    }

    if(srcg-&gt;meshCombine != CombineAs::ASSEMBLE) {
        thisShell.MergeCoincidentSurfaces();
    }

    // So now we've got the mesh or shell for this group. Combine it with
    // the previous group's mesh or shell with the requested Boolean, and
    // we're done.

    Group *prevg = srcg-&gt;RunningMeshGroup();

    if(!IsForcedToMesh()) {
        SShell *prevs = &amp;(prevg-&gt;runningShell);
        GenerateForBoolean&lt;SShell&gt;(prevs, &amp;thisShell, &amp;runningShell,
            srcg-&gt;meshCombine);

        if(srcg-&gt;meshCombine != CombineAs::ASSEMBLE) {
            runningShell.MergeCoincidentSurfaces();
        }

        // If the Boolean failed, then we should note that in the text screen
        // for this group.
        booleanFailed = runningShell.booleanFailed;
        if(booleanFailed != prevBooleanFailed) {
            SS.ScheduleShowTW();
        }
    } else {
        SMesh prevm, thism;
        prevm = {};
        thism = {};

        prevm.MakeFromCopyOf(&amp;(prevg-&gt;runningMesh));
        prevg-&gt;runningShell.TriangulateInto(&amp;prevm);

        thism.MakeFromCopyOf(&amp;thisMesh);
        thisShell.TriangulateInto(&amp;thism);

        SMesh outm = {};
        GenerateForBoolean&lt;SMesh&gt;(&amp;prevm, &amp;thism, &amp;outm, srcg-&gt;meshCombine);

        // Remove degenerate triangles; if we don't, they'll get split in SnapToMesh
        // in every generated group, resulting in polynomial increase in triangle count,
        // and corresponding slowdown.
        outm.RemoveDegenerateTriangles();

        if(srcg-&gt;meshCombine != CombineAs::ASSEMBLE) {
            // And make sure that the output mesh is vertex-to-vertex.
            SKdNode *root = SKdNode::From(&amp;outm);
            root-&gt;SnapToMesh(&amp;outm);
            root-&gt;MakeMeshInto(&amp;runningMesh);
        } else {
            runningMesh.MakeFromCopyOf(&amp;outm);
        }

        outm.Clear();
        thism.Clear();
        prevm.Clear();
    }

    displayDirty = true;
}

</t>
<t tx="leo.20191228122645.57">void Group::GenerateDisplayItems() {
    // This is potentially slow (since we've got to triangulate a shell, or
    // to find the emphasized edges for a mesh), so we will run it only
    // if its inputs have changed.
    if(displayDirty) {
        Group *pg = RunningMeshGroup();
        if(pg &amp;&amp; thisMesh.IsEmpty() &amp;&amp; thisShell.IsEmpty()) {
            // We don't contribute any new solid model in this group, so our
            // display items are identical to the previous group's; which means
            // that we can just display those, and stop ourselves from
            // recalculating for those every time we get a change in this group.
            //
            // Note that this can end up recursing multiple times (if multiple
            // groups that contribute no solid model exist in sequence), but
            // that's okay.
            pg-&gt;GenerateDisplayItems();

            displayMesh.Clear();
            displayMesh.MakeFromCopyOf(&amp;(pg-&gt;displayMesh));

            displayOutlines.Clear();
            if(SS.GW.showEdges || SS.GW.showOutlines) {
                displayOutlines.MakeFromCopyOf(&amp;pg-&gt;displayOutlines);
            }
        } else {
            // We do contribute new solid model, so we have to triangulate the
            // shell, and edge-find the mesh.
            displayMesh.Clear();
            runningShell.TriangulateInto(&amp;displayMesh);
            STriangle *t;
            for(t = runningMesh.l.First(); t; t = runningMesh.l.NextAfter(t)) {
                STriangle trn = *t;
                Vector n = trn.Normal();
                trn.an = n;
                trn.bn = n;
                trn.cn = n;
                displayMesh.AddTriangle(&amp;trn);
            }

            displayOutlines.Clear();

            if(SS.GW.showEdges || SS.GW.showOutlines) {
                SOutlineList rawOutlines = {};
                if(!runningMesh.l.IsEmpty()) {
                    // Triangle mesh only; no shell or emphasized edges.
                    runningMesh.MakeOutlinesInto(&amp;rawOutlines, EdgeKind::EMPHASIZED);
                } else {
                    displayMesh.MakeOutlinesInto(&amp;rawOutlines, EdgeKind::SHARP);
                }

                PolylineBuilder builder;
                builder.MakeFromOutlines(rawOutlines);
                builder.GenerateOutlines(&amp;displayOutlines);
                rawOutlines.Clear();
            }
        }

        // If we render this mesh, we need to know whether it's transparent,
        // and we'll want all transparent triangles last, to make the depth test
        // work correctly.
        displayMesh.PrecomputeTransparency();

        // Recalculate mass center if needed
        if(SS.centerOfMass.draw &amp;&amp; SS.centerOfMass.dirty &amp;&amp; h == SS.GW.activeGroup) {
            SS.UpdateCenterOfMass();
        }
        displayDirty = false;
    }
}

Group *Group::PreviousGroup() const {
    Group *prev = nullptr;
    for(auto const &amp;gh : SK.groupOrder) {
        Group *g = SK.GetGroup(gh);
        if(g-&gt;h == h) {
            return prev;
        }
        prev = g;
    }
    return nullptr;
}

Group *Group::RunningMeshGroup() const {
    if(type == Type::TRANSLATE || type == Type::ROTATE) {
        return SK.GetGroup(opA)-&gt;RunningMeshGroup();
    } else {
        return PreviousGroup();
    }
}

</t>
<t tx="leo.20191228122645.58">bool Group::IsMeshGroup() {
    switch(type) {
        case Group::Type::EXTRUDE:
        case Group::Type::LATHE:
        case Group::Type::REVOLVE:
        case Group::Type::HELIX:
        case Group::Type::ROTATE:
        case Group::Type::TRANSLATE:
            return true;

        default:
            return false;
    }
}

</t>
<t tx="leo.20191228122645.59">void Group::DrawMesh(DrawMeshAs how, Canvas *canvas) {
    if(!(SS.GW.showShaded ||
         SS.GW.drawOccludedAs != GraphicsWindow::DrawOccludedAs::VISIBLE)) return;

    switch(how) {
        case DrawMeshAs::DEFAULT: {
            // Force the shade color to something dim to not distract from
            // the sketch.
            Canvas::Fill fillFront = {};
            if(!SS.GW.showShaded) {
                fillFront.layer = Canvas::Layer::DEPTH_ONLY;
            }
            if(type == Type::DRAWING_3D || type == Type::DRAWING_WORKPLANE) {
                fillFront.color = Style::Color(Style::DIM_SOLID);
            }
            Canvas::hFill hcfFront = canvas-&gt;GetFill(fillFront);

            // The back faces are drawn in red; should never seem them, since we
            // draw closed shells, so that's a debugging aid.
            Canvas::hFill hcfBack = {};
            if(SS.drawBackFaces &amp;&amp; !displayMesh.isTransparent) {
                Canvas::Fill fillBack = {};
                fillBack.layer = fillFront.layer;
                fillBack.color = RgbaColor::FromFloat(1.0f, 0.1f, 0.1f);
                hcfBack = canvas-&gt;GetFill(fillBack);
            } else {
                hcfBack = hcfFront;
            }

            // Draw the shaded solid into the depth buffer for hidden line removal,
            // and if we're actually going to display it, to the color buffer too.
            canvas-&gt;DrawMesh(displayMesh, hcfFront, hcfBack);

            // Draw mesh edges, for debugging.
            if(SS.GW.showMesh) {
                Canvas::Stroke strokeTriangle = {};
                strokeTriangle.zIndex = 1;
                strokeTriangle.color  = RgbaColor::FromFloat(0.0f, 1.0f, 0.0f);
                strokeTriangle.width  = 1;
                strokeTriangle.unit   = Canvas::Unit::PX;
                Canvas::hStroke hcsTriangle = canvas-&gt;GetStroke(strokeTriangle);
                SEdgeList edges = {};
                for(const STriangle &amp;t : displayMesh.l) {
                    edges.AddEdge(t.a, t.b);
                    edges.AddEdge(t.b, t.c);
                    edges.AddEdge(t.c, t.a);
                }
                canvas-&gt;DrawEdges(edges, hcsTriangle);
                edges.Clear();
            }
            break;
        }

        case DrawMeshAs::HOVERED: {
            Canvas::Fill fill = {};
            fill.color   = Style::Color(Style::HOVERED);
            fill.pattern = Canvas::FillPattern::CHECKERED_A;
            fill.zIndex  = 2;
            Canvas::hFill hcf = canvas-&gt;GetFill(fill);

            std::vector&lt;uint32_t&gt; faces;
            hEntity he = SS.GW.hover.entity;
            if(he.v != 0 &amp;&amp; SK.GetEntity(he)-&gt;IsFace()) {
                faces.push_back(he.v);
            }
            canvas-&gt;DrawFaces(displayMesh, faces, hcf);
            break;
        }

        case DrawMeshAs::SELECTED: {
            Canvas::Fill fill = {};
            fill.color   = Style::Color(Style::SELECTED);
            fill.pattern = Canvas::FillPattern::CHECKERED_B;
            fill.zIndex  = 1;
            Canvas::hFill hcf = canvas-&gt;GetFill(fill);

            std::vector&lt;uint32_t&gt; faces;
            SS.GW.GroupSelection();
            auto const &amp;gs = SS.GW.gs;
            if(gs.faces &gt; 0) faces.push_back(gs.face[0].v);
            if(gs.faces &gt; 1) faces.push_back(gs.face[1].v);
            canvas-&gt;DrawFaces(displayMesh, faces, hcf);
            break;
        }
    }
}

</t>
<t tx="leo.20191228122645.6">static void PopulateMenuWithPathnames(Platform::MenuRef menu,
                                      std::vector&lt;Platform::Path&gt; pathnames,
                                      std::function&lt;void(const Platform::Path &amp;)&gt; onTrigger) {
    menu-&gt;Clear();
    if(pathnames.empty()) {
        Platform::MenuItemRef menuItem = menu-&gt;AddItem(_("(no recent files)"));
        menuItem-&gt;SetEnabled(false);
    } else {
        for(Platform::Path pathname : pathnames) {
            Platform::MenuItemRef menuItem = menu-&gt;AddItem(pathname.raw, [=]() {
                if(FileExists(pathname)) {
                    onTrigger(pathname);
                } else {
                    Error(_("File '%s' does not exist."), pathname.raw.c_str());
                }
            }, /*mnemonics=*/false);
        }
    }
}

</t>
<t tx="leo.20191228122645.60">void Group::Draw(Canvas *canvas) {
    // Everything here gets drawn whether or not the group is hidden; we
    // can control this stuff independently, with show/hide solids, edges,
    // mesh, etc.

    GenerateDisplayItems();
    DrawMesh(DrawMeshAs::DEFAULT, canvas);

    if(SS.GW.showEdges) {
        Canvas::Stroke strokeEdge = Style::Stroke(Style::SOLID_EDGE);
        strokeEdge.zIndex = 1;
        Canvas::hStroke hcsEdge = canvas-&gt;GetStroke(strokeEdge);

        canvas-&gt;DrawOutlines(displayOutlines, hcsEdge,
                             SS.GW.showOutlines
                             ? Canvas::DrawOutlinesAs::EMPHASIZED_WITHOUT_CONTOUR
                             : Canvas::DrawOutlinesAs::EMPHASIZED_AND_CONTOUR);

        if(SS.GW.drawOccludedAs != GraphicsWindow::DrawOccludedAs::INVISIBLE) {
            Canvas::Stroke strokeHidden = Style::Stroke(Style::HIDDEN_EDGE);
            if(SS.GW.drawOccludedAs == GraphicsWindow::DrawOccludedAs::VISIBLE) {
                strokeHidden.stipplePattern = StipplePattern::CONTINUOUS;
            }
            strokeHidden.layer  = Canvas::Layer::OCCLUDED;
            Canvas::hStroke hcsHidden = canvas-&gt;GetStroke(strokeHidden);

            canvas-&gt;DrawOutlines(displayOutlines, hcsHidden,
                                 Canvas::DrawOutlinesAs::EMPHASIZED_AND_CONTOUR);
        }
    }

    if(SS.GW.showOutlines) {
        Canvas::Stroke strokeOutline = Style::Stroke(Style::OUTLINE);
        strokeOutline.zIndex = 1;
        Canvas::hStroke hcsOutline = canvas-&gt;GetStroke(strokeOutline);

        canvas-&gt;DrawOutlines(displayOutlines, hcsOutline,
                             Canvas::DrawOutlinesAs::CONTOUR_ONLY);
    }
}

</t>
<t tx="leo.20191228122645.61">void Group::DrawPolyError(Canvas *canvas) {
    const Camera &amp;camera = canvas-&gt;GetCamera();

    Canvas::Stroke strokeUnclosed = Style::Stroke(Style::DRAW_ERROR);
    strokeUnclosed.color = strokeUnclosed.color.WithAlpha(50);
    Canvas::hStroke hcsUnclosed = canvas-&gt;GetStroke(strokeUnclosed);

    Canvas::Stroke strokeError = Style::Stroke(Style::DRAW_ERROR);
    strokeError.layer = Canvas::Layer::FRONT;
    strokeError.width = 1.0f;
    Canvas::hStroke hcsError = canvas-&gt;GetStroke(strokeError);

    double textHeight = Style::DefaultTextHeight() / camera.scale;

    // And finally show the polygons too, and any errors if it's not possible
    // to assemble the lines into closed polygons.
    if(polyError.how == PolyError::NOT_CLOSED) {
        // Report this error only in sketch-in-workplane groups; otherwise
        // it's just a nuisance.
        if(type == Type::DRAWING_WORKPLANE) {
            canvas-&gt;DrawVectorText(_("not closed contour, or not all same style!"),
                                   textHeight,
                                   polyError.notClosedAt.b, camera.projRight, camera.projUp,
                                   hcsError);
            canvas-&gt;DrawLine(polyError.notClosedAt.a, polyError.notClosedAt.b, hcsUnclosed);
        }
    } else if(polyError.how == PolyError::NOT_COPLANAR ||
              polyError.how == PolyError::SELF_INTERSECTING ||
              polyError.how == PolyError::ZERO_LEN_EDGE) {
        // These errors occur at points, not lines
        if(type == Type::DRAWING_WORKPLANE) {
            const char *msg;
            if(polyError.how == PolyError::NOT_COPLANAR) {
                msg = _("points not all coplanar!");
            } else if(polyError.how == PolyError::SELF_INTERSECTING) {
                msg = _("contour is self-intersecting!");
            } else {
                msg = _("zero-length edge!");
            }
            canvas-&gt;DrawVectorText(msg, textHeight,
                                   polyError.errorPointAt, camera.projRight, camera.projUp,
                                   hcsError);
        }
    } else {
        // The contours will get filled in DrawFilledPaths.
    }
}

</t>
<t tx="leo.20191228122645.62">void Group::DrawFilledPaths(Canvas *canvas) {
    for(const SBezierLoopSet &amp;sbls : bezierLoops.l) {
        if(sbls.l.IsEmpty() || sbls.l[0].l.IsEmpty())
            continue;

        // In an assembled loop, all the styles should be the same; so doesn't
        // matter which one we grab.
        const SBezier *sb = &amp;(sbls.l[0].l[0]);
        Style *s = Style::Get({ (uint32_t)sb-&gt;auxA });

        Canvas::Fill fill = {};
        fill.zIndex = 1;
        if(s-&gt;filled) {
            // This is a filled loop, where the user specified a fill color.
            fill.color = s-&gt;fillColor;
        } else if(h == SS.GW.activeGroup &amp;&amp; SS.checkClosedContour &amp;&amp;
                    polyError.how == PolyError::GOOD) {
            // If this is the active group, and we are supposed to check
            // for closed contours, and we do indeed have a closed and
            // non-intersecting contour, then fill it dimly.
            fill.color = Style::Color(Style::CONTOUR_FILL).WithAlpha(127);
        } else continue;
        Canvas::hFill hcf = canvas-&gt;GetFill(fill);

        SPolygon sp = {};
        sbls.MakePwlInto(&amp;sp);
        canvas-&gt;DrawPolygon(sp, hcf);
        sp.Clear();
    }
}

</t>
<t tx="leo.20191228122645.63">void Group::DrawContourAreaLabels(Canvas *canvas) {
    const Camera &amp;camera = canvas-&gt;GetCamera();
    Vector gr = camera.projRight.ScaledBy(1 / camera.scale);
    Vector gu = camera.projUp.ScaledBy(1 / camera.scale);

    for(SBezierLoopSet &amp;sbls : bezierLoops.l) {
        if(sbls.l.IsEmpty() || sbls.l[0].l.IsEmpty())
            continue;

        Vector min = sbls.l[0].l[0].ctrl[0];
        Vector max = min;
        Vector zero = Vector::From(0.0, 0.0, 0.0);
        sbls.GetBoundingProjd(Vector::From(1.0, 0.0, 0.0), zero, &amp;min.x, &amp;max.x);
        sbls.GetBoundingProjd(Vector::From(0.0, 1.0, 0.0), zero, &amp;min.y, &amp;max.y);
        sbls.GetBoundingProjd(Vector::From(0.0, 0.0, 1.0), zero, &amp;min.z, &amp;max.z);

        Vector mid = min.Plus(max).ScaledBy(0.5);

        hStyle hs = { Style::CONSTRAINT };
        Canvas::Stroke stroke = Style::Stroke(hs);
        stroke.layer = Canvas::Layer::FRONT;

        double scale = SS.MmPerUnit();
        std::string label = ssprintf("%.3f %s²",
                                     fabs(sbls.SignedArea() / (scale * scale)),
                                     SS.UnitName());

        double fontHeight = Style::TextHeight(hs);
        double textWidth  = VectorFont::Builtin()-&gt;GetWidth(fontHeight, label),
</t>
<t tx="leo.20191228122645.64">@path ./src/
#include "solvespace.h"
#include "libdxfrw.h"
#include "libdwgr.h"

namespace SolveSpace {

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122645.65">static std::string ToUpper(std::string str) {
    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
    return str;
}

</t>
<t tx="leo.20191228122645.66">class DxfImport : public DRW_Interface {
public:
    Vector blockX;
    Vector blockY;
    Vector blockZ;
    Vector blockT;

    @others
};

</t>
<t tx="leo.20191228122645.67">void invertXTransform() {
    blockX.x = -blockX.x;
    blockY.x = -blockY.x;
    blockT.x = -blockT.x;
}

</t>
<t tx="leo.20191228122645.68">void multBlockTransform(double x, double y, double sx, double sy, double angle) {
    Vector oldX = blockX;
    Vector oldY = blockY;
    Vector oldT = blockT;

    Vector newX = Vector::From(sx, 0.0, 0.0).RotatedAbout(Vector::From(0.0, 0.0, 1.0), angle);
    Vector newY = Vector::From(0.0, sy, 0.0).RotatedAbout(Vector::From(0.0, 0.0, 1.0), angle);
    Vector newT = Vector::From(x, y, 0.0);

    blockX = oldX.ScaledBy(newX.x).Plus(
             oldY.ScaledBy(newX.y));

    blockY = oldX.ScaledBy(newY.x).Plus(
             oldY.ScaledBy(newY.y));

    blockT = oldX.ScaledBy(newT.x).Plus(
             oldY.ScaledBy(newT.y)).Plus(oldT);
}

</t>
<t tx="leo.20191228122645.69">void clearBlockTransform() {
    blockX = Vector::From(1.0, 0.0, 0.0);
    blockY = Vector::From(0.0, 1.0, 0.0);
    blockZ = Vector::From(0.0, 0.0, 1.0);
    blockT = Vector::From(0.0, 0.0, 0.0);
}

Vector blockTransform(Vector v) {
    Vector r = blockT;
    r = r.Plus(blockX.ScaledBy(v.x));
    r = r.Plus(blockY.ScaledBy(v.y));
    r = r.Plus(blockZ.ScaledBy(v.z));
    return r;
}

</t>
<t tx="leo.20191228122645.7">void GraphicsWindow::PopulateRecentFiles() {
    PopulateMenuWithPathnames(openRecentMenu, SS.recentFiles, [](const Platform::Path &amp;path) {
        if(!SS.OkayToStartNewFile()) return;
        SS.Load(path);
    });

    PopulateMenuWithPathnames(linkRecentMenu, SS.recentFiles, [](const Platform::Path &amp;path) {
        Group::MenuGroup(Command::GROUP_LINK, path);
    });
}

</t>
<t tx="leo.20191228122645.70">void blockTransformArc(Vector *c, Vector *p0, Vector *p1) {
    bool oldSign = p0-&gt;Minus(*c).Cross(p1-&gt;Minus(*c)).z &gt; 0.0;

    *c = blockTransform(*c);
    *p0 = blockTransform(*p0);
    *p1 = blockTransform(*p1);

    bool newSign = p0-&gt;Minus(*c).Cross(p1-&gt;Minus(*c)).z &gt; 0.0;
    if(oldSign != newSign) std::swap(*p0, *p1);
}

Vector toVector(const DRW_Coord &amp;c, bool transform = true) {
    Vector result = Vector::From(c.x, c.y, c.z);
    if(transform) return blockTransform(result);
    return result;
}

Vector toVector(const DRW_Vertex2D &amp;c) {
    Vector result = Vector::From(c.x, c.y, 0.0);
    return blockTransform(result);
}

Vector toVector(const DRW_Vertex &amp;c) {
    Vector result = Vector::From(c.basePoint.x, c.basePoint.y, c.basePoint.z);
    return blockTransform(result);
}

</t>
<t tx="leo.20191228122645.71">double angleTo(Vector v0, Vector v1) {
    Vector d = v1.Minus(v0);
    double a = atan2(d.y, d.x);
    return M_PI + remainder(a - M_PI, 2 * M_PI);
}

Vector polar(double radius, double angle) {
    return Vector::From(radius * cos(angle), radius * sin(angle), 0.0);
}

hRequest createBulge(Vector p0, Vector p1, double bulge) {
    bool reversed = bulge &lt; 0.0;
    double alpha = atan(bulge) * 4.0;

    Vector middle = p1.Plus(p0).ScaledBy(0.5);
    double dist = p1.Minus(p0).Magnitude() / 2.0;
    double angle = angleTo(p0, p1);

    // alpha can't be 0.0 at this point
    double radius = fabs(dist / sin(alpha / 2.0));
    double wu = fabs(radius * radius - dist * dist);
    double h = sqrt(wu);

    if(bulge &gt; 0.0) {
        angle += M_PI_2;
    } else {
        angle -= M_PI_2;
    }

    if (fabs(alpha) &gt; M_PI) {
        h *= -1.0;
    }

    Vector center = polar(h, angle);
    center = center.Plus(middle);

    if(reversed) std::swap(p0, p1);
    blockTransformArc(&amp;center, &amp;p0, &amp;p1);

    hRequest hr = SS.GW.AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false);
    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(center);
    SK.GetEntity(hr.entity(2))-&gt;PointForceTo(p0);
    SK.GetEntity(hr.entity(3))-&gt;PointForceTo(p1);
    processPoint(hr.entity(1));
    processPoint(hr.entity(2));
    processPoint(hr.entity(3));
    return hr;
}

struct Block {
    std::vector&lt;std::unique_ptr&lt;DRW_Entity&gt;&gt; entities;
    DRW_Block data;
};

bool asConstruction = false;
unsigned unknownEntities = 0;
std::map&lt;std::string, hStyle&gt; styles;
std::map&lt;std::string, Block&gt; blocks;
std::map&lt;std::string, DRW_Layer&gt; layers;
Block *readBlock = NULL;
const DRW_Insert *insertInsert = NULL;

template&lt;class T&gt;
</t>
<t tx="leo.20191228122645.72">bool addPendingBlockEntity(const T &amp;e) {
    if(readBlock == NULL) return false;
    readBlock-&gt;entities.emplace_back(new T(e));
    return true;
}

</t>
<t tx="leo.20191228122645.73">void addEntity(DRW_Entity *e) {
    switch(e-&gt;eType) {
        case DRW::POINT:
            addPoint(*static_cast&lt;DRW_Point *&gt;(e));
            break;
        case DRW::LINE:
            addLine(*static_cast&lt;DRW_Line *&gt;(e));
            break;
        case DRW::ARC:
            addArc(*static_cast&lt;DRW_Arc *&gt;(e));
            break;
        case DRW::CIRCLE:
            addCircle(*static_cast&lt;DRW_Circle *&gt;(e));
            break;
        case DRW::POLYLINE:
            addPolyline(*static_cast&lt;DRW_Polyline *&gt;(e));
            break;
        case DRW::LWPOLYLINE:
            addLWPolyline(*static_cast&lt;DRW_LWPolyline *&gt;(e));
            break;
        case DRW::SPLINE:
            addSpline(static_cast&lt;DRW_Spline *&gt;(e));
            break;
        case DRW::INSERT:
            addInsert(*static_cast&lt;DRW_Insert *&gt;(e));
            break;
        case DRW::TEXT:
            addText(*static_cast&lt;DRW_Text *&gt;(e));
            break;
        case DRW::MTEXT:
            addMText(*static_cast&lt;DRW_MText *&gt;(e));
            break;
        case DRW::DIMALIGNED:
            addDimAlign(static_cast&lt;DRW_DimAligned *&gt;(e));
            break;
        case DRW::DIMLINEAR:
            addDimLinear(static_cast&lt;DRW_DimLinear *&gt;(e));
            break;
        case DRW::DIMRADIAL:
            addDimRadial(static_cast&lt;DRW_DimRadial *&gt;(e));
            break;
        case DRW::DIMDIAMETRIC:
            addDimDiametric(static_cast&lt;DRW_DimDiametric *&gt;(e));
            break;
        case DRW::DIMANGULAR:
            addDimAngular(static_cast&lt;DRW_DimAngular *&gt;(e));
            break;
        default:
            unknownEntities++;
    }
}

Style::TextOrigin dxfAlignToOrigin(DRW_Text::HAlign alignH, DRW_Text::VAlign alignV) {
    uint32_t origin = 0;
    switch(alignH) {
        case DRW_Text::HLeft:
            origin |= (uint32_t)Style::TextOrigin::LEFT;
            break;

        case DRW_Text::HMiddle:
        case DRW_Text::HCenter:
            break;

        case DRW_Text::HRight:
            origin |= (uint32_t)Style::TextOrigin::RIGHT;
            break;

        case DRW_Text::HAligned:
        case DRW_Text::HFit:
        default:
            origin |= (uint32_t)Style::TextOrigin::LEFT;
            break;
    }

    switch(alignV) {
        case DRW_Text::VBaseLine:
        case DRW_Text::VBottom:
            origin |= (uint32_t)Style::TextOrigin::BOT;
            break;

        case DRW_Text::VMiddle:
            break;

        case DRW_Text::VTop:
            origin |= (uint32_t)Style::TextOrigin::TOP;
            break;

        default:
            origin |= (uint32_t)Style::TextOrigin::BOT;
            break;
    }

    return (Style::TextOrigin)origin;
}

DRW_Layer *getSourceLayer(const DRW_Entity *e) {
    DRW_Layer *layer = NULL;
    if(insertInsert != NULL) {
        std::string l = insertInsert-&gt;layer;
        auto bi = layers.find(l);
        if(bi != layers.end()) layer = &amp;bi-&gt;second;
    } else {
        std::string l = e-&gt;layer;
        auto bi = layers.find(l);
        if(bi != layers.end()) layer = &amp;bi-&gt;second;
    }
    return layer;
}

</t>
<t tx="leo.20191228122645.74">int getColor(const DRW_Entity *e) {
    int col = e-&gt;color;
    if(col == DRW::ColorByBlock) {
        if(insertInsert != NULL) {
            col = insertInsert-&gt;color;
        } else {
            col = 7;
        }
    }
    if(col == DRW::ColorByLayer) {
        DRW_Layer *layer = getSourceLayer(e);
        if(layer != NULL) {
            col = layer-&gt;color;
        } else {
            col = 7;
        }
    }
    return col;
}

DRW_LW_Conv::lineWidth getLineWidth(const DRW_Entity *e) {
    DRW_LW_Conv::lineWidth result = e-&gt;lWeight;
    if(result == DRW_LW_Conv::widthByBlock) {
        if(insertInsert != NULL) {
            result = insertInsert-&gt;lWeight;
        } else {
            result = DRW_LW_Conv::widthDefault;
        }
    }
    if(result == DRW_LW_Conv::widthByLayer) {
        DRW_Layer *layer = getSourceLayer(e);
        if(layer != NULL) {
            result = layer-&gt;lWeight;
        } else {
            result = DRW_LW_Conv::widthDefault;
        }
    }
    return result;
}

std::string getLineType(const DRW_Entity *e) {
    std::string  result = e-&gt;lineType;
    if(result == "BYBLOCK") {
        if(insertInsert != NULL) {
            result = ToUpper(insertInsert-&gt;lineType);
        } else {
            result = "CONTINUOUS";
        }
    }
    if(result == "BYLAYER") {
        DRW_Layer *layer = getSourceLayer(e);
        if(layer != NULL) {
            result = ToUpper(layer-&gt;lineType);
        } else {
            result = "CONTINUOUS";
        }
    }
    return result;
}

hStyle invisibleStyle() {
    std::string id = "@dxf-invisible";

    auto si = styles.find(id);
    if(si != styles.end()) {
        return si-&gt;second;
    }

    hStyle hs = { Style::CreateCustomStyle(/*rememberForUndo=*/false) };
    Style *s = Style::Get(hs);
    s-&gt;name = id;
    s-&gt;visible = false;

    styles.emplace(id, hs);
    return hs;
}

hStyle styleFor(const DRW_Entity *e) {
    // Color.
    //! @todo which color to choose: index or RGB one?
    int col = getColor(e);
    RgbaColor c = RgbaColor::From(DRW::dxfColors[col][0],
                                  DRW::dxfColors[col][1],
                                  DRW::dxfColors[col][2]);

    // Line width.
    DRW_LW_Conv::lineWidth lw = getLineWidth(e);
    double width = DRW_LW_Conv::lineWidth2dxfInt(e-&gt;lWeight) / 100.0;
    if(width &lt; 0.0) width = 1.0;

    // Line stipple.
    //! @todo Probably, we can load default autocad patterns and match it with ours.
    std::string lineType = getLineType(e);
    StipplePattern stipple = StipplePattern::CONTINUOUS;
    for(uint32_t i = 0; i &lt;= (uint32_t)StipplePattern::LAST; i++) {
        StipplePattern st = (StipplePattern)i;
        if(lineType == DxfFileWriter::lineTypeName(st)) {
            stipple = st;
            break;
        }
    }

    // Text properties.
    DRW_Text::HAlign alignH = DRW_Text::HLeft;
    DRW_Text::VAlign alignV = DRW_Text::VBaseLine;
    double textAngle = 0.0;
    double textHeight = Style::DefaultTextHeight();

    if(e-&gt;eType == DRW::TEXT || e-&gt;eType == DRW::MTEXT) {
        const DRW_Text *text = static_cast&lt;const DRW_Text *&gt;(e);
        alignH = text-&gt;alignH;
        alignV = text-&gt;alignV;
        textHeight = text-&gt;height;
        textAngle = text-&gt;angle;
        // I have no idea why, but works
        if(alignH == DRW_Text::HMiddle) {
            alignV = DRW_Text::VMiddle;
        }
    }

    // Unique identifier based on style properties.
    std::string id = "@dxf";
    if(lw != DRW_LW_Conv::widthDefault)
        id += ssprintf("-w%.4g", width);
    if(lineType != "CONTINUOUS")
        id += ssprintf("-%s", lineType.c_str());
    if(c.red != 0 || c.green != 0 || c.blue != 0)
        id += ssprintf("-#%02x%02x%02x", c.red, c.green, c.blue);
    if(textHeight != Style::DefaultTextHeight())
        id += ssprintf("-h%.4g", textHeight);
    if(textAngle != 0.0)
        id += ssprintf("-a%.5g", textAngle);
    if(alignH != DRW_Text::HLeft)
        id += ssprintf("-oh%d", alignH);
    if(alignV != DRW_Text::VBaseLine)
        id += ssprintf("-ov%d", alignV);

    auto si = styles.find(id);
    if(si != styles.end()) {
        return si-&gt;second;
    }

    hStyle hs = { Style::CreateCustomStyle(/*rememberForUndo=*/false) };
    Style *s = Style::Get(hs);
    if(lw != DRW_LW_Conv::widthDefault) {
        s-&gt;widthAs = Style::UnitsAs::MM;
        s-&gt;width = width;
        s-&gt;stippleScale = 1.0 + width * 2.0;
    }
    s-&gt;name = id;
    s-&gt;stippleType = stipple;
    if(c.red != 0 || c.green != 0 || c.blue != 0) s-&gt;color = c;
    s-&gt;textHeightAs = Style::UnitsAs::MM;
    s-&gt;textHeight = textHeight;
    s-&gt;textAngle = textAngle;
    s-&gt;textOrigin = dxfAlignToOrigin(alignH, alignV);

    styles.emplace(id, hs);
    return hs;
}

</t>
<t tx="leo.20191228122645.75">void configureRequest(hRequest hr, hStyle hs) {
    Request *r = SK.GetRequest(hr);
    r-&gt;construction = asConstruction;
    r-&gt;style = hs;
}

struct VectorHash {
    size_t operator()(const Vector &amp;v) const {
        static const size_t size = std::numeric_limits&lt;size_t&gt;::max() / 2 - 1;
        static const double eps = (4.0 * LENGTH_EPS);

        double x = fabs(v.x) / eps;
        double y = fabs(v.y) / eps;

        size_t xs = size_t(fmod(x, double(size)));
        size_t ys = size_t(fmod(y, double(size)));

        return ys * size + xs;
    }
};

struct VectorPred {
</t>
<t tx="leo.20191228122645.76">    bool operator()(Vector a, Vector b) const {
        return a.Equals(b, LENGTH_EPS);
    }
};

std::unordered_map&lt;Vector, hEntity, VectorHash, VectorPred&gt; points;

</t>
<t tx="leo.20191228122645.77">void processPoint(hEntity he, bool constrain = true) {
    Entity *e = SK.GetEntity(he);
    Vector pos = e-&gt;PointGetNum();
    hEntity p = findPoint(pos);
    if(p == he) return;
    if(p != Entity::NO_ENTITY) {
        if(constrain) {
            Constraint::ConstrainCoincident(he, p);
        }
        // We don't add point because we already
        // have point in this position
        return;
    }
    points.emplace(pos, he);
}

hEntity findPoint(const Vector &amp;p) {
    auto it = points.find(p);
    if(it == points.end()) return Entity::NO_ENTITY;
    return it-&gt;second;
}

hEntity createOrGetPoint(const Vector &amp;p) {
    hEntity he = findPoint(p);
    if(he != Entity::NO_ENTITY) return he;

    hRequest hr = SS.GW.AddRequest(Request::Type::DATUM_POINT, /*rememberForUndo=*/false);
    he = hr.entity(0);
    SK.GetEntity(he)-&gt;PointForceTo(p);
    points.emplace(p, he);
    return he;
}

hEntity createLine(Vector p0, Vector p1, hStyle style, bool constrainHV = false) {
    if(p0.Equals(p1)) return Entity::NO_ENTITY;
    hRequest hr = SS.GW.AddRequest(Request::Type::LINE_SEGMENT, /*rememberForUndo=*/false);
    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(p0);
    SK.GetEntity(hr.entity(2))-&gt;PointForceTo(p1);
    processPoint(hr.entity(1));
    processPoint(hr.entity(2));

    if(constrainHV &amp;&amp; SS.GW.LockedInWorkplane()) {
        bool hasConstraint = false;
        Constraint::Type cType;
        if(fabs(p0.x - p1.x) &lt; LENGTH_EPS) {
            hasConstraint = true;
            cType = Constraint::Type::VERTICAL;
        } else if(fabs(p0.y - p1.y) &lt; LENGTH_EPS) {
            hasConstraint = true;
            cType = Constraint::Type::HORIZONTAL;
        }
        if(hasConstraint) {
            Constraint::Constrain(
                cType,
                Entity::NO_ENTITY,
                Entity::NO_ENTITY,
                hr.entity(0)
            );
        }
    }

    configureRequest(hr, style);
    return hr.entity(0);
}

hEntity createCircle(const Vector &amp;c, double r, hStyle style) {
    hRequest hr = SS.GW.AddRequest(Request::Type::CIRCLE, /*rememberForUndo=*/false);
    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(c);
    processPoint(hr.entity(1));
    SK.GetEntity(hr.entity(64))-&gt;DistanceForceTo(r);

    configureRequest(hr, style);
    return hr.entity(0);
}

</t>
<t tx="leo.20191228122645.78">void addLayer(const DRW_Layer &amp;data) override {
    layers.emplace(data.name, data);
}

</t>
<t tx="leo.20191228122645.79">void addBlock(const DRW_Block &amp;data) override {
    readBlock = &amp;blocks[data.name];
    readBlock-&gt;data = data;
}

</t>
<t tx="leo.20191228122645.8">void GraphicsWindow::Init() {
    scale     = 5;
    offset    = Vector::From(0, 0, 0);
    projRight = Vector::From(1, 0, 0);
    projUp    = Vector::From(0, 1, 0);

    // Make sure those are valid; could get a mouse move without a mouse
    // down if someone depresses the button, then drags into our window.
    orig.projRight = projRight;
    orig.projUp = projUp;

    // And with the last group active
    ssassert(!SK.groupOrder.IsEmpty(),
             "Group order can't be empty since we will activate the last group.");
    activeGroup = *SK.groupOrder.Last();
    SK.GetGroup(activeGroup)-&gt;Activate();

    showWorkplanes = false;
    showNormals = true;
    showPoints = true;
    showConstruction = true;
    showConstraints = true;
    showShaded = true;
    showEdges = true;
    showMesh = false;
    showOutlines = false;
    drawOccludedAs = DrawOccludedAs::INVISIBLE;

    showTextWindow = true;

    showSnapGrid = false;
    context.active = false;
    toolbarHovered = Command::NONE;

    if(!window) {
        window = Platform::CreateWindow();
        if(window) {
            using namespace std::placeholders;
            // Do this first, so that if it causes an onRender event we don't try to paint without
            // a canvas.
            window-&gt;SetMinContentSize(720, 670);
            window-&gt;onClose = std::bind(&amp;SolveSpaceUI::MenuFile, Command::EXIT);
            window-&gt;onRender = std::bind(&amp;GraphicsWindow::Paint, this);
            window-&gt;onKeyboardEvent = std::bind(&amp;GraphicsWindow::KeyboardEvent, this, _1);
            window-&gt;onMouseEvent = std::bind(&amp;GraphicsWindow::MouseEvent, this, _1);
            window-&gt;onSixDofEvent = std::bind(&amp;GraphicsWindow::SixDofEvent, this, _1);
            window-&gt;onEditingDone = std::bind(&amp;GraphicsWindow::EditControlDone, this, _1);
            PopulateMainMenu();
        }
    }

    if(window) {
        canvas = CreateRenderer();
        if(canvas) {
            persistentCanvas = canvas-&gt;CreateBatch();
            persistentDirty = true;
        }
    }

    // Do this last, so that all the menus get updated correctly.
    ClearSuper();
}

</t>
<t tx="leo.20191228122645.80">void endBlock() override {
    readBlock = NULL;
}

</t>
<t tx="leo.20191228122645.81">void addPoint(const DRW_Point &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Point&gt;(data)) return;

    hRequest hr = SS.GW.AddRequest(Request::Type::DATUM_POINT, /*rememberForUndo=*/false);
    SK.GetEntity(hr.entity(0))-&gt;PointForceTo(toVector(data.basePoint));
    processPoint(hr.entity(0));
}

</t>
<t tx="leo.20191228122645.82">void addLine(const DRW_Line &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Line&gt;(data)) return;

    createLine(toVector(data.basePoint), toVector(data.secPoint), styleFor(&amp;data),
               /*constrainHV=*/true);
}

</t>
<t tx="leo.20191228122645.83">void addArc(const DRW_Arc &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Arc&gt;(data)) return;

    hRequest hr = SS.GW.AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false);
    double r = data.radious;
    double sa = data.staangle;
    double ea = data.endangle;
    Vector c = Vector::From(data.basePoint.x, data.basePoint.y, data.basePoint.z);
    Vector rvs = Vector::From(r * cos(sa), r * sin(sa), data.basePoint.z).Plus(c);
    Vector rve = Vector::From(r * cos(ea), r * sin(ea), data.basePoint.z).Plus(c);

    if(data.extPoint.z == -1.0) {
        c.x = -c.x;
        rvs.x = - rvs.x;
        rve.x = - rve.x;
        std::swap(rvs, rve);
    }

    blockTransformArc(&amp;c, &amp;rvs, &amp;rve);

    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(c);
    SK.GetEntity(hr.entity(2))-&gt;PointForceTo(rvs);
    SK.GetEntity(hr.entity(3))-&gt;PointForceTo(rve);
    processPoint(hr.entity(1));
    processPoint(hr.entity(2));
    processPoint(hr.entity(3));
    configureRequest(hr, styleFor(&amp;data));
}

</t>
<t tx="leo.20191228122645.84">void addCircle(const DRW_Circle &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Circle&gt;(data)) return;

    createCircle(toVector(data.basePoint), data.radious, styleFor(&amp;data));
}

</t>
<t tx="leo.20191228122645.85">void addLWPolyline(const DRW_LWPolyline &amp;data)  override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_LWPolyline&gt;(data)) return;

    size_t vNum = data.vertlist.size();

    // Check for closed polyline.
    if((data.flags &amp; 1) != 1) vNum--;

    // Correct coordinate system for the case where z=-1, as described in
    // http://paulbourke.net/dataformats/dxf/dxf10.html.
    bool needSwapX = data.extPoint.z == -1.0;

    for(size_t i = 0; i &lt; vNum; i++) {
        DRW_Vertex2D c0 = *data.vertlist[i];
        DRW_Vertex2D c1 = *data.vertlist[(i + 1) % data.vertlist.size()];

        if(needSwapX) {
            c0.x = -c0.x;
            c1.x = -c1.x;
            c0.bulge = -c0.bulge;
        }

        Vector p0 = Vector::From(c0.x, c0.y, 0.0);
        Vector p1 = Vector::From(c1.x, c1.y, 0.0);
        hStyle hs = styleFor(&amp;data);

        if(EXACT(data.vertlist[i]-&gt;bulge == 0.0)) {
            createLine(blockTransform(p0), blockTransform(p1), hs, /*constrainHV=*/true);
        } else {
            hRequest hr = createBulge(p0, p1, c0.bulge);
            configureRequest(hr, hs);
        }
    }
}

</t>
<t tx="leo.20191228122645.86">void addPolyline(const DRW_Polyline &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Polyline&gt;(data)) return;

    size_t vNum = data.vertlist.size();

    // Check for closed polyline.
    if((data.flags &amp; 1) != 1) vNum--;

    // Correct coordinate system for the case where z=-1, as described in
    // http://paulbourke.net/dataformats/dxf/dxf10.html.
    bool needSwapX = (data.extPoint.z == -1.0);

    for(size_t i = 0; i &lt; vNum; i++) {
        DRW_Coord c0 = data.vertlist[i]-&gt;basePoint;
        DRW_Coord c1 = data.vertlist[(i + 1) % data.vertlist.size()]-&gt;basePoint;

        double bulge = data.vertlist[i]-&gt;bulge;
        if(needSwapX) {
            c0.x = -c0.x;
            c1.x = -c1.x;
            bulge = -bulge;
        }

        Vector p0 = Vector::From(c0.x, c0.y, c0.z);
        Vector p1 = Vector::From(c1.x, c1.y, c1.z);
        hStyle hs = styleFor(&amp;data);

        if(EXACT(bulge == 0.0)) {
            createLine(blockTransform(p0), blockTransform(p1), hs, /*constrainHV=*/true);
        } else {
            hRequest hr = createBulge(p0, p1, bulge);
            configureRequest(hr, hs);
        }
    }
}

</t>
<t tx="leo.20191228122645.87">void addSpline(const DRW_Spline *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(data-&gt;degree != 3) return;
    if(addPendingBlockEntity&lt;DRW_Spline&gt;(*data)) return;

    hRequest hr = SS.GW.AddRequest(Request::Type::CUBIC, /*rememberForUndo=*/false);
    for(int i = 0; i &lt; 4; i++) {
        SK.GetEntity(hr.entity(i + 1))-&gt;PointForceTo(toVector(*data-&gt;controllist[i]));
        processPoint(hr.entity(i + 1));
    }
    configureRequest(hr, styleFor(data));
}

</t>
<t tx="leo.20191228122645.88">void addInsert(const DRW_Insert &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Insert&gt;(data)) return;

    auto bi = blocks.find(data.name);
    ssassert(bi != blocks.end(), "Inserted block does not exist");
    Block *block = &amp;bi-&gt;second;

    // Push transform.
    Vector x = blockX;
    Vector y = blockY;
    Vector t = blockT;

    const DRW_Insert *oldInsert = insertInsert;
    insertInsert = &amp;data;

    if(data.extPoint.z == -1.0) invertXTransform();
    multBlockTransform(data.basePoint.x, data.basePoint.y, data.xscale, data.yscale,
                       data.angle);
    for(auto &amp;e : block-&gt;entities) {
        addEntity(&amp;*e);
    }

    insertInsert = oldInsert;

    // Pop transform.
    blockX = x;
    blockY = y;
    blockT = t;
}

</t>
<t tx="leo.20191228122645.89">void addMText(const DRW_MText &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_MText&gt;(data)) return;

    DRW_MText text = data;
    text.secPoint = text.basePoint;
    addText(text);
}

</t>
<t tx="leo.20191228122645.9">void GraphicsWindow::AnimateOntoWorkplane() {
    if(!LockedInWorkplane()) return;

    Entity *w = SK.GetEntity(ActiveWorkplane());
    Quaternion quatf = w-&gt;Normal()-&gt;NormalGetNum();

    // Get Z pointing vertical, if we're on turntable nav mode:
    if(SS.turntableNav) {
        Vector normalRight = quatf.RotationU();
        Vector normalUp    = quatf.RotationV();
        Vector normal      = normalRight.Cross(normalUp);
        if(normalRight.z != 0) {
            double theta = atan2(normalUp.z, normalRight.z);
            theta -= atan2(1, 0);
            normalRight = normalRight.RotatedAbout(normal, theta);
            normalUp    = normalUp.RotatedAbout(normal, theta);
            quatf       = Quaternion::From(normalRight, normalUp);
        }
    }

    Vector offsetf = (SK.GetEntity(w-&gt;point[0])-&gt;PointGetNum()).ScaledBy(-1);

    // If the view screen is open, then we need to refresh it.
    SS.ScheduleShowTW();

    AnimateOnto(quatf, offsetf);
}

</t>
<t tx="leo.20191228122645.90">void addText(const DRW_Text &amp;data) override {
    if(data.space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_Text&gt;(data)) return;

    Constraint c = {};
    c.group         = SS.GW.activeGroup;
    c.workplane     = SS.GW.ActiveWorkplane();
    c.type          = Constraint::Type::COMMENT;
    if(data.alignH == DRW_Text::HLeft &amp;&amp; data.alignV == DRW_Text::VBaseLine) {
        c.disp.offset   = toVector(data.basePoint);
    } else {
        c.disp.offset   = toVector(data.secPoint);
    }
    c.comment       = data.text;
    c.disp.style    = styleFor(&amp;data);
    Constraint::AddConstraint(&amp;c, /*rememberForUndo=*/false);
}

</t>
<t tx="leo.20191228122645.91">void addDimAlign(const DRW_DimAligned *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_DimAligned&gt;(*data)) return;

    Vector p0 = toVector(data-&gt;getDef1Point());
    Vector p1 = toVector(data-&gt;getDef2Point());
    Vector p2 = toVector(data-&gt;getTextPoint());
    hConstraint hc = Constraint::Constrain(
        Constraint::Type::PT_PT_DISTANCE,
        createOrGetPoint(p0),
        createOrGetPoint(p1),
        Entity::NO_ENTITY
    );

    Constraint *c = SK.GetConstraint(hc);
    if(data-&gt;hasActualMeasurement()) {
        c-&gt;valA = data-&gt;getActualMeasurement();
    } else {
        c-&gt;ModifyToSatisfy();
    }
    c-&gt;disp.offset = p2.Minus(p0.Plus(p1).ScaledBy(0.5));
}

</t>
<t tx="leo.20191228122645.92">void addDimLinear(const DRW_DimLinear *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_DimLinear&gt;(*data)) return;

    Vector p0 = toVector(data-&gt;getDef1Point(), /*transform=*/false);
    Vector p1 = toVector(data-&gt;getDef2Point(), /*transform=*/false);
    Vector p2 = toVector(data-&gt;getTextPoint(), /*transform=*/false);

    double angle = data-&gt;getAngle() * PI / 180.0;
    Vector dir = Vector::From(cos(angle), sin(angle), 0.0);
    Vector p3 = p1.Minus(p1.ClosestPointOnLine(p2, dir)).Plus(p1);
    if(p1.Minus(p3).Magnitude() &lt; LENGTH_EPS) {
        p3 = p0.Minus(p0.ClosestPointOnLine(p2, dir)).Plus(p1);
    }

    Vector p4 = p0.ClosestPointOnLine(p1, p3.Minus(p1)).Plus(p0).ScaledBy(0.5);

    p0 = blockTransform(p0);
    p1 = blockTransform(p1);
    p2 = blockTransform(p2);
    p3 = blockTransform(p3);
    p4 = blockTransform(p4);

    hConstraint hc = Constraint::Constrain(
        Constraint::Type::PT_LINE_DISTANCE,
        createOrGetPoint(p0),
        Entity::NO_ENTITY,
        createLine(p1, p3, invisibleStyle())
    );

    Constraint *c = SK.GetConstraint(hc);
    if(data-&gt;hasActualMeasurement()) {
        c-&gt;valA = data-&gt;getActualMeasurement();
    } else {
        c-&gt;ModifyToSatisfy();
    }
    c-&gt;disp.offset = p2.Minus(p4);
}

</t>
<t tx="leo.20191228122645.93">void addDimAngular(const DRW_DimAngular *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_DimAngular&gt;(*data)) return;

    Vector l0p0 = toVector(data-&gt;getFirstLine1());
    Vector l0p1 = toVector(data-&gt;getFirstLine2());
    Vector l1p0 = toVector(data-&gt;getSecondLine1());
    Vector l1p1 = toVector(data-&gt;getSecondLine2());

    hConstraint hc = Constraint::Constrain(
        Constraint::Type::ANGLE,
        Entity::NO_ENTITY,
        Entity::NO_ENTITY,
        createLine(l0p0, l0p1, invisibleStyle()),
        createLine(l1p1, l1p0, invisibleStyle()),
        /*other=*/false,
        /*other2=*/false
    );

    Constraint *c = SK.GetConstraint(hc);
    c-&gt;ModifyToSatisfy();
    if(data-&gt;hasActualMeasurement()) {
        double actual = data-&gt;getActualMeasurement() / PI * 180.0;
        if(fabs(180.0 - actual - c-&gt;valA) &lt; fabs(actual - c-&gt;valA)) {
            c-&gt;other = true;
        }
        c-&gt;valA = actual;
    }

    bool skew = false;
    Vector pi = Vector::AtIntersectionOfLines(l0p0, l0p1, l1p0, l1p1, &amp;skew);
    if(!skew) {
        c-&gt;disp.offset = toVector(data-&gt;getTextPoint()).Minus(pi);
    }
}

hConstraint createDiametric(Vector cp, double r, Vector tp, double actual,
</t>
<t tx="leo.20191228122645.94">                            bool asRadius = false) {
    hEntity he = createCircle(cp, r, invisibleStyle());

    hConstraint hc = Constraint::Constrain(
        Constraint::Type::DIAMETER,
        Entity::NO_ENTITY,
        Entity::NO_ENTITY,
        he
    );

    Constraint *c = SK.GetConstraint(hc);
    if(actual &gt; 0.0) {
        c-&gt;valA = asRadius ? actual * 2.0 : actual;
    } else {
        c-&gt;ModifyToSatisfy();
    }
    c-&gt;disp.offset = tp.Minus(cp);
    if(asRadius) c-&gt;other = true;
    return hc;
}

</t>
<t tx="leo.20191228122645.95">void addDimRadial(const DRW_DimRadial *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_DimRadial&gt;(*data)) return;

    Vector cp = toVector(data-&gt;getCenterPoint());
    Vector dp = toVector(data-&gt;getDiameterPoint());
    Vector tp = toVector(data-&gt;getTextPoint());
    double actual = -1.0;
    if(data-&gt;hasActualMeasurement()) {
        actual = data-&gt;getActualMeasurement();
    }

    createDiametric(cp, cp.Minus(dp).Magnitude(), tp, actual, /*asRadius=*/true);
}

</t>
<t tx="leo.20191228122645.96">void addDimDiametric(const DRW_DimDiametric *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_DimRadial&gt;(*data)) return;

    Vector dp1 = toVector(data-&gt;getDiameter1Point());
    Vector dp2 = toVector(data-&gt;getDiameter2Point());

    Vector cp = dp1.Plus(dp2).ScaledBy(0.5);
    Vector tp = toVector(data-&gt;getTextPoint());
    double actual = -1.0;
    if(data-&gt;hasActualMeasurement()) {
        actual = data-&gt;getActualMeasurement();
    }

    createDiametric(cp, cp.Minus(dp1).Magnitude(), tp, actual, /*asRadius=*/false);
}

</t>
<t tx="leo.20191228122645.97">void addDimAngular3P(const DRW_DimAngular3p *data) override {
    if(data-&gt;space != DRW::ModelSpace) return;
    if(addPendingBlockEntity&lt;DRW_DimAngular3p&gt;(*data)) return;

    DRW_DimAngular dim = *static_cast&lt;const DRW_Dimension *&gt;(data);
    dim.setFirstLine1(data-&gt;getVertexPoint());
    dim.setFirstLine2(data-&gt;getFirstLine());
    dim.setSecondLine1(data-&gt;getVertexPoint());
    dim.setSecondLine2(data-&gt;getSecondLine());
    addDimAngular(&amp;dim);
}
</t>
<t tx="leo.20191228122645.98">class DxfCheck3D : public DRW_Interface {
public:
    bool is3d;

    @others
};

</t>
<t tx="leo.20191228122645.99">void addEntity(DRW_Entity *e) {
    switch(e-&gt;eType) {
        case DRW::POINT:
            addPoint(*static_cast&lt;DRW_Point *&gt;(e));
            break;
        case DRW::LINE:
            addLine(*static_cast&lt;DRW_Line *&gt;(e));
            break;
        case DRW::ARC:
            addArc(*static_cast&lt;DRW_Arc *&gt;(e));
            break;
        case DRW::CIRCLE:
            addCircle(*static_cast&lt;DRW_Circle *&gt;(e));
            break;
        case DRW::POLYLINE:
            addPolyline(*static_cast&lt;DRW_Polyline *&gt;(e));
            break;
        case DRW::LWPOLYLINE:
            addLWPolyline(*static_cast&lt;DRW_LWPolyline *&gt;(e));
            break;
        case DRW::SPLINE:
            addSpline(static_cast&lt;DRW_Spline *&gt;(e));
            break;
        case DRW::INSERT:
            addInsert(*static_cast&lt;DRW_Insert *&gt;(e));
            break;
        case DRW::TEXT:
            addText(*static_cast&lt;DRW_Text *&gt;(e));
            break;
        case DRW::MTEXT:
            addMText(*static_cast&lt;DRW_MText *&gt;(e));
            break;
        case DRW::DIMALIGNED:
            addDimAlign(static_cast&lt;DRW_DimAligned *&gt;(e));
            break;
        case DRW::DIMLINEAR:
            addDimLinear(static_cast&lt;DRW_DimLinear *&gt;(e));
            break;
        case DRW::DIMRADIAL:
            addDimRadial(static_cast&lt;DRW_DimRadial *&gt;(e));
            break;
        case DRW::DIMDIAMETRIC:
            addDimDiametric(static_cast&lt;DRW_DimDiametric *&gt;(e));
            break;
        case DRW::DIMANGULAR:
            addDimAngular(static_cast&lt;DRW_DimAngular *&gt;(e));
            break;
        default:
            break;
    }
}

</t>
<t tx="leo.20191228122646.1">@path ./src/
//-----------------------------------------------------------------------------
// User-initiated (not parametric) operations to modify our sketch, by
// changing the requests, like to round a corner or split curves where they
// intersect.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

//-----------------------------------------------------------------------------
// Replace constraints on oldpt with the same constraints on newpt.
// Useful when splitting, tangent arcing, or removing bezier points.
//-----------------------------------------------------------------------------
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122646.10">void GraphicsWindow::SplitLinesOrCurves() {
    if(!LockedInWorkplane()) {
        Error(_("Must be sketching in workplane to split."));
        return;
    }

    GroupSelection();
    int n = gs.lineSegments + gs.circlesOrArcs + gs.cubics + gs.periodicCubics;
    if(!((n == 2 &amp;&amp; gs.points == 0) || (n == 1 &amp;&amp; gs.points == 1))) {
        Error(_("Select two entities that intersect each other "
                "(e.g. two lines/circles/arcs or a line/circle/arc and a point)."));
        return;
    }

    bool splitAtPoint = (gs.points == 1);
    hEntity ha = gs.entity[0],
            hb = splitAtPoint ? gs.point[0] : gs.entity[1];

    Entity *ea = SK.GetEntity(ha),
           *eb = SK.GetEntity(hb);
    SPointList inters = {};
    SBezierList sbla = {},
                sblb = {};
    Vector pi = Vector::From(0, 0, 0);

    SK.constraint.ClearTags();

    // First, decide the point where we're going to make the split.
    bool foundInters = false;
    if(splitAtPoint) {
        // One of the entities is a point, and this point must be on the other entity.
        // Verify that a corresponding point-coincident constraint exists for the point/entity.
        Vector p0, p1;
        if(ea-&gt;type == Entity::Type::LINE_SEGMENT) {
            p0 = ea-&gt;EndpointStart();
            p1 = ea-&gt;EndpointFinish();
        }

        for(Constraint &amp;c : SK.constraint) {
            if(c.ptA.request() == hb.request() &amp;&amp;
               c.entityA.request() == ha.request()) {
                pi = SK.GetEntity(c.ptA)-&gt;PointGetNum();

                if(ea-&gt;type == Entity::Type::LINE_SEGMENT &amp;&amp; !pi.OnLineSegment(p0, p1)) {
                    // The point isn't between line endpoints, so there isn't an actual
                    // intersection.
                    continue;
                }

                c.tag = 1;
                foundInters = true;
                break;
            }
        }
    } else {
        // Compute the possibly-rational Bezier curves for each of these non-point entities...
        ea-&gt;GenerateBezierCurves(&amp;sbla);
        eb-&gt;GenerateBezierCurves(&amp;sblb);
        // ... and then compute the points where they intersect, based on those curves.
        sbla.AllIntersectionsWith(&amp;sblb, &amp;inters);

        // If there's multiple points, then take the one closest to the mouse pointer.
        if(!inters.l.IsEmpty()) {
            double dmin = VERY_POSITIVE;
            SPoint *sp;
            for(sp = inters.l.First(); sp; sp = inters.l.NextAfter(sp)) {
                double d = ProjectPoint(sp-&gt;p).DistanceTo(currentMousePosition);
                if(d &lt; dmin) {
                    dmin = d;
                    pi = sp-&gt;p;
                }
            }
        }

        foundInters = true;
    }

    // Then, actually split the entities.
    if(foundInters) {
        SS.UndoRemember();

        // Remove any constraints we're going to replace.
        SK.constraint.RemoveTagged();

        hEntity hia = SplitEntity(ha, pi),
                hib = {};
        // SplitEntity adds the coincident constraints to join the split halves
        // of each original entity; and then we add the constraint to join
        // the two entities together at the split point.
        if(splitAtPoint) {
            // Remove datum point, as it has now been superseded by the split point.
            SK.request.ClearTags();
            for(Request &amp;r : SK.request) {
                if(r.h == hb.request()) {
                    if(r.type == Request::Type::DATUM_POINT) {
                        // Delete datum point.
                        r.tag = 1;
                        FixConstraintsForRequestBeingDeleted(r.h);
                    } else {
                        // Add constraint if not datum point, but endpoint of line/arc etc.
                        Constraint::ConstrainCoincident(hia, hb);
                    }
                    break;
                }
            }
            SK.request.RemoveTagged();
        } else {
            // Split second non-point entity and add constraint.
            hib = SplitEntity(hb, pi);
            if(hia.v &amp;&amp; hib.v) {
                Constraint::ConstrainCoincident(hia, hib);
            }
        }
    } else {
        Error(_("Can't split; no intersection found."));
        return;
    }

    // All done, clean up and regenerate.
    inters.Clear();
    sbla.Clear();
    sblb.Clear();
    ClearSelection();
}
</t>
<t tx="leo.20191228122646.100">void PolylineBuilder::Clear() {
    for(Edge *e : edges) {
        delete e;
    }
    edges.clear();

    for(auto &amp;v : vertices) {
        delete v.second;
    }
    vertices.clear();
}

PolylineBuilder::Vertex *PolylineBuilder::AddVertex(const Vector &amp;pos) {
    auto it = vertices.find(pos);
    if(it != vertices.end()) {
        return it-&gt;second;
    }

    Vertex *result = new Vertex;
    result-&gt;pos = pos;
    vertices.emplace(pos, result);

    return result;
}

PolylineBuilder::Edge *PolylineBuilder::AddEdge(const Vector &amp;p0, const Vector &amp;p1,
                                                uint32_t kind, uintptr_t data) {
    Vertex *v0 = AddVertex(p0);
    Vertex *v1 = AddVertex(p1);
    if(v0 == v1) return NULL;

    auto it = edgeMap.find(std::make_pair(v0, v1));
    if(it != edgeMap.end()) {
        return it-&gt;second;
    }

    PolylineBuilder::Edge *edge = new PolylineBuilder::Edge {};
    edge-&gt;a = v0;
    edge-&gt;b = v1;
    edge-&gt;kind = kind;
    edge-&gt;tag = 0;
    edge-&gt;data = data;
    edges.push_back(edge);
    edgeMap.emplace(std::make_pair(v0, v1), edge);

    v0-&gt;edges.push_back(edge);
    v1-&gt;edges.push_back(edge);

    return edge;
}

</t>
<t tx="leo.20191228122646.101">void PolylineBuilder::Generate(
    std::function&lt;void(Vertex *start, Vertex *next, Edge *edge)&gt; const &amp;startFunc,
    std::function&lt;void(Vertex *next, Edge *edge)&gt; const &amp;nextFunc,
    std::function&lt;void(Edge *alone)&gt; const &amp;aloneFunc, std::function&lt;void()&gt; const &amp;endFunc) {
    bool found;
    bool loop = false;
    do {
        found = false;
        for(PolylineBuilder::Edge *e : edges) {
            if(e-&gt;tag != 0) continue;

            Vertex *start;
            Vertex *next;
            if(!e-&gt;GetStartAndNext(&amp;start, &amp;next, loop)) continue;

            Vector startPos = start-&gt;pos;
            Vector nextPos = next-&gt;pos;
            found = true;
            e-&gt;tag = 1;

            startFunc(start, next, e);

            Edge *nextEdge;
            if(next-&gt;GetNext(e-&gt;kind, &amp;next, &amp;nextEdge)) {
                Vector plane = nextPos.Minus(startPos).Cross(next-&gt;pos.Minus(startPos));
                double dist = plane.Dot(startPos);
                nextFunc(next, nextEdge);
                while(next-&gt;GetNext(e-&gt;kind, plane, dist, &amp;next, &amp;nextEdge)) {
                    nextFunc(next, nextEdge);
                }
            }

            endFunc();
        }

        if(!found &amp;&amp; !loop) {
            loop  = true;
            found = true;
        }
    } while(found);

    for(PolylineBuilder::Edge *e : edges) {
        if(e-&gt;tag != 0) continue;
        aloneFunc(e);
    }
}

</t>
<t tx="leo.20191228122646.102">void PolylineBuilder::MakeFromEdges(const SEdgeList &amp;sel) {
    for(const SEdge &amp;se : sel.l) {
        AddEdge(se.a, se.b, (uint32_t)se.auxA, reinterpret_cast&lt;uintptr_t&gt;(&amp;se));
    }
}

</t>
<t tx="leo.20191228122646.103">void PolylineBuilder::MakeFromOutlines(const SOutlineList &amp;ol) {
    for(const SOutline &amp;so : ol.l) {
        // Use outline tag as kind, so that emphasized and contour outlines
        // would not be composed together.
        AddEdge(so.a, so.b, (uint32_t)so.tag, reinterpret_cast&lt;uintptr_t&gt;(&amp;so));
    }
}

</t>
<t tx="leo.20191228122646.104">void PolylineBuilder::GenerateEdges(SEdgeList *sel) {
    Vector prev;
    @others
}

</t>
<t tx="leo.20191228122646.105">auto startFunc = [&amp;](Vertex *start, Vertex *next, Edge *e) {
    sel-&gt;AddEdge(start-&gt;pos, next-&gt;pos, e-&gt;kind);
    prev = next-&gt;pos;
};

</t>
<t tx="leo.20191228122646.106">auto nextFunc = [&amp;](Vertex *next, Edge *e) {
    sel-&gt;AddEdge(prev, next-&gt;pos, e-&gt;kind);
    prev = next-&gt;pos;
};

</t>
<t tx="leo.20191228122646.107">auto aloneFunc = [&amp;](Edge *e) {
    sel-&gt;AddEdge(e-&gt;a-&gt;pos, e-&gt;b-&gt;pos, e-&gt;kind);
};

Generate(startFunc, nextFunc, aloneFunc);
</t>
<t tx="leo.20191228122646.108">void PolylineBuilder::GenerateOutlines(SOutlineList *sol) {
    Vector prev;
    @others
}
</t>
<t tx="leo.20191228122646.109">auto startFunc = [&amp;](Vertex *start, Vertex *next, Edge *e) {
    SOutline *so = e-&gt;outline;
    sol-&gt;AddEdge(start-&gt;pos, next-&gt;pos, so-&gt;nl, so-&gt;nr, so-&gt;tag);
    prev = next-&gt;pos;
};

</t>
<t tx="leo.20191228122646.11">@path ./src/
//-----------------------------------------------------------------------------
// Anything relating to mouse, keyboard, or 6-DOF mouse input.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122646.110">auto nextFunc = [&amp;](Vertex *next, Edge *e) {
    SOutline *so = e-&gt;outline;
    sol-&gt;AddEdge(prev, next-&gt;pos, so-&gt;nl, so-&gt;nr, so-&gt;tag);
    prev = next-&gt;pos;
};

</t>
<t tx="leo.20191228122646.111">auto aloneFunc = [&amp;](Edge *e) {
    SOutline *so = e-&gt;outline;
    sol-&gt;AddEdge(so-&gt;a, so-&gt;b, so-&gt;nl, so-&gt;nr, so-&gt;tag);
};

Generate(startFunc, nextFunc, aloneFunc);
</t>
<t tx="leo.20191228122646.112">@path ./src/
//-----------------------------------------------------------------------------
// Implementation of our Request class; a request is a user-created thing
// that will generate an entity (line, curve) when the sketch is generated,
// in the same way that other entities are generated automatically, like
// by an extrude or a step and repeat.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

const hRequest Request::HREQUEST_REFERENCE_XY = { 1 };
const hRequest Request::HREQUEST_REFERENCE_YZ = { 2 };
const hRequest Request::HREQUEST_REFERENCE_ZX = { 3 };

struct EntReqMapping {
    Request::Type  reqType;
    Entity::Type   entType;
    int            points;
    bool           useExtraPoints;
    bool           hasNormal;
    bool           hasDistance;
};
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122646.113">static const EntReqMapping EntReqMap[] = {
// request type                   entity type                 pts   xtra?   norml   dist
{ Request::Type::WORKPLANE,       Entity::Type::WORKPLANE,      1,  false,  true,   false },
{ Request::Type::DATUM_POINT,     (Entity::Type)0,              1,  false,  false,  false },
{ Request::Type::LINE_SEGMENT,    Entity::Type::LINE_SEGMENT,   2,  false,  false,  false },
{ Request::Type::CUBIC,           Entity::Type::CUBIC,          4,  true,   false,  false },
{ Request::Type::CUBIC_PERIODIC,  Entity::Type::CUBIC_PERIODIC, 3,  true,   false,  false },
{ Request::Type::CIRCLE,          Entity::Type::CIRCLE,         1,  false,  true,   true  },
{ Request::Type::ARC_OF_CIRCLE,   Entity::Type::ARC_OF_CIRCLE,  3,  false,  true,   false },
{ Request::Type::TTF_TEXT,        Entity::Type::TTF_TEXT,       4,  false,  true,   false },
{ Request::Type::IMAGE,           Entity::Type::IMAGE,          4,  false,  true,   false },
};

</t>
<t tx="leo.20191228122646.114">static void CopyEntityInfo(const EntReqMapping *te, int extraPoints,
                           Entity::Type *ent, Request::Type *req,
                           int *pts, bool *hasNormal, bool *hasDistance)
{
    int points = te-&gt;points;
    if(te-&gt;useExtraPoints) points += extraPoints;

    if(ent)         *ent         = te-&gt;entType;
    if(req)         *req         = te-&gt;reqType;
    if(pts)         *pts         = points;
    if(hasNormal)   *hasNormal   = te-&gt;hasNormal;
    if(hasDistance) *hasDistance = te-&gt;hasDistance;
}

</t>
<t tx="leo.20191228122646.115">bool EntReqTable::GetRequestInfo(Request::Type req, int extraPoints,
                                 Entity::Type *ent, int *pts, bool *hasNormal, bool *hasDistance)
{
    for(const EntReqMapping &amp;te : EntReqMap) {
        if(req == te.reqType) {
            CopyEntityInfo(&amp;te, extraPoints, ent, NULL, pts, hasNormal, hasDistance);
            return true;
        }
    }
    return false;
}

</t>
<t tx="leo.20191228122646.116">bool EntReqTable::GetEntityInfo(Entity::Type ent, int extraPoints,
                                Request::Type *req, int *pts, bool *hasNormal, bool *hasDistance)
{
    for(const EntReqMapping &amp;te : EntReqMap) {
        if(ent == te.entType) {
            CopyEntityInfo(&amp;te, extraPoints, NULL, req, pts, hasNormal, hasDistance);
            return true;
        }
    }
    return false;
}

Request::Type EntReqTable::GetRequestForEntity(Entity::Type ent) {
    Request::Type req;
    ssassert(GetEntityInfo(ent, 0, &amp;req, NULL, NULL, NULL),
             "No entity for request");
    return req;
}

</t>
<t tx="leo.20191228122646.117">void Request::Generate(IdList&lt;Entity,hEntity&gt; *entity,
                       IdList&lt;Param,hParam&gt; *param)
{
    int points = 0;
    Entity::Type et = (Entity::Type)0;
    bool hasNormal = false;
    bool hasDistance = false;
    int i;

    // Request-specific generation.
    switch(type) {
        case Type::TTF_TEXT: {
            double actualAspectRatio = SS.fonts.AspectRatio(font, str);
            if(EXACT(actualAspectRatio != 0.0)) {
                // We could load the font, so use the actual value.
                aspectRatio = actualAspectRatio;
            }
            if(EXACT(aspectRatio == 0.0)) {
                // We couldn't load the font and we don't have anything saved,
                // so just use 1:1, which is valid for the missing font symbol anyhow.
                aspectRatio = 1.0;
            }
            break;
        }

        case Type::IMAGE: {
            auto image = SS.images.find(file);
            if(image != SS.images.end()) {
                std::shared_ptr&lt;Pixmap&gt; pixmap = (*image).second;
                if(pixmap != NULL) {
                    aspectRatio = (double)pixmap-&gt;width / (double)pixmap-&gt;height;
                }
            }
            if(EXACT(aspectRatio == 0.0)) {
                aspectRatio = 1.0;
            }
            break;
        }

        default: // most requests don't do anything else
            break;
    }

    Entity e = {};
    EntReqTable::GetRequestInfo(type, extraPoints, &amp;et, &amp;points, &amp;hasNormal, &amp;hasDistance);

    // Generate the entity that's specific to this request.
    e.type = et;
    e.extraPoints = extraPoints;
    e.group = group;
    e.style = style;
    e.workplane = workplane;
    e.construction = construction;
    e.str = str;
    e.font = font;
    e.file = file;
    e.aspectRatio = aspectRatio;
    e.h = h.entity(0);

    // And generate entities for the points
    for(i = 0; i &lt; points; i++) {
        Entity p = {};
        p.workplane = workplane;
        // points start from entity 1, except for datum point case
        p.h = h.entity(i+((et != (Entity::Type)0) ? 1 : 0));
        p.group = group;
        p.style = style;
        p.construction = e.construction;
        if(workplane == Entity::FREE_IN_3D) {
            p.type = Entity::Type::POINT_IN_3D;
            // params for x y z
            p.param[0] = AddParam(param, h.param(16 + 3*i + 0));
            p.param[1] = AddParam(param, h.param(16 + 3*i + 1));
            p.param[2] = AddParam(param, h.param(16 + 3*i + 2));
        } else {
            p.type = Entity::Type::POINT_IN_2D;
            // params for u v
            p.param[0] = AddParam(param, h.param(16 + 3*i + 0));
            p.param[1] = AddParam(param, h.param(16 + 3*i + 1));
        }
        entity-&gt;Add(&amp;p);
        e.point[i] = p.h;
    }
    if(hasNormal) {
        Entity n = {};
        n.workplane = workplane;
        n.h = h.entity(32);
        n.group = group;
        n.style = style;
        n.construction = e.construction;
        if(workplane == Entity::FREE_IN_3D) {
            n.type = Entity::Type::NORMAL_IN_3D;
            n.param[0] = AddParam(param, h.param(32+0));
            n.param[1] = AddParam(param, h.param(32+1));
            n.param[2] = AddParam(param, h.param(32+2));
            n.param[3] = AddParam(param, h.param(32+3));
        } else {
            n.type = Entity::Type::NORMAL_IN_2D;
            // and this is just a copy of the workplane quaternion,
            // so no params required
        }
        ssassert(points &gt;= 1, "Positioning a normal requires a point");
        // The point determines where the normal gets displayed on-screen;
        // it's entirely cosmetic.
        n.point[0] = e.point[0];
        entity-&gt;Add(&amp;n);
        e.normal = n.h;
    }
    if(hasDistance) {
        Entity d = {};
        d.workplane = workplane;
        d.h = h.entity(64);
        d.group = group;
        d.style = style;
        d.type = Entity::Type::DISTANCE;
        d.param[0] = AddParam(param, h.param(64));
        entity-&gt;Add(&amp;d);
        e.distance = d.h;
    }

    if(et != (Entity::Type)0) entity-&gt;Add(&amp;e);
}

std::string Request::DescriptionString() const {
    const char *s = "";
    if(h == Request::HREQUEST_REFERENCE_XY) {
        s = "#XY";
    } else if(h == Request::HREQUEST_REFERENCE_YZ) {
        s = "#YZ";
    } else if(h == Request::HREQUEST_REFERENCE_ZX) {
        s = "#ZX";
    } else {
        switch(type) {
            case Type::WORKPLANE:       s = "workplane";      break;
            case Type::DATUM_POINT:     s = "datum-point";    break;
            case Type::LINE_SEGMENT:    s = "line-segment";   break;
            case Type::CUBIC:           s = "cubic-bezier";   break;
            case Type::CUBIC_PERIODIC:  s = "periodic-cubic"; break;
            case Type::CIRCLE:          s = "circle";         break;
            case Type::ARC_OF_CIRCLE:   s = "arc-of-circle";  break;
            case Type::TTF_TEXT:        s = "ttf-text";       break;
            case Type::IMAGE:           s = "image";          break;
        }
    }
    ssassert(s != NULL, "Unexpected request type");
    return ssprintf("r%03x-%s", h.v, s);
}

</t>
<t tx="leo.20191228122646.118">int Request::IndexOfPoint(hEntity he) const {
    if(type == Type::DATUM_POINT) {
        return (he == h.entity(0)) ? 0 : -1;
    }
    for(int i = 0; i &lt; MAX_POINTS_IN_ENTITY; i++) {
        if(he == h.entity(i + 1)) {
            return i;
        }
    }
    return -1;
}

hParam Request::AddParam(IdList&lt;Param,hParam&gt; *param, hParam hp) {
    Param pa = {};
    pa.h = hp;
    param-&gt;Add(&amp;pa);
    return hp;
}

</t>
<t tx="leo.20191228122646.119">@path ./src/
//-----------------------------------------------------------------------------
// Discovery and loading of our resources (icons, fonts, templates, etc).
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include &lt;zlib.h&gt;
#include &lt;png.h&gt;
#include &lt;regex&gt;
#include "solvespace.h"

namespace SolveSpace {

//-----------------------------------------------------------------------------
// Resource loading functions
//-----------------------------------------------------------------------------

std::string LoadString(const std::string &amp;name) {
    size_t size;
    const void *data = Platform::LoadResource(name, &amp;size);
    std::string result(static_cast&lt;const char *&gt;(data), size);

    // When editing resources under Windows, Windows newlines may sneak in.
    // Any files with them won't be merged, but ignoring them during development
    // helps external contributors.
    result.erase(std::remove(result.begin(), result.end(), '\r'),
                 result.end());

    return result;
}

std::string LoadStringFromGzip(const std::string &amp;name) {
    size_t deflatedSize;
    const void *data = Platform::LoadResource(name, &amp;deflatedSize);

    z_stream stream;
    stream.zalloc = Z_NULL;
    stream.zfree = Z_NULL;
    stream.opaque = Z_NULL;
    const int windowBits = /*maximum window*/ 15 + /*decode gzip header*/16;
    ssassert(inflateInit2(&amp;stream, windowBits) == Z_OK, "Cannot start inflation");

    // Extract length mod 2**32 from the gzip trailer.
    std::string result;
    ssassert(deflatedSize &gt;= 4, "Resource too small to have gzip trailer");

    // *(uint32_t *) may perform an unaligned access, so do a memcpy.
    uint32_t inflatedSize;
    memcpy(&amp;inflatedSize, (uint8_t *)((uintptr_t)data + deflatedSize - 4), sizeof(uint32_t));
    result.resize(inflatedSize);

    stream.next_in = (Bytef *)data;
    stream.avail_in = (uInt)deflatedSize;
    stream.next_out = (Bytef *)&amp;result[0];
    stream.avail_out = (uInt)result.length();
    ssassert(inflate(&amp;stream, Z_NO_FLUSH) == Z_STREAM_END, "Cannot inflate resource");
    ssassert(stream.avail_out == 0, "Inflated resource larger than what trailer indicates");

    inflateEnd(&amp;stream);

    return result;
}

std::shared_ptr&lt;Pixmap&gt; LoadPng(const std::string &amp;name) {
    size_t size;
    const void *data = Platform::LoadResource(name, &amp;size);

    std::shared_ptr&lt;Pixmap&gt; pixmap = Pixmap::FromPng(static_cast&lt;const uint8_t *&gt;(data), size);
    ssassert(pixmap != nullptr, "Cannot load pixmap");

    return pixmap;
}

//-----------------------------------------------------------------------------
// Pixmap manipulation
//-----------------------------------------------------------------------------

size_t Pixmap::GetBytesPerPixel() const {
    switch(format) {
        case Format::RGBA: return 4;
        case Format::BGRA: return 4;
        case Format::RGB:  return 3;
        case Format::BGR:  return 3;
        case Format::A:    return 1;
    }
    ssassert(false, "Unexpected pixmap format");
}

RgbaColor Pixmap::GetPixel(size_t x, size_t y) const {
    const uint8_t *pixel = &amp;data[y * stride + x * GetBytesPerPixel()];

    switch(format) {
        case Format::RGBA:
            return RgbaColor::From(pixel[0], pixel[1], pixel[2], pixel[3]);

        case Format::RGB:
            return RgbaColor::From(pixel[0], pixel[1], pixel[2],      255);

        case Format::BGRA:
            return RgbaColor::From(pixel[2], pixel[1], pixel[0], pixel[3]);

        case Format::BGR:
            return RgbaColor::From(pixel[2], pixel[1], pixel[0],      255);

        case Format::A:
            return RgbaColor::From(     255,      255,      255, pixel[0]);
    }
    ssassert(false, "Unexpected resource format");
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122646.12">void GraphicsWindow::UpdateDraggedPoint(hEntity hp, double mx, double my) {
    Entity *p = SK.GetEntity(hp);
    Vector pos = p-&gt;PointGetNum();
    UpdateDraggedNum(&amp;pos, mx, my);
    p-&gt;PointForceTo(pos);
}

</t>
<t tx="leo.20191228122646.120">void Pixmap::SetPixel(size_t x, size_t y, RgbaColor color) {
    uint8_t *pixel = &amp;data[y * stride + x * GetBytesPerPixel()];

    switch(format) {
        case Format::RGBA:
            pixel[0] = color.red;
            pixel[1] = color.green;
            pixel[2] = color.blue;
            pixel[3] = color.alpha;
            break;

        case Format::RGB:
            pixel[0] = color.red;
            pixel[1] = color.green;
            pixel[2] = color.blue;
            break;

        case Format::BGRA:
            pixel[0] = color.blue;
            pixel[1] = color.green;
            pixel[2] = color.red;
            pixel[3] = color.alpha;
            break;

        case Format::BGR:
            pixel[0] = color.blue;
            pixel[1] = color.green;
            pixel[2] = color.red;
            break;

        case Format::A:
            pixel[0] = color.alpha;
            break;
    }
}

</t>
<t tx="leo.20191228122646.121">void Pixmap::ConvertTo(Format newFormat) {
    switch(format) {
        case Format::RGBA:
            ssassert(newFormat == Format::BGRA, "Unexpected target format");
            break;

        case Format::BGRA:
            ssassert(newFormat == Format::RGBA, "Unexpected target format");
            break;

        case Format::RGB:
            ssassert(newFormat == Format::BGR, "Unexpected target format");
            break;

        case Format::BGR:
            ssassert(newFormat == Format::RGB, "Unexpected target format");
            break;

        case Format::A:
            ssassert(false, "Unexpected target format");
    }

    size_t bpp = GetBytesPerPixel();
    for(size_t j = 0; j != height; j++) {
        uint8_t *row = &amp;data[j * stride];
        for(size_t i = 0; i != width * bpp; i += bpp) {
            // This handles both RGB&lt;&gt;BGR and RGBA&lt;&gt;BGRA.
            std::swap(row[i], row[i + 2]);
        }
    }

    format = newFormat;
}

</t>
<t tx="leo.20191228122646.122">static std::shared_ptr&lt;Pixmap&gt; ReadPngIntoPixmap(png_struct *png_ptr, png_info *info_ptr,
                                                 bool flip) {
    png_read_png(png_ptr, info_ptr, PNG_TRANSFORM_EXPAND | PNG_TRANSFORM_GRAY_TO_RGB, NULL);

    std::shared_ptr&lt;Pixmap&gt; pixmap = std::make_shared&lt;Pixmap&gt;();
    pixmap-&gt;width    = png_get_image_width(png_ptr, info_ptr);
    pixmap-&gt;height   = png_get_image_height(png_ptr, info_ptr);
    if((png_get_color_type(png_ptr, info_ptr) &amp; PNG_COLOR_MASK_ALPHA) != 0) {
        pixmap-&gt;format = Pixmap::Format::RGBA;
    } else {
        pixmap-&gt;format = Pixmap::Format::RGB;
    }

    size_t stride = pixmap-&gt;width * pixmap-&gt;GetBytesPerPixel();
    if(stride % 4 != 0) stride += 4 - stride % 4;
    pixmap-&gt;stride = stride;

    pixmap-&gt;data = std::vector&lt;uint8_t&gt;(pixmap-&gt;stride * pixmap-&gt;height);
    uint8_t **rows = png_get_rows(png_ptr, info_ptr);
    for(size_t y = 0; y &lt; pixmap-&gt;height; y++) {
        uint8_t *srcRow = flip ? rows[pixmap-&gt;height - y - 1] : rows[y];
        memcpy(&amp;pixmap-&gt;data[pixmap-&gt;stride * y], srcRow,
               pixmap-&gt;width * pixmap-&gt;GetBytesPerPixel());
    }

    png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, NULL);
    return pixmap;
}

std::shared_ptr&lt;Pixmap&gt; Pixmap::FromPng(const uint8_t *data, size_t size, bool flip) {
    struct Slice { const uint8_t *data; size_t size; };
    Slice dataSlice = { data, size };
    png_struct *png_ptr = NULL;
    png_info *info_ptr = NULL;

    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if(!png_ptr) goto exit;
    info_ptr = png_create_info_struct(png_ptr);
    if(!info_ptr) goto exit;

    if(setjmp(png_jmpbuf(png_ptr))) goto exit;

    png_set_read_fn(png_ptr, &amp;dataSlice,
        [](png_struct *png_ptr, uint8_t *data, size_t size) {
            Slice *dataSlice = (Slice *)png_get_io_ptr(png_ptr);
            if(size &lt;= dataSlice-&gt;size) {
                memcpy(data, dataSlice-&gt;data, size);
                dataSlice-&gt;data += size;
                dataSlice-&gt;size -= size;
            } else {
                png_error(png_ptr, "EOF");
            }
        });

    return ReadPngIntoPixmap(png_ptr, info_ptr, flip);

exit:
    png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, NULL);
    return nullptr;
}

std::shared_ptr&lt;Pixmap&gt; Pixmap::ReadPng(FILE *f, bool flip) {
    png_struct *png_ptr = NULL;
    png_info *info_ptr = NULL;

    uint8_t header[8];
    if(fread(header, 1, sizeof(header), f) != sizeof(header)) goto exit;
    if(png_sig_cmp(header, 0, sizeof(header))) goto exit;

    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if(!png_ptr) goto exit;
    info_ptr = png_create_info_struct(png_ptr);
    if(!info_ptr) goto exit;

    if(setjmp(png_jmpbuf(png_ptr))) goto exit;

    png_init_io(png_ptr, f);
    png_set_sig_bytes(png_ptr, sizeof(header));

    return ReadPngIntoPixmap(png_ptr, info_ptr, flip);

exit:
    png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr, NULL);
    return nullptr;
}

std::shared_ptr&lt;Pixmap&gt; Pixmap::ReadPng(const Platform::Path &amp;filename, bool flip) {
    FILE *f = OpenFile(filename, "rb");
    if(!f) return NULL;
    std::shared_ptr&lt;Pixmap&gt; pixmap = ReadPng(f, flip);
    fclose(f);
    return pixmap;
}

</t>
<t tx="leo.20191228122646.123">bool Pixmap::WritePng(FILE *f, bool flip) {
    int colorType = 0;
    bool bgr = false;
    switch(format) {
        case Format::RGBA: colorType = PNG_COLOR_TYPE_RGBA; bgr = false; break;
        case Format::BGRA: colorType = PNG_COLOR_TYPE_RGBA; bgr = true;  break;
        case Format::RGB:  colorType = PNG_COLOR_TYPE_RGB;  bgr = false; break;
        case Format::BGR:  colorType = PNG_COLOR_TYPE_RGB;  bgr = true;  break;
        case Format::A:    colorType = PNG_COLOR_TYPE_GRAY; bgr = false; break;
    }

    std::vector&lt;uint8_t *&gt; rows;
    for(size_t y = 0; y &lt; height; y++) {
        if(flip) {
            rows.push_back(&amp;data[stride * (height - y - 1)]);
        } else {
            rows.push_back(&amp;data[stride * y]);
        }
    }

    png_struct *png_ptr = NULL;
    png_info *info_ptr = NULL;

    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if(!png_ptr) goto exit;
    info_ptr = png_create_info_struct(png_ptr);
    if(!info_ptr) goto exit;

    if(setjmp(png_jmpbuf(png_ptr))) goto exit;

    png_init_io(png_ptr, f);
    png_set_IHDR(png_ptr, info_ptr,
                 (png_uint_32)width, (png_uint_32)height, 8, colorType,
                 PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
    if(bgr) png_set_bgr(png_ptr);
    png_write_info(png_ptr, info_ptr);
    png_write_image(png_ptr, &amp;rows[0]);
    png_write_end(png_ptr, info_ptr);

    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
    return true;

exit:
    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);
    return false;
}

</t>
<t tx="leo.20191228122646.124">bool Pixmap::WritePng(const Platform::Path &amp;filename, bool flip) {
    FILE *f = OpenFile(filename, "wb");
    if(!f) return false;
    bool success = WritePng(f, flip);
    fclose(f);
    return success;
}

</t>
<t tx="leo.20191228122646.125">bool Pixmap::Equals(const Pixmap &amp;other) const {
    if(format != other.format || width != other.width || height != other.height) {
        return false;
    }

    size_t rowLength = width * GetBytesPerPixel();
    for(size_t y = 0; y &lt; height; y++) {
        if(memcmp(&amp;data[y * stride], &amp;other.data[y * other.stride], rowLength)) {
            return false;
        }
    }

    return true;
}

std::shared_ptr&lt;Pixmap&gt; Pixmap::Create(Format format, size_t width, size_t height) {
    std::shared_ptr&lt;Pixmap&gt; pixmap = std::make_shared&lt;Pixmap&gt;();
    pixmap-&gt;format = format;
    pixmap-&gt;width  = width;
    pixmap-&gt;height = height;
    // Align to fulfill OpenGL texture requirements.
    size_t stride = pixmap-&gt;width * pixmap-&gt;GetBytesPerPixel();
    if(stride % 4 != 0) stride += 4 - stride % 4;
    pixmap-&gt;stride = stride;
    pixmap-&gt;data   = std::vector&lt;uint8_t&gt;(pixmap-&gt;stride * pixmap-&gt;height);
    return pixmap;
}

std::shared_ptr&lt;Pixmap&gt; Pixmap::Copy() {
    std::shared_ptr&lt;Pixmap&gt; pixmap = std::make_shared&lt;Pixmap&gt;();
    pixmap-&gt;format = format;
    pixmap-&gt;width  = width;
    pixmap-&gt;height = height;
    pixmap-&gt;stride = stride;
    pixmap-&gt;data   = data;
    return pixmap;
}

//-----------------------------------------------------------------------------
// ASCII sequence parsing
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122646.126">class ASCIIReader {
public:
    std::string::const_iterator pos, end;

    @others
};

//-----------------------------------------------------------------------------
// Bitmap font manipulation
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122646.127">static ASCIIReader From(const std::string &amp;str) {
    return ASCIIReader({ str.cbegin(), str.cend() });
}

</t>
<t tx="leo.20191228122646.128">bool AtEnd() const {
    return pos == end;
}

</t>
<t tx="leo.20191228122646.129">bool SkipSpace() {
    bool skipped = false;
    while(!AtEnd()) {
        char c = *pos;
        if(!(c == ' ' || c == '\t' || c == '\n')) break;
        skipped = true;
        pos++;
    }
    return skipped;
}

</t>
<t tx="leo.20191228122646.13">void GraphicsWindow::UpdateDraggedNum(Vector *pos, double mx, double my) {
    *pos = pos-&gt;Plus(projRight.ScaledBy((mx - orig.mouse.x)/scale));
    *pos = pos-&gt;Plus(projUp.ScaledBy((my - orig.mouse.y)/scale));
}

</t>
<t tx="leo.20191228122646.130">char PeekChar() {
    ssassert(!AtEnd(), "Unexpected EOF");
    return *pos;
}

</t>
<t tx="leo.20191228122646.131">char ReadChar() {
    ssassert(!AtEnd(), "Unexpected EOF");
    return *pos++;
}

</t>
<t tx="leo.20191228122646.132">bool TryChar(char c) {
    if(AtEnd()) {
        return false;
    } else if(*pos == c) {
        pos++;
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="leo.20191228122646.133">void ExpectChar(char c) {
    if(!TryChar(c)) {
        dbp("Expecting character '%c'", c);
        ssassert(false, "Unexpected character");
    }
}

</t>
<t tx="leo.20191228122646.134">bool TryString(const std::string &amp;s) {
    if((size_t)(end - pos) &gt;= s.size() &amp;&amp; std::string(pos, pos + s.size()) == s) {
        pos += s.size();
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="leo.20191228122646.135">void ExpectString(const std::string &amp;s) {
    if(!TryString(s)) {
        dbp("Expecting string '%s'", s.c_str());
        ssassert(false, "Unexpected string");
    }
}

size_t CountUntilEol() const {
    return std::find(pos, end, '\n') - pos;
}

</t>
<t tx="leo.20191228122646.136">void SkipUntilEol() {
    pos = std::find(pos, end, '\n');
}

std::string ReadUntilEol() {
    auto eol = std::find(pos, end, '\n');
    std::string result(pos, eol);
    if(eol != end) {
        pos = eol + 1;
    } else {
        pos = end;
    }
    return result;
}

uint8_t Read4HexBits() {
    char c = ReadChar();
    if(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        return c - '0';
    } else if(c &gt;= 'a' &amp;&amp; c &lt;= 'f') {
        return 10 + (c - 'a');
    } else if(c &gt;= 'A' &amp;&amp; c &lt;= 'F') {
        return 10 + (c - 'A');
    } else ssassert(false, "Unexpected hex digit");
}

uint8_t Read8HexBits() {
    uint8_t h = Read4HexBits(),
            l = Read4HexBits();
    return (h &lt;&lt; 4) + l;
}

uint16_t Read16HexBits() {
    uint16_t h = Read8HexBits(),
             l = Read8HexBits();
    return (h &lt;&lt; 8) + l;
}

long ReadIntegerDecimal(int base = 10) {
    char *endptr;
    long l = strtol(&amp;*pos, &amp;endptr, base);
    ssassert(&amp;*pos != endptr, "Cannot read an integer number");
    pos += endptr - &amp;*pos;
    return l;
}

</t>
<t tx="leo.20191228122646.137">double ReadFloatDecimal() {
    char *endptr;
    double d = strtod(&amp;*pos, &amp;endptr);
    ssassert(&amp;*pos != endptr, "Cannot read a floating-point number");
    pos += endptr - &amp;*pos;
    return d;
}

</t>
<t tx="leo.20191228122646.138">bool TryRegex(const std::regex &amp;re, std::smatch *m) {
    if(std::regex_search(pos, end, *m, re, std::regex_constants::match_continuous)) {
        pos += m-&gt;length();
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="leo.20191228122646.139">void ExpectRegex(const std::regex &amp;re, std::smatch *m) {
    ssassert(TryRegex(re, m), "Unmatched regex");
}
</t>
<t tx="leo.20191228122646.14">void GraphicsWindow::AddPointToDraggedList(hEntity hp) {
    Entity *p = SK.GetEntity(hp);
    // If an entity and its points are both selected, then its points could
    // end up in the list twice. This would be bad, because it would move
    // twice as far as the mouse pointer...
    List&lt;hEntity&gt; *lhe = &amp;(pending.points);
    for(hEntity *hee = lhe-&gt;First(); hee; hee = lhe-&gt;NextAfter(hee)) {
        if(*hee == hp) {
            // Exact same point.
            return;
        }
        Entity *pe = SK.GetEntity(*hee);
        if(pe-&gt;type == p-&gt;type &amp;&amp;
           pe-&gt;type != Entity::Type::POINT_IN_2D &amp;&amp;
           pe-&gt;type != Entity::Type::POINT_IN_3D &amp;&amp;
           pe-&gt;group == p-&gt;group)
        {
            // Transform-type point, from the same group. So it handles the
            // same unknowns.
            return;
        }
    }
    pending.points.Add(&amp;hp);
}

</t>
<t tx="leo.20191228122646.140">static uint8_t *BitmapFontTextureRow(std::shared_ptr&lt;Pixmap&gt; texture,
                                     uint16_t position, size_t y) {
    // position = 0;
    size_t col = position % (texture-&gt;width / 16),
           row = position / (texture-&gt;width / 16);
    return &amp;texture-&gt;data[texture-&gt;stride * (16 * row + y) + 16 * col];
}

BitmapFont BitmapFont::From(std::string &amp;&amp;unifontData) {
    BitmapFont font  = {};
    font.unifontData = std::move(unifontData);
    font.texture     = Pixmap::Create(Pixmap::Format::A, 1024, 1024);

    return font;
}

</t>
<t tx="leo.20191228122646.141">void BitmapFont::AddGlyph(char32_t codepoint, std::shared_ptr&lt;const Pixmap&gt; pixmap) {
    ssassert((pixmap-&gt;width == 8 || pixmap-&gt;width == 16) &amp;&amp; pixmap-&gt;height == 16,
             "Unexpected pixmap dimensions");
    ssassert(pixmap-&gt;format == Pixmap::Format::RGB,
             "Unexpected pixmap format");
    ssassert(glyphs.find(codepoint) == glyphs.end(),
             "Glyph with this codepoint already exists");
    ssassert(nextPosition != 0xffff,
             "Too many glyphs for current texture size");

    BitmapFont::Glyph glyph = {};
    glyph.advanceCells = (uint8_t)(pixmap-&gt;width / 8);
    glyph.position     = nextPosition++;
    glyphs.emplace(codepoint, glyph);

    for(size_t y = 0; y &lt; pixmap-&gt;height; y++) {
        uint8_t *row = BitmapFontTextureRow(texture, glyph.position, y);
        for(size_t x = 0; x &lt; pixmap-&gt;width; x++) {
            if((pixmap-&gt;GetPixel(x, y).ToPackedInt() &amp; 0xffffff) != 0) {
                row[x] = 255;
            }
        }
    }
}

</t>
<t tx="leo.20191228122646.142">const BitmapFont::Glyph &amp;BitmapFont::GetGlyph(char32_t codepoint) {
    auto it = glyphs.find(codepoint);
    if(it != glyphs.end()) {
        return (*it).second;
    }

    ssassert(nextPosition != 0xffff,
             "Too many glyphs for current texture size");

    // Find the hex representation in the (sorted) Unifont file.
    @others
}

</t>
<t tx="leo.20191228122646.143">auto first = unifontData.cbegin(),
     last  = unifontData.cend();
while(first &lt;= last) {
    auto mid = first + (last - first) / 2;
    while(mid != unifontData.cbegin()) {
        if(*mid == '\n') {
            mid++;
            break;
        }
        mid--;
    }

    ASCIIReader reader = { mid, unifontData.cend() };
    if(reader.AtEnd()) break;

    // Read the codepoint.
    char32_t foundCodepoint = reader.Read16HexBits();
    reader.ExpectChar(':');

    if(foundCodepoint &gt; codepoint) {
        last = mid - 1;
        continue; // and first stays the same
    }
    if(foundCodepoint &lt; codepoint) {
        first = mid + 1;
        while(first != unifontData.cend()) {
            if(*first == '\n') break;
            first++;
        }
        continue; // and last stays the same
    }

    // Found the codepoint.
    Glyph glyph = {};
    glyph.position = nextPosition++;

    // Read glyph bits.
    unsigned short glyphBits[16];
    size_t glyphLength = reader.CountUntilEol();
    if(glyphLength == 4 * 16) {
        glyph.advanceCells = 2;
        for(size_t i = 0; i &lt; 16; i++) {
            glyphBits[i] = reader.Read16HexBits();
        }
    } else if(glyphLength == 2 * 16) {
        glyph.advanceCells = 1;
        for(size_t i = 0; i &lt; 16; i++) {
            glyphBits[i] = (uint16_t)reader.Read8HexBits() &lt;&lt; 8;
        }
    } else ssassert(false, "Unexpected glyph bitmap length");

    // Fill in the texture (one texture byte per glyph bit).
    for(size_t y = 0; y &lt; 16; y++) {
        uint8_t *row = BitmapFontTextureRow(texture, glyph.position, y);
        for(size_t x = 0; x &lt; 16; x++) {
            if(glyphBits[y] &amp; (1 &lt;&lt; (15 - x))) {
                row[x] = 255;
            }
        }
    }

    it = glyphs.emplace(codepoint, glyph).first;

    textureUpdated = true;
    return (*it).second;
}

// Glyph doesn't exist; return replacement glyph instead.
ssassert(codepoint != 0xfffd, "Cannot parse replacement glyph");
return GetGlyph(0xfffd);
</t>
<t tx="leo.20191228122646.144">void BitmapFont::LocateGlyph(char32_t codepoint,
                             double *s0, double *t0, double *s1, double *t1,
                             size_t *w, size_t *h) {
    const Glyph &amp;glyph = GetGlyph(codepoint);
    *w  = glyph.advanceCells * 8;
    *h  = 16;
    *s0 = (16.0 * (glyph.position % (texture-&gt;width / 16))) / texture-&gt;width;
    *s1 = *s0 + (double)(*w) / texture-&gt;width;
    *t0 = (16.0 * (glyph.position / (texture-&gt;width / 16))) / texture-&gt;height;
    *t1 = *t0 + (double)(*h) / texture-&gt;height;
}

size_t BitmapFont::GetWidth(char32_t codepoint) {
    if(codepoint &gt;= 0xe000 &amp;&amp; codepoint &lt;= 0xefff) {
        // These are special-cased because checkboxes predate support for 2 cell wide
        // characters; and so all Printf() calls pad them with spaces.
        return 1;
    }

    return GetGlyph(codepoint).advanceCells;
}

size_t BitmapFont::GetWidth(const std::string &amp;str) {
    size_t width = 0;
    for(char32_t codepoint : ReadUTF8(str)) {
        width += GetWidth(codepoint);
    }
    return width;
}

BitmapFont BitmapFont::Create() {
    BitmapFont Font = BitmapFont::From(LoadStringFromGzip("fonts/unifont.hex.gz"));
    // Unifont doesn't have a glyph for U+0020.
    Font.AddGlyph(0x0020, Pixmap::Create(Pixmap::Format::RGB, 8, 16));
    Font.AddGlyph(0xE000, LoadPng("fonts/private/0-check-false.png"));
    Font.AddGlyph(0xE001, LoadPng("fonts/private/1-check-true.png"));
    Font.AddGlyph(0xE002, LoadPng("fonts/private/2-radio-false.png"));
    Font.AddGlyph(0xE003, LoadPng("fonts/private/3-radio-true.png"));
    Font.AddGlyph(0xE004, LoadPng("fonts/private/4-stipple-dot.png"));
    Font.AddGlyph(0xE005, LoadPng("fonts/private/5-stipple-dash-long.png"));
    Font.AddGlyph(0xE006, LoadPng("fonts/private/6-stipple-dash.png"));
    Font.AddGlyph(0xE007, LoadPng("fonts/private/7-stipple-zigzag.png"));
    return Font;
}

//-----------------------------------------------------------------------------
// Vector font manipulation
//-----------------------------------------------------------------------------

const static int ARC_POINTS = 8;
</t>
<t tx="leo.20191228122646.145">static void MakePwlArc(VectorFont::Contour *contour, bool isReversed,
                       const Point2d &amp;cp, double radius, double a1, double a2) {
    if(radius &lt; LENGTH_EPS) return;

    double aSign = 1.0;
    if(isReversed) {
        if(a1 &lt;= a2 + LENGTH_EPS) a1 += 2.0 * M_PI;
        aSign = -1.0;
    } else {
        if(a2 &lt;= a1 + LENGTH_EPS) a2 += 2.0 * M_PI;
    }

    double aStep = aSign * fabs(a2 - a1) / (double)ARC_POINTS;
    for(int i = 0; i &lt;= ARC_POINTS; i++) {
        contour-&gt;points.emplace_back(cp.Plus(Point2d::FromPolar(radius, a1 + aStep * i)));
    }
}

</t>
<t tx="leo.20191228122646.146">static void MakePwlBulge(VectorFont::Contour *contour, const Point2d &amp;v, double bulge) {
    bool reversed = bulge &lt; 0.0;
    double alpha = atan(bulge) * 4.0;
    const Point2d &amp;point = contour-&gt;points.back();

    Point2d middle = point.Plus(v).ScaledBy(0.5);
    double dist = point.DistanceTo(v) / 2.0;
    double angle = point.AngleTo(v);

    // alpha can't be 0.0 at this point
    double radius = fabs(dist / sin(alpha / 2.0));
    double wu = fabs(radius*radius - dist*dist);
    double h = sqrt(wu);

    if(bulge &gt; 0.0) {
        angle += M_PI_2;
    } else {
        angle -= M_PI_2;
    }

    if(fabs(alpha) &gt; M_PI) {
        h = -h;
    }

    Point2d center = Point2d::FromPolar(h, angle).Plus(middle);
    double a1 = center.AngleTo(point);
    double a2 = center.AngleTo(v);
    MakePwlArc(contour, reversed, center, radius, a1, a2);
}

</t>
<t tx="leo.20191228122646.147">static void GetGlyphBBox(const VectorFont::Glyph &amp;glyph,
                         double *rminx, double *rmaxx, double *rminy, double *rmaxy) {
    double minx = 0.0, maxx = 0.0, miny = 0.0, maxy = 0.0;
    if(!glyph.contours.empty()) {
        const Point2d &amp;start = glyph.contours[0].points[0];
        minx = maxx = start.x;
        miny = maxy = start.y;
        for(const VectorFont::Contour &amp;c : glyph.contours) {
            for(const Point2d &amp;p : c.points) {
                maxx = std::max(maxx, p.x);
                minx = std::min(minx, p.x);
                maxy = std::max(maxy, p.y);
                miny = std::min(miny, p.y);
            }
        }
    }

    if(rminx) *rminx = minx;
    if(rmaxx) *rmaxx = maxx;
    if(rminy) *rminy = miny;
    if(rmaxy) *rmaxy = maxy;
}

VectorFont VectorFont::From(std::string &amp;&amp;lffData) {
    VectorFont font = {};
    font.lffData = std::move(lffData);

    ASCIIReader reader = ASCIIReader::From(font.lffData);
    std::smatch m;
    while(reader.TryRegex(std::regex("#\\s*(\\w+)\\s*:\\s*(.+?)\n"), &amp;m)) {
        std::string name  = m.str(1),
                    value = m.str(2);
        std::transform(name.begin(), name.end(), name.begin(), ::tolower);
        if(name == "letterspacing") {
            font.rightSideBearing = std::stod(value);
        } else if(name == "wordspacing") {
            Glyph space = {};
            space.advanceWidth = std::stod(value);
            font.glyphs.emplace(' ', std::move(space));
        }
    }

    GetGlyphBBox(font.GetGlyph('A'), nullptr, nullptr, nullptr, &amp;font.capHeight);
    GetGlyphBBox(font.GetGlyph('h'), nullptr, nullptr, nullptr, &amp;font.ascender);
    GetGlyphBBox(font.GetGlyph('p'), nullptr, nullptr, &amp;font.descender, nullptr);

    ssassert(!font.IsEmpty(), "Expected to load a font");
    return font;
}

</t>
<t tx="leo.20191228122646.148">const VectorFont::Glyph &amp;VectorFont::GetGlyph(char32_t codepoint) {
    auto it = glyphs.find(codepoint);
    if(it != glyphs.end()) {
        return (*it).second;
    }

    auto firstGlyph = std::find(lffData.cbegin(), lffData.cend(), '[');
    ssassert(firstGlyph != lffData.cend(), "Vector font contains no glyphs");

    // Find the serialized representation in the (sorted) lff file.
    @others
}

VectorFont *VectorFont::Builtin() {
    static VectorFont Font;
    if(Font.IsEmpty()) {
        Font = VectorFont::From(LoadStringFromGzip("fonts/unicode.lff.gz"));
    }
    return &amp;Font;
}

double VectorFont::GetCapHeight(double forCapHeight) const {
    ssassert(!IsEmpty(), "Expected a loaded font");

    return forCapHeight;
}

double VectorFont::GetHeight(double forCapHeight) const {
    ssassert(!IsEmpty(), "Expected a loaded font");

    return (ascender - descender) * (forCapHeight / capHeight);
}

double VectorFont::GetWidth(double forCapHeight, const std::string &amp;str) {
    ssassert(!IsEmpty(), "Expected a loaded font");

    double width = 0;
    for(char32_t codepoint : ReadUTF8(str)) {
        width += GetGlyph(codepoint).advanceWidth;
    }
    width -= rightSideBearing;
    return width * (forCapHeight / capHeight);
}

Vector VectorFont::GetExtents(double forCapHeight, const std::string &amp;str) {
    Vector ex = {};
    ex.x = GetWidth(forCapHeight, str);
    ex.y = GetHeight(forCapHeight);
    return ex;
}

</t>
<t tx="leo.20191228122646.149">auto first = firstGlyph,
     last  = lffData.cend();
while(first &lt;= last) {
    auto mid = first + (last - first) / 2;
    while(mid &gt; first) {
        if(*mid == '[' &amp;&amp; *(mid - 1) == '\n') break;
        mid--;
    }

    ASCIIReader reader = { mid, lffData.cend() };
    if(reader.AtEnd()) break;

    // Read the codepoint.
    reader.ExpectChar('[');
    char32_t foundCodepoint = reader.Read16HexBits();
    reader.ExpectChar(']');
    reader.SkipUntilEol();

    if(foundCodepoint &gt; codepoint) {
        last = mid - 1;
        continue; // and first stays the same
    }
    if(foundCodepoint &lt; codepoint) {
        first = mid + 1;
        while(first != lffData.cend()) {
            if(*first == '[' &amp;&amp; *(first - 1) == '\n') break;
            first++;
        }
        continue; // and last stays the same
    }

    // Found the codepoint.
    VectorFont::Glyph glyph = {};

    // Read glyph contours.
    while(!reader.AtEnd()) {
        if(reader.TryChar('\n')) {
            // Skip.
        } else if(reader.TryChar('[')) {
            // End of glyph.
            if(glyph.contours.back().points.empty()) {
                // Remove an useless empty contour, if any.
                glyph.contours.pop_back();
            }
            break;
        } else if(reader.TryChar('C')) {
            // Another character is referenced in this one.
            char32_t baseCodepoint = reader.Read16HexBits();
            const VectorFont::Glyph &amp;baseGlyph = GetGlyph(baseCodepoint);
            std::copy(baseGlyph.contours.begin(), baseGlyph.contours.end(),
                      std::back_inserter(glyph.contours));
        } else {
            Contour contour;
            do {
                Point2d p;
                p.x = reader.ReadFloatDecimal();
                reader.ExpectChar(',');
                p.y = reader.ReadFloatDecimal();

                if(reader.TryChar(',')) {
                    // Point with a bulge.
                    reader.ExpectChar('A');
                    double bulge = reader.ReadFloatDecimal();
                    MakePwlBulge(&amp;contour, p, bulge);
                } else {
                    // Just a point.
                    contour.points.emplace_back(std::move(p));
                }
            } while(reader.TryChar(';'));
            reader.ExpectChar('\n');
            glyph.contours.emplace_back(std::move(contour));
        }
    }

    // Calculate metrics.
    GetGlyphBBox(glyph, &amp;glyph.leftSideBearing, &amp;glyph.boundingWidth, nullptr, nullptr);
    glyph.advanceWidth = glyph.leftSideBearing + glyph.boundingWidth + rightSideBearing;

    it = glyphs.emplace(codepoint, std::move(glyph)).first;
    return (*it).second;
}

// Glyph doesn't exist; return replacement glyph instead.
ssassert(codepoint != 0xfffd, "Cannot parse replacement glyph");
return GetGlyph(0xfffd);
</t>
<t tx="leo.20191228122646.15">void GraphicsWindow::StartDraggingByEntity(hEntity he) {
    Entity *e = SK.GetEntity(he);
    if(e-&gt;IsPoint()) {
        AddPointToDraggedList(e-&gt;h);
    } else if(e-&gt;type == Entity::Type::LINE_SEGMENT ||
              e-&gt;type == Entity::Type::ARC_OF_CIRCLE ||
              e-&gt;type == Entity::Type::CUBIC ||
              e-&gt;type == Entity::Type::CUBIC_PERIODIC ||
              e-&gt;type == Entity::Type::CIRCLE ||
              e-&gt;type == Entity::Type::TTF_TEXT ||
              e-&gt;type == Entity::Type::IMAGE)
    {
        int pts;
        EntReqTable::GetEntityInfo(e-&gt;type, e-&gt;extraPoints,
            NULL, &amp;pts, NULL, NULL);
        for(int i = 0; i &lt; pts; i++) {
            AddPointToDraggedList(e-&gt;point[i]);
        }
    }
}

</t>
<t tx="leo.20191228122646.150">void VectorFont::Trace(double forCapHeight, Vector o, Vector u, Vector v, const std::string &amp;str,
                       const std::function&lt;void(Vector, Vector)&gt; &amp;traceEdge) {
    ssassert(!IsEmpty(), "Expected a loaded font");

    double scale = (forCapHeight / capHeight);
    u = u.ScaledBy(scale);
    v = v.ScaledBy(scale);

    for(char32_t codepoint : ReadUTF8(str)) {
        const Glyph &amp;glyph = GetGlyph(codepoint);

        for(const VectorFont::Contour &amp;contour : glyph.contours) {
            Vector prevp;
            bool penUp = true;
            for(const Point2d &amp;pt : contour.points) {
                Vector p = o.Plus(u.ScaledBy(pt.x))
                            .Plus(v.ScaledBy(pt.y));
                if(!penUp) traceEdge(prevp, p);
                prevp = p;
                penUp = false;
            }
        }

        o = o.Plus(u.ScaledBy(glyph.advanceWidth));
    }
}

</t>
<t tx="leo.20191228122646.151">void VectorFont::Trace(double forCapHeight, Vector o, Vector u, Vector v, const std::string &amp;str,
                       const std::function&lt;void(Vector, Vector)&gt; &amp;traceEdge, const Camera &amp;camera) {
    ssassert(!IsEmpty(), "Expected a loaded font");

    // Perform grid-fitting only when the text is parallel to the view plane.
    if(camera.gridFit &amp;&amp; !(u.WithMagnitude(1).Equals(camera.projRight) &amp;&amp;
                           v.WithMagnitude(1).Equals(camera.projUp))) {
        return Trace(forCapHeight, o, u, v, str, traceEdge);
    }

    double scale = forCapHeight / capHeight;
    u = u.ScaledBy(scale);
    v = v.ScaledBy(scale);

    for(char32_t codepoint : ReadUTF8(str)) {
        const Glyph &amp;glyph = GetGlyph(codepoint);
        double actualWidth = std::max(1.0, glyph.boundingWidth);

        // Align (o+lsb), (o+lsb+u) and (o+lsb+v) to pixel grid.
        Vector ao =  o.Plus(u.ScaledBy(glyph.leftSideBearing));
        Vector au = ao.Plus(u.ScaledBy(actualWidth));
        Vector av = ao.Plus(v.ScaledBy(capHeight));

        ao = camera.AlignToPixelGrid(ao);
        au = camera.AlignToPixelGrid(au);
        av = camera.AlignToPixelGrid(av);

        au = au.Minus(ao).ScaledBy(1.0 / actualWidth);
        av = av.Minus(ao).ScaledBy(1.0 / capHeight);

        for(const VectorFont::Contour &amp;contour : glyph.contours) {
            Vector prevp;
            bool penUp = true;
            for(const Point2d &amp;pt : contour.points) {
                Vector p = ao.Plus(au.ScaledBy(pt.x - glyph.leftSideBearing))
                             .Plus(av.ScaledBy(pt.y));
                if(!penUp) traceEdge(prevp, p);
                prevp = p;
                penUp = false;
            }
        }

        o = o.Plus(u.ScaledBy(glyph.advanceWidth));
    }
}

//-----------------------------------------------------------------------------
// Gettext plural expression evaluation
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122646.152">class PluralExpr {
public:
    @others
};

</t>
<t tx="leo.20191228122646.153">class Token {
public:
    enum class Type {
        END,
        VALUE,
        BINARY_OP,
        QUERY,
        COLON,
        PAREN_LEFT,
        PAREN_RIGHT,
    };

    // Only valid for type == BINARY_OP.
    enum class Op {
        NONE,
        // comparison
        EQ,             // ==
        NEQ,            // !=
        LT,             // &lt;
        GT,             // &gt;
        LE,             // &lt;=
        GE,             // &gt;=
        // logical
        AND,            // &amp;&amp;
        OR,             // ||
        // arithmetic
        MOD,            // %
    };

    Type     type;
    Op       op;
    unsigned value;

    int Precedence();
};

ASCIIReader        reader;
std::vector&lt;Token&gt; stack;
unsigned           value;

Token Lex();

Token PopToken();
void Reduce();
void Eval();

static unsigned Eval(const std::string &amp;s, unsigned n);
</t>
<t tx="leo.20191228122646.154">int PluralExpr::Token::Precedence() {
    switch(type) {
        case Type::BINARY_OP:
            switch(op) {
                case Op::MOD:
                    return 7;

                case Op::LT:
                case Op::GT:
                case Op::LE:
                case Op::GE:
                    return 6;

                case Op::EQ:
                case Op::NEQ:
                    return 5;

                case Op::AND:
                    return 4;

                case Op::OR:
                    return 3;

                case Op::NONE:
                    ;
            }
            ssassert(false, "Unexpected operator");

        case Type::QUERY:
        case Type::COLON:
            return 1;

        case Type::VALUE:
            return 0;

        default:
            ssassert(false, "Unexpected token op");
    }
}

PluralExpr::Token PluralExpr::Lex() {
    Token t = {};

    reader.SkipSpace();

    char c = reader.PeekChar();
    if(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        t.type  = Token::Type::VALUE;
        t.value = reader.ReadIntegerDecimal();
    } else if(reader.TryChar('n')) {
        t.type  = Token::Type::VALUE;
        t.value = value;
    } else if(reader.TryChar('%')) {
        t.type  = Token::Type::BINARY_OP;
        t.op    = Token::Op::MOD;
    } else if(reader.TryChar('&lt;')) {
        t.type  = Token::Type::BINARY_OP;
        if(reader.TryChar('=')) {
            t.op = Token::Op::LE;
        } else {
            t.op = Token::Op::LT;
        }
    } else if(reader.TryChar('&gt;')) {
        t.type  = Token::Type::BINARY_OP;
        if(reader.TryChar('=')) {
            t.op = Token::Op::GE;
        } else {
            t.op = Token::Op::GT;
        }
    } else if(reader.TryChar('!')) {
        reader.ExpectChar('=');
        t.type  = Token::Type::BINARY_OP;
        t.op    = Token::Op::NEQ;
    } else if(reader.TryChar('=')) {
        reader.ExpectChar('=');
        t.type  = Token::Type::BINARY_OP;
        t.op    = Token::Op::EQ;
    } else if(reader.TryChar('&amp;')) {
        reader.ExpectChar('&amp;');
        t.type  = Token::Type::BINARY_OP;
        t.op    = Token::Op::AND;
    } else if(reader.TryChar('|')) {
        reader.ExpectChar('|');
        t.type  = Token::Type::BINARY_OP;
        t.op    = Token::Op::OR;
    } else if(reader.TryChar('?')) {
        t.type  = Token::Type::QUERY;
    } else if(reader.TryChar(':')) {
        t.type  = Token::Type::COLON;
    } else if(reader.TryChar('(')) {
        t.type  = Token::Type::PAREN_LEFT;
    } else if(reader.TryChar(')')) {
        t.type  = Token::Type::PAREN_RIGHT;
    } else if(reader.AtEnd()) {
        t.type  = Token::Type::END;
    } else {
        ssassert(false, "Unexpected character");
    }

    return t;
}

PluralExpr::Token PluralExpr::PopToken() {
    ssassert(!stack.empty(), "Expected a non-empty stack");
    Token t = stack.back();
    stack.pop_back();
    return t;
}

</t>
<t tx="leo.20191228122646.155">void PluralExpr::Reduce() {
    Token r;
    r.type = Token::Type::VALUE;

    Token a  = PopToken();
    ssassert(a.type == Token::Type::VALUE, "Expected 1st operand to be a value");

    Token op = PopToken();
    switch(op.type) {
        case Token::Type::BINARY_OP: {
            Token b = PopToken();
            ssassert(b.type == Token::Type::VALUE, "Expected 2nd operand to be a value");

            switch(op.op) {
                case Token::Op::EQ:
                    r.value = (a.value == b.value ? 1 : 0);
                    break;
                case Token::Op::NEQ:
                    r.value = (a.value != b.value ? 1 : 0);
                    break;
                case Token::Op::LT:
                    r.value = (b.value &lt;  a.value ? 1 : 0);
                    break;
                case Token::Op::GT:
                    r.value = (b.value &gt;  a.value ? 1 : 0);
                    break;
                case Token::Op::LE:
                    r.value = (b.value &lt;= a.value ? 1 : 0);
                    break;
                case Token::Op::GE:
                    r.value = (b.value &gt;= a.value ? 1 : 0);
                    break;
                case Token::Op::AND:
                    r.value = a.value &amp;&amp; b.value;
                    break;
                case Token::Op::OR:
                    r.value = a.value || b.value;
                    break;
                case Token::Op::MOD:
                    r.value = b.value %  a.value;
                    break;
                case Token::Op::NONE:
                    ssassert(false, "Unexpected operator");
            }
            break;
        }

        case Token::Type::COLON: {
            Token b = PopToken();
            ssassert(PopToken().type == Token::Type::QUERY, "Expected ?");
            Token c = PopToken();
            r.value = c.value ? b.value : a.value;
            break;
        }

        default:
            ssassert(false, "Unexpected operator type");
    }

    stack.push_back(r);
}

</t>
<t tx="leo.20191228122646.156">void PluralExpr::Eval() {
    while(true) {
        Token t = Lex();
        switch(t.type) {
            case Token::Type::END:
            case Token::Type::PAREN_RIGHT:
                while(stack.size() &gt; 1 &amp;&amp;
                      stack.end()[-2].type != Token::Type::PAREN_LEFT) {
                    Reduce();
                }
                if(t.type == Token::Type::PAREN_RIGHT) {
                    ssassert(stack.size() &gt; 1, "Expected (");
                    stack.push_back(t);
                }
                return;

            case Token::Type::PAREN_LEFT:
                stack.push_back(t);
                Eval();
                if(stack.back().type != Token::Type::PAREN_RIGHT) {
                    ssassert(false, "Expected )");
                }
                stack.pop_back();
                stack.erase(stack.end() - 2);
                break;

            case Token::Type::VALUE:
                stack.push_back(t);
                break;

            case Token::Type::BINARY_OP:
            case Token::Type::QUERY:
            case Token::Type::COLON:
                while(stack.size() &gt; 1 &amp;&amp;
                      stack.end()[-2].type != Token::Type::PAREN_LEFT &amp;&amp;
                      t.Precedence() &lt; stack.end()[-2].Precedence()) {
                    Reduce();
                }
                stack.push_back(t);
                break;
        }
    }
}

</t>
<t tx="leo.20191228122646.157">unsigned PluralExpr::Eval(const std::string &amp;s, unsigned n) {
    PluralExpr expr = {};
    expr.reader = ASCIIReader::From(s);
    expr.value  = n;
    expr.Eval();

    Token t = expr.PopToken();
    ssassert(t.type == Token::Type::VALUE, "Expected a value");
    return t.value;
}

//-----------------------------------------------------------------------------
// Gettext message keys
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122646.158">class TranslationKey {
public:
    bool        hasContext;
    std::string context;
    std::string ident;
};

struct TranslationKeyLess {
</t>
<t tx="leo.20191228122646.159">    bool operator()(const TranslationKey &amp;a, const TranslationKey &amp;b) const {
        return a.hasContext &lt; b.hasContext ||
            (a.hasContext == b.hasContext &amp;&amp; a.context &lt; b.context) ||
            (a.hasContext == b.hasContext &amp;&amp; a.context == b.context &amp;&amp; a.ident &lt; b.ident);
    }
};

//-----------------------------------------------------------------------------
// Gettext .po file parsing
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122646.16">void GraphicsWindow::StartDraggingBySelection() {
    List&lt;Selection&gt; *ls = &amp;(selection);
    for(Selection *s = ls-&gt;First(); s; s = ls-&gt;NextAfter(s)) {
        if(!s-&gt;entity.v) continue;

        StartDraggingByEntity(s-&gt;entity);
    }
    // The user might select a point, and then click it again to start
    // dragging; but the point just got unselected by that click. So drag
    // the hovered item too, and they'll always have it.
    if(hover.entity.v) {
        hEntity dragEntity = ChooseFromHoverToDrag().entity;
        if(dragEntity != Entity::NO_ENTITY) {
            StartDraggingByEntity(dragEntity);
        }
    }
}

</t>
<t tx="leo.20191228122646.160">class GettextParser {
public:
    ASCIIReader reader;

    unsigned    pluralCount;
    std::string pluralExpr;

    std::map&lt;TranslationKey, std::vector&lt;std::string&gt;, TranslationKeyLess&gt; messages;

    void SkipSpace();
    std::string ReadString();
    void ParseHeader(const std::string &amp;header);
    void Parse();
};

</t>
<t tx="leo.20191228122646.161">void GettextParser::SkipSpace() {
    while(!reader.AtEnd()) {
        if(reader.TryChar('#')) {
            reader.SkipUntilEol();
        } else if(!reader.SkipSpace()) {
            break;
        }
    }
}

std::string GettextParser::ReadString() {
    SkipSpace();
    reader.ExpectChar('"');

    std::string result;
    while(true) {
        if(reader.AtEnd()) {
            ssassert(false, "Unexpected EOF within a string");
        } else if(reader.TryChar('\"')) {
            SkipSpace();
            if(!reader.TryChar('\"')) {
                break;
            }
        } else if(reader.TryChar('\\')) {
            if(reader.TryChar('\\')) {
                result += '\\';
            } else if(reader.TryChar('n')) {
                result += '\n';
            } else if(reader.TryChar('t')) {
                result += '\t';
            } else if(reader.TryChar('"')) {
                result += '"';
            } else {
                ssassert(false, "Unexpected escape sequence");
            }
        } else {
            result += reader.ReadChar();
        }
    }
    return result;
}

</t>
<t tx="leo.20191228122646.162">void GettextParser::ParseHeader(const std::string &amp;header) {
    ASCIIReader reader = ASCIIReader::From(header);
    while(!reader.AtEnd()) {
        reader.SkipSpace();
        if(reader.TryString("Plural-Forms:")) {
            reader.SkipSpace();
            reader.ExpectString("nplurals=");
            reader.SkipSpace();
            pluralCount = reader.ReadIntegerDecimal();
            reader.SkipSpace();
            reader.ExpectString(";");
            reader.SkipSpace();
            reader.ExpectString("plural=");
            pluralExpr = reader.ReadUntilEol();
        } else {
            reader.SkipUntilEol();
        }
    }
}

</t>
<t tx="leo.20191228122646.163">void GettextParser::Parse() {
    // Default to a single form, in case a header is missing.
    pluralCount = 1;
    pluralExpr  = "0";

    SkipSpace();
    while(!reader.AtEnd()) {
        TranslationKey key = {};

        if(reader.TryString("msgctxt")) {
            key.hasContext = true;
            key.context = ReadString();
        }

        reader.ExpectString("msgid");
        key.ident = ReadString();

        if(reader.TryString("msgid_plural")) {
            ReadString(); // we don't need it
        }

        std::vector&lt;std::string&gt; msgstrs;
        while(reader.TryString("msgstr")) {
            if(reader.TryChar('[')) {
                unsigned index = reader.ReadIntegerDecimal();
                reader.ExpectChar(']');
                if(msgstrs.size() &lt;= index) {
                    msgstrs.resize(index + 1);
                }
                msgstrs[index] = ReadString();
            } else {
                msgstrs.emplace_back(ReadString());
                break;
            }
        }

        if(key.ident.empty()) {
            ssassert(msgstrs.size() == 1,
                     "Expected exactly one header msgstr");
            ParseHeader(msgstrs[0]);
        } else {
            ssassert(msgstrs.size() == 1 ||
                     msgstrs.size() == pluralCount,
                     "Expected msgstr count to match plural form count");
            messages.emplace(key, msgstrs);
        }
    }
}

//-----------------------------------------------------------------------------
// Translation management
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122646.164">class Translation {
public:
    unsigned    pluralCount;
    std::string pluralExpr;

    std::map&lt;TranslationKey, std::vector&lt;std::string&gt;, TranslationKeyLess&gt; messages;

    static Translation From(const std::string &amp;poData);

    const std::string &amp;Translate(const TranslationKey &amp;key);
    const std::string &amp;TranslatePlural(const TranslationKey &amp;key, unsigned n);
};

Translation Translation::From(const std::string &amp;poData) {
    GettextParser parser = {};
    parser.reader = ASCIIReader::From(poData);
    parser.Parse();

    Translation trans = {};
    trans.pluralCount = parser.pluralCount;
    trans.pluralExpr  = parser.pluralExpr;
    trans.messages    = parser.messages;
    return trans;
}

</t>
<t tx="leo.20191228122646.165">const std::string &amp;Translation::Translate(const TranslationKey &amp;key) {
    auto it = messages.find(key);
    if(it == messages.end()) {
        dbp("Missing (absent) translation for %s'%s'", key.context.c_str(), key.ident.c_str());
        messages[key].emplace_back(key.ident);
        it = messages.find(key);
    }
    if(it-&gt;second[0].empty()) {
        dbp("Missing (empty) translation for %s'%s'", key.context.c_str(), key.ident.c_str());
        it-&gt;second[0] = key.ident;
    }
    if(it-&gt;second.size() != 1) {
        dbp("Incorrect use of translated message %s'%s'", key.context.c_str(), key.ident.c_str());
        ssassert(false, "Using a message with a plural form without a number");
    }
    return it-&gt;second[0];
}

</t>
<t tx="leo.20191228122646.166">const std::string &amp;Translation::TranslatePlural(const TranslationKey &amp;key, unsigned n) {
    unsigned pluralForm = PluralExpr::Eval(pluralExpr, n);

    auto it = messages.find(key);
    if(it == messages.end()) {
        dbp("Missing (absent) translation for %s'%s'", key.context.c_str(), key.ident.c_str());
        for(unsigned i = 0; i &lt; pluralCount; i++) {
            messages[key].emplace_back(key.ident);
        }
        it = messages.find(key);
    }
    if(it-&gt;second[pluralForm].empty()) {
        dbp("Missing (empty) translation for %s'%s'[%d]",
            key.context.c_str(), key.ident.c_str(), pluralForm);
        it-&gt;second[pluralForm] = key.ident;
    }
    return it-&gt;second[pluralForm];
}

//-----------------------------------------------------------------------------
// Locale management
//-----------------------------------------------------------------------------

static std::set&lt;Locale, LocaleLess&gt; locales;
static std::map&lt;Locale, Translation, LocaleLess&gt; translations;
static Translation dummyTranslation;
static Translation *currentTranslation = &amp;dummyTranslation;

</t>
<t tx="leo.20191228122646.167">const std::set&lt;Locale, LocaleLess&gt; &amp;Locales() {
    if(!locales.empty()) return locales;

    std::string localeList = LoadString("locales.txt");
    ASCIIReader reader = ASCIIReader::From(localeList);
    while(!reader.AtEnd()) {
        reader.SkipSpace();
        if(reader.TryChar('#')) {
            reader.SkipUntilEol();
            continue;
        }

        std::smatch m;
        reader.ExpectRegex(std::regex("([a-z]{2})-([A-Z]{2}),([0-9A-F]{4}),(.+?)\n"), &amp;m);
        Locale locale = {};
        locale.language    = m.str(1);
        locale.region      = m.str(2);
        locale.lcid        = std::stoi(m.str(3), NULL, 16);
        locale.displayName = m.str(4);
        locales.emplace(locale);
    }
    return locales;
}

template&lt;class Predicate&gt;
</t>
<t tx="leo.20191228122646.168">bool SetLocale(Predicate pred) {
    auto it = std::find_if(Locales().begin(), Locales().end(), pred);
    if(it != locales.end()) {
        std::string filename = "locales/" + it-&gt;language + "_" + it-&gt;region + ".po";
        translations[*it] = Translation::From(LoadString(filename));
        currentTranslation = &amp;translations[*it];
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="leo.20191228122646.169">bool SetLocale(const std::string &amp;name) {
    return SetLocale([&amp;](const Locale &amp;locale) {
        if(name == locale.language + "-" + locale.region) {
            return true;
        } else if(name == locale.language + "_" + locale.region) {
            return true;
        } else if(name == locale.language) {
            return true;
        } else {
            return false;
        }
    });
}

</t>
<t tx="leo.20191228122646.17">void GraphicsWindow::MouseMoved(double x, double y, bool leftDown,
            bool middleDown, bool rightDown, bool shiftDown, bool ctrlDown)
{
    if(window-&gt;IsEditorVisible()) return;
    if(context.active) return;

    SS.extraLine.draw = false;

    if(!orig.mouseDown) {
        // If someone drags the mouse into our window with the left button
        // already depressed, then we don't have our starting point; so
        // don't try.
        leftDown = false;
    }

    if(rightDown) {
        middleDown = true;
        shiftDown = !shiftDown;
    }

    if(SS.showToolbar) {
        if(ToolbarMouseMoved((int)x, (int)y)) {
            hover.Clear();
            return;
        }
    }

    if(!leftDown &amp;&amp; (pending.operation == Pending::DRAGGING_POINTS ||
                     pending.operation == Pending::DRAGGING_MARQUEE))
    {
        ClearPending();
        Invalidate();
    }

    Point2d mp = Point2d::From(x, y);
    currentMousePosition = mp;

    if(rightDown &amp;&amp; orig.mouse.DistanceTo(mp) &lt; 5 &amp;&amp; !orig.startedMoving) {
        // Avoid accidentally panning (or rotating if shift is down) if the
        // user wants a context menu.
        return;
    }
    orig.startedMoving = true;

    // If the middle button is down, then mouse movement is used to pan and
    // rotate our view. This wins over everything else.
    if(middleDown) {
        hover.Clear();

        double dx = (x - orig.mouse.x) / scale;
        double dy = (y - orig.mouse.y) / scale;

        if(!(shiftDown || ctrlDown)) {
            double s = 0.3*(PI/180)*scale; // degrees per pixel
            if(SS.turntableNav) {          // lock the Z to vertical
                projRight = orig.projRight.RotatedAbout(Vector::From(0, 0, 1), -s * dx);
                projUp    = orig.projUp.RotatedAbout(
                    Vector::From(orig.projRight.x, orig.projRight.y, orig.projRight.y), s * dy);
            } else {
                projRight = orig.projRight.RotatedAbout(orig.projUp, -s * dx);
                projUp    = orig.projUp.RotatedAbout(orig.projRight, s * dy);
            }

            NormalizeProjectionVectors();
        } else if(ctrlDown) {
            double theta = atan2(orig.mouse.y, orig.mouse.x);
            theta -= atan2(y, x);
            SS.extraLine.draw = true;
            SS.extraLine.ptA = UnProjectPoint(Point2d::From(0, 0));
            SS.extraLine.ptB = UnProjectPoint(mp);

            Vector normal = orig.projRight.Cross(orig.projUp);
            projRight = orig.projRight.RotatedAbout(normal, theta);
            projUp = orig.projUp.RotatedAbout(normal, theta);

            NormalizeProjectionVectors();
        } else {
            offset.x = orig.offset.x + dx*projRight.x + dy*projUp.x;
            offset.y = orig.offset.y + dx*projRight.y + dy*projUp.y;
            offset.z = orig.offset.z + dx*projRight.z + dy*projUp.z;
        }

        orig.projRight = projRight;
        orig.projUp = projUp;
        orig.offset = offset;
        orig.mouse.x = x;
        orig.mouse.y = y;

        if(SS.TW.shown.screen == TextWindow::Screen::EDIT_VIEW) {
            if(havePainted) {
                SS.ScheduleShowTW();
            }
        }
        Invalidate();
        havePainted = false;
        return;
    }

    if(pending.operation == Pending::NONE) {
        double dm = orig.mouse.DistanceTo(mp);
        // If we're currently not doing anything, then see if we should
        // start dragging something.
        if(leftDown &amp;&amp; dm &gt; 3) {
            Entity *e = NULL;
            hEntity dragEntity = ChooseFromHoverToDrag().entity;
            if(dragEntity.v) e = SK.GetEntity(dragEntity);
            if(e &amp;&amp; e-&gt;type != Entity::Type::WORKPLANE) {
                Entity *e = SK.GetEntity(dragEntity);
                if(e-&gt;type == Entity::Type::CIRCLE &amp;&amp; selection.n &lt;= 1) {
                    // Drag the radius.
                    ClearSelection();
                    pending.circle = dragEntity;
                    pending.operation = Pending::DRAGGING_RADIUS;
                } else if(e-&gt;IsNormal()) {
                    ClearSelection();
                    pending.normal = dragEntity;
                    pending.operation = Pending::DRAGGING_NORMAL;
                } else {
                    if(!hoverWasSelectedOnMousedown) {
                        // The user clicked an unselected entity, which
                        // means they're dragging just the hovered thing,
                        // not the full selection. So clear all the selection
                        // except that entity.
                        ClearSelection();
                        MakeSelected(e-&gt;h);
                    }
                    StartDraggingBySelection();
                    if(!hoverWasSelectedOnMousedown) {
                        // And then clear the selection again, since they
                        // probably didn't want that selected if they just
                        // were dragging it.
                        ClearSelection();
                    }
                    hover.Clear();
                    pending.operation = Pending::DRAGGING_POINTS;
                }
            } else if(hover.constraint.v &amp;&amp;
                            SK.GetConstraint(hover.constraint)-&gt;HasLabel())
            {
                ClearSelection();
                pending.constraint = hover.constraint;
                pending.operation = Pending::DRAGGING_CONSTRAINT;
            }
            if(pending.operation != Pending::NONE) {
                // We just started a drag, so remember for the undo before
                // the drag changes anything.
                SS.UndoRemember();
            } else {
                if(!hover.constraint.v) {
                    // That's just marquee selection, which should not cause
                    // an undo remember.
                    if(dm &gt; 10) {
                        if(hover.entity.v) {
                            // Avoid accidentally selecting workplanes when
                            // starting drags.
                            MakeUnselected(hover.entity, /*coincidentPointTrick=*/false);
                            hover.Clear();
                        }
                        pending.operation = Pending::DRAGGING_MARQUEE;
                        orig.marqueePoint =
                            UnProjectPoint(orig.mouseOnButtonDown);
                    }
                }
            }
        } else {
            // Otherwise, just hit test and give up; but don't hit test
            // if the mouse is down, because then the user could hover
            // a point, mouse down (thus selecting it), and drag, in an
            // effort to drag the point, but instead hover a different
            // entity before we move far enough to start the drag.
            if(!leftDown) {
                // Hit testing can potentially take a lot of time.
                // If we haven't painted since last time we highlighted
                // something, don't hit test again, since this just causes
                // a lag.
                if(!havePainted) return;
                HitTestMakeSelection(mp);
            }
        }
        return;
    }

    // If the user has started an operation from the menu, but not
    // completed it, then just do the selection.
    if(pending.operation == Pending::COMMAND) {
        HitTestMakeSelection(mp);
        return;
    }

    // We're currently dragging something; so do that. But if we haven't
    // painted since the last time we solved, do nothing, because there's
    // no sense solving a frame and not displaying it.
    if(!havePainted) {
        if(pending.operation == Pending::DRAGGING_POINTS &amp;&amp; ctrlDown) {
            SS.extraLine.ptA = UnProjectPoint(orig.mouseOnButtonDown);
            SS.extraLine.ptB = UnProjectPoint(mp);
            SS.extraLine.draw = true;
        }
        return;
    }

    havePainted = false;
    switch(pending.operation) {
        case Pending::DRAGGING_CONSTRAINT: {
            Constraint *c = SK.constraint.FindById(pending.constraint);
            UpdateDraggedNum(&amp;(c-&gt;disp.offset), x, y);
            orig.mouse = mp;
            Invalidate();
            return;
        }

        case Pending::DRAGGING_NEW_LINE_POINT:
            if(!ctrlDown) {
                SS.GW.pending.hasSuggestion =
                    SS.GW.SuggestLineConstraint(SS.GW.pending.request, &amp;SS.GW.pending.suggestion);
            } else {
                SS.GW.pending.hasSuggestion = false;
            }
            // fallthrough
        case Pending::DRAGGING_NEW_POINT:
            UpdateDraggedPoint(pending.point, x, y);
            HitTestMakeSelection(mp);
            SS.MarkGroupDirtyByEntity(pending.point);
            orig.mouse = mp;
            Invalidate();
            break;

        case Pending::DRAGGING_POINTS:
            if(shiftDown || ctrlDown) {
                // Edit the rotation associated with a POINT_N_ROT_TRANS,
                // either within (ctrlDown) or out of (shiftDown) the plane
                // of the screen. So first get the rotation to apply, in qt.
                Quaternion qt;
                if(ctrlDown) {
                    double d = mp.DistanceTo(orig.mouseOnButtonDown);
                    if(d &lt; 25) {
                        // Don't start dragging the position about the normal
                        // until we're a little ways out, to get a reasonable
                        // reference pos
                        orig.mouse = mp;
                        break;
                    }
                    double theta = atan2(orig.mouse.y-orig.mouseOnButtonDown.y,
                } else {
                    double dx = -(x - orig.mouse.x);
                    double dy = -(y - orig.mouse.y);
                    double s = 0.3*(PI/180); // degrees per pixel
                    qt = Quaternion::From(projUp,   -s*dx).Times(
                         Quaternion::From(projRight, s*dy));
                }
                orig.mouse = mp;

                // Now apply this rotation to the points being dragged.
                List&lt;hEntity&gt; *lhe = &amp;(pending.points);
                for(hEntity *he = lhe-&gt;First(); he; he = lhe-&gt;NextAfter(he)) {
                    Entity *e = SK.GetEntity(*he);
                    if(e-&gt;type != Entity::Type::POINT_N_ROT_TRANS) {
                        if(ctrlDown) {
                            Vector p = e-&gt;PointGetNum();
                            p = p.Minus(SS.extraLine.ptA);
                            p = qt.Rotate(p);
                            p = p.Plus(SS.extraLine.ptA);
                            e-&gt;PointForceTo(p);
                            SS.MarkGroupDirtyByEntity(e-&gt;h);
                        }
                        continue;
                    }

                    Quaternion q = e-&gt;PointGetQuaternion();
                    Vector     p = e-&gt;PointGetNum();
                    q = qt.Times(q);
                    e-&gt;PointForceQuaternionTo(q);
                    // Let's rotate about the selected point; so fix up the
                    // translation so that that point didn't move.
                    e-&gt;PointForceTo(p);
                    SS.MarkGroupDirtyByEntity(e-&gt;h);
                }
            } else {
                List&lt;hEntity&gt; *lhe = &amp;(pending.points);
                for(hEntity *he = lhe-&gt;First(); he; he = lhe-&gt;NextAfter(he)) {
                    UpdateDraggedPoint(*he, x, y);
                    SS.MarkGroupDirtyByEntity(*he);
                }
                orig.mouse = mp;
            }
            break;

        case Pending::DRAGGING_NEW_CUBIC_POINT: {
            UpdateDraggedPoint(pending.point, x, y);
            HitTestMakeSelection(mp);

            hRequest hr = pending.point.request();
            if(pending.point == hr.entity(4)) {
                // The very first segment; dragging final point drags both
                // tangent points.
                Vector p0 = SK.GetEntity(hr.entity(1))-&gt;PointGetNum(),
                       p3 = SK.GetEntity(hr.entity(4))-&gt;PointGetNum(),
                       p1 = p0.ScaledBy(2.0/3).Plus(p3.ScaledBy(1.0/3)),
                       p2 = p0.ScaledBy(1.0/3).Plus(p3.ScaledBy(2.0/3));
                SK.GetEntity(hr.entity(1+1))-&gt;PointForceTo(p1);
                SK.GetEntity(hr.entity(1+2))-&gt;PointForceTo(p2);
            } else {
                // A subsequent segment; dragging point drags only final
                // tangent point.
                int i = SK.GetEntity(hr.entity(0))-&gt;extraPoints;
                Vector pn   = SK.GetEntity(hr.entity(4+i))-&gt;PointGetNum(),
                       pnm2 = SK.GetEntity(hr.entity(2+i))-&gt;PointGetNum(),
                       pnm1 = (pn.Plus(pnm2)).ScaledBy(0.5);
                SK.GetEntity(hr.entity(3+i))-&gt;PointForceTo(pnm1);
            }

            orig.mouse = mp;
            SS.MarkGroupDirtyByEntity(pending.point);
            break;
        }
        case Pending::DRAGGING_NEW_ARC_POINT: {
            UpdateDraggedPoint(pending.point, x, y);
            HitTestMakeSelection(mp);

            hRequest hr = pending.point.request();
            Vector ona = SK.GetEntity(hr.entity(2))-&gt;PointGetNum();
            Vector onb = SK.GetEntity(hr.entity(3))-&gt;PointGetNum();
            Vector center = (ona.Plus(onb)).ScaledBy(0.5);

            SK.GetEntity(hr.entity(1))-&gt;PointForceTo(center);

            orig.mouse = mp;
            SS.MarkGroupDirtyByEntity(pending.point);
            break;
        }
        case Pending::DRAGGING_NEW_RADIUS:
        case Pending::DRAGGING_RADIUS: {
            Entity *circle = SK.GetEntity(pending.circle);
            Vector center = SK.GetEntity(circle-&gt;point[0])-&gt;PointGetNum();
            Point2d c2 = ProjectPoint(center);
            double r = c2.DistanceTo(mp)/scale;
            SK.GetEntity(circle-&gt;distance)-&gt;DistanceForceTo(r);

            SS.MarkGroupDirtyByEntity(pending.circle);
            break;
        }

        case Pending::DRAGGING_NORMAL: {
            Entity *normal = SK.GetEntity(pending.normal);
            Vector p = SK.GetEntity(normal-&gt;point[0])-&gt;PointGetNum();
            Point2d p2 = ProjectPoint(p);

            Quaternion q = normal-&gt;NormalGetNum();
            Vector u = q.RotationU(), v = q.RotationV();

            if(ctrlDown) {
                double theta = atan2(orig.mouse.y-p2.y, orig.mouse.x-p2.x);
                theta -= atan2(y-p2.y, x-p2.x);

                Vector normal = projRight.Cross(projUp);
                u = u.RotatedAbout(normal, -theta);
                v = v.RotatedAbout(normal, -theta);
            } else {
                double dx = -(x - orig.mouse.x);
                double dy = -(y - orig.mouse.y);
                double s = 0.3*(PI/180); // degrees per pixel
                u = u.RotatedAbout(projUp, -s*dx);
                u = u.RotatedAbout(projRight, s*dy);
                v = v.RotatedAbout(projUp, -s*dx);
                v = v.RotatedAbout(projRight, s*dy);
            }
            orig.mouse = mp;
            normal-&gt;NormalForceTo(Quaternion::From(u, v));

            SS.MarkGroupDirtyByEntity(pending.normal);
            break;
        }

        case Pending::DRAGGING_MARQUEE:
            orig.mouse = mp;
            Invalidate();
            return;

        case Pending::NONE:
        case Pending::COMMAND:
            ssassert(false, "Unexpected pending operation");
    }
}

</t>
<t tx="leo.20191228122646.170">bool SetLocale(uint16_t lcid) {
    return SetLocale([&amp;](const Locale &amp;locale) {
        return locale.lcid == lcid;
    });
}

</t>
<t tx="leo.20191228122646.171">const std::string &amp;Translate(const char *msgid) {
    TranslationKey key = {};
    key.ident      = msgid;
    return currentTranslation-&gt;Translate(key);
}

</t>
<t tx="leo.20191228122646.172">const std::string &amp;Translate(const char *msgctxt, const char *msgid) {
    TranslationKey key = {};
    key.hasContext = true;
    key.context    = msgctxt;
    key.ident      = msgid;
    return currentTranslation-&gt;Translate(key);
}

</t>
<t tx="leo.20191228122646.173">const std::string &amp;TranslatePlural(const char *msgid, unsigned n) {
    TranslationKey key = {};
    key.ident      = msgid;
    return currentTranslation-&gt;TranslatePlural(key, n);
}

</t>
<t tx="leo.20191228122646.174">const std::string &amp;TranslatePlural(const char *msgctxt, const char *msgid, unsigned n) {
    TranslationKey key = {};
    key.hasContext = true;
    key.context    = msgctxt;
    key.ident      = msgid;
    return currentTranslation-&gt;TranslatePlural(key, n);
}

}
</t>
<t tx="leo.20191228122646.18">void GraphicsWindow::ClearPending(bool scheduleShowTW) {
    pending.points.Clear();
    pending.requests.Clear();
    pending = {};
    if(scheduleShowTW) {
        SS.ScheduleShowTW();
    }
}

</t>
<t tx="leo.20191228122646.19">bool GraphicsWindow::IsFromPending(hRequest r) {
    for(auto &amp;req : pending.requests) {
        if(req == r) return true;
    }
    return false;
}

</t>
<t tx="leo.20191228122646.2">void GraphicsWindow::ReplacePointInConstraints(hEntity oldpt, hEntity newpt) {
    for(auto &amp;c : SK.constraint) {
        if(c.ptA == oldpt)
            c.ptA = newpt;
        if(c.ptB == oldpt)
            c.ptB = newpt;
    }
}

//-----------------------------------------------------------------------------
// Remove constraints on hpt. Useful when removing bezier points.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122646.20">void GraphicsWindow::AddToPending(hRequest r) {
    pending.requests.Add(&amp;r);
}

</t>
<t tx="leo.20191228122646.21">void GraphicsWindow::ReplacePending(hRequest before, hRequest after) {
    for(auto &amp;req : pending.requests) {
        if(req == before) {
            req = after;
        }
    }
}

</t>
<t tx="leo.20191228122646.22">void GraphicsWindow::MouseMiddleOrRightDown(double x, double y) {
    if(window-&gt;IsEditorVisible()) return;

    orig.offset = offset;
    orig.projUp = projUp;
    orig.projRight = projRight;
    orig.mouse.x = x;
    orig.mouse.y = y;
    orig.startedMoving = false;
}

</t>
<t tx="leo.20191228122646.23">void GraphicsWindow::MouseRightUp(double x, double y) {
    SS.extraLine.draw = false;
    Invalidate();

    // Don't show a context menu if the user is right-clicking the toolbar,
    // or if they are finishing a pan.
    if(ToolbarMouseMoved((int)x, (int)y)) return;
    if(orig.startedMoving) return;

    if(context.active) return;

    if(pending.operation == Pending::DRAGGING_NEW_LINE_POINT &amp;&amp; pending.hasSuggestion) {
        Constraint::TryConstrain(SS.GW.pending.suggestion,
            Entity::NO_ENTITY, Entity::NO_ENTITY, pending.request.entity(0));
    }

    if(pending.operation == Pending::DRAGGING_NEW_LINE_POINT ||
       pending.operation == Pending::DRAGGING_NEW_CUBIC_POINT)
    {
        // Special case; use a right click to stop drawing lines, since
        // a left click would draw another one. This is quicker and more
        // intuitive than hitting escape. Likewise for new cubic segments.
        ClearPending();
        return;
    }

    // The current mouse location
    Vector v = offset.ScaledBy(-1);
    v = v.Plus(projRight.ScaledBy(x/scale));
    v = v.Plus(projUp.ScaledBy(y/scale));

    Platform::MenuRef menu = Platform::CreateMenu();
    context.active = true;

    if(!hover.IsEmpty()) {
        MakeSelected(&amp;hover);
        SS.ScheduleShowTW();
    }
    GroupSelection();

    bool itemsSelected = (gs.n &gt; 0 || gs.constraints &gt; 0);
    if(itemsSelected) {
        if(gs.stylables &gt; 0) {
            Platform::MenuRef styleMenu = menu-&gt;AddSubMenu(_("Assign to Style"));

            bool empty = true;
            for(const Style &amp;s : SK.style) {
                if(s.h.v &lt; Style::FIRST_CUSTOM) continue;

                styleMenu-&gt;AddItem(s.DescriptionString(), [&amp;]() {
                    Style::AssignSelectionToStyle(s.h.v);
                });
                empty = false;
            }

            if(!empty) styleMenu-&gt;AddSeparator();

            styleMenu-&gt;AddItem(_("No Style"), [&amp;]() {
                Style::AssignSelectionToStyle(0);
            });
            styleMenu-&gt;AddItem(_("Newly Created Custom Style..."), [&amp;]() {
                uint32_t vs = Style::CreateCustomStyle();
                Style::AssignSelectionToStyle(vs);
                ForceTextWindowShown();
            });
        }
        if(gs.n + gs.constraints == 1) {
            menu-&gt;AddItem(_("Group Info"), [&amp;]() {
                hGroup hg;
                if(gs.entities == 1) {
                    hg = SK.GetEntity(gs.entity[0])-&gt;group;
                } else if(gs.points == 1) {
                    hg = SK.GetEntity(gs.point[0])-&gt;group;
                } else if(gs.constraints == 1) {
                    hg = SK.GetConstraint(gs.constraint[0])-&gt;group;
                } else {
                    return;
                }
                ClearSelection();

                SS.TW.GoToScreen(TextWindow::Screen::GROUP_INFO);
                SS.TW.shown.group = hg;
                SS.ScheduleShowTW();
                ForceTextWindowShown();
            });
        }
        if(gs.n + gs.constraints == 1 &amp;&amp; gs.stylables == 1) {
            menu-&gt;AddItem(_("Style Info"), [&amp;]() {
                hStyle hs;
                if(gs.entities == 1) {
                    hs = Style::ForEntity(gs.entity[0]);
                } else if(gs.points == 1) {
                    hs = Style::ForEntity(gs.point[0]);
                } else if(gs.constraints == 1) {
                    hs = SK.GetConstraint(gs.constraint[0])-&gt;GetStyle();
                } else {
                    return;
                }
                ClearSelection();

                SS.TW.GoToScreen(TextWindow::Screen::STYLE_INFO);
                SS.TW.shown.style = hs;
                SS.ScheduleShowTW();
                ForceTextWindowShown();
            });
        }
        if(gs.withEndpoints &gt; 0) {
            menu-&gt;AddItem(_("Select Edge Chain"),
                          [&amp;]() { MenuEdit(Command::SELECT_CHAIN); });
        }
        if(gs.constraints == 1 &amp;&amp; gs.n == 0) {
            Constraint *c = SK.GetConstraint(gs.constraint[0]);
            if(c-&gt;HasLabel() &amp;&amp; c-&gt;type != Constraint::Type::COMMENT) {
                menu-&gt;AddItem(_("Toggle Reference Dimension"),
                              [&amp;]() { Constraint::MenuConstrain(Command::REFERENCE); });
            }
            if(c-&gt;type == Constraint::Type::ANGLE ||
               c-&gt;type == Constraint::Type::EQUAL_ANGLE)
            {
                menu-&gt;AddItem(_("Other Supplementary Angle"),
                              [&amp;]() { Constraint::MenuConstrain(Command::OTHER_ANGLE); });
            }
        }
        if(gs.constraintLabels &gt; 0 || gs.points &gt; 0) {
            menu-&gt;AddItem(_("Snap to Grid"),
                          [&amp;]() { MenuEdit(Command::SNAP_TO_GRID); });
        }

        if(gs.points == 1 &amp;&amp; gs.point[0].isFromRequest()) {
            Request *r = SK.GetRequest(gs.point[0].request());
            int index = r-&gt;IndexOfPoint(gs.point[0]);
            if((r-&gt;type == Request::Type::CUBIC &amp;&amp; (index &gt; 1 &amp;&amp; index &lt; r-&gt;extraPoints + 2)) ||
                    r-&gt;type == Request::Type::CUBIC_PERIODIC) {
                menu-&gt;AddItem(_("Remove Spline Point"), [&amp;]() {
                    int index = r-&gt;IndexOfPoint(gs.point[0]);
                    ssassert(r-&gt;extraPoints != 0,
                             "Expected a bezier with interior control points");

                    SS.UndoRemember();
                    Entity *e = SK.GetEntity(r-&gt;h.entity(0));

                    // First, fix point-coincident constraints involving this point.
                    // Then, remove all other constraints, since they would otherwise
                    // jump to an adjacent one and mess up the bezier after generation.
                    FixConstraintsForPointBeingDeleted(e-&gt;point[index]);
                    RemoveConstraintsForPointBeingDeleted(e-&gt;point[index]);

                    for(int i = index; i &lt; MAX_POINTS_IN_ENTITY - 1; i++) {
                        if(e-&gt;point[i + 1].v == 0) break;
                        Entity *p0 = SK.GetEntity(e-&gt;point[i]);
                        Entity *p1 = SK.GetEntity(e-&gt;point[i + 1]);
                        ReplacePointInConstraints(p1-&gt;h, p0-&gt;h);
                        p0-&gt;PointForceTo(p1-&gt;PointGetNum());
                    }
                    r-&gt;extraPoints--;
                    SS.MarkGroupDirtyByEntity(gs.point[0]);
                    ClearSelection();
                });
            }
        }
        if(gs.entities == 1 &amp;&amp; gs.entity[0].isFromRequest()) {
            Request *r = SK.GetRequest(gs.entity[0].request());
            if(r-&gt;type == Request::Type::CUBIC || r-&gt;type == Request::Type::CUBIC_PERIODIC) {
                Entity *e = SK.GetEntity(gs.entity[0]);
                int addAfterPoint = e-&gt;GetPositionOfPoint(GetCamera(), Point2d::From(x, y));
                ssassert(addAfterPoint != -1, "Expected a nearest bezier point to be located");
                // Skip derivative point.
                if(r-&gt;type == Request::Type::CUBIC) addAfterPoint++;
                menu-&gt;AddItem(_("Add Spline Point"), [&amp;]() {
                    @others
}

hRequest GraphicsWindow::AddRequest(Request::Type type) {
    return AddRequest(type, /*rememberForUndo=*/true);
}
hRequest GraphicsWindow::AddRequest(Request::Type type, bool rememberForUndo) {
    if(rememberForUndo) SS.UndoRemember();

    Request r = {};
    r.group = activeGroup;
    Group *g = SK.GetGroup(activeGroup);
    if(g-&gt;type == Group::Type::DRAWING_3D || g-&gt;type == Group::Type::DRAWING_WORKPLANE) {
        r.construction = false;
    } else {
        r.construction = true;
    }
    r.workplane = ActiveWorkplane();
    r.type = type;
    SK.request.AddAndAssignId(&amp;r);

    // We must regenerate the parameters, so that the code that tries to
    // place this request's entities where the mouse is can do so. But
    // we mustn't try to solve until reasonable values have been supplied
    // for these new parameters, or else we'll get a numerical blowup.
    r.Generate(&amp;SK.entity, &amp;SK.param);
    SS.MarkGroupDirty(r.group);
    return r.h;
}

Vector GraphicsWindow::SnapToEntityByScreenPoint(Point2d pp, hEntity he) {
    Entity *e = SK.GetEntity(he);
    if(e-&gt;IsPoint()) return e-&gt;PointGetNum();
    SEdgeList *edges = e-&gt;GetOrGenerateEdges();

    double minD = -1.0f;
    double k;
    const SEdge *edge = NULL;
    for(const auto &amp;e : edges-&gt;l) {
        Point2d p0 = ProjectPoint(e.a);
        Point2d p1 = ProjectPoint(e.b);
        Point2d dir = p1.Minus(p0);
        double d = pp.DistanceToLine(p0, dir, /*asSegment=*/true);
        if(minD &gt; 0.0 &amp;&amp; d &gt; minD) continue;
        minD = d;
        k = pp.Minus(p0).Dot(dir) / dir.Dot(dir);
        edge = &amp;e;
    }
    if(edge == NULL) return UnProjectPoint(pp);
    return edge-&gt;a.Plus(edge-&gt;b.Minus(edge-&gt;a).ScaledBy(k));
}

</t>
<t tx="leo.20191228122646.24">                int pointCount = r-&gt;extraPoints +
                                 ((r-&gt;type == Request::Type::CUBIC_PERIODIC) ? 3 : 4);
                if(pointCount &gt;= MAX_POINTS_IN_ENTITY) {
                    Error(_("Cannot add spline point: maximum number of points reached."));
                    return;
                }

                SS.UndoRemember();
                r-&gt;extraPoints++;
                SS.MarkGroupDirtyByEntity(gs.entity[0]);
                SS.GenerateAll(SolveSpaceUI::Generate::REGEN);

                Entity *e = SK.GetEntity(r-&gt;h.entity(0));
                for(int i = MAX_POINTS_IN_ENTITY; i &gt; addAfterPoint + 1; i--) {
                    Entity *p0 = SK.entity.FindByIdNoOops(e-&gt;point[i]);
                    if(p0 == NULL) continue;
                    Entity *p1 = SK.GetEntity(e-&gt;point[i - 1]);
                    ReplacePointInConstraints(p1-&gt;h, p0-&gt;h);
                    p0-&gt;PointForceTo(p1-&gt;PointGetNum());
                }
                Entity *p = SK.GetEntity(e-&gt;point[addAfterPoint + 1]);
                p-&gt;PointForceTo(v);
                SS.MarkGroupDirtyByEntity(gs.entity[0]);
                ClearSelection();
            });
        }
    }
    if(gs.entities == gs.n) {
        menu-&gt;AddItem(_("Toggle Construction"),
                      [&amp;]() { MenuRequest(Command::CONSTRUCTION); });
    }

    if(gs.points == 1) {
        Entity *p = SK.GetEntity(gs.point[0]);
        Constraint *c;
        IdList&lt;Constraint,hConstraint&gt; *lc = &amp;(SK.constraint);
        for(c = lc-&gt;First(); c; c = lc-&gt;NextAfter(c)) {
            if(c-&gt;type != Constraint::Type::POINTS_COINCIDENT) continue;
            if(c-&gt;ptA == p-&gt;h || c-&gt;ptB == p-&gt;h) {
                break;
            }
        }
        if(c) {
            menu-&gt;AddItem(_("Delete Point-Coincident Constraint"), [&amp;]() {
                if(!p-&gt;IsPoint()) return;

                SS.UndoRemember();
                SK.constraint.ClearTags();
                Constraint *c;
                for(c = SK.constraint.First(); c; c = SK.constraint.NextAfter(c)) {
                    if(c-&gt;type != Constraint::Type::POINTS_COINCIDENT) continue;
                    if(c-&gt;ptA == p-&gt;h || c-&gt;ptB == p-&gt;h) {
                        c-&gt;tag = 1;
                    }
                }
                SK.constraint.RemoveTagged();
                ClearSelection();
            });
        }
    }
    menu-&gt;AddSeparator();
    if(LockedInWorkplane()) {
        menu-&gt;AddItem(_("Cut"),
                      [&amp;]() { MenuClipboard(Command::CUT); });
        menu-&gt;AddItem(_("Copy"),
                      [&amp;]() { MenuClipboard(Command::COPY); });
    }
} else {
    menu-&gt;AddItem(_("Select All"),
                  [&amp;]() { MenuEdit(Command::SELECT_ALL); });
}

if((!SS.clipboard.r.IsEmpty() || !SS.clipboard.c.IsEmpty()) &amp;&amp; LockedInWorkplane()) {
    menu-&gt;AddItem(_("Paste"),
                  [&amp;]() { MenuClipboard(Command::PASTE); });
    menu-&gt;AddItem(_("Paste Transformed..."),
                  [&amp;]() { MenuClipboard(Command::PASTE_TRANSFORM); });
}

if(itemsSelected) {
    menu-&gt;AddItem(_("Delete"),
                  [&amp;]() { MenuClipboard(Command::DELETE); });
    menu-&gt;AddSeparator();
    menu-&gt;AddItem(_("Unselect All"),
                  [&amp;]() { MenuEdit(Command::UNSELECT_ALL); });
}
// If only one item is selected, then it must be the one that we just
// selected from the hovered item; in which case unselect all and hovered
// are equivalent.
if(!hover.IsEmpty() &amp;&amp; selection.n &gt; 1) {
    menu-&gt;AddItem(_("Unselect Hovered"), [&amp;] {
        if(!hover.IsEmpty()) {
            MakeUnselected(&amp;hover, /*coincidentPointTrick=*/true);
        }
    });
}

if(itemsSelected) {
    menu-&gt;AddSeparator();
    menu-&gt;AddItem(_("Zoom to Fit"),
                  [&amp;]() { MenuView(Command::ZOOM_TO_FIT); });
}

menu-&gt;PopUp();

context.active = false;
SS.ScheduleShowTW();
</t>
<t tx="leo.20191228122646.25">bool GraphicsWindow::ConstrainPointByHovered(hEntity pt, const Point2d *projected) {
    if(!hover.entity.v) return false;

    Entity *point = SK.GetEntity(pt);
    Entity *e = SK.GetEntity(hover.entity);
    if(e-&gt;IsPoint()) {
        point-&gt;PointForceTo(e-&gt;PointGetNum());
        Constraint::ConstrainCoincident(e-&gt;h, pt);
        return true;
    }
    if(e-&gt;IsCircle()) {
        if(projected != NULL) {
            Vector snapPos = SnapToEntityByScreenPoint(*projected, e-&gt;h);
            point-&gt;PointForceTo(snapPos);
        }
        Constraint::Constrain(Constraint::Type::PT_ON_CIRCLE,
            pt, Entity::NO_ENTITY, e-&gt;h);
        return true;
    }
    if(e-&gt;type == Entity::Type::LINE_SEGMENT) {
        if(projected != NULL) {
            Vector snapPos = SnapToEntityByScreenPoint(*projected, e-&gt;h);
            point-&gt;PointForceTo(snapPos);
        }
        Constraint::Constrain(Constraint::Type::PT_ON_LINE,
            pt, Entity::NO_ENTITY, e-&gt;h);
        return true;
    }

    return false;
}

</t>
<t tx="leo.20191228122646.26">bool GraphicsWindow::MouseEvent(Platform::MouseEvent event) {
    using Platform::MouseEvent;

    double width, height;
    window-&gt;GetContentSize(&amp;width, &amp;height);

    event.x = event.x - width / 2;
    event.y = height / 2 - event.y;

    switch(event.type) {
        case MouseEvent::Type::MOTION:
            this-&gt;MouseMoved(event.x, event.y,
                             event.button == MouseEvent::Button::LEFT,
                             event.button == MouseEvent::Button::MIDDLE,
                             event.button == MouseEvent::Button::RIGHT,
                             event.shiftDown,
                             event.controlDown);
            break;

        case MouseEvent::Type::PRESS:
            if(event.button == MouseEvent::Button::LEFT) {
                this-&gt;MouseLeftDown(event.x, event.y, event.shiftDown, event.controlDown);
            } else if(event.button == MouseEvent::Button::MIDDLE ||
                      event.button == MouseEvent::Button::RIGHT) {
                this-&gt;MouseMiddleOrRightDown(event.x, event.y);
            }
            break;

        case MouseEvent::Type::DBL_PRESS:
            if(event.button == MouseEvent::Button::LEFT) {
                this-&gt;MouseLeftDoubleClick(event.x, event.y);
            }
            break;

        case MouseEvent::Type::RELEASE:
            if(event.button == MouseEvent::Button::LEFT) {
                this-&gt;MouseLeftUp(event.x, event.y, event.shiftDown, event.controlDown);
            } else if(event.button == MouseEvent::Button::RIGHT) {
                this-&gt;MouseRightUp(event.x, event.y);
            }
            break;

        case MouseEvent::Type::SCROLL_VERT:
            this-&gt;MouseScroll(event.x, event.y, (int)event.scrollDelta);
            break;

        case MouseEvent::Type::LEAVE:
            this-&gt;MouseLeave();
            break;
    }

    return true;
}

</t>
<t tx="leo.20191228122646.27">void GraphicsWindow::MouseLeftDown(double mx, double my, bool shiftDown, bool ctrlDown) {
    orig.mouseDown = true;

    if(window-&gt;IsEditorVisible()) {
        orig.mouse = Point2d::From(mx, my);
        orig.mouseOnButtonDown = orig.mouse;
        window-&gt;HideEditor();
        return;
    }
    SS.TW.HideEditControl();

    if(SS.showToolbar) {
        if(ToolbarMouseDown((int)mx, (int)my)) return;
    }

    // This will be clobbered by MouseMoved below.
    bool hasConstraintSuggestion = pending.hasSuggestion;
    Constraint::Type constraintSuggestion = pending.suggestion;

    // Make sure the hover is up to date.
    MouseMoved(mx, my, /*leftDown=*/false, /*middleDown=*/false, /*rightDown=*/false,
        /*shiftDown=*/false, /*ctrlDown=*/false);
    orig.mouse.x = mx;
    orig.mouse.y = my;
    orig.mouseOnButtonDown = orig.mouse;
    Point2d mouse = Point2d::From(mx, my);

    // The current mouse location
    Vector v = offset.ScaledBy(-1);
    v = v.Plus(projRight.ScaledBy(mx/scale));
    v = v.Plus(projUp.ScaledBy(my/scale));

    hRequest hr = {};
    hConstraint hc = {};
    switch(pending.operation) {
        case Pending::COMMAND:
            switch(pending.command) {
                case Command::DATUM_POINT:
                    hr = AddRequest(Request::Type::DATUM_POINT);
                    SK.GetEntity(hr.entity(0))-&gt;PointForceTo(v);
                    ConstrainPointByHovered(hr.entity(0), &amp;mouse);

                    ClearSuper();
                    break;

                case Command::LINE_SEGMENT:
                case Command::CONSTR_SEGMENT:
                    hr = AddRequest(Request::Type::LINE_SEGMENT);
                    SK.GetRequest(hr)-&gt;construction = (pending.command == Command::CONSTR_SEGMENT);
                    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(v);
                    ConstrainPointByHovered(hr.entity(1), &amp;mouse);

                    ClearSuper();
                    AddToPending(hr);

                    pending.operation = Pending::DRAGGING_NEW_LINE_POINT;
                    pending.request = hr;
                    pending.point = hr.entity(2);
                    pending.description = _("click next point of line, or press Esc");
                    SK.GetEntity(pending.point)-&gt;PointForceTo(v);
                    break;

                case Command::RECTANGLE: {
                    if(!SS.GW.LockedInWorkplane()) {
                        Error(_("Can't draw rectangle in 3d; first, activate a workplane "
                                "with Sketch -&gt; In Workplane."));
                        ClearSuper();
                        break;
                    }
                    hRequest lns[4];
                    int i;
                    SS.UndoRemember();
                    for(i = 0; i &lt; 4; i++) {
                        lns[i] = AddRequest(Request::Type::LINE_SEGMENT, /*rememberForUndo=*/false);
                        AddToPending(lns[i]);
                    }
                    for(i = 0; i &lt; 4; i++) {
                        Constraint::ConstrainCoincident(
                            lns[i].entity(1), lns[(i+1)%4].entity(2));
                        SK.GetEntity(lns[i].entity(1))-&gt;PointForceTo(v);
                        SK.GetEntity(lns[i].entity(2))-&gt;PointForceTo(v);
                    }
                    for(i = 0; i &lt; 4; i++) {
                        Constraint::Constrain(
                            (i % 2) ? Constraint::Type::HORIZONTAL : Constraint::Type::VERTICAL,
                            Entity::NO_ENTITY, Entity::NO_ENTITY,
                            lns[i].entity(0));
                    }
                    if(ConstrainPointByHovered(lns[2].entity(1), &amp;mouse)) {
                        Vector pos = SK.GetEntity(lns[2].entity(1))-&gt;PointGetNum();
                        for(i = 0; i &lt; 4; i++) {
                            SK.GetEntity(lns[i].entity(1))-&gt;PointForceTo(pos);
                            SK.GetEntity(lns[i].entity(2))-&gt;PointForceTo(pos);
                        }
                    }

                    pending.operation = Pending::DRAGGING_NEW_POINT;
                    pending.point = lns[1].entity(2);
                    pending.description = _("click to place other corner of rectangle");
                    hr = lns[0];
                    break;
                }
                case Command::CIRCLE:
                    hr = AddRequest(Request::Type::CIRCLE);
                    // Centered where we clicked
                    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(v);
                    // Normal to the screen
                    SK.GetEntity(hr.entity(32))-&gt;NormalForceTo(
                        Quaternion::From(SS.GW.projRight, SS.GW.projUp));
                    // Initial radius zero
                    SK.GetEntity(hr.entity(64))-&gt;DistanceForceTo(0);

                    ConstrainPointByHovered(hr.entity(1), &amp;mouse);

                    ClearSuper();

                    pending.operation = Pending::DRAGGING_NEW_RADIUS;
                    pending.circle = hr.entity(0);
                    pending.description = _("click to set radius");
                    break;

                case Command::ARC: {
                    if(!SS.GW.LockedInWorkplane()) {
                        Error(_("Can't draw arc in 3d; first, activate a workplane "
                                "with Sketch -&gt; In Workplane."));
                        ClearPending();
                        break;
                    }
                    hr = AddRequest(Request::Type::ARC_OF_CIRCLE);
                    // This fudge factor stops us from immediately failing to solve
                    // because of the arc's implicit (equal radius) tangent.
                    Vector adj = SS.GW.projRight.WithMagnitude(2/SS.GW.scale);
                    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(v.Minus(adj));
                    SK.GetEntity(hr.entity(2))-&gt;PointForceTo(v);
                    SK.GetEntity(hr.entity(3))-&gt;PointForceTo(v);
                    ConstrainPointByHovered(hr.entity(2), &amp;mouse);

                    ClearSuper();
                    AddToPending(hr);

                    pending.operation = Pending::DRAGGING_NEW_ARC_POINT;
                    pending.point = hr.entity(3);
                    pending.description = _("click to place point");
                    break;
                }
                case Command::CUBIC:
                    hr = AddRequest(Request::Type::CUBIC);
                    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(v);
                    SK.GetEntity(hr.entity(2))-&gt;PointForceTo(v);
                    SK.GetEntity(hr.entity(3))-&gt;PointForceTo(v);
                    SK.GetEntity(hr.entity(4))-&gt;PointForceTo(v);
                    ConstrainPointByHovered(hr.entity(1), &amp;mouse);

                    ClearSuper();
                    AddToPending(hr);

                    pending.operation = Pending::DRAGGING_NEW_CUBIC_POINT;
                    pending.point = hr.entity(4);
                    pending.description = _("click next point of cubic, or press Esc");
                    break;

                case Command::WORKPLANE:
                    if(LockedInWorkplane()) {
                        Error(_("Sketching in a workplane already; sketch in 3d before "
                                "creating new workplane."));
                        ClearSuper();
                        break;
                    }
                    hr = AddRequest(Request::Type::WORKPLANE);
                    SK.GetEntity(hr.entity(1))-&gt;PointForceTo(v);
                    SK.GetEntity(hr.entity(32))-&gt;NormalForceTo(
                        Quaternion::From(SS.GW.projRight, SS.GW.projUp));
                    ConstrainPointByHovered(hr.entity(1), &amp;mouse);

                    ClearSuper();
                    break;

                case Command::TTF_TEXT: {
                    if(!SS.GW.LockedInWorkplane()) {
                        Error(_("Can't draw text in 3d; first, activate a workplane "
                                "with Sketch -&gt; In Workplane."));
                        ClearSuper();
                        break;
                    }
                    hr = AddRequest(Request::Type::TTF_TEXT);
                    AddToPending(hr);
                    Request *r = SK.GetRequest(hr);
                    r-&gt;str = "Abc";
                    r-&gt;font = "BitstreamVeraSans-Roman-builtin.ttf";

                    for(int i = 1; i &lt;= 4; i++) {
                        SK.GetEntity(hr.entity(i))-&gt;PointForceTo(v);
                    }

                    pending.operation = Pending::DRAGGING_NEW_POINT;
                    pending.point = hr.entity(3);
                    pending.description = _("click to place bottom right of text");
                    break;
                }

                case Command::IMAGE: {
                    if(!SS.GW.LockedInWorkplane()) {
                        Error(_("Can't draw image in 3d; first, activate a workplane "
                                "with Sketch -&gt; In Workplane."));
                        ClearSuper();
                        break;
                    }
                    hr = AddRequest(Request::Type::IMAGE);
                    AddToPending(hr);
                    Request *r = SK.GetRequest(hr);
                    r-&gt;file = pending.filename;

                    for(int i = 1; i &lt;= 4; i++) {
                        SK.GetEntity(hr.entity(i))-&gt;PointForceTo(v);
                    }

                    pending.operation = Pending::DRAGGING_NEW_POINT;
                    pending.point = hr.entity(3);
                    pending.description = "click to place bottom right of image";
                    break;
                }

                case Command::COMMENT: {
                    ClearSuper();
                    Constraint c = {};
                    c.group       = SS.GW.activeGroup;
                    c.workplane   = SS.GW.ActiveWorkplane();
                    c.type        = Constraint::Type::COMMENT;
                    c.disp.offset = v;
                    c.comment     = _("NEW COMMENT -- DOUBLE-CLICK TO EDIT");
                    hc = Constraint::AddConstraint(&amp;c);
                    break;
                }
                default: ssassert(false, "Unexpected pending menu id");
            }
            break;

        case Pending::DRAGGING_RADIUS:
            ClearPending();
            break;

        case Pending::DRAGGING_NEW_POINT:
        case Pending::DRAGGING_NEW_ARC_POINT:
            ConstrainPointByHovered(pending.point, &amp;mouse);
            ClearPending();
            break;

        case Pending::DRAGGING_NEW_CUBIC_POINT: {
            hRequest hr = pending.point.request();
            Request *r = SK.GetRequest(hr);

            if(hover.entity == hr.entity(1) &amp;&amp; r-&gt;extraPoints &gt;= 2) {
                // They want the endpoints coincident, which means a periodic
                // spline instead.
                r-&gt;type = Request::Type::CUBIC_PERIODIC;
                // Remove the off-curve control points, which are no longer
                // needed here; so move [2,ep+1] down, skipping first pt.
                int i;
                for(i = 2; i &lt;= r-&gt;extraPoints+1; i++) {
                    SK.GetEntity(hr.entity((i-1)+1))-&gt;PointForceTo(
                        SK.GetEntity(hr.entity(i+1))-&gt;PointGetNum());
                }
                // and move ep+3 down by two, skipping both
                SK.GetEntity(hr.entity((r-&gt;extraPoints+1)+1))-&gt;PointForceTo(
                  SK.GetEntity(hr.entity((r-&gt;extraPoints+3)+1))-&gt;PointGetNum());
                r-&gt;extraPoints -= 2;
                // And we're done.
                SS.MarkGroupDirty(r-&gt;group);
                ClearPending();
                break;
            }

            if(ConstrainPointByHovered(pending.point, &amp;mouse)) {
                ClearPending();
                break;
            }

            Entity e;
            if(r-&gt;extraPoints &gt;= (int)arraylen(e.point) - 4) {
                ClearPending();
                break;
            }

            (SK.GetRequest(hr)-&gt;extraPoints)++;
            SS.GenerateAll(SolveSpaceUI::Generate::REGEN);

            int ep = r-&gt;extraPoints;
            Vector last = SK.GetEntity(hr.entity(3+ep))-&gt;PointGetNum();

            SK.GetEntity(hr.entity(2+ep))-&gt;PointForceTo(last);
            SK.GetEntity(hr.entity(3+ep))-&gt;PointForceTo(v);
            SK.GetEntity(hr.entity(4+ep))-&gt;PointForceTo(v);
            pending.point = hr.entity(4+ep);
            break;
        }

        case Pending::DRAGGING_NEW_LINE_POINT: {
            if(hover.entity.v) {
                Entity *e = SK.GetEntity(hover.entity);
                if(e-&gt;IsPoint()) {
                    hRequest hrl = pending.point.request();
                    Entity *sp = SK.GetEntity(hrl.entity(1));
                    if(( e-&gt;PointGetNum()).Equals(
                       (sp-&gt;PointGetNum())))
                    {
                        // If we constrained by the hovered point, then we
                        // would create a zero-length line segment. That's
                        // not good, so just stop drawing.
                        ClearPending();
                        break;
                    }
                }
            }

            bool doneDragging = ConstrainPointByHovered(pending.point, &amp;mouse);

            // Constrain the line segment horizontal or vertical if close enough
            if(hasConstraintSuggestion) {
                Constraint::TryConstrain(constraintSuggestion,
                    Entity::NO_ENTITY, Entity::NO_ENTITY, pending.request.entity(0));
            }

            if(doneDragging) {
                ClearPending();
                break;
            }

            // Create a new line segment, so that we continue drawing.
            hRequest hr = AddRequest(Request::Type::LINE_SEGMENT);
            ReplacePending(pending.request, hr);
            SK.GetRequest(hr)-&gt;construction = SK.GetRequest(pending.request)-&gt;construction;
            // Displace the second point of the new line segment slightly,
            // to avoid creating zero-length edge warnings.
            SK.GetEntity(hr.entity(2))-&gt;PointForceTo(
                v.Plus(projRight.ScaledBy(0.5/scale)));

            // Constrain the line segments to share an endpoint
            Constraint::ConstrainCoincident(pending.point, hr.entity(1));
            Vector pendingPos = SK.GetEntity(pending.point)-&gt;PointGetNum();
            SK.GetEntity(hr.entity(1))-&gt;PointForceTo(pendingPos);

            // And drag an endpoint of the new line segment
            pending.operation = Pending::DRAGGING_NEW_LINE_POINT;
            pending.request = hr;
            pending.point = hr.entity(2);
            pending.description = _("click next point of line, or press Esc");

            break;
        }

        case Pending::NONE:
        default:
            ClearPending();
            if(!hover.IsEmpty()) {
                if(!ctrlDown) {
                    hoverWasSelectedOnMousedown = IsSelected(&amp;hover);
                    MakeSelected(&amp;hover);
                } else {
                    MakeUnselected(&amp;hover, /*coincidentPointTrick=*/true);
                }
            }
            break;
    }

    // Activate group with newly created request/constraint
    Group *g = NULL;
    if(hr.v != 0) {
        g = SK.GetGroup(SK.GetRequest(hr)-&gt;group);
    }
    if(hc.v != 0) {
        g = SK.GetGroup(SK.GetConstraint(hc)-&gt;group);
    }
    if(g != NULL) {
        g-&gt;visible = true;
    }

    SS.ScheduleShowTW();
    Invalidate();
}

</t>
<t tx="leo.20191228122646.28">void GraphicsWindow::MouseLeftUp(double mx, double my, bool shiftDown, bool ctrlDown) {
    orig.mouseDown = false;
    hoverWasSelectedOnMousedown = false;

    switch(pending.operation) {
        case Pending::DRAGGING_POINTS:
            SS.extraLine.draw = false;
            // fall through
        case Pending::DRAGGING_CONSTRAINT:
        case Pending::DRAGGING_NORMAL:
        case Pending::DRAGGING_RADIUS:
            ClearPending();
            Invalidate();
            break;

        case Pending::DRAGGING_MARQUEE:
            SelectByMarquee();
            ClearPending();
            Invalidate();
            break;

        case Pending::NONE:
            if(hover.IsEmpty() &amp;&amp; !ctrlDown) {
                ClearSelection();
            }
            break;

        default:
            break;  // do nothing
    }
}

</t>
<t tx="leo.20191228122646.29">void GraphicsWindow::EditConstraint(hConstraint constraint) {
    constraintBeingEdited = constraint;
    ClearSuper();

    Constraint *c = SK.GetConstraint(constraintBeingEdited);
    if(!c-&gt;HasLabel()) {
        // Not meaningful to edit a constraint without a dimension
        return;
    }
    if(c-&gt;reference) {
        // Not meaningful to edit a reference dimension
        return;
    }

    Vector p3 = c-&gt;GetLabelPos(GetCamera());
    Point2d p2 = ProjectPoint(p3);

    std::string editValue;
    std::string editPlaceholder;
    switch(c-&gt;type) {
        case Constraint::Type::COMMENT:
            editValue = c-&gt;comment;
            editPlaceholder = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
            break;

        default: {
            double value = fabs(c-&gt;valA);

            // If displayed as radius, also edit as radius.
            if(c-&gt;type == Constraint::Type::DIAMETER &amp;&amp; c-&gt;other)
                value /= 2;

            // Try showing value with default number of digits after decimal first.
            if(c-&gt;type == Constraint::Type::LENGTH_RATIO) {
                editValue = ssprintf("%.3f", value);
            } else if(c-&gt;type == Constraint::Type::ANGLE) {
                editValue = SS.DegreeToString(value);
            } else {
                editValue = SS.MmToString(value);
                value /= SS.MmPerUnit();
            }
            // If that's not enough to represent it exactly, show the value with as many
            // digits after decimal as required, up to 10.
            int digits = 0;
            while(fabs(std::stod(editValue) - value) &gt; 1e-10) {
                editValue = ssprintf("%.*f", digits, value);
                digits++;
            }
            editPlaceholder = "10.000000";
            break;
        }
    }

    double width, height;
    window-&gt;GetContentSize(&amp;width, &amp;height);
    hStyle hs = c-&gt;disp.style;
    if(hs.v == 0) hs.v = Style::CONSTRAINT;
    double capHeight = Style::TextHeight(hs);
    double fontHeight = VectorFont::Builtin()-&gt;GetHeight(capHeight);
    double editMinWidth = VectorFont::Builtin()-&gt;GetWidth(capHeight, editPlaceholder);
    window-&gt;ShowEditor(p2.x + width / 2, height / 2 - p2.y,
                        fontHeight, editMinWidth,
                        /*isMonospace=*/false, editValue);
}

</t>
<t tx="leo.20191228122646.3">void GraphicsWindow::RemoveConstraintsForPointBeingDeleted(hEntity hpt) {
    SK.constraint.ClearTags();
    for(auto &amp;c : SK.constraint) {
        if(c.ptA == hpt || c.ptB == hpt) {
            c.tag = 1;
            (SS.deleted.constraints)++;
            if(c.type != Constraint::Type::POINTS_COINCIDENT &amp;&amp;
               c.type != Constraint::Type::HORIZONTAL &amp;&amp;
               c.type != Constraint::Type::VERTICAL)
            {
                (SS.deleted.nonTrivialConstraints)++;
            }
        }
    }
    SK.constraint.RemoveTagged();
}

//-----------------------------------------------------------------------------
// Let's say that A is coincident with B, and B is coincident with C. This
// implies that A is coincident with C; but if we delete B, then both
// constraints must be deleted too (since they reference B), and A is no
// longer constrained to C. This routine adds back that constraint.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122646.30">void GraphicsWindow::MouseLeftDoubleClick(double mx, double my) {
    if(window-&gt;IsEditorVisible()) return;
    SS.TW.HideEditControl();

    if(hover.constraint.v) {
        EditConstraint(hover.constraint);
    }
}

</t>
<t tx="leo.20191228122646.31">void GraphicsWindow::EditControlDone(const std::string &amp;s) {
    window-&gt;HideEditor();
    window-&gt;Invalidate();

    Constraint *c = SK.GetConstraint(constraintBeingEdited);

    if(c-&gt;type == Constraint::Type::COMMENT) {
        SS.UndoRemember();
        c-&gt;comment = s;
        return;
    }

    if(Expr *e = Expr::From(s, true)) {
        SS.UndoRemember();

        switch(c-&gt;type) {
            case Constraint::Type::PROJ_PT_DISTANCE:
            case Constraint::Type::PT_LINE_DISTANCE:
            case Constraint::Type::PT_FACE_DISTANCE:
            case Constraint::Type::PT_PLANE_DISTANCE:
            case Constraint::Type::LENGTH_DIFFERENCE: {
                // The sign is not displayed to the user, but this is a signed
                // distance internally. To flip the sign, the user enters a
                // negative distance.
                bool wasNeg = (c-&gt;valA &lt; 0);
                if(wasNeg) {
                    c-&gt;valA = -SS.ExprToMm(e);
                } else {
                    c-&gt;valA = SS.ExprToMm(e);
                }
                break;
            }
            case Constraint::Type::ANGLE:
            case Constraint::Type::LENGTH_RATIO:
                // These don't get the units conversion for distance, and
                // they're always positive
                c-&gt;valA = fabs(e-&gt;Eval());
                break;

            case Constraint::Type::DIAMETER:
                c-&gt;valA = fabs(SS.ExprToMm(e));

                // If displayed and edited as radius, convert back
                // to diameter
                if(c-&gt;other)
                    c-&gt;valA *= 2;
                break;

            default:
                // These are always positive, and they get the units conversion.
                c-&gt;valA = fabs(SS.ExprToMm(e));
                break;
        }
        SS.MarkGroupDirty(c-&gt;group);
    }
}

</t>
<t tx="leo.20191228122646.32">void GraphicsWindow::MouseScroll(double x, double y, int delta) {
    double offsetRight = offset.Dot(projRight);
    double offsetUp = offset.Dot(projUp);

    double righti = x/scale - offsetRight;
    double upi = y/scale - offsetUp;

    if(delta &gt; 0) {
        scale *= 1.2;
    } else if(delta &lt; 0) {
        scale /= 1.2;
    } else return;

    double rightf = x/scale - offsetRight;
    double upf = y/scale - offsetUp;

    offset = offset.Plus(projRight.ScaledBy(rightf - righti));
    offset = offset.Plus(projUp.ScaledBy(upf - upi));

    if(SS.TW.shown.screen == TextWindow::Screen::EDIT_VIEW) {
        if(havePainted) {
            SS.ScheduleShowTW();
        }
    }
    havePainted = false;
    Invalidate();
}

</t>
<t tx="leo.20191228122646.33">void GraphicsWindow::MouseLeave() {
    // Un-hover everything when the mouse leaves our window, unless there's
    // currently a context menu shown.
    if(!context.active) {
        hover.Clear();
        toolbarHovered = Command::NONE;
        Invalidate();
    }
    SS.extraLine.draw = false;
}

</t>
<t tx="leo.20191228122646.34">void GraphicsWindow::SixDofEvent(Platform::SixDofEvent event) {
    if(event.type == Platform::SixDofEvent::Type::RELEASE) {
        ZoomToFit(/*includingInvisibles=*/false, /*useSelection=*/true);
        Invalidate();
        return;
    }

    if(!havePainted) return;
    Vector out = projRight.Cross(projUp);

    // rotation vector is axis of rotation, and its magnitude is angle
    Vector aa = Vector::From(event.rotationX, event.rotationY, event.rotationZ);
    // but it's given with respect to screen projection frame
    aa = aa.ScaleOutOfCsys(projRight, projUp, out);
    double aam = aa.Magnitude();
    if(aam &gt; 0.0) aa = aa.WithMagnitude(1);

    // This can either transform our view, or transform a linked part.
    GroupSelection();
    Entity *e = NULL;
    Group *g = NULL;
    if(gs.points == 1   &amp;&amp; gs.n == 1) e = SK.GetEntity(gs.point [0]);
    if(gs.entities == 1 &amp;&amp; gs.n == 1) e = SK.GetEntity(gs.entity[0]);
    if(e) g = SK.GetGroup(e-&gt;group);
    if(g &amp;&amp; g-&gt;type == Group::Type::LINKED &amp;&amp; !event.shiftDown) {
        // Apply the transformation to a linked part. Gain down the Z
        // axis, since it's hard to see what you're doing on that one since
        // it's normal to the screen.
        Vector t = projRight.ScaledBy(event.translationX/scale).Plus(
                   projUp   .ScaledBy(event.translationY/scale).Plus(
                   out      .ScaledBy(0.1*event.translationZ/scale)));
        Quaternion q = Quaternion::From(aa, aam);

        // If we go five seconds without SpaceNavigator input, or if we've
        // switched groups, then consider that a new action and save an undo
        // point.
        int64_t now = GetMilliseconds();
        if(now - last6DofTime &gt; 5000 ||
           last6DofGroup != g-&gt;h)
        {
            SS.UndoRemember();
        }

        g-&gt;TransformImportedBy(t, q);

        last6DofTime = now;
        last6DofGroup = g-&gt;h;
        SS.MarkGroupDirty(g-&gt;h);
    } else {
        // Apply the transformation to the view of the everything. The
        // x and y components are translation; but z component is scale,
        // not translation, or else it would do nothing in a parallel
        // projection
        offset = offset.Plus(projRight.ScaledBy(event.translationX/scale));
        offset = offset.Plus(projUp.ScaledBy(event.translationY/scale));
        scale *= exp(0.001*event.translationZ);

        if(aam &gt; 0.0) {
            projRight = projRight.RotatedAbout(aa, -aam);
            projUp    = projUp.   RotatedAbout(aa, -aam);
            NormalizeProjectionVectors();
        }
    }

    havePainted = false;
    Invalidate();
}
</t>
<t tx="leo.20191228122646.35">@path ./src/
//-----------------------------------------------------------------------------
// Operations on polygons (planar, of line segment edges).
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

Vector STriangle::Normal() const {
    Vector ab = b.Minus(a), bc = c.Minus(b);
    return ab.Cross(bc);
}

double STriangle::MinAltitude() const {
    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122646.36">    double altA = a.DistanceToLine(b, c.Minus(b)),
           altB = b.DistanceToLine(c, a.Minus(c)),
           altC = c.DistanceToLine(a, b.Minus(a));

    return min(altA, min(altB, altC));
}

bool STriangle::ContainsPoint(Vector p) const {
    Vector n = Normal();
    if(MinAltitude() &lt; LENGTH_EPS) {
        // shouldn't happen; zero-area triangle
        return false;
    }
    return ContainsPointProjd(n.WithMagnitude(1), p);
}

</t>
<t tx="leo.20191228122646.37">bool STriangle::ContainsPointProjd(Vector n, Vector p) const {
    Vector ab = b.Minus(a), bc = c.Minus(b), ca = a.Minus(c);

    Vector no_ab = n.Cross(ab);
    if(no_ab.Dot(p) &lt; no_ab.Dot(a) - LENGTH_EPS) return false;

    Vector no_bc = n.Cross(bc);
    if(no_bc.Dot(p) &lt; no_bc.Dot(b) - LENGTH_EPS) return false;

    Vector no_ca = n.Cross(ca);
    if(no_ca.Dot(p) &lt; no_ca.Dot(c) - LENGTH_EPS) return false;

    return true;
}

</t>
<t tx="leo.20191228122646.38">bool STriangle::Raytrace(const Vector &amp;rayPoint, const Vector &amp;rayDir,
                         double *t, Vector *inters) const {
    // Algorithm from: "Fast, Minimum Storage Ray/Triangle Intersection" by
    // Tomas Moeller and Ben Trumbore.

    // Find vectors for two edges sharing vertex A.
    Vector edge1 = b.Minus(a);
    Vector edge2 = c.Minus(a);

    // Begin calculating determinant - also used to calculate U parameter.
    Vector pvec = rayDir.Cross(edge2);

    // If determinant is near zero, ray lies in plane of triangle.
    // Also, cull back facing triangles here.
    double det = edge1.Dot(pvec);
    if(-det &lt; LENGTH_EPS) return false;
    double inv_det = 1.0f / det;

    // Calculate distance from vertex A to ray origin.
    Vector tvec = rayPoint.Minus(a);

    // Calculate U parameter and test bounds.
    double u = tvec.Dot(pvec) * inv_det;
    if (u &lt; 0.0f || u &gt; 1.0f) return false;

    // Prepare to test V parameter.
    Vector qvec = tvec.Cross(edge1);

    // Calculate V parameter and test bounds.
    double v = rayDir.Dot(qvec) * inv_det;
    if (v &lt; 0.0f || u + v &gt; 1.0f) return false;

    // Calculate t, ray intersects triangle.
    *t = edge2.Dot(qvec) * inv_det;

    // Calculate intersection point.
    if(inters != NULL) *inters = rayPoint.Plus(rayDir.ScaledBy(*t));

    return true;
}

double STriangle::SignedVolume() const {
    return a.Dot(b.Cross(c)) / 6.0;
}

double STriangle::Area() const {
    Vector ab = a.Minus(b);
    Vector cb = c.Minus(b);
    return ab.Cross(cb).Magnitude() / 2.0;
}

</t>
<t tx="leo.20191228122646.39">bool STriangle::IsDegenerate() const {
    return a.OnLineSegment(b, c) ||
           b.OnLineSegment(a, c) ||
           c.OnLineSegment(a, b);
}

</t>
<t tx="leo.20191228122646.4">void GraphicsWindow::FixConstraintsForRequestBeingDeleted(hRequest hr) {
    Request *r = SK.GetRequest(hr);
    if(r-&gt;group != SS.GW.activeGroup) return;

    Entity *e;
    for(e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
        if(!(e-&gt;h.isFromRequest())) continue;
        if(e-&gt;h.request() != hr) continue;

        if(e-&gt;type != Entity::Type::POINT_IN_2D &amp;&amp;
           e-&gt;type != Entity::Type::POINT_IN_3D)
        {
            continue;
        }

        // This is a point generated by the request being deleted; so fix
        // the constraints for that.
        FixConstraintsForPointBeingDeleted(e-&gt;h);
    }
}
</t>
<t tx="leo.20191228122646.40">void STriangle::FlipNormal() {
    swap(a, b);
    swap(an, bn);
}

STriangle STriangle::Transform(Vector u, Vector v, Vector n) const {
    STriangle tr = *this;
    tr.a  = tr.a.ScaleOutOfCsys(u, v, n);
    tr.an = tr.an.ScaleOutOfCsys(u, v, n);
    tr.b  = tr.b.ScaleOutOfCsys(u, v, n);
    tr.bn = tr.bn.ScaleOutOfCsys(u, v, n);
    tr.c  = tr.c.ScaleOutOfCsys(u, v, n);
    tr.cn = tr.cn.ScaleOutOfCsys(u, v, n);
    return tr;
}

STriangle STriangle::From(STriMeta meta, Vector a, Vector b, Vector c) {
    STriangle tr = {};
    tr.meta = meta;
    tr.a = a;
    tr.b = b;
    tr.c = c;
    return tr;
}

SEdge SEdge::From(Vector a, Vector b) {
    SEdge se = {};
    se.a = a;
    se.b = b;
    return se;
}

</t>
<t tx="leo.20191228122646.41">bool SEdge::EdgeCrosses(Vector ea, Vector eb, Vector *ppi, SPointList *spl) const {
    Vector d = eb.Minus(ea);
    double t_eps = LENGTH_EPS/d.Magnitude();

    double t, tthis;
    bool skew;
    Vector pi;
    bool inOrEdge0, inOrEdge1;

    Vector dthis = b.Minus(a);
    double tthis_eps = LENGTH_EPS/dthis.Magnitude();

    if((ea.Equals(a) &amp;&amp; eb.Equals(b)) ||
       (eb.Equals(a) &amp;&amp; ea.Equals(b)))
    {
        if(ppi) *ppi = a;
        if(spl) spl-&gt;Add(a);
        return true;
    }

    // Can't just test if distance between d and a equals distance between d and b;
    // they could be on opposite sides, since we don't have the sign.
    double m = sqrt(d.Magnitude()*dthis.Magnitude());
    if(sqrt(fabs(d.Dot(dthis))) &gt; (m - LENGTH_EPS)) {
        // The edges are parallel.
        if(fabs(a.DistanceToLine(ea, d)) &gt; LENGTH_EPS) {
            // and not coincident, so can't be intersecting
            return false;
        }
        // The edges are coincident. Make sure that neither endpoint lies
        // on the other
        bool inters = false;
        double t;
        t = a.Minus(ea).DivProjected(d);
        if(t &gt; t_eps &amp;&amp; t &lt; (1 - t_eps)) inters = true;
        t = b.Minus(ea).DivProjected(d);
        if(t &gt; t_eps &amp;&amp; t &lt; (1 - t_eps)) inters = true;
        t = ea.Minus(a).DivProjected(dthis);
        if(t &gt; tthis_eps &amp;&amp; t &lt; (1 - tthis_eps)) inters = true;
        t = eb.Minus(a).DivProjected(dthis);
        if(t &gt; tthis_eps &amp;&amp; t &lt; (1 - tthis_eps)) inters = true;

        if(inters) {
            if(ppi) *ppi = a;
            if(spl) spl-&gt;Add(a);
            return true;
        } else {
            // So coincident but disjoint, okay.
            return false;
        }
    }

    // Lines are not parallel, so look for an intersection.
    pi = Vector::AtIntersectionOfLines(ea, eb, a, b,
                                       &amp;skew,
                                       &amp;t, &amp;tthis);
    if(skew) return false;

    inOrEdge0 = (t     &gt; -t_eps)     &amp;&amp; (t     &lt; (1 + t_eps));
    inOrEdge1 = (tthis &gt; -tthis_eps) &amp;&amp; (tthis &lt; (1 + tthis_eps));

    if(inOrEdge0 &amp;&amp; inOrEdge1) {
        if(a.Equals(ea) || b.Equals(ea) ||
           a.Equals(eb) || b.Equals(eb))
        {
            // Not an intersection if we share an endpoint with an edge
            return false;
        }
        // But it's an intersection if a vertex of one edge lies on the
        // inside of the other (or if they cross away from either's
        // vertex).
        if(ppi) *ppi = pi;
        if(spl) spl-&gt;Add(pi);
        return true;
    }
    return false;
}

</t>
<t tx="leo.20191228122646.42">void SEdgeList::Clear() {
    l.Clear();
}

</t>
<t tx="leo.20191228122646.43">void SEdgeList::AddEdge(Vector a, Vector b, int auxA, int auxB, int tag) {
    SEdge e = {};
    e.tag = tag;
    e.a = a;
    e.b = b;
    e.auxA = auxA;
    e.auxB = auxB;
    l.Add(&amp;e);
}

</t>
<t tx="leo.20191228122646.44">bool SEdgeList::AssembleContour(Vector first, Vector last, SContour *dest,
                                SEdge *errorAt, bool keepDir) const
{
    int i;

    dest-&gt;AddPoint(first);
    dest-&gt;AddPoint(last);

    do {
        for(i = 0; i &lt; l.n; i++) {
            /// @todo fix const!
            SEdge *se = const_cast&lt;SEdge*&gt;(&amp;(l[i]));
            if(se-&gt;tag) continue;

            if(se-&gt;a.Equals(last)) {
                dest-&gt;AddPoint(se-&gt;b);
                last = se-&gt;b;
                se-&gt;tag = 1;
                break;
            }
            // Don't allow backwards edges if keepDir is true.
            if(!keepDir &amp;&amp; se-&gt;b.Equals(last)) {
                dest-&gt;AddPoint(se-&gt;a);
                last = se-&gt;a;
                se-&gt;tag = 1;
                break;
            }
        }
        if(i &gt;= l.n) {
            // Couldn't assemble a closed contour; mark where.
            if(errorAt) {
                errorAt-&gt;a = first;
                errorAt-&gt;b = last;
            }
            return false;
        }

    } while(!last.Equals(first));

    return true;
}

</t>
<t tx="leo.20191228122646.45">bool SEdgeList::AssemblePolygon(SPolygon *dest, SEdge *errorAt, bool keepDir) const {
    dest-&gt;Clear();

    bool allClosed = true;
    for(;;) {
        Vector first = Vector::From(0, 0, 0);
        Vector last  = Vector::From(0, 0, 0);
        int i;
        for(i = 0; i &lt; l.n; i++) {
            if(!l[i].tag) {
                first = l[i].a;
                last = l[i].b;
                /// @todo fix const!
                const_cast&lt;SEdge*&gt;(&amp;(l[i]))-&gt;tag = 1;
                break;
            }
        }
        if(i &gt;= l.n) {
            return allClosed;
        }

        // Create a new empty contour in our polygon, and finish assembling
        // into that contour.
        dest-&gt;AddEmptyContour();
        if(!AssembleContour(first, last, dest-&gt;l.Last(), errorAt, keepDir)) {
            allClosed = false;
        }
        // But continue assembling, even if some of the contours are open
    }
}

//-----------------------------------------------------------------------------
// Test if the specified edge crosses any of the edges in our list. Two edges
// are not considered to cross if they share an endpoint (within LENGTH_EPS),
// but they are considered to cross if they are coincident and overlapping.
// If pi is not NULL, then a crossing is returned in that.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122646.46">int SEdgeList::AnyEdgeCrossings(Vector a, Vector b, Vector *ppi, SPointList *spl) const {
    @others
}
</t>
<t tx="leo.20191228122646.47">    auto cnt = std::count_if(l.begin(), l.end(),
                             [&amp;](SEdge const &amp;se) { return se.EdgeCrosses(a, b, ppi, spl); });
    return static_cast&lt;int&gt;(cnt);
}

//-----------------------------------------------------------------------------
// Returns true if the intersecting edge list contains an edge that shares
// an endpoint with one of our edges.
//-----------------------------------------------------------------------------
bool SEdgeList::ContainsEdgeFrom(const SEdgeList *sel) const {
    for(const SEdge *se = l.First(); se; se = l.NextAfter(se)) {
        if(sel-&gt;ContainsEdge(se)) return true;
    }
    return false;
</t>
<t tx="leo.20191228122646.48">bool SEdgeList::ContainsEdge(const SEdge *set) const {
    for(const SEdge *se = l.First(); se; se = l.NextAfter(se)) {
        if((se-&gt;a).Equals(set-&gt;a) &amp;&amp; (se-&gt;b).Equals(set-&gt;b)) return true;
        if((se-&gt;b).Equals(set-&gt;a) &amp;&amp; (se-&gt;a).Equals(set-&gt;b)) return true;
    }
    return false;
}

//-----------------------------------------------------------------------------
// Remove unnecessary edges:
// - if two are anti-parallel then
//     if both=true, remove both
//     else remove only one.
// - if two are parallel then remove one.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122646.49">void SEdgeList::CullExtraneousEdges(bool both) {
    l.ClearTags();
    for(int i = 0; i &lt; l.n; i++) {
        SEdge *se = &amp;(l[i]);
        for(int j = i + 1; j &lt; l.n; j++) {
            SEdge *set = &amp;(l[j]);
            if((set-&gt;a).Equals(se-&gt;a) &amp;&amp; (set-&gt;b).Equals(se-&gt;b)) {
                // Two parallel edges exist; so keep only the first one.
                set-&gt;tag = 1;
            }
            if((set-&gt;a).Equals(se-&gt;b) &amp;&amp; (set-&gt;b).Equals(se-&gt;a)) {
                // Two anti-parallel edges exist; if both=true, keep neither,
                // otherwise keep only one.
                if (both) se-&gt;tag = 1;
                set-&gt;tag = 1;
            }
        }
    }
    l.RemoveTagged();
}

//-----------------------------------------------------------------------------
// Make a kd-tree of edges. This is used for O(log(n)) implementations of stuff
// that would naively be O(n).
//-----------------------------------------------------------------------------
SKdNodeEdges *SKdNodeEdges::Alloc() {
    SKdNodeEdges *ne = (SKdNodeEdges *)AllocTemporary(sizeof(SKdNodeEdges));
    *ne = {};
    return ne;
}
SEdgeLl *SEdgeLl::Alloc() {
    SEdgeLl *sell = (SEdgeLl *)AllocTemporary(sizeof(SEdgeLl));
    *sell = {};
    return sell;
}
SKdNodeEdges *SKdNodeEdges::From(SEdgeList *sel) {
    SEdgeLl *sell = NULL;
    SEdge *se;
    for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
        SEdgeLl *n = SEdgeLl::Alloc();
        n-&gt;se = se;
        n-&gt;next = sell;
        sell = n;
    }
    return SKdNodeEdges::From(sell);
}
SKdNodeEdges *SKdNodeEdges::From(SEdgeLl *sell) {
    SKdNodeEdges *n = SKdNodeEdges::Alloc();

    // Compute the midpoints (just mean, though median would be better) of
    // each component.
    Vector ptAve = Vector::From(0, 0, 0);
    SEdgeLl *flip;
    int totaln = 0;
    for(flip = sell; flip; flip = flip-&gt;next) {
        ptAve = ptAve.Plus(flip-&gt;se-&gt;a);
        ptAve = ptAve.Plus(flip-&gt;se-&gt;b);
        totaln++;
    }
    ptAve = ptAve.ScaledBy(1.0 / (2*totaln));

    // For each component, see how it splits.
    int ltln[3] = { 0, 0, 0 }, gtln[3] = { 0, 0, 0 };
    double badness[3];
    for(flip = sell; flip; flip = flip-&gt;next) {
        for(int i = 0; i &lt; 3; i++) {
            if(flip-&gt;se-&gt;a.Element(i) &lt; ptAve.Element(i) + KDTREE_EPS ||
               flip-&gt;se-&gt;b.Element(i) &lt; ptAve.Element(i) + KDTREE_EPS)
            {
                ltln[i]++;
            }
            if(flip-&gt;se-&gt;a.Element(i) &gt; ptAve.Element(i) - KDTREE_EPS ||
               flip-&gt;se-&gt;b.Element(i) &gt; ptAve.Element(i) - KDTREE_EPS)
            {
                gtln[i]++;
            }
        }
    }
    for(int i = 0; i &lt; 3; i++) {
        badness[i] = pow((double)ltln[i], 4) + pow((double)gtln[i], 4);
    }

    // Choose the least bad coordinate to split along.
    if(badness[0] &lt; badness[1] &amp;&amp; badness[0] &lt; badness[2]) {
        n-&gt;which = 0;
    } else if(badness[1] &lt; badness[2]) {
        n-&gt;which = 1;
    } else {
        n-&gt;which = 2;
    }
    n-&gt;c = ptAve.Element(n-&gt;which);

    if(totaln &lt; 3 || totaln == gtln[n-&gt;which] || totaln == ltln[n-&gt;which]) {
        n-&gt;edges = sell;
        // and we're a leaf node
        return n;
    }

    // Sort the edges according to which side(s) of the split plane they're on.
    SEdgeLl *gtl = NULL, *ltl = NULL;
    for(flip = sell; flip; flip = flip-&gt;next) {
        if(flip-&gt;se-&gt;a.Element(n-&gt;which) &lt; n-&gt;c + KDTREE_EPS ||
           flip-&gt;se-&gt;b.Element(n-&gt;which) &lt; n-&gt;c + KDTREE_EPS)
        {
            SEdgeLl *selln = SEdgeLl::Alloc();
            selln-&gt;se = flip-&gt;se;
            selln-&gt;next = ltl;
            ltl = selln;
        }
        if(flip-&gt;se-&gt;a.Element(n-&gt;which) &gt; n-&gt;c - KDTREE_EPS ||
           flip-&gt;se-&gt;b.Element(n-&gt;which) &gt; n-&gt;c - KDTREE_EPS)
        {
            SEdgeLl *selln = SEdgeLl::Alloc();
            selln-&gt;se = flip-&gt;se;
            selln-&gt;next = gtl;
            gtl = selln;
        }
    }

    n-&gt;lt = SKdNodeEdges::From(ltl);
    n-&gt;gt = SKdNodeEdges::From(gtl);
    return n;
}

</t>
<t tx="leo.20191228122646.5">void GraphicsWindow::FixConstraintsForPointBeingDeleted(hEntity hpt) {
    List&lt;hEntity&gt; ld = {};

    Constraint *c;
    SK.constraint.ClearTags();
    for(c = SK.constraint.First(); c; c = SK.constraint.NextAfter(c)) {
        if(c-&gt;type != Constraint::Type::POINTS_COINCIDENT) continue;
        if(c-&gt;group != SS.GW.activeGroup) continue;

        if(c-&gt;ptA == hpt) {
            ld.Add(&amp;(c-&gt;ptB));
            c-&gt;tag = 1;
        }
        if(c-&gt;ptB == hpt) {
            ld.Add(&amp;(c-&gt;ptA));
            c-&gt;tag = 1;
        }
    }
    // Remove constraints without waiting for regeneration; this way
    // if another point takes the place of the deleted one (e.g. when
    // removing control points of a bezier) the constraint doesn't
    // spuriously move. Similarly, subsequent calls of this function
    // (if multiple coincident points are getting deleted) will work
    // correctly.
    SK.constraint.RemoveTagged();

    // If more than one point was constrained coincident with hpt, then
    // those two points were implicitly coincident with each other. By
    // deleting hpt (and all constraints that mention it), we will delete
    // that relationship. So put it back here now.
    for(int i = 1; i &lt; ld.n; i++) {
        Constraint::ConstrainCoincident(ld[i-1], ld[i]);
    }
    ld.Clear();
}

//-----------------------------------------------------------------------------
// A curve by its parametric equation, helper functions for computing tangent
// arcs by a numerical method.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122646.50">int SKdNodeEdges::AnyEdgeCrossings(Vector a, Vector b, int cnt,
        Vector *pi, SPointList *spl) const
{
    int inters = 0;
    if(gt &amp;&amp; lt) {
        if(a.Element(which) &lt; c + KDTREE_EPS ||
           b.Element(which) &lt; c + KDTREE_EPS)
        {
            inters += lt-&gt;AnyEdgeCrossings(a, b, cnt, pi, spl);
        }
        if(a.Element(which) &gt; c - KDTREE_EPS ||
           b.Element(which) &gt; c - KDTREE_EPS)
        {
            inters += gt-&gt;AnyEdgeCrossings(a, b, cnt, pi, spl);
        }
    } else {
        SEdgeLl *sell;
        for(sell = edges; sell; sell = sell-&gt;next) {
            SEdge *se = sell-&gt;se;
            if(se-&gt;tag == cnt) continue;
            if(se-&gt;EdgeCrosses(a, b, pi, spl)) {
                inters++;
            }
            se-&gt;tag = cnt;
        }
    }
    return inters;
}

//-----------------------------------------------------------------------------
// We have an edge list that contains only collinear edges, maybe with more
// splits than necessary. Merge any collinear segments that join.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122646.51">void SEdgeList::MergeCollinearSegments(Vector a, Vector b) {
    const Vector lineStart = a;
    const Vector lineDirection = b.Minus(a);
    std::sort(l.begin(), l.end(), [&amp;](const SEdge &amp;a, const SEdge &amp;b) {
        double ta = (a.a.Minus(lineStart)).DivProjected(lineDirection);
        double tb = (b.a.Minus(lineStart)).DivProjected(lineDirection);

        return (ta &lt; tb);
    });

    l.ClearTags();
    SEdge *prev = nullptr;
    for(auto &amp;now : l) {
        if(prev != nullptr) {
            if((prev-&gt;b).Equals(now.a) &amp;&amp; prev-&gt;auxA == now.auxA) {
                // The previous segment joins up to us; so merge it into us.
                prev-&gt;tag = 1;
                now.a     = prev-&gt;a;
            }
        }
        prev = &amp;now;
    }
    l.RemoveTagged();
}

</t>
<t tx="leo.20191228122646.52">void SPointList::Clear() {
    l.Clear();
}

</t>
<t tx="leo.20191228122646.53">bool SPointList::ContainsPoint(Vector pt) const {
    return (IndexForPoint(pt) &gt;= 0);
}

</t>
<t tx="leo.20191228122646.54">int SPointList::IndexForPoint(Vector pt) const {
    int i;
    for(i = 0; i &lt; l.n; i++) {
        const SPoint *p = &amp;(l[i]);
        if(pt.Equals(p-&gt;p)) {
            return i;
        }
    }
    // Not found, so return negative to indicate that.
    return -1;
}

</t>
<t tx="leo.20191228122646.55">void SPointList::IncrementTagFor(Vector pt) {
    SPoint *p;
    for(p = l.First(); p; p = l.NextAfter(p)) {
        if(pt.Equals(p-&gt;p)) {
            (p-&gt;tag)++;
            return;
        }
    }
    SPoint pa;
    pa.p = pt;
    pa.tag = 1;
    l.Add(&amp;pa);
}

</t>
<t tx="leo.20191228122646.56">void SPointList::Add(Vector pt) {
    SPoint p = {};
    p.p = pt;
    l.Add(&amp;p);
}

</t>
<t tx="leo.20191228122646.57">void SContour::AddPoint(Vector p) {
    SPoint sp;
    sp.tag = 0;
    sp.p = p;

    l.Add(&amp;sp);
}

</t>
<t tx="leo.20191228122646.58">void SContour::MakeEdgesInto(SEdgeList *el) const {
    int i;
    for(i = 0; i &lt; (l.n - 1); i++) {
        el-&gt;AddEdge(l[i].p, l[i+1].p);
    }
}

</t>
<t tx="leo.20191228122646.59">void SContour::CopyInto(SContour *dest) const {
    for(const SPoint *sp = l.First(); sp; sp = l.NextAfter(sp)) {
        dest-&gt;AddPoint(sp-&gt;p);
    }
}

</t>
<t tx="leo.20191228122646.6">void GraphicsWindow::ParametricCurve::MakeFromEntity(hEntity he, bool reverse) {
    *this = {};
    Entity *e = SK.GetEntity(he);
    if(e-&gt;type == Entity::Type::LINE_SEGMENT) {
        isLine = true;
        p0 = e-&gt;EndpointStart(),
        p1 = e-&gt;EndpointFinish();
        if(reverse) {
            swap(p0, p1);
        }
    } else if(e-&gt;type == Entity::Type::ARC_OF_CIRCLE) {
        isLine = false;
        p0 = SK.GetEntity(e-&gt;point[0])-&gt;PointGetNum();
        Vector pe = SK.GetEntity(e-&gt;point[1])-&gt;PointGetNum();
        r = (pe.Minus(p0)).Magnitude();
        e-&gt;ArcGetAngles(&amp;theta0, &amp;theta1, &amp;dtheta);
        if(reverse) {
            swap(theta0, theta1);
            dtheta = -dtheta;
        }
        EntityBase *wrkpln = SK.GetEntity(e-&gt;workplane)-&gt;Normal();
        u = wrkpln-&gt;NormalU();
        v = wrkpln-&gt;NormalV();
    } else ssassert(false, "Unexpected entity type");
}
double GraphicsWindow::ParametricCurve::LengthForAuto() {
    if(isLine) {
        // Allow a third of the line to disappear with auto radius
        return (p1.Minus(p0)).Magnitude() / 3;
    } else {
        // But only a twentieth of the arc; shorter means fewer numerical
        // problems since the curve is more linear over shorter sections.
        return (fabs(dtheta)*r)/20;
    }
}
Vector GraphicsWindow::ParametricCurve::PointAt(double t) {
    if(isLine) {
        return p0.Plus((p1.Minus(p0)).ScaledBy(t));
    } else {
        double theta = theta0 + dtheta*t;
        return p0.Plus(u.ScaledBy(r*cos(theta)).Plus(v.ScaledBy(r*sin(theta))));
    }
}
Vector GraphicsWindow::ParametricCurve::TangentAt(double t) {
    if(isLine) {
        return p1.Minus(p0);
    } else {
        double theta = theta0 + dtheta*t;
        Vector t =  u.ScaledBy(-r*sin(theta)).Plus(v.ScaledBy(r*cos(theta)));
        t = t.ScaledBy(dtheta);
        return t;
    }
}
/** Changes or copies the given entity and connects it to the arc.
 * \param t Where on this parametric curve does it connect to the arc.
 * \param reuseOrig Should the original entity be modified
 * \param orig The original entity.
 * \param arc The arc that will be connected to.
 * \param arcFinish Whether to connect to the end point of the arc.
 * \param pointf When changing the original entity, whether the end point should be modified.
 */
</t>
<t tx="leo.20191228122646.60">void SContour::FindPointWithMinX() {
    xminPt = Vector::From(1e10, 1e10, 1e10);
    for(const SPoint *sp = l.First(); sp; sp = l.NextAfter(sp)) {
        if(sp-&gt;p.x &lt; xminPt.x) {
            xminPt = sp-&gt;p;
        }
    }
}

Vector SContour::ComputeNormal() const {
    Vector n = Vector::From(0, 0, 0);

    for(int i = 0; i &lt; l.n - 2; i++) {
        Vector u = (l[i+1].p).Minus(l[i+0].p).WithMagnitude(1);
        Vector v = (l[i+2].p).Minus(l[i+1].p).WithMagnitude(1);
        Vector nt = u.Cross(v);
        if(nt.Magnitude() &gt; n.Magnitude()) {
            n = nt;
        }
    }
    return n.WithMagnitude(1);
}

Vector SContour::AnyEdgeMidpoint() const {
    ssassert(l.n &gt;= 2, "Need two points to find a midpoint");
    return ((l[0].p).Plus(l[1].p)).ScaledBy(0.5);
}

</t>
<t tx="leo.20191228122646.61">bool SContour::IsClockwiseProjdToNormal(Vector n) const {
    // Degenerate things might happen as we draw; doesn't really matter
    // what we do then.
    if(n.Magnitude() &lt; 0.01) return true;

    return (SignedAreaProjdToNormal(n) &lt; 0);
}

double SContour::SignedAreaProjdToNormal(Vector n) const {
    // An arbitrary 2d coordinate system that has n as its normal
    Vector u = n.Normal(0);
    Vector v = n.Normal(1);

    double area = 0;
    for(int i = 0; i &lt; (l.n - 1); i++) {
        double u0 = (l[i  ].p).Dot(u);
        double v0 = (l[i  ].p).Dot(v);
        double u1 = (l[i+1].p).Dot(u);
        double v1 = (l[i+1].p).Dot(v);

        area += ((v0 + v1)/2)*(u1 - u0);
    }
    return area;
}

</t>
<t tx="leo.20191228122646.62">bool SContour::ContainsPointProjdToNormal(Vector n, Vector p) const {
    Vector u = n.Normal(0);
    Vector v = n.Normal(1);

    double up = p.Dot(u);
    double vp = p.Dot(v);

    bool inside = false;
    for(int i = 0; i &lt; (l.n - 1); i++) {
        double ua = (l[i  ].p).Dot(u);
        double va = (l[i  ].p).Dot(v);
        // The curve needs to be exactly closed; approximation is death.
        double ub = (l[(i+1)%(l.n-1)].p).Dot(u);
        double vb = (l[(i+1)%(l.n-1)].p).Dot(v);

        if ((((va &lt;= vp) &amp;&amp; (vp &lt; vb)) ||
             ((vb &lt;= vp) &amp;&amp; (vp &lt; va))) &amp;&amp;
            (up &lt; (ub - ua) * (vp - va) / (vb - va) + ua))
        {
          inside = !inside;
        }
    }

    return inside;
}

</t>
<t tx="leo.20191228122646.63">void SContour::Reverse() {
    l.Reverse();
}


</t>
<t tx="leo.20191228122646.64">void SPolygon::Clear() {
    int i;
    for(i = 0; i &lt; l.n; i++) {
        (l[i]).l.Clear();
    }
    l.Clear();
}

</t>
<t tx="leo.20191228122646.65">void SPolygon::AddEmptyContour() {
    SContour c = {};
    l.Add(&amp;c);
}

</t>
<t tx="leo.20191228122646.66">void SPolygon::MakeEdgesInto(SEdgeList *el) const {
    int i;
    for(i = 0; i &lt; l.n; i++) {
        (l[i]).MakeEdgesInto(el);
    }
}

Vector SPolygon::ComputeNormal() const {
    if(l.IsEmpty())
        return Vector::From(0, 0, 0);
    return (l[0]).ComputeNormal();
}

double SPolygon::SignedArea() const {
    double area = 0;
    // This returns the true area only if the contours are all oriented
    // correctly, with the holes backwards from the outer contours.
    for(const SContour *sc = l.First(); sc; sc = l.NextAfter(sc)) {
        area += sc-&gt;SignedAreaProjdToNormal(normal);
    }
    return area;
}

</t>
<t tx="leo.20191228122646.67">bool SPolygon::ContainsPoint(Vector p) const {
    return (WindingNumberForPoint(p) % 2) == 1;
}

size_t SPolygon::WindingNumberForPoint(Vector p) const {
</t>
<t tx="leo.20191228122646.68">    auto winding = std::count_if(l.begin(), l.end(), [&amp;](const SContour &amp;sc) {
        return sc.ContainsPointProjdToNormal(normal, p);
    });
    return winding;
}

</t>
<t tx="leo.20191228122646.69">void SPolygon::FixContourDirections() {
    // At output, the contour's tag will be 1 if we reversed it, else 0.
    l.ClearTags();

    // Outside curve looks counterclockwise, projected against our normal.
    int i, j;
    for(i = 0; i &lt; l.n; i++) {
        SContour *sc = &amp;(l[i]);
        if(sc-&gt;l.n &lt; 2) continue;
        // The contours may not intersect, but they may share vertices; so
        // testing a vertex for point-in-polygon may fail, but the midpoint
        // of an edge is okay.
        Vector pt = (((sc-&gt;l[0]).p).Plus(sc-&gt;l[1].p)).ScaledBy(0.5);

        sc-&gt;timesEnclosed = 0;
        bool outer = true;
        for(j = 0; j &lt; l.n; j++) {
            if(i == j) continue;
            SContour *sct = &amp;(l[j]);
            if(sct-&gt;ContainsPointProjdToNormal(normal, pt)) {
                outer = !outer;
                (sc-&gt;timesEnclosed)++;
            }
        }

        bool clockwise = sc-&gt;IsClockwiseProjdToNormal(normal);
        if((clockwise &amp;&amp; outer) || (!clockwise &amp;&amp; !outer)) {
            sc-&gt;Reverse();
            sc-&gt;tag = 1;
        }
    }
}

</t>
<t tx="leo.20191228122646.7">void GraphicsWindow::ParametricCurve::CreateRequestTrimmedTo(double t,
    bool reuseOrig, hEntity orig, hEntity arc, bool arcFinish, bool pointf)
{
    hRequest hr;
    Entity *e;
    if(isLine) {
        if (reuseOrig) {
            e = SK.GetEntity(orig);
            int i = pointf ? 1 : 0;
            SK.GetEntity(e-&gt;point[i])-&gt;PointForceTo(PointAt(t));
            ConstrainPointIfCoincident(e-&gt;point[i]);
        } else {
            hr = SS.GW.AddRequest(Request::Type::LINE_SEGMENT, /*rememberForUndo=*/false),
            e = SK.GetEntity(hr.entity(0));
            SK.GetEntity(e-&gt;point[0])-&gt;PointForceTo(PointAt(t));
            SK.GetEntity(e-&gt;point[1])-&gt;PointForceTo(PointAt(1));
            ConstrainPointIfCoincident(e-&gt;point[0]);
            ConstrainPointIfCoincident(e-&gt;point[1]);
            Constraint::Constrain(Constraint::Type::PT_ON_LINE,
                hr.entity(1), Entity::NO_ENTITY, orig);
        }
        Constraint::Constrain(Constraint::Type::ARC_LINE_TANGENT,
            Entity::NO_ENTITY, Entity::NO_ENTITY,
            arc, e-&gt;h, /*other=*/arcFinish, /*other2=*/false);
    } else {
        if (reuseOrig) {
            e = SK.GetEntity(orig);
            int i = pointf ? 2 : 1;
            SK.GetEntity(e-&gt;point[i])-&gt;PointForceTo(PointAt(t));
            ConstrainPointIfCoincident(e-&gt;point[i]);
        } else {
            hr = SS.GW.AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false),
            e = SK.GetEntity(hr.entity(0));
            SK.GetEntity(e-&gt;point[0])-&gt;PointForceTo(p0);
            if(dtheta &gt; 0) {
                SK.GetEntity(e-&gt;point[1])-&gt;PointForceTo(PointAt(t));
                SK.GetEntity(e-&gt;point[2])-&gt;PointForceTo(PointAt(1));
            } else {
                SK.GetEntity(e-&gt;point[2])-&gt;PointForceTo(PointAt(t));
                SK.GetEntity(e-&gt;point[1])-&gt;PointForceTo(PointAt(1));
            }
            ConstrainPointIfCoincident(e-&gt;point[0]);
            ConstrainPointIfCoincident(e-&gt;point[1]);
            ConstrainPointIfCoincident(e-&gt;point[2]);
        }
        // The tangency constraint alone is enough to fully constrain it,
        // so there's no need for more.
        Constraint::Constrain(Constraint::Type::CURVE_CURVE_TANGENT,
            Entity::NO_ENTITY, Entity::NO_ENTITY,
            arc, e-&gt;h, /*other=*/arcFinish, /*other2=*/(dtheta &lt; 0));
    }
}

//-----------------------------------------------------------------------------
// If a point in the same group as hpt, and numerically coincident with hpt,
// happens to exist, then constrain that point coincident to hpt.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122646.70">bool SPolygon::IsEmpty() const {
    if(l.IsEmpty() || l[0].l.IsEmpty())
        return true;
    return false;
}

Vector SPolygon::AnyPoint() const {
    ssassert(!IsEmpty(), "Need at least one point");
    return l[0].l[0].p;
}

</t>
<t tx="leo.20191228122646.71">bool SPolygon::SelfIntersecting(Vector *intersectsAt) const {
    SEdgeList el = {};
    MakeEdgesInto(&amp;el);
    SKdNodeEdges *kdtree = SKdNodeEdges::From(&amp;el);

    int cnt = 1;
    el.l.ClearTags();

    bool ret = false;
    SEdge *se;
    for(se = el.l.First(); se; se = el.l.NextAfter(se)) {
        int inters = kdtree-&gt;AnyEdgeCrossings(se-&gt;a, se-&gt;b, cnt, intersectsAt);
        if(inters != 1) {
            ret = true;
            break;
        }
        cnt++;
    }

    el.Clear();
    return ret;
}

</t>
<t tx="leo.20191228122646.72">void SPolygon::InverseTransformInto(SPolygon *sp, Vector u, Vector v, Vector n) const {
    for(const SContour &amp;sc : l) {
        SContour tsc = {};
        tsc.timesEnclosed = sc.timesEnclosed;
        for(const SPoint &amp;sp : sc.l) {
            tsc.AddPoint(sp.p.DotInToCsys(u, v, n));
        }
        sp-&gt;l.Add(&amp;tsc);
    }
}

//-----------------------------------------------------------------------------
// Low-quality routines to cutter radius compensate a polygon. Assumes the
// polygon is in the xy plane, and the contours all go in the right direction
// with respect to normal (0, 0, -1).
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122646.73">void SPolygon::OffsetInto(SPolygon *dest, double r) const {
    int i;
    dest-&gt;Clear();
    for(i = 0; i &lt; l.n; i++) {
        const SContour *sc = &amp;(l[i]);
        dest-&gt;AddEmptyContour();
        sc-&gt;OffsetInto(&amp;(dest-&gt;l[dest-&gt;l.n-1]), r);
    }
}
//-----------------------------------------------------------------------------
// Calculate the intersection point of two lines. Returns true for success,
// false if they're parallel.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122646.74">static bool IntersectionOfLines(double x0A, double y0A, double dxA, double dyA,
                                double x0B, double y0B, double dxB, double dyB,
                                double *xi, double *yi)
{
    double A[2][2];
    double b[2];

    // The line is given to us in the form:
    //    (x(t), y(t)) = (x0, y0) + t*(dx, dy)
    // so first rewrite it as
    //    (x - x0, y - y0) dot (dy, -dx) = 0
    //    x*dy - x0*dy - y*dx + y0*dx = 0
    //    x*dy - y*dx = (x0*dy - y0*dx)

    // So write the matrix, pre-pivoted.
    if(fabs(dyA) &gt; fabs(dyB)) {
        A[0][0] = dyA;  A[0][1] = -dxA;  b[0] = x0A*dyA - y0A*dxA;
        A[1][0] = dyB;  A[1][1] = -dxB;  b[1] = x0B*dyB - y0B*dxB;
    } else {
        A[1][0] = dyA;  A[1][1] = -dxA;  b[1] = x0A*dyA - y0A*dxA;
        A[0][0] = dyB;  A[0][1] = -dxB;  b[0] = x0B*dyB - y0B*dxB;
    }

    // Check the determinant; if it's zero then no solution.
    if(fabs(A[0][0]*A[1][1] - A[0][1]*A[1][0]) &lt; LENGTH_EPS) {
        return false;
    }

    // Solve
    double v = A[1][0] / A[0][0];
    A[1][0] -= A[0][0]*v;
    A[1][1] -= A[0][1]*v;
    b[1] -= b[0]*v;

    // Back-substitute.
    *yi = b[1] / A[1][1];
    *xi = (b[0] - A[0][1]*(*yi)) / A[0][0];

    return true;
}
</t>
<t tx="leo.20191228122646.75">void SContour::OffsetInto(SContour *dest, double r) const {
    int i;

    for(i = 0; i &lt; l.n; i++) {
        Vector a, b, c;
        Vector dp, dn;
        double thetan, thetap;

        a = l[WRAP(i-1, (l.n-1))].p;
        b = l[WRAP(i,   (l.n-1))].p;
        c = l[WRAP(i+1, (l.n-1))].p;

        dp = a.Minus(b);
        thetap = atan2(dp.y, dp.x);

        dn = b.Minus(c);
        thetan = atan2(dn.y, dn.x);

        // A short line segment in a badly-generated polygon might look
        // okay but screw up our sense of direction.
        if(dp.Magnitude() &lt; LENGTH_EPS || dn.Magnitude() &lt; LENGTH_EPS) {
            continue;
        }

        if(thetan &gt; thetap &amp;&amp; (thetan - thetap) &gt; PI) {
            thetap += 2*PI;
        }
        if(thetan &lt; thetap &amp;&amp; (thetap - thetan) &gt; PI) {
            thetan += 2*PI;
        }

        if(fabs(thetan - thetap) &lt; (1*PI)/180) {
            Vector p = { b.x - r*sin(thetap), b.y + r*cos(thetap), 0 };
            dest-&gt;AddPoint(p);
        } else if(thetan &lt; thetap) {
            // This is an inside corner. We have two edges, Ep and En. Move
            // out from their intersection by radius, normal to En, and
            // then draw a line parallel to En. Move out from their
            // intersection by radius, normal to Ep, and then draw a second
            // line parallel to Ep. The point that we want to generate is
            // the intersection of these two lines--it removes as much
            // material as we can without removing any that we shouldn't.
            double px0, py0, pdx, pdy;
            double nx0, ny0, ndx, ndy;
            double x = 0.0, y = 0.0;

            px0 = b.x - r*sin(thetap);
            py0 = b.y + r*cos(thetap);
            pdx = cos(thetap);
            pdy = sin(thetap);

            nx0 = b.x - r*sin(thetan);
            ny0 = b.y + r*cos(thetan);
            ndx = cos(thetan);
            ndy = sin(thetan);

            IntersectionOfLines(px0, py0, pdx, pdy,
                                nx0, ny0, ndx, ndy,
                                &amp;x, &amp;y);

            dest-&gt;AddPoint(Vector::From(x, y, 0));
        } else {
            if(fabs(thetap - thetan) &lt; (6*PI)/180) {
                Vector pp = { b.x - r*sin(thetap),
                              b.y + r*cos(thetap), 0 };
                dest-&gt;AddPoint(pp);

                Vector pn = { b.x - r*sin(thetan),
                              b.y + r*cos(thetan), 0 };
                dest-&gt;AddPoint(pn);
            } else {
                double theta;
                for(theta = thetap; theta &lt;= thetan; theta += (6*PI)/180) {
                    Vector p = { b.x - r*sin(theta),
                                 b.y + r*cos(theta), 0 };
                    dest-&gt;AddPoint(p);
                }
            }
        }
    }
}

</t>
<t tx="leo.20191228122646.76">@path ./src/
//-----------------------------------------------------------------------------
// Anything relating to plane polygons and triangles, and (generally, non-
// planar) meshes thereof.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------

#ifndef SOLVESPACE_POLYGON_H
#define SOLVESPACE_POLYGON_H

class SPointList;
class SPolygon;
class SContour;
class SMesh;
class SBsp3;
class SOutlineList;

enum class EarType : uint32_t {
    UNKNOWN = 0,
    NOT_EAR = 1,
    EAR     = 2
};

enum class BspClass : uint32_t {
    POS         = 100,
    NEG         = 101,
    COPLANAR    = 200
};

enum class EdgeKind : uint32_t {
    NAKED_OR_SELF_INTER  = 100,
    SELF_INTER           = 200,
    TURNING              = 300,
    EMPHASIZED           = 400,
    SHARP                = 500,
};

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122646.77">class SEdge {
public:
    int    tag;
    int    auxA, auxB;
    Vector a, b;

    static SEdge From(Vector a, Vector b);
    bool EdgeCrosses(Vector a, Vector b, Vector *pi=NULL, SPointList *spl=NULL) const;
};

</t>
<t tx="leo.20191228122646.78">class SEdgeList {
public:
    List&lt;SEdge&gt;     l;

    void Clear();
    void AddEdge(Vector a, Vector b, int auxA=0, int auxB=0, int tag=0);
    bool AssemblePolygon(SPolygon *dest, SEdge *errorAt, bool keepDir=false) const;
    bool AssembleContour(Vector first, Vector last, SContour *dest,
// of the boundary. So increasing this number never breaks anything, but may
// result in more duplicated elements. So it's conservative to be sloppy here.
#define KDTREE_EPS (20*LENGTH_EPS)

</t>
<t tx="leo.20191228122646.79">class SEdgeLl {
public:
    SEdge       *se;
    SEdgeLl     *next;

    static SEdgeLl *Alloc();
};

</t>
<t tx="leo.20191228122646.8">void GraphicsWindow::ParametricCurve::ConstrainPointIfCoincident(hEntity hpt) {
    Entity *e, *pt;
    pt = SK.GetEntity(hpt);
    Vector ev, ptv;
    ptv = pt-&gt;PointGetNum();

    for(e = SK.entity.First(); e; e = SK.entity.NextAfter(e)) {
        if(e-&gt;h == pt-&gt;h) continue;
        if(!e-&gt;IsPoint()) continue;
        if(e-&gt;group != pt-&gt;group) continue;
        if(e-&gt;workplane != pt-&gt;workplane) continue;

        ev = e-&gt;PointGetNum();
        if(!ev.Equals(ptv)) continue;

        Constraint::ConstrainCoincident(hpt, e-&gt;h);
        break;
    }
}

//-----------------------------------------------------------------------------
// A single point must be selected when this function is called. We find two
// non-construction line segments that join at this point, and create a
// tangent arc joining them.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122646.80">class SKdNodeEdges {
public:
    int which; // whether c is x, y, or z
    double c;
    SKdNodeEdges    *gt;
    SKdNodeEdges    *lt;

    SEdgeLl         *edges;

    static SKdNodeEdges *From(SEdgeList *sel);
    static SKdNodeEdges *From(SEdgeLl *sell);
    static SKdNodeEdges *Alloc();
    @others
};

</t>
<t tx="leo.20191228122646.81">    int AnyEdgeCrossings(Vector a, Vector b, int cnt,
        Vector *pi=NULL, SPointList *spl=NULL) const;
};

class SPoint {
public:
    int     tag;

    EarType ear;

    Vector  p;
    Vector  auxv;
</t>
<t tx="leo.20191228122646.82">class SPointList {
public:
    List&lt;SPoint&gt;    l;

    void Clear();
    bool ContainsPoint(Vector pt) const;
    int IndexForPoint(Vector pt) const;
    void IncrementTagFor(Vector pt);
    void Add(Vector pt);
};

</t>
<t tx="leo.20191228122646.83">class SContour {
public:
    int             tag;
    int             timesEnclosed;
    Vector          xminPt;
    List&lt;SPoint&gt;    l;

    void AddPoint(Vector p);
    void MakeEdgesInto(SEdgeList *el) const;
    void Reverse();
    Vector ComputeNormal() const;
    double SignedAreaProjdToNormal(Vector n) const;
    bool IsClockwiseProjdToNormal(Vector n) const;
    bool ContainsPointProjdToNormal(Vector n, Vector p) const;
    void OffsetInto(SContour *dest, double r) const;
    void CopyInto(SContour *dest) const;
    void FindPointWithMinX();
    Vector AnyEdgeMidpoint() const;

    bool IsEar(int bp, double scaledEps) const;
    bool BridgeToContour(SContour *sc, SEdgeList *el, List&lt;Vector&gt; *vl);
    void ClipEarInto(SMesh *m, int bp, double scaledEps);
    void UvTriangulateInto(SMesh *m, SSurface *srf);
};

</t>
<t tx="leo.20191228122646.84">typedef struct {
    uint32_t face;
    RgbaColor color;
} STriMeta;

</t>
<t tx="leo.20191228122646.85">class SPolygon {
public:
    List&lt;SContour&gt;  l;
    Vector          normal;

    Vector ComputeNormal() const;
    void AddEmptyContour();
    size_t WindingNumberForPoint(Vector p) const;
    double SignedArea() const;
    bool ContainsPoint(Vector p) const;
    void MakeEdgesInto(SEdgeList *el) const;
    void FixContourDirections();
    void Clear();
    bool SelfIntersecting(Vector *intersectsAt) const;
    bool IsEmpty() const;
    Vector AnyPoint() const;
    void OffsetInto(SPolygon *dest, double r) const;
    void UvTriangulateInto(SMesh *m, SSurface *srf);
    void UvGridTriangulateInto(SMesh *m, SSurface *srf);
    void TriangulateInto(SMesh *m) const;
    void InverseTransformInto(SPolygon *sp, Vector u, Vector v, Vector n) const;
};

</t>
<t tx="leo.20191228122646.86">class STriangle {
public:
    int         tag;
    STriMeta    meta;

    union {
        struct { Vector a, b, c; };
        Vector vertices[3];
    };

    union {
        struct { Vector an, bn, cn; };
        Vector normals[3];
    };

    static STriangle From(STriMeta meta, Vector a, Vector b, Vector c);
    Vector Normal() const;
    void FlipNormal();
    double MinAltitude() const;
    bool ContainsPoint(Vector p) const;
    bool ContainsPointProjd(Vector n, Vector p) const;
    STriangle Transform(Vector o, Vector u, Vector v) const;
    @others
};

// A linked list of triangles
</t>
<t tx="leo.20191228122646.87">    bool Raytrace(const Vector &amp;rayPoint, const Vector &amp;rayDir,
                  double *t, Vector *inters) const;
    double SignedVolume() const;
    double Area() const;
    bool IsDegenerate() const;
};

class SBsp2 {
public:
    Vector      np;     // normal to the plane

    Vector      no;     // outer normal to the edge
    double      d;
    SEdge       edge;

    SBsp2       *pos;
    SBsp2       *neg;

    SBsp2       *more;

    void InsertTriangleHow(BspClass how, STriangle *tr, SMesh *m, SBsp3 *bsp3);
    void InsertTriangle(STriangle *tr, SMesh *m, SBsp3 *bsp3);
    Vector IntersectionWith(Vector a, Vector b) const;
    void InsertEdge(SEdge *nedge, Vector nnp, Vector out);
</t>
<t tx="leo.20191228122646.88">    static SBsp2 *InsertOrCreateEdge(SBsp2 *where, SEdge *nedge,
                                     Vector nnp, Vector out);
    static SBsp2 *Alloc();
};

class SBsp3 {
public:
    Vector      n;
    double      d;

    STriangle   tri;
    SBsp3       *pos;
    SBsp3       *neg;

    SBsp3       *more;

    SBsp2       *edges;

    static SBsp3 *Alloc();
    static SBsp3 *FromMesh(const SMesh *m);

    Vector IntersectionWith(Vector a, Vector b) const;

    void InsertHow(BspClass how, STriangle *str, SMesh *instead);
    void Insert(STriangle *str, SMesh *instead);
    static SBsp3 *InsertOrCreate(SBsp3 *where, STriangle *str, SMesh *instead);

</t>
<t tx="leo.20191228122646.89">    void InsertConvexHow(BspClass how, STriMeta meta, Vector *vertex, size_t n,
                                SMesh *instead);
    SBsp3 *InsertConvex(STriMeta meta, Vector *vertex, size_t n, SMesh *instead);

    void InsertInPlane(bool pos2, STriangle *tr, SMesh *m);

    void GenerateInPaintOrder(SMesh *m) const;
};

class SMesh {
public:
    List&lt;STriangle&gt;     l;

    bool    flipNormal;
    bool    keepCoplanar;
    bool    atLeastOneDiscarded;
    bool    isTransparent;

    void Clear();
    void AddTriangle(const STriangle *st);
    void AddTriangle(STriMeta meta, Vector a, Vector b, Vector c);
    void AddTriangle(STriMeta meta, Vector n,
    void MakeFromCopyOf(SMesh *a);
    void MakeFromTransformationOf(SMesh *a, Vector trans,

    bool IsEmpty() const;
    void RemapFaces(Group *g, int remap);

    uint32_t FirstIntersectionWith(Point2d mp) const;

    Vector GetCenterOfMass() const;
</t>
<t tx="leo.20191228122646.9">void GraphicsWindow::MakeTangentArc() {
    if(!LockedInWorkplane()) {
        Error(_("Must be sketching in workplane to create tangent arc."));
        return;
    }

    // The point corresponding to the vertex to be rounded.
    Vector pshared = SK.GetEntity(gs.point[0])-&gt;PointGetNum();
    ClearSelection();

    // First, find two requests (that are not construction, and that are
    // in our group and workplane) that generate entities that have an
    // endpoint at our vertex to be rounded.
    int i, c = 0;
    Entity *ent[2];
    Request *req[2];
    hRequest hreq[2];
    hEntity hent[2];
    bool pointf[2];
    for(auto &amp;r : SK.request) {
        if(r.group != activeGroup)
            continue;
        if(r.workplane != ActiveWorkplane())
            continue;
        if(r.construction)
            continue;
        if(r.type != Request::Type::LINE_SEGMENT &amp;&amp; r.type != Request::Type::ARC_OF_CIRCLE) {
            continue;
        }

        Entity *e = SK.GetEntity(r.h.entity(0));
        Vector ps = e-&gt;EndpointStart(),
               pf = e-&gt;EndpointFinish();

        if(ps.Equals(pshared) || pf.Equals(pshared)) {
            if(c &lt; 2) {
                // We record the entity and request and their handles,
                // and whether the vertex to be rounded is the start or
                // finish of this entity.
                ent[c] = e;
                hent[c] = e-&gt;h;
                req[c] = &amp;r;
                hreq[c] = r.h;
                pointf[c] = (pf.Equals(pshared));
            }
            c++;
        }
    }
    if(c != 2) {
        Error(_("To create a tangent arc, select a point where two "
                "non-construction lines or circles in this group and "
                "workplane join."));
        return;
    }

    Entity *wrkpl = SK.GetEntity(ActiveWorkplane());
    Vector wn = wrkpl-&gt;Normal()-&gt;NormalN();

    // Based on these two entities, we make the objects that we'll use to
    // numerically find the tangent arc.
    ParametricCurve pc[2];
    pc[0].MakeFromEntity(ent[0]-&gt;h, pointf[0]);
    pc[1].MakeFromEntity(ent[1]-&gt;h, pointf[1]);

    // And thereafter we mustn't touch the entity or req ptrs,
    // because the new requests/entities we add might force a
    // realloc.
    memset(ent, 0, sizeof(ent));
    memset(req, 0, sizeof(req));

    Vector pinter;
    double r = 0.0, vv = 0.0;
    // We now do Newton iterations to find the tangent arc, and its positions
    // t back along the two curves, starting from shared point of the curves
    // at t = 0. Lots of iterations helps convergence, and this is still
    // ~10 ms for everything.
    int iters = 1000;
    double t[2] = { 0, 0 }, tp[2];
    for(i = 0; i &lt; iters + 20; i++) {
        Vector p0 = pc[0].PointAt(t[0]),
               p1 = pc[1].PointAt(t[1]),
               t0 = pc[0].TangentAt(t[0]),
               t1 = pc[1].TangentAt(t[1]);

        pinter = Vector::AtIntersectionOfLines(p0, p0.Plus(t0),
                                               p1, p1.Plus(t1),
                                               NULL, NULL, NULL);

        // The sign of vv determines whether shortest distance is
        // clockwise or anti-clockwise.
        Vector v = (wn.Cross(t0)).WithMagnitude(1);
        vv = t1.Dot(v);

        double dot = (t0.WithMagnitude(1)).Dot(t1.WithMagnitude(1));
        double theta = acos(dot);

        if(SS.tangentArcManual) {
            r = SS.tangentArcRadius;
        } else {
            r = 200/scale;
            // Set the radius so that no more than one third of the
            // line segment disappears.
            r = min(r, pc[0].LengthForAuto()*tan(theta/2));
            r = min(r, pc[1].LengthForAuto()*tan(theta/2));;
        }
        // We are source-stepping the radius, to improve convergence. So
        // ramp that for most of the iterations, and then do a few at
        // the end with that constant for polishing.
        if(i &lt; iters) {
            r *= 0.1 + 0.9*i/((double)iters);
        }

        // The distance from the intersection of the lines to the endpoint
        // of the arc, along each line.
        double el = r/tan(theta/2);

        // Compute the endpoints of the arc, for each curve
        Vector pa0 = pinter.Plus(t0.WithMagnitude(el)),
               pa1 = pinter.Plus(t1.WithMagnitude(el));

        tp[0] = t[0];
        tp[1] = t[1];

        // And convert those points to parameter values along the curve.
        t[0] += (pa0.Minus(p0)).DivProjected(t0);
        t[1] += (pa1.Minus(p1)).DivProjected(t1);
    }

    // Stupid check for convergence, and for an out of range result (as
    // we would get, for example, if the line is too short to fit the
    // rounding arc).
    if(fabs(tp[0] - t[0]) &gt; 1e-3 || fabs(tp[1] - t[1]) &gt; 1e-3 ||
        t[0] &lt; 0.01 || t[1] &lt; 0.01 ||
        t[0] &gt; 0.99 || t[1] &gt; 0.99 ||
        isnan(t[0]) || isnan(t[1]))
    {
        Error(_("Couldn't round this corner. Try a smaller radius, or try "
                "creating the desired geometry by hand with tangency "
                "constraints."));
        return;
    }

    // Compute the location of the center of the arc
    Vector center = pc[0].PointAt(t[0]),
           v0inter = pinter.Minus(center);
    int a, b;
    if(vv &lt; 0) {
        a = 1; b = 2;
        center = center.Minus(v0inter.Cross(wn).WithMagnitude(r));
    } else {
        a = 2; b = 1;
        center = center.Plus(v0inter.Cross(wn).WithMagnitude(r));
    }

    SS.UndoRemember();

    if (SS.tangentArcModify) {
        // Delete the coincident constraint for the removed point.
        SK.constraint.ClearTags();
        for(i = 0; i &lt; SK.constraint.n; i++) {
            Constraint *cs = &amp;(SK.constraint[i]);
            if(cs-&gt;group != activeGroup) continue;
            if(cs-&gt;workplane != ActiveWorkplane()) continue;
            if(cs-&gt;type != Constraint::Type::POINTS_COINCIDENT) continue;
            if (SK.GetEntity(cs-&gt;ptA)-&gt;PointGetNum().Equals(pshared)) {
            cs-&gt;tag = 1;
            }
        }
        SK.constraint.RemoveTagged();
    } else {
        // Make the original entities construction, or delete them
        // entirely, according to user preference.
        SK.GetRequest(hreq[0])-&gt;construction = true;
        SK.GetRequest(hreq[1])-&gt;construction = true;
    }

    // Create and position the new tangent arc.
    hRequest harc = AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false);
    Entity *earc = SK.GetEntity(harc.entity(0));
    hEntity hearc = earc-&gt;h;

    SK.GetEntity(earc-&gt;point[0])-&gt;PointForceTo(center);
    SK.GetEntity(earc-&gt;point[a])-&gt;PointForceTo(pc[0].PointAt(t[0]));
    SK.GetEntity(earc-&gt;point[b])-&gt;PointForceTo(pc[1].PointAt(t[1]));

    earc = NULL;

    // Modify or duplicate the original entities and connect them to the tangent arc.
    pc[0].CreateRequestTrimmedTo(t[0], SS.tangentArcModify,
                hent[0], hearc, /*arcFinish=*/(b == 1), pointf[0]);
    pc[1].CreateRequestTrimmedTo(t[1], SS.tangentArcModify,
                hent[1], hearc, /*arcFinish=*/(a == 1), pointf[1]);
}

hEntity GraphicsWindow::SplitLine(hEntity he, Vector pinter) {
    // Save the original endpoints, since we're about to delete this entity.
    Entity *e01 = SK.GetEntity(he);
    hEntity hep0 = e01-&gt;point[0], hep1 = e01-&gt;point[1];
    Vector p0 = SK.GetEntity(hep0)-&gt;PointGetNum(),
           p1 = SK.GetEntity(hep1)-&gt;PointGetNum();

    // Add the two line segments this one gets split into.
    hRequest r0i = AddRequest(Request::Type::LINE_SEGMENT, /*rememberForUndo=*/false),
             ri1 = AddRequest(Request::Type::LINE_SEGMENT, /*rememberForUndo=*/false);
    // Don't get entities till after adding, realloc issues

    Entity *e0i = SK.GetEntity(r0i.entity(0)),
           *ei1 = SK.GetEntity(ri1.entity(0));

    SK.GetEntity(e0i-&gt;point[0])-&gt;PointForceTo(p0);
    SK.GetEntity(e0i-&gt;point[1])-&gt;PointForceTo(pinter);
    SK.GetEntity(ei1-&gt;point[0])-&gt;PointForceTo(pinter);
    SK.GetEntity(ei1-&gt;point[1])-&gt;PointForceTo(p1);

    ReplacePointInConstraints(hep0, e0i-&gt;point[0]);
    ReplacePointInConstraints(hep1, ei1-&gt;point[1]);
    Constraint::ConstrainCoincident(e0i-&gt;point[1], ei1-&gt;point[0]);
    return e0i-&gt;point[1];
}

hEntity GraphicsWindow::SplitCircle(hEntity he, Vector pinter) {
    Entity *circle = SK.GetEntity(he);
    if(circle-&gt;type == Entity::Type::CIRCLE) {
        // Start with an unbroken circle, split it into a 360 degree arc.
        Vector center = SK.GetEntity(circle-&gt;point[0])-&gt;PointGetNum();

        circle = NULL; // shortly invalid!
        hRequest hr = AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false);

        Entity *arc = SK.GetEntity(hr.entity(0));

        SK.GetEntity(arc-&gt;point[0])-&gt;PointForceTo(center);
        SK.GetEntity(arc-&gt;point[1])-&gt;PointForceTo(pinter);
        SK.GetEntity(arc-&gt;point[2])-&gt;PointForceTo(pinter);

        Constraint::ConstrainCoincident(arc-&gt;point[1], arc-&gt;point[2]);
        return arc-&gt;point[1];
    } else {
        // Start with an arc, break it in to two arcs
        hEntity hc = circle-&gt;point[0],
                hs = circle-&gt;point[1],
                hf = circle-&gt;point[2];
        Vector center = SK.GetEntity(hc)-&gt;PointGetNum(),
               start  = SK.GetEntity(hs)-&gt;PointGetNum(),
               finish = SK.GetEntity(hf)-&gt;PointGetNum();

        circle = NULL; // shortly invalid!
        hRequest hr0 = AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false),
                 hr1 = AddRequest(Request::Type::ARC_OF_CIRCLE, /*rememberForUndo=*/false);

        Entity *arc0 = SK.GetEntity(hr0.entity(0)),
               *arc1 = SK.GetEntity(hr1.entity(0));

        SK.GetEntity(arc0-&gt;point[0])-&gt;PointForceTo(center);
        SK.GetEntity(arc0-&gt;point[1])-&gt;PointForceTo(start);
        SK.GetEntity(arc0-&gt;point[2])-&gt;PointForceTo(pinter);

        SK.GetEntity(arc1-&gt;point[0])-&gt;PointForceTo(center);
        SK.GetEntity(arc1-&gt;point[1])-&gt;PointForceTo(pinter);
        SK.GetEntity(arc1-&gt;point[2])-&gt;PointForceTo(finish);

        ReplacePointInConstraints(hs, arc0-&gt;point[1]);
        ReplacePointInConstraints(hf, arc1-&gt;point[2]);
        Constraint::ConstrainCoincident(arc0-&gt;point[2], arc1-&gt;point[1]);
        return arc0-&gt;point[2];
    }
}

hEntity GraphicsWindow::SplitCubic(hEntity he, Vector pinter) {
    // Save the original endpoints, since we're about to delete this entity.
    Entity *e01 = SK.GetEntity(he);
    SBezierList sbl = {};
    e01-&gt;GenerateBezierCurves(&amp;sbl);

    hEntity hep0 = e01-&gt;point[0],
            hep1 = e01-&gt;point[3+e01-&gt;extraPoints],
            hep0n = Entity::NO_ENTITY, // the new start point
            hep1n = Entity::NO_ENTITY, // the new finish point
            hepin = Entity::NO_ENTITY; // the intersection point

    // The curve may consist of multiple cubic segments. So find which one
    // contains the intersection point.
    double t;
    int i, j;
    for(i = 0; i &lt; sbl.l.n; i++) {
        SBezier *sb = &amp;(sbl.l[i]);
        ssassert(sb-&gt;deg == 3, "Expected a cubic bezier");

        sb-&gt;ClosestPointTo(pinter, &amp;t, /*mustConverge=*/false);
        if(pinter.Equals(sb-&gt;PointAt(t))) {
            // Split that segment at the intersection.
            SBezier b0i, bi1, b01 = *sb;
            b01.SplitAt(t, &amp;b0i, &amp;bi1);

            // Add the two cubic segments this one gets split into.
            hRequest r0i = AddRequest(Request::Type::CUBIC, /*rememberForUndo=*/false),
                     ri1 = AddRequest(Request::Type::CUBIC, /*rememberForUndo=*/false);
            // Don't get entities till after adding, realloc issues

            Entity *e0i = SK.GetEntity(r0i.entity(0)),
                   *ei1 = SK.GetEntity(ri1.entity(0));

            for(j = 0; j &lt;= 3; j++) {
                SK.GetEntity(e0i-&gt;point[j])-&gt;PointForceTo(b0i.ctrl[j]);
            }
            for(j = 0; j &lt;= 3; j++) {
                SK.GetEntity(ei1-&gt;point[j])-&gt;PointForceTo(bi1.ctrl[j]);
            }

            Constraint::ConstrainCoincident(e0i-&gt;point[3], ei1-&gt;point[0]);
            if(i == 0) hep0n = e0i-&gt;point[0];
            hep1n = ei1-&gt;point[3];
            hepin = e0i-&gt;point[3];
        } else {
            hRequest r = AddRequest(Request::Type::CUBIC, /*rememberForUndo=*/false);
            Entity *e = SK.GetEntity(r.entity(0));

            for(j = 0; j &lt;= 3; j++) {
                SK.GetEntity(e-&gt;point[j])-&gt;PointForceTo(sb-&gt;ctrl[j]);
            }

            if(i == 0) hep0n = e-&gt;point[0];
            hep1n = e-&gt;point[3];
        }
    }

    sbl.Clear();

    ReplacePointInConstraints(hep0, hep0n);
    ReplacePointInConstraints(hep1, hep1n);
    return hepin;
}

hEntity GraphicsWindow::SplitEntity(hEntity he, Vector pinter) {
    Entity *e = SK.GetEntity(he);
    Entity::Type entityType = e-&gt;type;

    hEntity ret;
    if(e-&gt;IsCircle()) {
        ret = SplitCircle(he, pinter);
    } else if(e-&gt;type == Entity::Type::LINE_SEGMENT) {
        ret = SplitLine(he, pinter);
    } else if(e-&gt;type == Entity::Type::CUBIC || e-&gt;type == Entity::Type::CUBIC_PERIODIC) {
        ret = SplitCubic(he, pinter);
    } else {
        Error(_("Couldn't split this entity; lines, circles, or cubics only."));
        return Entity::NO_ENTITY;
    }

    // Finally, delete the request that generated the original entity.
    Request::Type reqType = EntReqTable::GetRequestForEntity(entityType);
    SK.request.ClearTags();
    for(auto &amp;r : SK.request) {
        if(r.group != activeGroup)
            continue;
        if(r.type != reqType)
            continue;

        // If the user wants to keep the old entities around, they can just
        // mark them construction first.
        if(he == r.h.entity(0) &amp;&amp; !r.construction) {
            r.tag = 1;
            break;
        }
    }
    DeleteTaggedRequests();

    return ret;
}

</t>
<t tx="leo.20191228122646.90">class STriangleLl {
public:
    STriangle       *tri;

    STriangleLl     *next;

    static STriangleLl *Alloc();
};

</t>
<t tx="leo.20191228122646.91">class SOutline {
public:
    int    tag;
    Vector a, b, nl, nr;

    bool IsVisible(Vector projDir) const;
};

</t>
<t tx="leo.20191228122646.92">class SOutlineList {
public:
    List&lt;SOutline&gt; l;

    void Clear();
    void AddEdge(Vector a, Vector b, Vector nl, Vector nr, int tag = 0);
    void ListTaggedInto(SEdgeList *el, int auxA = 0, int auxB = 0);

    void MakeFromCopyOf(SOutlineList *ol);
};

</t>
<t tx="leo.20191228122646.93">class SKdNode {
public:
    struct EdgeOnInfo {
        int        count;
        bool       frontFacing;
        bool       intersectsMesh;
        STriangle *tr;
        int        ai;
        int        bi;
    };

    int which;  // whether c is x, y, or z
    double c;

    SKdNode      *gt;
    SKdNode      *lt;

    STriangleLl  *tris;

    static SKdNode *Alloc();
    static SKdNode *From(SMesh *m);
    static SKdNode *From(STriangleLl *tll);

    void AddTriangle(STriangle *tr);
    void MakeMeshInto(SMesh *m) const;
    void ListTrianglesInto(std::vector&lt;STriangle *&gt; *tl) const;
    void ClearTags() const;

    void FindEdgeOn(Vector a, Vector b, int cnt, bool coplanarIsInter, EdgeOnInfo *info) const;
    void MakeCertainEdgesInto(SEdgeList *sel, EdgeKind how, bool coplanarIsInter,
@others
</t>
<t tx="leo.20191228122646.94">class PolylineBuilder {
public:
    struct Edge;

    struct Vertex {
        Vector              pos;
        std::vector&lt;Edge *&gt; edges;

        bool GetNext(uint32_t kind, Vertex **next, Edge **nextEdge);
        bool GetNext(uint32_t kind, Vector plane, double d, Vertex **next, Edge **nextEdge);
        size_t CountEdgesWithTagAndKind(int tag, uint32_t kind) const;
    };

    struct VertexPairHash {
        size_t operator()(const std::pair&lt;Vertex *, Vertex *&gt; &amp;v) const;
    };

    struct Edge {
        Vertex   *a;
        Vertex   *b;
        uint32_t  kind;
        int       tag;

        union {
            uintptr_t  data;
            SOutline  *outline;
            SEdge     *edge;
        };

        Vertex *GetOtherVertex(Vertex *v) const;
        bool GetStartAndNext(Vertex **start, Vertex **next, bool loop) const;
    };

    std::unordered_map&lt;Vector, Vertex *, VectorHash, VectorPred&gt; vertices;
    std::unordered_map&lt;std::pair&lt;Vertex *, Vertex *&gt;, Edge *, VertexPairHash&gt; edgeMap;
    std::vector&lt;Edge *&gt; edges;

    ~PolylineBuilder();
    void Clear();

    Vertex *AddVertex(const Vector &amp;pos);
    Edge *AddEdge(const Vector &amp;p0, const Vector &amp;p1, uint32_t kind, uintptr_t data = 0);
    void Generate(std::function&lt;void(Vertex *start, Vertex *next, Edge *edge)&gt; const &amp;startFunc,
#endif

</t>
<t tx="leo.20191228122646.95">@path ./src/
//-----------------------------------------------------------------------------
// A helper class to assemble scattered edges into contiguous polylines,
// as nicely as possible.
//
// Copyright 2016 M-Labs Ltd
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122646.96">bool PolylineBuilder::Vertex::GetNext(uint32_t kind, Vertex **next, Edge **nextEdge) {
    @others
}

</t>
<t tx="leo.20191228122646.97">auto it = std::find_if(edges.begin(), edges.end(), [&amp;](const Edge *e) {
    return e-&gt;tag == 0 &amp;&amp; e-&gt;kind == kind;
});

if(it != edges.end()) {
    (*it)-&gt;tag = 1;
    *next = (*it)-&gt;GetOtherVertex(this);
    *nextEdge = *it;
    return true;
}

return false;
</t>
<t tx="leo.20191228122646.98">bool PolylineBuilder::Vertex::GetNext(uint32_t kind, Vector plane, double dist,
                                      Vertex **next, Edge **nextEdge) {
    Edge *best = NULL;
    double minD = VERY_POSITIVE;
    for(Edge *e : edges) {
        if(e-&gt;tag != 0) continue;
        if(e-&gt;kind != kind) continue;

        // We choose the best next edge with minimal distance from the current plane
        Vector nextPos = e-&gt;GetOtherVertex(this)-&gt;pos;
        double curD = fabs(plane.Dot(nextPos) - dist);
        if(best != NULL &amp;&amp; curD &gt; minD) continue;
        best = e;
        minD = curD;
    }

    if(best != NULL) {
        best-&gt;tag = 1;
        *next = best-&gt;GetOtherVertex(this);
        *nextEdge = best;
        return true;
    }

    return false;
}


size_t PolylineBuilder::Vertex::CountEdgesWithTagAndKind(int tag, uint32_t kind) const {
    return std::count_if(edges.begin(), edges.end(), [&amp;](const Edge *e) {
        return e-&gt;tag == tag &amp;&amp; e-&gt;kind == kind;
    });
}

PolylineBuilder::Vertex *PolylineBuilder::Edge::GetOtherVertex(PolylineBuilder::Vertex *v) const {
    if(a == v) return b;
    if(b == v) return a;
    return NULL;
}

size_t PolylineBuilder::VertexPairHash::operator()(const std::pair&lt;Vertex *, Vertex *&gt; &amp;v) const {
    return ((uintptr_t)v.first / sizeof(Vertex)) ^
           ((uintptr_t)v.second / sizeof(Vertex));
}

</t>
<t tx="leo.20191228122646.99">bool PolylineBuilder::Edge::GetStartAndNext(PolylineBuilder::Vertex **start,
                                            PolylineBuilder::Vertex **next, bool loop) const {
    size_t numA = a-&gt;CountEdgesWithTagAndKind(0, kind);
    size_t numB = b-&gt;CountEdgesWithTagAndKind(0, kind);

    if((numA == 1 &amp;&amp; numB &gt; 1) || (loop &amp;&amp; numA &gt; 1 &amp;&amp; numB &gt; 1)) {
        *start = a;
        *next = b;
        return true;
    }

    if(numA &gt; 1 &amp;&amp; numB == 1) {
        *start = b;
        *next = a;
        return true;
    }

    return false;
}

PolylineBuilder::~PolylineBuilder() {
    Clear();
}

</t>
<t tx="leo.20191228122647.1">@path ./src/
//-----------------------------------------------------------------------------
// Discovery and loading of our resources (icons, fonts, templates, etc).
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------

#ifndef __RESOURCE_H
#define __RESOURCE_H

class Camera;
class Point2d;
class Pixmap;
class Vector;

std::string LoadString(const std::string &amp;name);
std::string LoadStringFromGzip(const std::string &amp;name);
std::shared_ptr&lt;Pixmap&gt; LoadPng(const std::string &amp;name);

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122647.10">class hStyle {
public:
    uint32_t v;
};

template&lt;&gt;
struct IsHandleOracle&lt;hStyle&gt; : std::true_type {};

struct EntityId {
    uint32_t v;     // entity ID, starting from 0
};

template&lt;&gt;
struct IsHandleOracle&lt;EntityId&gt; : std::true_type {};

struct EntityKey {
    hEntity     input;
    int         copyNumber;
    // (input, copyNumber) gets mapped to ((Request)xxx).entity(h.v)
};
struct EntityKeyHash {
    size_t operator()(const EntityKey &amp;k) const {
        size_t h1 = std::hash&lt;uint32_t&gt;{}(k.input.v),
               h2 = std::hash&lt;uint32_t&gt;{}(k.copyNumber);
        return h1 ^ (h2 &lt;&lt; 1);
    }
};
struct EntityKeyEqual {
</t>
<t tx="leo.20191228122647.100">void TextWindow::ScreenChangeStyleYesNo(int link, uint32_t v) {
    SS.UndoRemember();
    hStyle hs = { v };
    Style *s = Style::Get(hs);
    switch(link) {
        // Units for the width
        case 'w':
            if(s-&gt;widthAs != Style::UnitsAs::MM) {
                s-&gt;widthAs = Style::UnitsAs::MM;
                s-&gt;width /= SS.GW.scale;
                s-&gt;stippleScale /= SS.GW.scale;
            }
            break;
        case 'W':
            if(s-&gt;widthAs != Style::UnitsAs::PIXELS) {
                s-&gt;widthAs = Style::UnitsAs::PIXELS;
                s-&gt;width *= SS.GW.scale;
                s-&gt;stippleScale *= SS.GW.scale;
            }
            break;

        // Units for the height
        case 'g':
            if(s-&gt;textHeightAs != Style::UnitsAs::MM) {
                s-&gt;textHeightAs = Style::UnitsAs::MM;
                s-&gt;textHeight /= SS.GW.scale;
            }
            break;

        case 'G':
            if(s-&gt;textHeightAs != Style::UnitsAs::PIXELS) {
                s-&gt;textHeightAs = Style::UnitsAs::PIXELS;
                s-&gt;textHeight *= SS.GW.scale;
            }
            break;

        case 'e':
            s-&gt;exportable = !(s-&gt;exportable);
            break;

        case 'v':
            s-&gt;visible = !(s-&gt;visible);
            break;

        case 'f':
            s-&gt;filled = !(s-&gt;filled);
            break;

        // Horizontal text alignment
        case 'L':
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin |  (uint32_t)Style::TextOrigin::LEFT);
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::RIGHT);
            break;
        case 'H':
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::LEFT);
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::RIGHT);
            break;
        case 'R':
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::LEFT);
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin |  (uint32_t)Style::TextOrigin::RIGHT);
            break;

        // Vertical text alignment
        case 'B':
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin |  (uint32_t)Style::TextOrigin::BOT);
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::TOP);
            break;
        case 'V':
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::BOT);
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::TOP);
            break;
        case 'T':
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin &amp; ~(uint32_t)Style::TextOrigin::BOT);
            s-&gt;textOrigin = (Style::TextOrigin)((uint32_t)s-&gt;textOrigin |  (uint32_t)Style::TextOrigin::TOP);
            break;
    }
    SS.GW.Invalidate(/*clearPersistent=*/true);
}

</t>
<t tx="leo.20191228122647.101">bool TextWindow::EditControlDoneForStyles(const std::string &amp;str) {
    Style *s;
    switch(edit.meaning) {
        case Edit::STYLE_STIPPLE_PERIOD:
        case Edit::STYLE_TEXT_HEIGHT:
        case Edit::STYLE_WIDTH: {
            SS.UndoRemember();
            s = Style::Get(edit.style);

            double v;
            Style::UnitsAs units = (edit.meaning == Edit::STYLE_TEXT_HEIGHT) ?
                            s-&gt;textHeightAs : s-&gt;widthAs;
            if(units == Style::UnitsAs::MM) {
                v = SS.StringToMm(str);
            } else {
                v = atof(str.c_str());
            }
            v = max(0.0, v);
            if(edit.meaning == Edit::STYLE_TEXT_HEIGHT) {
                s-&gt;textHeight = v;
            } else if(edit.meaning == Edit::STYLE_STIPPLE_PERIOD) {
                s-&gt;stippleScale = v;
            } else {
                s-&gt;width = v;
            }
            break;
        }
        case Edit::STYLE_TEXT_ANGLE:
            SS.UndoRemember();
            s = Style::Get(edit.style);
            s-&gt;textAngle = WRAP_SYMMETRIC(atof(str.c_str()), 360);
            break;

        case Edit::BACKGROUND_COLOR:
        case Edit::STYLE_FILL_COLOR:
        case Edit::STYLE_COLOR: {
            Vector rgb;
            if(sscanf(str.c_str(), "%lf, %lf, %lf", &amp;rgb.x, &amp;rgb.y, &amp;rgb.z)==3) {
                rgb = rgb.ClampWithin(0, 1);
                if(edit.meaning == Edit::STYLE_COLOR) {
                    SS.UndoRemember();
                    s = Style::Get(edit.style);
                    s-&gt;color = RGBf(rgb.x, rgb.y, rgb.z);
                } else if(edit.meaning == Edit::STYLE_FILL_COLOR) {
                    SS.UndoRemember();
                    s = Style::Get(edit.style);
                    s-&gt;fillColor = RGBf(rgb.x, rgb.y, rgb.z);
                } else {
                    SS.backgroundColor = RGBf(rgb.x, rgb.y, rgb.z);
                }
            } else {
                Error(_("Bad format: specify color as r, g, b"));
            }
            break;
        }
        case Edit::STYLE_NAME:
            if(str.empty()) {
                Error(_("Style name cannot be empty"));
            } else {
                SS.UndoRemember();
                s = Style::Get(edit.style);
                s-&gt;name = str;
            }
            break;

        default: return false;
    }
    SS.GW.persistentDirty = true;
    return true;
}

</t>
<t tx="leo.20191228122647.102">void TextWindow::ShowStyleInfo() {
    Printf(true, "%Fl%f%Ll(back to list of styles)%E", &amp;ScreenShowListOfStyles);

    Style *s = Style::Get(shown.style);

    if(s-&gt;h.v &lt; Style::FIRST_CUSTOM) {
        Printf(true, "%FtSTYLE  %E%s ", s-&gt;DescriptionString().c_str());
    } else {
        Printf(true, "%FtSTYLE  %E%s "
                     "[%Fl%Ll%D%frename%E/%Fl%Ll%D%fdel%E]",
            s-&gt;DescriptionString().c_str(),
            s-&gt;h.v, &amp;ScreenChangeStyleName,
            s-&gt;h.v, &amp;ScreenDeleteStyle);
    }
    Printf(true, "%Ft line stroke style%E");
    Printf(false, "%Ba   %Ftcolor %E%Bz  %Ba (%@, %@, %@) %D%f%Ls%Fl[change]%E",
        &amp;s-&gt;color,
        s-&gt;color.redF(), s-&gt;color.greenF(), s-&gt;color.blueF(),
        s-&gt;h.v, ScreenChangeStyleColor);

    // The line width, and its units
    if(s-&gt;widthAs == Style::UnitsAs::PIXELS) {
        Printf(false, "   %Ftwidth%E %@ %D%f%Lp%Fl[change]%E",
            s-&gt;width,
            s-&gt;h.v, &amp;ScreenChangeStyleMetric,
            (s-&gt;h.v &lt; Style::FIRST_CUSTOM) ? 'w' : 'W');
    } else {
        Printf(false, "   %Ftwidth%E %s %D%f%Lp%Fl[change]%E",
            SS.MmToString(s-&gt;width).c_str(),
            s-&gt;h.v, &amp;ScreenChangeStyleMetric,
            (s-&gt;h.v &lt; Style::FIRST_CUSTOM) ? 'w' : 'W');
    }

    if(s-&gt;widthAs == Style::UnitsAs::PIXELS) {
        Printf(false, "%Ba   %Ftstipple width%E %@ %D%f%Lp%Fl[change]%E",
            s-&gt;stippleScale,
            s-&gt;h.v, &amp;ScreenChangeStyleMetric, 's');
    } else {
        Printf(false, "%Ba   %Ftstipple width%E %s %D%f%Lp%Fl[change]%E",
            SS.MmToString(s-&gt;stippleScale).c_str(),
            s-&gt;h.v, &amp;ScreenChangeStyleMetric, 's');
    }

    bool widthpx = (s-&gt;widthAs == Style::UnitsAs::PIXELS);
    if(s-&gt;h.v &lt; Style::FIRST_CUSTOM) {
        Printf(false,"   %Ftin units of %Fdpixels%E");
    } else {
        Printf(false,"%Ba   %Ftin units of  %Fd"
                            "%D%f%LW%s pixels%E  "
                            "%D%f%Lw%s %s",
            s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
            widthpx ? RADIO_TRUE : RADIO_FALSE,
            s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
            !widthpx ? RADIO_TRUE : RADIO_FALSE,
            SS.UnitName());
    }

    Printf(false,"%Ba   %Ftstipple type:%E");

    const size_t patternCount = (size_t)StipplePattern::LAST + 1;
    @others
}

</t>
<t tx="leo.20191228122647.103">const char *patternsSource[patternCount] = {
    "___________",
    "-  -  -  - ",
    "- - - - - -",
    "__ __ __ __",
    "-.-.-.-.-.-",
    "..-..-..-..",
    "...........",
    "~~~~~~~~~~~",
    "__~__~__~__"
};
std::string patterns[patternCount];

for(uint32_t i = 0; i &lt;= (uint32_t)StipplePattern::LAST; i++) {
    const char *str = patternsSource[i];
    do {
        switch(*str) {
            case ' ': patterns[i] += " "; break;
            case '.': patterns[i] += "\xEE\x80\x84"; break;
            case '_': patterns[i] += "\xEE\x80\x85"; break;
            case '-': patterns[i] += "\xEE\x80\x86"; break;
            case '~': patterns[i] += "\xEE\x80\x87"; break;
            default: ssassert(false, "Unexpected stipple pattern element");
        }
    } while(*(++str));
}

for(uint32_t i = 0; i &lt;= (uint32_t)StipplePattern::LAST; i++) {
    const char *radio = s-&gt;stippleType == (StipplePattern)i ? RADIO_TRUE : RADIO_FALSE;
    Printf(false, "%Bp     %D%f%Lp%s %s%E",
        (i % 2 == 0) ? 'd' : 'a',
        s-&gt;h.v, &amp;ScreenChangeStylePatternType,
        i + 1, radio, patterns[i].c_str());
}

if(s-&gt;h.v &gt;= Style::FIRST_CUSTOM) {
    // The fill color, and whether contours are filled

    Printf(false, "");
    Printf(false, "%Ft contour fill style%E");
    Printf(false,
        "%Ba   %Ftcolor %E%Bz  %Ba (%@, %@, %@) %D%f%Lf%Fl[change]%E",
        &amp;s-&gt;fillColor,
        s-&gt;fillColor.redF(), s-&gt;fillColor.greenF(), s-&gt;fillColor.blueF(),
        s-&gt;h.v, ScreenChangeStyleColor);

    Printf(false, "%Bd   %D%f%Lf%s  contours are filled%E",
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        s-&gt;filled ? CHECK_TRUE : CHECK_FALSE);
}

// The text height, and its units
Printf(false, "");
Printf(false, "%Ft text style%E");

if(s-&gt;textHeightAs == Style::UnitsAs::PIXELS) {
    Printf(false, "%Ba   %Ftheight %E%@ %D%f%Lt%Fl%s%E",
        s-&gt;textHeight,
        s-&gt;h.v, &amp;ScreenChangeStyleMetric,
        "[change]");
} else {
    Printf(false, "%Ba   %Ftheight %E%s %D%f%Lt%Fl%s%E",
        SS.MmToString(s-&gt;textHeight).c_str(),
        s-&gt;h.v, &amp;ScreenChangeStyleMetric,
        "[change]");
}

bool textHeightpx = (s-&gt;textHeightAs == Style::UnitsAs::PIXELS);
if(s-&gt;h.v &lt; Style::FIRST_CUSTOM) {
    Printf(false,"%Bd   %Ftin units of %Fdpixels");
} else {
    Printf(false,"%Bd   %Ftin units of  %Fd"
                        "%D%f%LG%s pixels%E  "
                        "%D%f%Lg%s %s",
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        textHeightpx ? RADIO_TRUE : RADIO_FALSE,
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        !textHeightpx ? RADIO_TRUE : RADIO_FALSE,
        SS.UnitName());
}

if(s-&gt;h.v &gt;= Style::FIRST_CUSTOM) {
    Printf(false, "%Ba   %Ftangle %E%@ %D%f%Ll%Fl[change]%E",
        s-&gt;textAngle,
        s-&gt;h.v, &amp;ScreenChangeStyleTextAngle);

    Printf(false, "");
    Printf(false, "%Ft text comment alignment%E");
    bool neither;
    neither = !((uint32_t)s-&gt;textOrigin &amp; ((uint32_t)Style::TextOrigin::LEFT | (uint32_t)Style::TextOrigin::RIGHT));
    Printf(false, "%Ba   "
                  "%D%f%LL%s left%E    "
                  "%D%f%LH%s center%E  "
                  "%D%f%LR%s right%E  ",
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        ((uint32_t)s-&gt;textOrigin &amp; (uint32_t)Style::TextOrigin::LEFT) ? RADIO_TRUE : RADIO_FALSE,
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        neither ? RADIO_TRUE : RADIO_FALSE,
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        ((uint32_t)s-&gt;textOrigin &amp; (uint32_t)Style::TextOrigin::RIGHT) ? RADIO_TRUE : RADIO_FALSE);

    neither = !((uint32_t)s-&gt;textOrigin &amp; ((uint32_t)Style::TextOrigin::BOT | (uint32_t)Style::TextOrigin::TOP));
    Printf(false, "%Bd   "
                  "%D%f%LB%s bottom%E  "
                  "%D%f%LV%s center%E  "
                  "%D%f%LT%s top%E  ",
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        ((uint32_t)s-&gt;textOrigin &amp; (uint32_t)Style::TextOrigin::BOT) ? RADIO_TRUE : RADIO_FALSE,
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        neither ? RADIO_TRUE : RADIO_FALSE,
        s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
        ((uint32_t)s-&gt;textOrigin &amp; (uint32_t)Style::TextOrigin::TOP) ? RADIO_TRUE : RADIO_FALSE);
}

if(s-&gt;h.v &gt;= Style::FIRST_CUSTOM) {
    Printf(false, "");

    Printf(false, "  %Fd%D%f%Lv%s  show these objects on screen%E",
            s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
            s-&gt;visible ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, "  %Fd%D%f%Le%s  export these objects%E",
            s-&gt;h.v, &amp;ScreenChangeStyleYesNo,
            s-&gt;exportable ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, "");
    Printf(false, "To assign lines or curves to this style,");
    Printf(false, "right-click them on the drawing.");
}
</t>
<t tx="leo.20191228122647.104">void TextWindow::ScreenAssignSelectionToStyle(int link, uint32_t v) {
    Style::AssignSelectionToStyle(v);
}
</t>
<t tx="leo.20191228122647.105">@path ./src/
//-----------------------------------------------------------------------------
// Once we've written our constraint equations in the symbolic algebra system,
// these routines linearize them, and solve by a modified Newton's method.
// This also contains the routines to detect non-convergence or inconsistency,
// and report diagnostics to the user.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

// This tolerance is used to determine whether two (linearized) constraints
// are linearly dependent. If this is too small, then we will attempt to
// solve truly inconsistent systems and fail. But if it's too large, then
// we will give up on legitimate systems like a skinny right angle triangle by
// its hypotenuse and long side.
const double System::RANK_MAG_TOLERANCE = 1e-4;

// The solver will converge all unknowns to within this tolerance. This must
// always be much less than LENGTH_EPS, and in practice should be much less.
const double System::CONVERGE_TOLERANCE = (LENGTH_EPS/(1e2));

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122647.106">bool System::WriteJacobian(int tag) {

    int j = 0;
    for(auto &amp;p : param) {
        if(j &gt;= MAX_UNKNOWNS)
            return false;

        if(p.tag != tag)
            continue;
        mat.param[j] = p.h;
        j++;
    }
    mat.n = j;

    int i = 0;

    for(auto &amp;e : eq) {
        if(i &gt;= MAX_UNKNOWNS) return false;

        if(e.tag != tag)
            continue;

        mat.eq[i] = e.h;
        Expr *f   = e.e-&gt;DeepCopyWithParamsAsPointers(&amp;param, &amp;(SK.param));
        f = f-&gt;FoldConstants();

        // Hash table (61 bits) to accelerate generation of zero partials.
        uint64_t scoreboard = f-&gt;ParamsUsed();
        for(j = 0; j &lt; mat.n; j++) {
            Expr *pd;
            if(scoreboard &amp; ((uint64_t)1 &lt;&lt; (mat.param[j].v % 61)) &amp;&amp;
                f-&gt;DependsOn(mat.param[j]))
            {
                pd = f-&gt;PartialWrt(mat.param[j]);
                pd = pd-&gt;FoldConstants();
                pd = pd-&gt;DeepCopyWithParamsAsPointers(&amp;param, &amp;(SK.param));
            } else {
                pd = Expr::From(0.0);
            }
            mat.A.sym[i][j] = pd;
        }
        mat.B.sym[i] = f;
        i++;
    }
    mat.m = i;

    return true;
}

</t>
<t tx="leo.20191228122647.107">void System::EvalJacobian() {
    int i, j;
    for(i = 0; i &lt; mat.m; i++) {
        for(j = 0; j &lt; mat.n; j++) {
            mat.A.num[i][j] = (mat.A.sym[i][j])-&gt;Eval();
        }
    }
}

</t>
<t tx="leo.20191228122647.108">bool System::IsDragged(hParam p) {
    hParam *pp;
    for(pp = dragged.First(); pp; pp = dragged.NextAfter(pp)) {
        if(p == *pp) return true;
    }
    return false;
}

</t>
<t tx="leo.20191228122647.109">void System::SolveBySubstitution() {
    for(auto &amp;teq : eq) {
        Expr *tex = teq.e;

        if(tex-&gt;op    == Expr::Op::MINUS &amp;&amp;
           tex-&gt;a-&gt;op == Expr::Op::PARAM &amp;&amp;
           tex-&gt;b-&gt;op == Expr::Op::PARAM)
        {
            hParam a = tex-&gt;a-&gt;parh;
            hParam b = tex-&gt;b-&gt;parh;
            if(!(param.FindByIdNoOops(a) &amp;&amp; param.FindByIdNoOops(b))) {
                // Don't substitute unless they're both solver params;
                // otherwise it's an equation that can be solved immediately,
                // or an error to flag later.
                continue;
            }

            if(IsDragged(a)) {
                // A is being dragged, so A should stay, and B should go
                std::swap(a, b);
            }

            for(auto &amp;req : eq) {
                req.e-&gt;Substitute(a, b); // A becomes B, B unchanged
            }
            for(auto &amp;rp : param) {
                if(rp.substd == a) {
                    rp.substd = b;
                }
            }
            Param *ptr = param.FindById(a);
            ptr-&gt;tag = VAR_SUBSTITUTED;
            ptr-&gt;substd = b;

            teq.tag = EQ_SUBSTITUTED;
        }
    }
}

//-----------------------------------------------------------------------------
// Calculate the rank of the Jacobian matrix, by Gram-Schimdt orthogonalization
// in place. A row (~equation) is considered to be all zeros if its magnitude
// is less than the tolerance RANK_MAG_TOLERANCE.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122647.11">    bool operator()(const EntityKey &amp;a, const EntityKey &amp;b) const {
        return std::tie(a.input, a.copyNumber) == std::tie(b.input, b.copyNumber);
    }
};
typedef std::unordered_map&lt;EntityKey, EntityId, EntityKeyHash, EntityKeyEqual&gt; EntityMap;

// A set of requests. Every request must have an associated group.
</t>
<t tx="leo.20191228122647.110">int System::CalculateRank() {
    // Actually work with magnitudes squared, not the magnitudes
    double rowMag[MAX_UNKNOWNS] = {};
    double tol = RANK_MAG_TOLERANCE*RANK_MAG_TOLERANCE;

    int i, iprev, j;
    int rank = 0;

    for(i = 0; i &lt; mat.m; i++) {
        // Subtract off this row's component in the direction of any
        // previous rows
        for(iprev = 0; iprev &lt; i; iprev++) {
            if(rowMag[iprev] &lt;= tol) continue; // ignore zero rows

            double dot = 0;
            for(j = 0; j &lt; mat.n; j++) {
                dot += (mat.A.num[iprev][j]) * (mat.A.num[i][j]);
            }
            for(j = 0; j &lt; mat.n; j++) {
                mat.A.num[i][j] -= (dot/rowMag[iprev])*mat.A.num[iprev][j];
            }
        }
        // Our row is now normal to all previous rows; calculate the
        // magnitude of what's left
        double mag = 0;
        for(j = 0; j &lt; mat.n; j++) {
            mag += (mat.A.num[i][j]) * (mat.A.num[i][j]);
        }
        if(mag &gt; tol) {
            rank++;
        }
        rowMag[i] = mag;
    }

    return rank;
}

</t>
<t tx="leo.20191228122647.111">bool System::TestRank(int *rank) {
    EvalJacobian();
    int jacobianRank = CalculateRank();
    if(rank) *rank = jacobianRank;
    return jacobianRank == mat.m;
}

</t>
<t tx="leo.20191228122647.112">bool System::SolveLinearSystem(double X[], double A[][MAX_UNKNOWNS],
                               double B[], int n)
{
    // Gaussian elimination, with partial pivoting. It's an error if the
    // matrix is singular, because that means two constraints are
    // equivalent.
    int i, j, ip, jp, imax = 0;
    double max, temp;

    for(i = 0; i &lt; n; i++) {
        // We are trying eliminate the term in column i, for rows i+1 and
        // greater. First, find a pivot (between rows i and N-1).
        max = 0;
        for(ip = i; ip &lt; n; ip++) {
            if(ffabs(A[ip][i]) &gt; max) {
                imax = ip;
                max = ffabs(A[ip][i]);
            }
        }
        // Don't give up on a singular matrix unless it's really bad; the
        // assumption code is responsible for identifying that condition,
        // so we're not responsible for reporting that error.
        if(ffabs(max) &lt; 1e-20) continue;

        // Swap row imax with row i
        for(jp = 0; jp &lt; n; jp++) {
            swap(A[i][jp], A[imax][jp]);
        }
        swap(B[i], B[imax]);

        // For rows i+1 and greater, eliminate the term in column i.
        for(ip = i+1; ip &lt; n; ip++) {
            temp = A[ip][i]/A[i][i];

            for(jp = i; jp &lt; n; jp++) {
                A[ip][jp] -= temp*(A[i][jp]);
            }
            B[ip] -= temp*B[i];
        }
    }

    // We've put the matrix in upper triangular form, so at this point we
    // can solve by back-substitution.
    for(i = n - 1; i &gt;= 0; i--) {
        if(ffabs(A[i][i]) &lt; 1e-20) continue;

        temp = B[i];
        for(j = n - 1; j &gt; i; j--) {
            temp -= X[j]*A[i][j];
        }
        X[i] = temp / A[i][i];
    }

    return true;
}

</t>
<t tx="leo.20191228122647.113">bool System::SolveLeastSquares() {
    int r, c, i;

    // Scale the columns; this scale weights the parameters for the least
    // squares solve, so that we can encourage the solver to make bigger
    // changes in some parameters, and smaller in others.
    for(c = 0; c &lt; mat.n; c++) {
        if(IsDragged(mat.param[c])) {
            // It's least squares, so this parameter doesn't need to be all
            // that big to get a large effect.
            mat.scale[c] = 1/20.0;
        } else {
            mat.scale[c] = 1;
        }
        for(r = 0; r &lt; mat.m; r++) {
            mat.A.num[r][c] *= mat.scale[c];
        }
    }

    // Write A*A'
    for(r = 0; r &lt; mat.m; r++) {
        for(c = 0; c &lt; mat.m; c++) {  // yes, AAt is square
            double sum = 0;
            for(i = 0; i &lt; mat.n; i++) {
                sum += mat.A.num[r][i]*mat.A.num[c][i];
            }
            mat.AAt[r][c] = sum;
        }
    }

    if(!SolveLinearSystem(mat.Z, mat.AAt, mat.B.num, mat.m)) return false;

    // And multiply that by A' to get our solution.
    for(c = 0; c &lt; mat.n; c++) {
        double sum = 0;
        for(i = 0; i &lt; mat.m; i++) {
            sum += mat.A.num[i][c]*mat.Z[i];
        }
        mat.X[c] = sum * mat.scale[c];
    }
    return true;
}

</t>
<t tx="leo.20191228122647.114">bool System::NewtonSolve(int tag) {

    int iter = 0;
    bool converged = false;
    int i;

    // Evaluate the functions at our operating point.
    for(i = 0; i &lt; mat.m; i++) {
        mat.B.num[i] = (mat.B.sym[i])-&gt;Eval();
    }
    do {
        // And evaluate the Jacobian at our initial operating point.
        EvalJacobian();

        if(!SolveLeastSquares()) break;

        // Take the Newton step;
        //      J(x_n) (x_{n+1} - x_n) = 0 - F(x_n)
        for(i = 0; i &lt; mat.n; i++) {
            Param *p = param.FindById(mat.param[i]);
            p-&gt;val -= mat.X[i];
            if(isnan(p-&gt;val)) {
                // Very bad, and clearly not convergent
                return false;
            }
        }

        // Re-evalute the functions, since the params have just changed.
        for(i = 0; i &lt; mat.m; i++) {
            mat.B.num[i] = (mat.B.sym[i])-&gt;Eval();
        }
        // Check for convergence
        converged = true;
        for(i = 0; i &lt; mat.m; i++) {
            if(isnan(mat.B.num[i])) {
                return false;
            }
            if(ffabs(mat.B.num[i]) &gt; CONVERGE_TOLERANCE) {
                converged = false;
                break;
            }
        }
    } while(iter++ &lt; 50 &amp;&amp; !converged);

    return converged;
}

</t>
<t tx="leo.20191228122647.115">void System::WriteEquationsExceptFor(hConstraint hc, Group *g) {
    // Generate all the equations from constraints in this group
    for(auto &amp;con : SK.constraint) {
        ConstraintBase *c = &amp;con;
        if(c-&gt;group != g-&gt;h) continue;
        if(c-&gt;h == hc) continue;

        if(c-&gt;HasLabel() &amp;&amp; c-&gt;type != Constraint::Type::COMMENT &amp;&amp;
                g-&gt;allDimsReference)
        {
            // When all dimensions are reference, we adjust them to display
            // the correct value, and then don't generate any equations.
            c-&gt;ModifyToSatisfy();
            continue;
        }
        if(g-&gt;relaxConstraints &amp;&amp; c-&gt;type != Constraint::Type::POINTS_COINCIDENT) {
            // When the constraints are relaxed, we keep only the point-
            // coincident constraints, and the constraints generated by
            // the entities and groups.
            continue;
        }

        c-&gt;GenerateEquations(&amp;eq);
    }
    // And the equations from entities
    for(auto &amp;ent : SK.entity) {
        EntityBase *e = &amp;ent;
        if(e-&gt;group != g-&gt;h) continue;

        e-&gt;GenerateEquations(&amp;eq);
    }
    // And from the groups themselves
    g-&gt;GenerateEquations(&amp;eq);
}

</t>
<t tx="leo.20191228122647.116">void System::FindWhichToRemoveToFixJacobian(Group *g, List&lt;hConstraint&gt; *bad, bool forceDofCheck) {
    int a;

    for(a = 0; a &lt; 2; a++) {
        for(auto &amp;con : SK.constraint) {
            ConstraintBase *c = &amp;con;
            if(c-&gt;group != g-&gt;h) continue;
            if((c-&gt;type == Constraint::Type::POINTS_COINCIDENT &amp;&amp; a == 0) ||
               (c-&gt;type != Constraint::Type::POINTS_COINCIDENT &amp;&amp; a == 1))
            {
                // Do the constraints in two passes: first everything but
                // the point-coincident constraints, then only those
                // constraints (so they appear last in the list).
                continue;
            }

            param.ClearTags();
            eq.Clear();
            WriteEquationsExceptFor(c-&gt;h, g);
            eq.ClearTags();

            // It's a major speedup to solve the easy ones by substitution here,
            // and that doesn't break anything.
            if(!forceDofCheck) {
                SolveBySubstitution();
            }

            WriteJacobian(0);
            EvalJacobian();

            int rank = CalculateRank();
            if(rank == mat.m) {
                // We fixed it by removing this constraint
                bad-&gt;Add(&amp;(c-&gt;h));
            }
        }
    }
}

SolveResult System::Solve(Group *g, int *rank, int *dof, List&lt;hConstraint&gt; *bad,
</t>
<t tx="leo.20191228122647.117">                          bool andFindBad, bool andFindFree, bool forceDofCheck)
{
    WriteEquationsExceptFor(Constraint::NO_CONSTRAINT, g);

    int i;
    bool rankOk;

/*
    dbp("%d equations", eq.n);
    for(i = 0; i &lt; eq.n; i++) {
        dbp("  %.3f = %s = 0", eq[i].e-&gt;Eval(), eq[i].e-&gt;Print());
    }
    dbp("%d parameters", param.n);
    for(i = 0; i &lt; param.n; i++) {
        dbp("   param %08x at %.3f", param[i].h.v, param[i].val);
    } */

    // All params and equations are assigned to group zero.
    param.ClearTags();
    eq.ClearTags();

    // Solving by substitution eliminates duplicate e.g. H/V constraints, which can cause rank test
    // to succeed even on overdefined systems, which will fail later.
    if(!forceDofCheck) {
        SolveBySubstitution();
    }

    // Before solving the big system, see if we can find any equations that
    // are soluble alone. This can be a huge speedup. We don't know whether
    // the system is consistent yet, but if it isn't then we'll catch that
    // later.
    int alone = 1;
    for(auto &amp;e : eq) {
        if(e.tag != 0)
            continue;

        hParam hp = e.e-&gt;ReferencedParams(&amp;param);
        if(hp == Expr::NO_PARAMS) continue;
        if(hp == Expr::MULTIPLE_PARAMS) continue;

        Param *p = param.FindById(hp);
        if(p-&gt;tag != 0) continue; // let rank test catch inconsistency

        e.tag  = alone;
        p-&gt;tag = alone;
        WriteJacobian(alone);
        if(!NewtonSolve(alone)) {
            // We don't do the rank test, so let's arbitrarily return
            // the DIDNT_CONVERGE result here.
            rankOk = true;
            // Failed to converge, bail out early
            goto didnt_converge;
        }
        alone++;
    }

    // Now write the Jacobian for what's left, and do a rank test; that
    // tells us if the system is inconsistently constrained.
    if(!WriteJacobian(0)) {
        return SolveResult::TOO_MANY_UNKNOWNS;
    }

    rankOk = TestRank(rank);

    // And do the leftovers as one big system
    if(!NewtonSolve(0)) {
        goto didnt_converge;
    }

    rankOk = TestRank(rank);
    if(!rankOk) {
        if(andFindBad) FindWhichToRemoveToFixJacobian(g, bad, forceDofCheck);
    } else {
        // This is not the full Jacobian, but any substitutions or single-eq
        // solves removed one equation and one unknown, therefore no effect
        // on the number of DOF.
        if(dof) *dof = CalculateDof();
        MarkParamsFree(andFindFree);
    }
    // System solved correctly, so write the new values back in to the
    // main parameter table.
    for(auto &amp;p : param) {
        double val;
        if(p.tag == VAR_SUBSTITUTED) {
            val = param.FindById(p.substd)-&gt;val;
        } else {
            val = p.val;
        }
        Param *pp = SK.GetParam(p.h);
        pp-&gt;val = val;
        pp-&gt;known = true;
        pp-&gt;free  = p.free;
    }
    return rankOk ? SolveResult::OKAY : SolveResult::REDUNDANT_OKAY;

didnt_converge:
    SK.constraint.ClearTags();
    // Not using range-for here because index is used in additional ways
    for(i = 0; i &lt; eq.n; i++) {
        if(ffabs(mat.B.num[i]) &gt; CONVERGE_TOLERANCE || isnan(mat.B.num[i])) {
            // This constraint is unsatisfied.
            if(!mat.eq[i].isFromConstraint()) continue;

            hConstraint hc = mat.eq[i].constraint();
            ConstraintBase *c = SK.constraint.FindByIdNoOops(hc);
            if(!c) continue;
            // Don't double-show constraints that generated multiple
            // unsatisfied equations
            if(!c-&gt;tag) {
                bad-&gt;Add(&amp;(c-&gt;h));
                c-&gt;tag = 1;
            }
        }
    }

    return rankOk ? SolveResult::DIDNT_CONVERGE : SolveResult::REDUNDANT_DIDNT_CONVERGE;
}

SolveResult System::SolveRank(Group *g, int *rank, int *dof, List&lt;hConstraint&gt; *bad,
</t>
<t tx="leo.20191228122647.118">                              bool andFindBad, bool andFindFree)
{
    WriteEquationsExceptFor(Constraint::NO_CONSTRAINT, g);

    // All params and equations are assigned to group zero.
    param.ClearTags();
    eq.ClearTags();

    // Now write the Jacobian, and do a rank test; that
    // tells us if the system is inconsistently constrained.
    if(!WriteJacobian(0)) {
        return SolveResult::TOO_MANY_UNKNOWNS;
    }

    bool rankOk = TestRank(rank);
    if(!rankOk) {
        if(andFindBad) FindWhichToRemoveToFixJacobian(g, bad, /*forceDofCheck=*/true);
    } else {
        if(dof) *dof = CalculateDof();
        MarkParamsFree(andFindFree);
    }
    return rankOk ? SolveResult::OKAY : SolveResult::REDUNDANT_OKAY;
}

</t>
<t tx="leo.20191228122647.119">void System::Clear() {
    entity.Clear();
    param.Clear();
    eq.Clear();
    dragged.Clear();
}

</t>
<t tx="leo.20191228122647.12">class Group {
public:
    static const hGroup     HGROUP_REFERENCES;

    int         tag;
    hGroup      h;

    enum class CopyAs {
        NUMERIC,
        N_TRANS,
        N_ROT_AA,
        N_ROT_TRANS,
        N_ROT_AXIS_TRANS,
    };

    enum class Type : uint32_t {
        DRAWING_3D                    = 5000,
        DRAWING_WORKPLANE             = 5001,
        EXTRUDE                       = 5100,
        LATHE                         = 5101,
        REVOLVE                       = 5102,
        HELIX                         = 5103,
        ROTATE                        = 5200,
        TRANSLATE                     = 5201,
        LINKED                        = 5300
    };
    Group::Type type;

    int order;

    hGroup      opA;
    hGroup      opB;
    bool        visible;
    bool        suppress;
    bool        relaxConstraints;
    bool        allowRedundant;
    bool        allDimsReference;
    double      scale;

    bool        clean;
    bool        dofCheckOk;
    hEntity     activeWorkplane;
    double      valA;
    double      valB;
    double      valC;
    RgbaColor   color;

    struct {
        SolveResult         how;
        int                 dof;
        List&lt;hConstraint&gt;   remove;
    } solved;

    enum class Subtype : uint32_t {
        // For drawings in 2d
        WORKPLANE_BY_POINT_ORTHO   = 6000,
        WORKPLANE_BY_LINE_SEGMENTS = 6001,
        // For extrudes, translates, and rotates
        ONE_SIDED                  = 7000,
        TWO_SIDED                  = 7001
    };
    Group::Subtype subtype;

    bool skipFirst; // for step and repeat ops

    struct {
        Quaternion  q;
        hEntity     origin;
        hEntity     entityB;
        hEntity     entityC;
        bool        swapUV;
        bool        negateU;
        bool        negateV;
    } predef;

    SPolygon                polyLoops;
    SBezierLoopSetSet       bezierLoops;
    SBezierLoopSet          bezierOpens;

    struct {
        PolyError       how;
        SEdge           notClosedAt;
        Vector          errorPointAt;
    }               polyError;

    bool            booleanFailed;

    SShell          thisShell;
    SShell          runningShell;

    SMesh           thisMesh;
    SMesh           runningMesh;

    bool            displayDirty;
    SMesh           displayMesh;
    SOutlineList    displayOutlines;

    enum class CombineAs : uint32_t {
        UNION           = 0,
        DIFFERENCE      = 1,
        ASSEMBLE        = 2
    };
    CombineAs meshCombine;

    bool forceToMesh;

    EntityMap remap;

    Platform::Path linkFile;
    SMesh       impMesh;
    SShell      impShell;
    EntityList  impEntity;

    std::string     name;


    void Activate();
    std::string DescriptionString();
    void Clear();

    static void AddParam(ParamList *param, hParam hp, double v);
    void Generate(EntityList *entity, ParamList *param);
    bool IsSolvedOkay();
    void TransformImportedBy(Vector t, Quaternion q);
    bool IsForcedToMeshBySource() const;
    bool IsForcedToMesh() const;
    // When a request generates entities from entities, and the source
    // entities may have come from multiple requests, it's necessary to
    // remap the entity ID so that it's still unique. We do this with a
    // mapping list.
    enum {
        REMAP_LAST         = 1000,
        REMAP_TOP          = 1001,
        REMAP_BOTTOM       = 1002,
        REMAP_PT_TO_LINE   = 1003,
        REMAP_LINE_TO_FACE = 1004,
        REMAP_LATHE_START  = 1006,
        REMAP_LATHE_END    = 1007,
        REMAP_PT_TO_ARC    = 1008,
        REMAP_PT_TO_NORMAL = 1009,
    };
    hEntity Remap(hEntity in, int copyNumber);
    void MakeExtrusionLines(EntityList *el, hEntity in);
    void MakeLatheCircles(IdList&lt;Entity,hEntity&gt; *el, IdList&lt;Param,hParam&gt; *param, hEntity in, Vector pt, Vector axis, int ai);
    void MakeLatheSurfacesSelectable(IdList&lt;Entity, hEntity&gt; *el, hEntity in, Vector axis);
    void MakeExtrusionTopBottomFaces(EntityList *el, hEntity pt);
    void CopyEntity(EntityList *el,
    void ExtrusionForceVectorTo(const Vector &amp;v);

    // Assembling the curves into loops, and into a piecewise linear polygon
    // at the same time.
    void AssembleLoops(bool *allClosed, bool *allCoplanar, bool *allNonZeroLen);
    void GenerateLoops();
    // And the mesh stuff
    Group *PreviousGroup() const;
    Group *RunningMeshGroup() const;
    bool IsMeshGroup();

    void GenerateShellAndMesh();
    template&lt;class T&gt; void GenerateForStepAndRepeat(T *steps, T *outs, Group::CombineAs forWhat);
    template&lt;class T&gt; void GenerateForBoolean(T *a, T *b, T *o, Group::CombineAs how);
    void GenerateDisplayItems();

    enum class DrawMeshAs { DEFAULT, HOVERED, SELECTED };
    void DrawMesh(DrawMeshAs how, Canvas *canvas);
    void Draw(Canvas *canvas);
    void DrawPolyError(Canvas *canvas);
    void DrawFilledPaths(Canvas *canvas);
    void DrawContourAreaLabels(Canvas *canvas);

    SPolygon GetPolygon();

    static void MenuGroup(Command id);
    static void MenuGroup(Command id, Platform::Path linkFile);
};

// A user request for some primitive or derived operation; for example a
// line, or a step and repeat.
</t>
<t tx="leo.20191228122647.120">void System::MarkParamsFree(bool find) {
    // If requested, find all the free (unbound) variables. This might be
    // more than the number of degrees of freedom. Don't always do this,
    // because the display would get annoying and it's slow.
    for(auto &amp;p : param) {
        p.free = false;

        if(find) {
            if(p.tag == 0) {
                p.tag = VAR_DOF_TEST;
                WriteJacobian(0);
                EvalJacobian();
                int rank = CalculateRank();
                if(rank == mat.m) {
                    p.free = true;
                }
                p.tag = 0;
            }
        }
    }
}

</t>
<t tx="leo.20191228122647.121">int System::CalculateDof() {
    return mat.n - mat.m;
}

</t>
<t tx="leo.20191228122647.122">@path ./src/
//-----------------------------------------------------------------------------
// The text-based browser window, used to view the structure of the model by
// groups and for other similar purposes.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

//-----------------------------------------------------------------------------
// A navigation bar that always appears at the top of the window, with a
// link to bring us back home.
//-----------------------------------------------------------------------------
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122647.123">void TextWindow::ScreenHome(int link, uint32_t v) {
    SS.TW.GoToScreen(Screen::LIST_OF_GROUPS);
}
</t>
<t tx="leo.20191228122647.124">void TextWindow::ShowHeader(bool withNav) {
    ClearScreen();

    const char *header;
    std::string desc;
    if(SS.GW.LockedInWorkplane()) {
        header = "in plane: ";
        desc = SK.GetEntity(SS.GW.ActiveWorkplane())-&gt;DescriptionString();
    } else {
        header = "drawing / constraining in 3d";
        desc = "";
    }

    // Navigation buttons
    if(withNav) {
        Printf(false, " %Fl%Lh%fhome%E   %Ft%s%E%s",
            (&amp;TextWindow::ScreenHome), header, desc.c_str());
    } else {
        Printf(false, "        %Ft%s%E%s", header, desc.c_str());
    }

    // Leave space for the icons that are painted here.
    Printf(false, "");
    Printf(false, "");
}

//-----------------------------------------------------------------------------
// The screen that shows a list of every group in the sketch, with options
// to hide or show them, and to view them in detail. This is our home page.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122647.125">void TextWindow::ScreenSelectGroup(int link, uint32_t v) {
    SS.TW.GoToScreen(Screen::GROUP_INFO);
    SS.TW.shown.group.v = v;
}
</t>
<t tx="leo.20191228122647.126">void TextWindow::ScreenToggleGroupShown(int link, uint32_t v) {
    hGroup hg = { v };
    Group *g = SK.GetGroup(hg);
    g-&gt;visible = !(g-&gt;visible);
    // If a group was just shown, then it might not have been generated
    // previously, so regenerate.
    SS.GenerateAll();
}
</t>
<t tx="leo.20191228122647.127">void TextWindow::ScreenShowGroupsSpecial(int link, uint32_t v) {
    bool state = link == 's';
    for(hGroup hg : SK.groupOrder) {
        Group *g = SK.GetGroup(hg);

        g-&gt;visible = state;
    }
    SS.GW.persistentDirty = true;
}
</t>
<t tx="leo.20191228122647.128">void TextWindow::ScreenActivateGroup(int link, uint32_t v) {
    SS.GW.activeGroup.v = v;
    SK.GetGroup(SS.GW.activeGroup)-&gt;Activate();
    SS.GW.ClearSuper();
}
</t>
<t tx="leo.20191228122647.129">void TextWindow::ReportHowGroupSolved(hGroup hg) {
    SS.GW.ClearSuper();
    SS.TW.GoToScreen(Screen::GROUP_SOLVE_INFO);
    SS.TW.shown.group = hg;
    SS.ScheduleShowTW();
}
</t>
<t tx="leo.20191228122647.13">class Request {
public:
    // Some predefined requests, that are present in every sketch.
    static const hRequest   HREQUEST_REFERENCE_XY;
    static const hRequest   HREQUEST_REFERENCE_YZ;
    static const hRequest   HREQUEST_REFERENCE_ZX;

    int         tag;
    hRequest    h;

    // Types of requests
    enum class Type : uint32_t {
        WORKPLANE              = 100,
        DATUM_POINT            = 101,
        LINE_SEGMENT           = 200,
        CUBIC                  = 300,
        CUBIC_PERIODIC         = 301,
        CIRCLE                 = 400,
        ARC_OF_CIRCLE          = 500,
        TTF_TEXT               = 600,
        IMAGE                  = 700
    };

    Request::Type type;
    int         extraPoints;

    hEntity     workplane; // or Entity::FREE_IN_3D
    hGroup      group;
    hStyle      style;

    bool        construction;

    std::string str;
    std::string font;
    Platform::Path file;
    double      aspectRatio;

    static hParam AddParam(ParamList *param, hParam hp);
    void Generate(EntityList *entity, ParamList *param);

    std::string DescriptionString() const;
    int IndexOfPoint(hEntity he) const;

    @others
};

</t>
<t tx="leo.20191228122647.130">void TextWindow::ScreenHowGroupSolved(int link, uint32_t v) {
    if(SS.GW.activeGroup.v != v) {
        ScreenActivateGroup(link, v);
    }
    SS.TW.GoToScreen(Screen::GROUP_SOLVE_INFO);
    SS.TW.shown.group.v = v;
}
</t>
<t tx="leo.20191228122647.131">void TextWindow::ScreenShowConfiguration(int link, uint32_t v) {
    SS.TW.GoToScreen(Screen::CONFIGURATION);
}
</t>
<t tx="leo.20191228122647.132">void TextWindow::ScreenShowEditView(int link, uint32_t v) {
    SS.TW.GoToScreen(Screen::EDIT_VIEW);
}
</t>
<t tx="leo.20191228122647.133">void TextWindow::ScreenGoToWebsite(int link, uint32_t v) {
    Platform::OpenInBrowser("http://solvespace.com/txtlink");
}
</t>
<t tx="leo.20191228122647.134">void TextWindow::ShowListOfGroups() {
    @others
}


//-----------------------------------------------------------------------------
// The screen that shows information about a specific group, and allows the
// user to edit various things about it.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122647.135">const char *radioTrue  = " " RADIO_TRUE  " ",
           *radioFalse = " " RADIO_FALSE " ",
           *checkTrue  = " " CHECK_TRUE  " ",
           *checkFalse = " " CHECK_FALSE " ";

Printf(true, "%Ft active");
Printf(false, "%Ft    shown dof group-name%E");
bool afterActive = false;
bool backgroundParity = false;
for(hGroup hg : SK.groupOrder) {
    Group *g = SK.GetGroup(hg);

    std::string s = g-&gt;DescriptionString();
    bool active = (g-&gt;h == SS.GW.activeGroup);
    bool shown = g-&gt;visible;
    bool ok = g-&gt;IsSolvedOkay();
    @others
}

Printf(true,  "  %Fl%Ls%fshow all%E / %Fl%Lh%fhide all%E",
    &amp;(TextWindow::ScreenShowGroupsSpecial),
    &amp;(TextWindow::ScreenShowGroupsSpecial));
Printf(true,  "  %Fl%Ls%fline styles%E /"
               " %Fl%Ls%fview%E /"
               " %Fl%Ls%fconfiguration%E",
    &amp;(TextWindow::ScreenShowListOfStyles),
    &amp;(TextWindow::ScreenShowEditView),
    &amp;(TextWindow::ScreenShowConfiguration));
</t>
<t tx="leo.20191228122647.136">bool warn = (g-&gt;type == Group::Type::DRAWING_WORKPLANE &amp;&amp;
             g-&gt;polyError.how != PolyError::GOOD) ||
            ((g-&gt;type == Group::Type::EXTRUDE ||
              g-&gt;type == Group::Type::LATHE) &amp;&amp;
             SK.GetGroup(g-&gt;opA)-&gt;polyError.how != PolyError::GOOD);
int dof = g-&gt;solved.dof;
char sdof[16] = "ok ";
if(ok &amp;&amp; dof &gt; 0) {
    if(dof &gt; 999) {
      strcpy(sdof, "###");
    } else {
      sprintf(sdof, "%-3d", dof);
    }
}
bool ref = (g-&gt;h == Group::HGROUP_REFERENCES);
Printf(false,
       "%Bp%Fd "
       "%Ft%s%Fb%D%f%Ll%s%E "
       "%Fb%s%D%f%Ll%s%E  "
       "%Fp%D%f%s%Ll%s%E "
       "%Fl%Ll%D%f%s",
       // Alternate between light and dark backgrounds, for readability
       backgroundParity ? 'd' : 'a',
       // Link that activates the group
       ref ? "   " : "",
       g-&gt;h.v, (&amp;TextWindow::ScreenActivateGroup),
       ref ? "" : (active ? radioTrue : radioFalse),
       // Link that hides or shows the group
       afterActive ? " - " : "",
       g-&gt;h.v, (&amp;TextWindow::ScreenToggleGroupShown),
       afterActive ? "" : (shown ? checkTrue : checkFalse),
       // Link to the errors, if a problem occurred while solving
       ok ? (warn ? 'm' : (dof &gt; 0 ? 'i' : 's')) : 'x',
       g-&gt;h.v, (&amp;TextWindow::ScreenHowGroupSolved),
       ok ? (warn ? "err" : sdof) : "",
       ok ? "" : "ERR",
       // Link to a screen that gives more details on the group
       g-&gt;h.v, (&amp;TextWindow::ScreenSelectGroup), s.c_str());

if(active) afterActive = true;
backgroundParity = !backgroundParity;
</t>
<t tx="leo.20191228122647.137">void TextWindow::ScreenHoverConstraint(int link, uint32_t v) {
    if(!SS.GW.showConstraints) return;

    hConstraint hc = { v };
    SS.GW.hover.Clear();
    SS.GW.hover.constraint = hc;
    SS.GW.hover.emphasized = true;
}
</t>
<t tx="leo.20191228122647.138">void TextWindow::ScreenHoverRequest(int link, uint32_t v) {
    SS.GW.hover.Clear();
    hRequest hr = { v };
    SS.GW.hover.entity = hr.entity(0);
    SS.GW.hover.emphasized = true;
}
</t>
<t tx="leo.20191228122647.139">void TextWindow::ScreenSelectConstraint(int link, uint32_t v) {
    SS.GW.ClearSelection();
    GraphicsWindow::Selection sel = {};
    sel.constraint.v = v;
    SS.GW.selection.Add(&amp;sel);
}
</t>
<t tx="leo.20191228122647.14">    void Clear() {}
};

#define MAX_POINTS_IN_ENTITY (12)
class EntityBase {
public:
    int         tag;
    hEntity     h;

    static const hEntity    FREE_IN_3D;
    static const hEntity    NO_ENTITY;

    enum class Type : uint32_t {
        POINT_IN_3D            =  2000,
        POINT_IN_2D            =  2001,
        POINT_N_TRANS          =  2010,
        POINT_N_ROT_TRANS      =  2011,
        POINT_N_COPY           =  2012,
        POINT_N_ROT_AA         =  2013,
        POINT_N_ROT_AXIS_TRANS =  2014,

        NORMAL_IN_3D           =  3000,
        NORMAL_IN_2D           =  3001,
        NORMAL_N_COPY          =  3010,
        NORMAL_N_ROT           =  3011,
        NORMAL_N_ROT_AA        =  3012,

        DISTANCE               =  4000,
        DISTANCE_N_COPY        =  4001,

        FACE_NORMAL_PT         =  5000,
        FACE_XPROD             =  5001,
        FACE_N_ROT_TRANS       =  5002,
        FACE_N_TRANS           =  5003,
        FACE_N_ROT_AA          =  5004,

        WORKPLANE              = 10000,
        LINE_SEGMENT           = 11000,
        CUBIC                  = 12000,
        CUBIC_PERIODIC         = 12001,
        CIRCLE                 = 13000,
        ARC_OF_CIRCLE          = 14000,
        TTF_TEXT               = 15000,
        IMAGE                  = 16000
    };

    Type        type;

    hGroup      group;
    hEntity     workplane;   // or Entity::FREE_IN_3D

    // When it comes time to draw an entity, we look here to get the
    // defining variables.
    hEntity     point[MAX_POINTS_IN_ENTITY];
    int         extraPoints;
    hEntity     normal;
    hEntity     distance;
    // The only types that have their own params are points, normals,
    // and directions.
    hParam      param[8];

    // Transformed points/normals/distances have their numerical base
    Vector      numPoint;
    Quaternion  numNormal;
    double      numDistance;

    std::string str;
    std::string font;
    Platform::Path file;
    double      aspectRatio;

    // For entities that are derived by a transformation, the number of
    // times to apply the transformation.
    int timesApplied;

    Quaternion GetAxisAngleQuaternion(int param0) const;
    ExprQuaternion GetAxisAngleQuaternionExprs(int param0) const;

    bool IsCircle() const;
    Expr *CircleGetRadiusExpr() const;
    double CircleGetRadiusNum() const;
    void ArcGetAngles(double *thetaa, double *thetab, double *dtheta) const;

    bool HasVector() const;
    ExprVector VectorGetExprs() const;
    ExprVector VectorGetExprsInWorkplane(hEntity wrkpl) const;
    Vector VectorGetNum() const;
    Vector VectorGetRefPoint() const;
    Vector VectorGetStartPoint() const;

    // For distances
    bool IsDistance() const;
    double DistanceGetNum() const;
    Expr *DistanceGetExpr() const;
    void DistanceForceTo(double v);

    bool IsWorkplane() const;
    // The plane is points P such that P dot (xn, yn, zn) - d = 0
    void WorkplaneGetPlaneExprs(ExprVector *n, Expr **d) const;
    ExprVector WorkplaneGetOffsetExprs() const;
    Vector WorkplaneGetOffset() const;
    EntityBase *Normal() const;

    bool IsFace() const;
    ExprVector FaceGetNormalExprs() const;
    Vector FaceGetNormalNum() const;
    ExprVector FaceGetPointExprs() const;
    Vector FaceGetPointNum() const;

    bool IsPoint() const;
    // Applies for any of the point types
    Vector PointGetNum() const;
    ExprVector PointGetExprs() const;
    void PointGetExprsInWorkplane(hEntity wrkpl, Expr **u, Expr **v) const;
    ExprVector PointGetExprsInWorkplane(hEntity wrkpl) const;
    void PointForceTo(Vector v);
    void PointForceParamTo(Vector v);
    // These apply only the POINT_N_ROT_TRANS, which has an assoc rotation
    Quaternion PointGetQuaternion() const;
    void PointForceQuaternionTo(Quaternion q);

    bool IsNormal() const;
    // Applies for any of the normal types
    Quaternion NormalGetNum() const;
    ExprQuaternion NormalGetExprs() const;
    void NormalForceTo(Quaternion q);

    Vector NormalU() const;
    Vector NormalV() const;
    Vector NormalN() const;
    ExprVector NormalExprsU() const;
    ExprVector NormalExprsV() const;
    ExprVector NormalExprsN() const;

    Vector CubicGetStartNum() const;
    Vector CubicGetFinishNum() const;
    ExprVector CubicGetStartTangentExprs() const;
    ExprVector CubicGetFinishTangentExprs() const;
    Vector CubicGetStartTangentNum() const;
    Vector CubicGetFinishTangentNum() const;

    bool HasEndpoints() const;
    Vector EndpointStart() const;
    Vector EndpointFinish() const;
    bool IsInPlane(Vector norm, double distance) const;

    void RectGetPointsExprs(ExprVector *eap, ExprVector *ebp) const;

    void AddEq(IdList&lt;Equation,hEquation&gt; *l, Expr *expr, int index) const;
    void GenerateEquations(IdList&lt;Equation,hEquation&gt; *l) const;

</t>
<t tx="leo.20191228122647.140">void TextWindow::ScreenSelectRequest(int link, uint32_t v) {
    SS.GW.ClearSelection();
    GraphicsWindow::Selection sel = {};
    hRequest hr = { v };
    sel.entity = hr.entity(0);
    SS.GW.selection.Add(&amp;sel);
}

</t>
<t tx="leo.20191228122647.141">void TextWindow::ScreenChangeGroupOption(int link, uint32_t v) {
    SS.UndoRemember();
    Group *g = SK.GetGroup(SS.TW.shown.group);

    switch(link) {
        case 's': g-&gt;subtype = Group::Subtype::ONE_SIDED; break;
        case 'S': g-&gt;subtype = Group::Subtype::TWO_SIDED; break;

        case 'k': g-&gt;skipFirst = true; break;
        case 'K': g-&gt;skipFirst = false; break;

        case 'c':
            if(g-&gt;type == Group::Type::EXTRUDE) {
                // When an extrude group is first created, it's positioned for a union
                // extrusion. If no constraints were added, flip it when we switch between
                // union and difference modes to avoid manual work doing the same.
                if(g-&gt;meshCombine != (Group::CombineAs)v &amp;&amp; g-&gt;GetNumConstraints() == 0 &amp;&amp;
                        ((Group::CombineAs)v == Group::CombineAs::DIFFERENCE ||
                        g-&gt;meshCombine == Group::CombineAs::DIFFERENCE)) {
                    g-&gt;ExtrusionForceVectorTo(g-&gt;ExtrusionGetVector().Negated());
                }
            }
            g-&gt;meshCombine = (Group::CombineAs)v;
            break;

        case 'P': g-&gt;suppress = !(g-&gt;suppress); break;

        case 'r': g-&gt;relaxConstraints = !(g-&gt;relaxConstraints); break;

        case 'e': g-&gt;allowRedundant = !(g-&gt;allowRedundant); break;

        case 'v': g-&gt;visible = !(g-&gt;visible); break;

        case 'd': g-&gt;allDimsReference = !(g-&gt;allDimsReference); break;

        case 'f': g-&gt;forceToMesh = !(g-&gt;forceToMesh); break;
    }

    SS.MarkGroupDirty(g-&gt;h);
    SS.GW.ClearSuper();
}

</t>
<t tx="leo.20191228122647.142">void TextWindow::ScreenColor(int link, uint32_t v) {
    SS.UndoRemember();

    Group *g = SK.GetGroup(SS.TW.shown.group);
    SS.TW.ShowEditControlWithColorPicker(3, g-&gt;color);
    SS.TW.edit.meaning = Edit::GROUP_COLOR;
}
</t>
<t tx="leo.20191228122647.143">void TextWindow::ScreenOpacity(int link, uint32_t v) {
    Group *g = SK.GetGroup(SS.TW.shown.group);

    SS.TW.ShowEditControl(11, ssprintf("%.2f", g-&gt;color.alphaF()));
    SS.TW.edit.meaning = Edit::GROUP_OPACITY;
    SS.TW.edit.group = g-&gt;h;
}
</t>
<t tx="leo.20191228122647.144">void TextWindow::ScreenChangeExprA(int link, uint32_t v) {
    Group *g = SK.GetGroup(SS.TW.shown.group);

    SS.TW.ShowEditControl(10, ssprintf("%d", (int)g-&gt;valA));
    SS.TW.edit.meaning = Edit::TIMES_REPEATED;
    SS.TW.edit.group.v = v;
}
</t>
<t tx="leo.20191228122647.145">void TextWindow::ScreenChangeGroupName(int link, uint32_t v) {
    Group *g = SK.GetGroup(SS.TW.shown.group);
    SS.TW.ShowEditControl(12, g-&gt;DescriptionString().substr(5));
    SS.TW.edit.meaning = Edit::GROUP_NAME;
    SS.TW.edit.group.v = v;
}
</t>
<t tx="leo.20191228122647.146">void TextWindow::ScreenChangeGroupScale(int link, uint32_t v) {
    Group *g = SK.GetGroup(SS.TW.shown.group);

    SS.TW.ShowEditControl(13, ssprintf("%.3f", g-&gt;scale));
    SS.TW.edit.meaning = Edit::GROUP_SCALE;
    SS.TW.edit.group.v = v;
}
</t>
<t tx="leo.20191228122647.147">void TextWindow::ScreenDeleteGroup(int link, uint32_t v) {
    SS.UndoRemember();

    hGroup hg = SS.TW.shown.group;
    if(hg == SS.GW.activeGroup) {
        SS.GW.activeGroup = SK.GetGroup(SS.GW.activeGroup)-&gt;PreviousGroup()-&gt;h;
    }

    // Reset the text window, since we're displaying information about
    // the group that's about to get deleted.
    SS.TW.ClearSuper();

    // This is a major change, so let's re-solve everything.
    SK.group.RemoveById(hg);
    SS.GenerateAll(SolveSpaceUI::Generate::ALL);

    // Reset the graphics window. This will also recreate the default
    // group if it was removed.
    SS.GW.ClearSuper();
}
</t>
<t tx="leo.20191228122647.148">void TextWindow::ShowGroupInfo() {
    Group *g = SK.GetGroup(shown.group);
    const char *s = "???";

    if(shown.group == Group::HGROUP_REFERENCES) {
        Printf(true, "%FtGROUP  %E%s", g-&gt;DescriptionString().c_str());
        goto list_items;
    } else {
        Printf(true, "%FtGROUP  %E%s [%Fl%Ll%D%frename%E/%Fl%Ll%D%fdel%E]",
            g-&gt;DescriptionString().c_str(),
            g-&gt;h.v, &amp;TextWindow::ScreenChangeGroupName,
            g-&gt;h.v, &amp;TextWindow::ScreenDeleteGroup);
    }

    if(g-&gt;type == Group::Type::LATHE) {
        Printf(true, " %Ftlathe plane sketch");
    } else if(g-&gt;type == Group::Type::EXTRUDE || g-&gt;type == Group::Type::ROTATE ||
              g-&gt;type == Group::Type::TRANSLATE || g-&gt;type == Group::Type::REVOLVE ||
              g-&gt;type == Group::Type::HELIX) {
        if(g-&gt;type == Group::Type::EXTRUDE) {
            s = "extrude plane sketch";
        } else if(g-&gt;type == Group::Type::TRANSLATE) {
            s = "translate original sketch";
        } else if(g-&gt;type == Group::Type::HELIX) {
            s = "create helical extrusion";
        } else if(g-&gt;type == Group::Type::ROTATE) {
            s = "rotate original sketch";
        } else if(g-&gt;type == Group::Type::REVOLVE) {
            s = "revolve original sketch";
        }
        Printf(true, " %Ft%s%E", s);

        bool one = (g-&gt;subtype == Group::Subtype::ONE_SIDED);
        Printf(false,
            "%Ba   %f%Ls%Fd%s one-sided%E  "
                  "%f%LS%Fd%s two-sided%E",
            &amp;TextWindow::ScreenChangeGroupOption,
            one ? RADIO_TRUE : RADIO_FALSE,
            &amp;TextWindow::ScreenChangeGroupOption,
            !one ? RADIO_TRUE : RADIO_FALSE);

        if(g-&gt;type == Group::Type::ROTATE || g-&gt;type == Group::Type::TRANSLATE) {
            if(g-&gt;subtype == Group::Subtype::ONE_SIDED) {
                bool skip = g-&gt;skipFirst;
                Printf(false,
                   "%Bd   %Ftstart  %f%LK%Fd%s with original%E  "
                         "%f%Lk%Fd%s with copy #1%E",
                    &amp;ScreenChangeGroupOption,
                    !skip ? RADIO_TRUE : RADIO_FALSE,
                    &amp;ScreenChangeGroupOption,
                    skip ? RADIO_TRUE : RADIO_FALSE);
            }

            int times = (int)(g-&gt;valA);
            Printf(false, "%Bp   %Ftrepeat%E %d time%s %Fl%Ll%D%f[change]%E",
                (g-&gt;subtype == Group::Subtype::ONE_SIDED) ? 'a' : 'd',
                times, times == 1 ? "" : "s",
                g-&gt;h.v, &amp;TextWindow::ScreenChangeExprA);
        }
    } else if(g-&gt;type == Group::Type::LINKED) {
        Printf(true, " %Ftlink geometry from file%E");
        Platform::Path relativePath = g-&gt;linkFile.RelativeTo(SS.saveFile.Parent());
        if(relativePath.IsEmpty()) {
            Printf(false, "%Ba   '%s'", g-&gt;linkFile.raw.c_str());
        } else {
            Printf(false, "%Ba   '%s'", relativePath.raw.c_str());
        }
        Printf(false, "%Bd   %Ftscaled by%E %# %Fl%Ll%f%D[change]%E",
            g-&gt;scale,
            &amp;TextWindow::ScreenChangeGroupScale, g-&gt;h.v);
    } else if(g-&gt;type == Group::Type::DRAWING_3D) {
        Printf(true, " %Ftsketch in 3d%E");
    } else if(g-&gt;type == Group::Type::DRAWING_WORKPLANE) {
        Printf(true, " %Ftsketch in new workplane%E");
    } else {
        Printf(true, "???");
    }
    Printf(false, "");

    if(g-&gt;type == Group::Type::EXTRUDE || g-&gt;type == Group::Type::LATHE ||
       g-&gt;type == Group::Type::REVOLVE || g-&gt;type == Group::Type::LINKED ||
       g-&gt;type == Group::Type::HELIX) {
        bool un   = (g-&gt;meshCombine == Group::CombineAs::UNION);
        bool diff = (g-&gt;meshCombine == Group::CombineAs::DIFFERENCE);
        bool asy  = (g-&gt;meshCombine == Group::CombineAs::ASSEMBLE);

        Printf(false, " %Ftsolid model as");
        Printf(false, "%Ba   %f%D%Lc%Fd%s union%E  "
                             "%f%D%Lc%Fd%s difference%E  "
                             "%f%D%Lc%Fd%s assemble%E  ",
            &amp;TextWindow::ScreenChangeGroupOption,
            Group::CombineAs::UNION,
            un ? RADIO_TRUE : RADIO_FALSE,
            &amp;TextWindow::ScreenChangeGroupOption,
            Group::CombineAs::DIFFERENCE,
            diff ? RADIO_TRUE : RADIO_FALSE,
            &amp;TextWindow::ScreenChangeGroupOption,
            Group::CombineAs::ASSEMBLE,
            (asy ? RADIO_TRUE : RADIO_FALSE));

        if(g-&gt;type == Group::Type::EXTRUDE || g-&gt;type == Group::Type::LATHE ||
           g-&gt;type == Group::Type::REVOLVE || g-&gt;type == Group::Type::HELIX) {
            Printf(false,
                "%Bd   %Ftcolor   %E%Bz  %Bd (%@, %@, %@) %f%D%Lf%Fl[change]%E",
                &amp;g-&gt;color,
                g-&gt;color.redF(), g-&gt;color.greenF(), g-&gt;color.blueF(),
                ScreenColor, top[rows-1] + 2);
            Printf(false, "%Bd   %Ftopacity%E %@ %f%Lf%Fl[change]%E",
                g-&gt;color.alphaF(),
                &amp;TextWindow::ScreenOpacity);
        }

        if(g-&gt;type == Group::Type::EXTRUDE || g-&gt;type == Group::Type::LATHE ||
           g-&gt;type == Group::Type::REVOLVE || g-&gt;type == Group::Type::LINKED ||
           g-&gt;type == Group::Type::HELIX) {
            Printf(false, "   %Fd%f%LP%s  suppress this group's solid model",
                &amp;TextWindow::ScreenChangeGroupOption,
                g-&gt;suppress ? CHECK_TRUE : CHECK_FALSE);
        }

        Printf(false, "");
    }

    Printf(false, " %f%Lv%Fd%s  show entities from this group",
        &amp;TextWindow::ScreenChangeGroupOption,
        g-&gt;visible ? CHECK_TRUE : CHECK_FALSE);

    if(!g-&gt;IsForcedToMeshBySource()) {
        Printf(false, " %f%Lf%Fd%s  force NURBS surfaces to triangle mesh",
            &amp;TextWindow::ScreenChangeGroupOption,
            g-&gt;forceToMesh ? CHECK_TRUE : CHECK_FALSE);
    } else {
        Printf(false, " (model already forced to triangle mesh)");
    }

    Printf(true, " %f%Lr%Fd%s  relax constraints and dimensions",
        &amp;TextWindow::ScreenChangeGroupOption,
        g-&gt;relaxConstraints ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, " %f%Le%Fd%s  allow redundant constraints",
        &amp;TextWindow::ScreenChangeGroupOption,
        g-&gt;allowRedundant ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, " %f%Ld%Fd%s  treat all dimensions as reference",
        &amp;TextWindow::ScreenChangeGroupOption,
        g-&gt;allDimsReference ? CHECK_TRUE : CHECK_FALSE);

    if(g-&gt;booleanFailed) {
        Printf(false, "");
        Printf(false, "The Boolean operation failed. It may be ");
        Printf(false, "possible to fix the problem by choosing ");
        Printf(false, "'force NURBS surfaces to triangle mesh'.");
    }

list_items:
    Printf(false, "");
    Printf(false, "%Ft requests in group");

    int a = 0;
    for(auto &amp;r : SK.request) {

        if(r.group == shown.group) {
            std::string s = r.DescriptionString();
            Printf(false, "%Bp   %Fl%Ll%D%f%h%s%E",
                   (a &amp; 1) ? 'd' : 'a',
                   r.h.v,
                   (&amp;TextWindow::ScreenSelectRequest),
                   &amp;(TextWindow::ScreenHoverRequest),
                   s.c_str());
            a++;
        }
    }
    if(a == 0) Printf(false, "%Ba   (none)");

    a = 0;
    Printf(false, "");
    Printf(false, "%Ft constraints in group (%d DOF)", g-&gt;solved.dof);
    for(auto &amp;c : SK.constraint) {

        if(c.group == shown.group) {
            std::string s = c.DescriptionString();
            Printf(false, "%Bp   %Fl%Ll%D%f%h%s%E %s",
                   (a &amp; 1) ? 'd' : 'a',
                   c.h.v,
                   (&amp;TextWindow::ScreenSelectConstraint),
                   (&amp;TextWindow::ScreenHoverConstraint),
                   s.c_str(),
                   c.reference ? "(ref)" : "");
            a++;
        }
    }
    if(a == 0) Printf(false, "%Ba   (none)");
}

//-----------------------------------------------------------------------------
// The screen that's displayed when the sketch fails to solve. A report of
// what failed, and (if the problem is a singular Jacobian) a list of
// constraints that could be removed to fix it.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122647.15">    void Clear() {}
};

class Entity : public EntityBase {
public:
    // Necessary for Entity e = {} to zero-initialize, since
    // classes with base classes are not aggregates and
    // the default constructor does not initialize members.
    //
    // Note EntityBase({}); without explicitly value-initializing
    // the base class, MSVC2013 will default-initialize it, leaving
    // POD members with indeterminate value.
    Entity() : EntityBase({}), forceHidden(), actPoint(), actNormal(),
        actDistance(), actVisible(), style(), construction(),
        beziers(), edges(), edgesChordTol(), screenBBox(), screenBBoxValid() {};

    // A linked entity that was hidden in the source file ends up hidden
    // here too.
    bool        forceHidden;

    // All points/normals/distances have their numerical value; this is
    // a convenience, to simplify the link/assembly code, so that the
    // part is entirely described by the entities.
    Vector      actPoint;
    Quaternion  actNormal;
    double      actDistance;
    // and the shown state also gets saved here, for later import
    bool        actVisible;

    hStyle      style;
    bool        construction;

    SBezierList beziers;
    SEdgeList   edges;
    double      edgesChordTol;
    BBox        screenBBox;
    bool        screenBBoxValid;

    bool IsStylable() const;
    bool IsVisible() const;

    enum class DrawAs { DEFAULT, OVERLAY, HIDDEN, HOVERED, SELECTED };
    void Draw(DrawAs how, Canvas *canvas);
    void GetReferencePoints(std::vector&lt;Vector&gt; *refs);
    int GetPositionOfPoint(const Camera &amp;camera, Point2d p);

    void ComputeInterpolatingSpline(SBezierList *sbl, bool periodic) const;
    void GenerateBezierCurves(SBezierList *sbl) const;
    void GenerateEdges(SEdgeList *el);

    SBezierList *GetOrGenerateBezierCurves();
    SEdgeList *GetOrGenerateEdges();
    BBox GetOrGenerateScreenBBox(bool *hasBBox);

    void CalculateNumerical(bool forExport);

    std::string DescriptionString() const;

</t>
<t tx="leo.20191228122647.16">void Clear() {
    beziers.l.Clear();
    edges.l.Clear();
}
</t>
<t tx="leo.20191228122647.17">class EntReqTable {
public:
    @others
};

template&lt;&gt;
struct IsHandleOracle&lt;hConstraint&gt; : std::true_type {};

</t>
<t tx="leo.20191228122647.18">    static bool GetRequestInfo(Request::Type req, int extraPoints,
                               EntityBase::Type *ent, int *pts, bool *hasNormal, bool *hasDistance);
    static bool GetEntityInfo(EntityBase::Type ent, int extraPoints,
                              Request::Type *req, int *pts, bool *hasNormal, bool *hasDistance);
    static Request::Type GetRequestForEntity(EntityBase::Type ent);
};

class Param {
public:
    int         tag;
    hParam      h;

    double      val;
    bool        known;
    bool        free;

    // Used only in the solver
    hParam      substd;

    static const hParam NO_PARAM;

</t>
<t tx="leo.20191228122647.19">    void Clear() {}
};


class hConstraint {
public:
    uint32_t v;

    inline hEquation equation(int i) const;
    inline hParam param(int i) const;
</t>
<t tx="leo.20191228122647.2">class Pixmap {
public:
    enum class Format { BGRA, RGBA, BGR, RGB, A };

    Format                     format;
    size_t                     width;
    size_t                     height;
    size_t                     stride;
    std::vector&lt;uint8_t&gt;       data;

    static std::shared_ptr&lt;Pixmap&gt; Create(Format format, size_t width, size_t height);
    static std::shared_ptr&lt;Pixmap&gt; FromPng(const uint8_t *data, size_t size, bool flip = false);

    static std::shared_ptr&lt;Pixmap&gt; ReadPng(FILE *f, bool flip = false);
    static std::shared_ptr&lt;Pixmap&gt; ReadPng(const Platform::Path &amp;filename, bool flip = false);
    bool WritePng(FILE *f, bool flip = false);
    bool WritePng(const Platform::Path &amp;filename, bool flip = false);

    size_t GetBytesPerPixel() const;
    RgbaColor GetPixel(size_t x, size_t y) const;
    bool Equals(const Pixmap &amp;other) const;

    void ConvertTo(Format newFormat);
    void SetPixel(size_t x, size_t y, RgbaColor color);

    std::shared_ptr&lt;Pixmap&gt; Copy();
};

</t>
<t tx="leo.20191228122647.20">class ConstraintBase {
public:
    int         tag;
    hConstraint h;

    static const hConstraint NO_CONSTRAINT;

    enum class Type : uint32_t {
        POINTS_COINCIDENT      =  20,
        PT_PT_DISTANCE         =  30,
        PT_PLANE_DISTANCE      =  31,
        PT_LINE_DISTANCE       =  32,
        PT_FACE_DISTANCE       =  33,
        PROJ_PT_DISTANCE       =  34,
        PT_IN_PLANE            =  41,
        PT_ON_LINE             =  42,
        PT_ON_FACE             =  43,
        EQUAL_LENGTH_LINES     =  50,
        LENGTH_RATIO           =  51,
        EQ_LEN_PT_LINE_D       =  52,
        EQ_PT_LN_DISTANCES     =  53,
        EQUAL_ANGLE            =  54,
        EQUAL_LINE_ARC_LEN     =  55,
        LENGTH_DIFFERENCE      =  56,
        SYMMETRIC              =  60,
        SYMMETRIC_HORIZ        =  61,
        SYMMETRIC_VERT         =  62,
        SYMMETRIC_LINE         =  63,
        AT_MIDPOINT            =  70,
        HORIZONTAL             =  80,
        VERTICAL               =  81,
        DIAMETER               =  90,
        PT_ON_CIRCLE           = 100,
        SAME_ORIENTATION       = 110,
        ANGLE                  = 120,
        PARALLEL               = 121,
        PERPENDICULAR          = 122,
        ARC_LINE_TANGENT       = 123,
        CUBIC_LINE_TANGENT     = 124,
        CURVE_CURVE_TANGENT    = 125,
        EQUAL_RADIUS           = 130,
        WHERE_DRAGGED          = 200,

        COMMENT                = 1000
    };

    Type        type;

    hGroup      group;
    hEntity     workplane;

    // These are the parameters for the constraint.
    double      valA;
    hParam      valP;
    hEntity     ptA;
    hEntity     ptB;
    hEntity     entityA;
    hEntity     entityB;
    hEntity     entityC;
    hEntity     entityD;
    bool        other;
    bool        other2;

    bool        reference;  // a ref dimension, that generates no eqs
    std::string comment;    // since comments are represented as constraints

    @others
};

template&lt;&gt;
struct IsHandleOracle&lt;hEquation&gt; : std::true_type {};

</t>
<t tx="leo.20191228122647.21">bool Equals(const ConstraintBase &amp;c) const {
    return type == c.type &amp;&amp; group == c.group &amp;&amp; workplane == c.workplane &amp;&amp;
        valA == c.valA &amp;&amp; valP == c.valP &amp;&amp; ptA == c.ptA &amp;&amp; ptB == c.ptB &amp;&amp;
        entityA == c.entityA &amp;&amp; entityB == c.entityB &amp;&amp;
        entityC == c.entityC &amp;&amp; entityD == c.entityD &amp;&amp;
        other == c.other &amp;&amp; other2 == c.other2 &amp;&amp; reference == c.reference &amp;&amp;
        comment == c.comment;
}

bool HasLabel() const;

void Generate(IdList&lt;Param, hParam&gt; *param);

void GenerateEquations(IdList&lt;Equation,hEquation&gt; *entity,
static ExprVector PointInThreeSpace(hEntity workplane, Expr *u, Expr *v);

</t>
<t tx="leo.20191228122647.22">    void Clear() {}
};

class Constraint : public ConstraintBase {
public:
    // See Entity::Entity().
    Constraint() : ConstraintBase({}), disp() {}

    // These define how the constraint is drawn on-screen.
    struct {
        Vector      offset;
        hStyle      style;
    } disp;

    bool IsVisible() const;
    bool IsStylable() const;
    hStyle GetStyle() const;
    bool HasLabel() const;
    std::string Label() const;

    enum class DrawAs { DEFAULT, HOVERED, SELECTED };
    void Draw(DrawAs how, Canvas *canvas);
    Vector GetLabelPos(const Camera &amp;camera);
    void GetReferencePoints(const Camera &amp;camera, std::vector&lt;Vector&gt; *refs);

    void DoLayout(DrawAs how, Canvas *canvas,
    void DoLineWithArrows(Canvas *canvas, Canvas::hStroke hcs,

    void DoEqualLenTicks(Canvas *canvas, Canvas::hStroke hcs,
    static hConstraint ConstrainCoincident(hEntity ptA, hEntity ptB);
</t>
<t tx="leo.20191228122647.23">    static hConstraint Constrain(Constraint::Type type, hEntity ptA, hEntity ptB, hEntity entityA,
                                 hEntity entityB = Entity::NO_ENTITY, bool other = false,
                                 bool other2 = false);
    static hConstraint TryConstrain(Constraint::Type type, hEntity ptA, hEntity ptB,
                                    hEntity entityA, hEntity entityB = Entity::NO_ENTITY,
                                    bool other = false, bool other2 = false);
};

class hEquation {
public:
    uint32_t v;

    inline bool isFromConstraint() const;
    inline hConstraint constraint() const;
</t>
<t tx="leo.20191228122647.24">class Equation {
public:
    int         tag;
    hEquation   h;

    Expr        *e;

    @others
}
inline hEntity hRequest::entity(int i) const
    { hEntity r; r.v = (v &lt;&lt; 16) | (uint32_t)i; return r; }
inline hParam hRequest::param(int i) const
    { hParam r; r.v = (v &lt;&lt; 16) | (uint32_t)i; return r; }

inline bool hEntity::isFromRequest() const
    { if(v &amp; 0x80000000) return false; else return true; }
inline hRequest hEntity::request() const
    { hRequest r; r.v = (v &gt;&gt; 16); return r; }
inline hGroup hEntity::group() const
    { hGroup r; r.v = (v &gt;&gt; 16) &amp; 0x3fff; return r; }
inline hEquation hEntity::equation(int i) const
    { hEquation r; r.v = v | 0x40000000 | (uint32_t)i; return r; }

inline hRequest hParam::request() const
    { hRequest r; r.v = (v &gt;&gt; 16); return r; }


inline hEquation hConstraint::equation(int i) const
    { hEquation r; r.v = (v &lt;&lt; 16) | (uint32_t)i; return r; }
inline hParam hConstraint::param(int i) const
    { hParam r; r.v = v | 0x40000000 | (uint32_t)i; return r; }

inline bool hEquation::isFromConstraint() const
    { if(v &amp; 0xc0000000) return false; else return true; }
inline hConstraint hEquation::constraint() const
    { hConstraint r; r.v = (v &gt;&gt; 16); return r; }

// The format for entities stored on the clipboard.
</t>
<t tx="leo.20191228122647.25">    void Clear() {}
};


class Style {
public:
    int         tag;
    hStyle      h;

    enum {
        // If an entity has no style, then it will be colored according to
        // whether the group that it's in is active or not, whether it's
        // construction or not, and so on.
        NO_STYLE       = 0,

        ACTIVE_GRP     = 1,
        CONSTRUCTION   = 2,
        INACTIVE_GRP   = 3,
        DATUM          = 4,
        SOLID_EDGE     = 5,
        CONSTRAINT     = 6,
        SELECTED       = 7,
        HOVERED        = 8,
        CONTOUR_FILL   = 9,
        NORMALS        = 10,
        ANALYZE        = 11,
        DRAW_ERROR     = 12,
        DIM_SOLID      = 13,
        HIDDEN_EDGE    = 14,
        OUTLINE        = 15,

        FIRST_CUSTOM   = 0x100
    };

    std::string name;

    enum class UnitsAs : uint32_t {
        PIXELS   = 0,
        MM       = 1
    };
    double      width;
    UnitsAs     widthAs;
    double      textHeight;
    UnitsAs     textHeightAs;
    enum class TextOrigin : uint32_t {
        NONE    = 0x00,
        LEFT    = 0x01,
        RIGHT   = 0x02,
        BOT     = 0x04,
        TOP     = 0x08
    };
    TextOrigin  textOrigin;
    double      textAngle;
    RgbaColor   color;
    bool        filled;
    RgbaColor   fillColor;
    bool        visible;
    bool        exportable;
    StipplePattern stippleType;
    double      stippleScale;
    int         zIndex;

    // The default styles, for entities that don't have a style assigned yet,
    // and for datums and such.
</t>
<t tx="leo.20191228122647.26">    typedef struct {
        hStyle      h;
        const char *cnfPrefix;
        RgbaColor   color;
        double      width;
        int         zIndex;
    } Default;
    static const Default Defaults[];

    static std::string CnfColor(const std::string &amp;prefix);
    static std::string CnfWidth(const std::string &amp;prefix);
    static std::string CnfTextHeight(const std::string &amp;prefix);
    static std::string CnfPrefixToName(const std::string &amp;prefix);

    static void CreateAllDefaultStyles();
    static void CreateDefaultStyle(hStyle h);
    static void FillDefaultStyle(Style *s, const Default *d = NULL, bool factory = false);
    static void FreezeDefaultStyles(Platform::SettingsRef settings);
    static void LoadFactoryDefaults();

    static void AssignSelectionToStyle(uint32_t v);
    static uint32_t CreateCustomStyle(bool rememberForUndo = true);

    static RgbaColor RewriteColor(RgbaColor rgb);

    static Style *Get(hStyle hs);
    static RgbaColor Color(hStyle hs, bool forExport=false);
    static RgbaColor Color(int hs, bool forExport=false);
    static RgbaColor FillColor(hStyle hs, bool forExport=false);
    static double Width(hStyle hs);
    static double Width(int hs);
    static double WidthMm(int hs);
    static double TextHeight(hStyle hs);
    static double DefaultTextHeight();
    static Canvas::Stroke Stroke(hStyle hs);
    static Canvas::Stroke Stroke(int hs);
    static bool Exportable(int hs);
    static hStyle ForEntity(hEntity he);
    static StipplePattern PatternType(hStyle hs);
    static double StippleScaleMm(hStyle hs);

    std::string DescriptionString() const;

    void Clear() {}
inline bool hRequest::IsFromReferences() const {
    if(*this == Request::HREQUEST_REFERENCE_XY) return true;
    if(*this == Request::HREQUEST_REFERENCE_YZ) return true;
    if(*this == Request::HREQUEST_REFERENCE_ZX) return true;
    return false;
</t>
<t tx="leo.20191228122647.27">class ClipboardRequest {
public:
    Request::Type type;
    int         extraPoints;
    hStyle      style;
    std::string str;
    std::string font;
    Platform::Path file;
    bool        construction;

    Vector      point[MAX_POINTS_IN_ENTITY];
    double      distance;

    hEntity     oldEnt;
    hEntity     oldPointEnt[MAX_POINTS_IN_ENTITY];
    hRequest    newReq;
};

#endif
</t>
<t tx="leo.20191228122647.28">@path ./src/
//-----------------------------------------------------------------------------
// Entry point in to the program, our registry-stored settings and top-level
// housekeeping when we open, save, and create new files.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"
#include "config.h"

SolveSpaceUI SolveSpace::SS = {};
Sketch SolveSpace::SK = {};

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122647.29">void SolveSpaceUI::Init() {
#if !defined(HEADLESS)
    // Check that the resource system works.
    dbp("%s", LoadString("banner.txt").data());
#endif

    Platform::SettingsRef settings = Platform::GetSettings();

    SS.tangentArcRadius = 10.0;

    // Then, load the registry settings.
    // Default list of colors for the model material
    modelColor[0] = settings-&gt;ThawColor("ModelColor_0", RGBi(150, 150, 150));
    modelColor[1] = settings-&gt;ThawColor("ModelColor_1", RGBi(100, 100, 100));
    modelColor[2] = settings-&gt;ThawColor("ModelColor_2", RGBi( 30,  30,  30));
    modelColor[3] = settings-&gt;ThawColor("ModelColor_3", RGBi(150,   0,   0));
    modelColor[4] = settings-&gt;ThawColor("ModelColor_4", RGBi(  0, 100,   0));
    modelColor[5] = settings-&gt;ThawColor("ModelColor_5", RGBi(  0,  80,  80));
    modelColor[6] = settings-&gt;ThawColor("ModelColor_6", RGBi(  0,   0, 130));
    modelColor[7] = settings-&gt;ThawColor("ModelColor_7", RGBi( 80,   0,  80));
    // Light intensities
    lightIntensity[0] = settings-&gt;ThawFloat("LightIntensity_0", 1.0);
    lightIntensity[1] = settings-&gt;ThawFloat("LightIntensity_1", 0.5);
    ambientIntensity = 0.3; // no setting for that yet
    // Light positions
    lightDir[0].x = settings-&gt;ThawFloat("LightDir_0_Right",   -1.0);
    lightDir[0].y = settings-&gt;ThawFloat("LightDir_0_Up",       1.0);
    lightDir[0].z = settings-&gt;ThawFloat("LightDir_0_Forward",  0.0);
    lightDir[1].x = settings-&gt;ThawFloat("LightDir_1_Right",    1.0);
    lightDir[1].y = settings-&gt;ThawFloat("LightDir_1_Up",       0.0);
    lightDir[1].z = settings-&gt;ThawFloat("LightDir_1_Forward",  0.0);

    exportMode = false;
    // Chord tolerance
    chordTol = settings-&gt;ThawFloat("ChordTolerancePct", 0.5);
    // Max pwl segments to generate
    maxSegments = settings-&gt;ThawInt("MaxSegments", 10);
    // Chord tolerance
    exportChordTol = settings-&gt;ThawFloat("ExportChordTolerance", 0.1);
    // Max pwl segments to generate
    exportMaxSegments = settings-&gt;ThawInt("ExportMaxSegments", 64);
    // View units
    viewUnits = (Unit)settings-&gt;ThawInt("ViewUnits", (uint32_t)Unit::MM);
    // Number of digits after the decimal point
    afterDecimalMm = settings-&gt;ThawInt("AfterDecimalMm", 2);
    afterDecimalInch = settings-&gt;ThawInt("AfterDecimalInch", 3);
    afterDecimalDegree = settings-&gt;ThawInt("AfterDecimalDegree", 2);
    useSIPrefixes = settings-&gt;ThawBool("UseSIPrefixes", false);
    // Camera tangent (determines perspective)
    cameraTangent = settings-&gt;ThawFloat("CameraTangent", 0.3f/1e3);
    // Grid spacing
    gridSpacing = settings-&gt;ThawFloat("GridSpacing", 5.0);
    // Export scale factor
    exportScale = settings-&gt;ThawFloat("ExportScale", 1.0);
    // Export offset (cutter radius comp)
    exportOffset = settings-&gt;ThawFloat("ExportOffset", 0.0);
    // Rewrite exported colors close to white into black (assuming white bg)
    fixExportColors = settings-&gt;ThawBool("FixExportColors", true);
    // Draw back faces of triangles (when mesh is leaky/self-intersecting)
    drawBackFaces = settings-&gt;ThawBool("DrawBackFaces", true);
    // Use turntable mouse navigation
    turntableNav = settings-&gt;ThawBool("TurntableNav", false);
    // Immediately edit dimension
    immediatelyEditDimension = settings-&gt;ThawBool("ImmediatelyEditDimension", false);
    // Check that contours are closed and not self-intersecting
    checkClosedContour = settings-&gt;ThawBool("CheckClosedContour", true);
    // Enable automatic constrains for lines
    automaticLineConstraints = settings-&gt;ThawBool("AutomaticLineConstraints", true);
    // Draw closed polygons areas
    showContourAreas = settings-&gt;ThawBool("ShowContourAreas", false);
    // Export shaded triangles in a 2d view
    exportShadedTriangles = settings-&gt;ThawBool("ExportShadedTriangles", true);
    // Export pwl curves (instead of exact) always
    exportPwlCurves = settings-&gt;ThawBool("ExportPwlCurves", false);
    // Background color on-screen
    backgroundColor = settings-&gt;ThawColor("BackgroundColor", RGBi(0, 0, 0));
    // Whether export canvas size is fixed or derived from bbox
    exportCanvasSizeAuto = settings-&gt;ThawBool("ExportCanvasSizeAuto", true);
    // Margins for automatic canvas size
    exportMargin.left   = settings-&gt;ThawFloat("ExportMargin_Left",   5.0);
    exportMargin.right  = settings-&gt;ThawFloat("ExportMargin_Right",  5.0);
    exportMargin.bottom = settings-&gt;ThawFloat("ExportMargin_Bottom", 5.0);
    exportMargin.top    = settings-&gt;ThawFloat("ExportMargin_Top",    5.0);
    // Dimensions for fixed canvas size
    exportCanvas.width  = settings-&gt;ThawFloat("ExportCanvas_Width",  100.0);
    exportCanvas.height = settings-&gt;ThawFloat("ExportCanvas_Height", 100.0);
    exportCanvas.dx     = settings-&gt;ThawFloat("ExportCanvas_Dx",     5.0);
    exportCanvas.dy     = settings-&gt;ThawFloat("ExportCanvas_Dy",     5.0);
    // Extra parameters when exporting G code
    gCode.depth         = settings-&gt;ThawFloat("GCode_Depth", 10.0);
    gCode.passes        = settings-&gt;ThawInt("GCode_Passes", 1);
    gCode.feed          = settings-&gt;ThawFloat("GCode_Feed", 10.0);
    gCode.plungeFeed    = settings-&gt;ThawFloat("GCode_PlungeFeed", 10.0);
    // Show toolbar in the graphics window
    showToolbar = settings-&gt;ThawBool("ShowToolbar", true);
    // Recent files menus
    for(size_t i = 0; i &lt; MAX_RECENT; i++) {
        std::string rawPath = settings-&gt;ThawString("RecentFile_" + std::to_string(i), "");
        if(rawPath.empty()) continue;
        recentFiles.push_back(Platform::Path::From(rawPath));
    }
    // Autosave timer
    autosaveInterval = settings-&gt;ThawInt("AutosaveInterval", 5);
    // Locale
    std::string locale = settings-&gt;ThawString("Locale", "");
    if(!locale.empty()) {
        SetLocale(locale);
    }

    generateAllTimer = Platform::CreateTimer();
    generateAllTimer-&gt;onTimeout = std::bind(&amp;SolveSpaceUI::GenerateAll, &amp;SS, Generate::DIRTY,
                                            /*andFindFree=*/false, /*genForBBox=*/false);

    showTWTimer = Platform::CreateTimer();
    showTWTimer-&gt;onTimeout = std::bind(&amp;TextWindow::Show, &amp;TW);

    autosaveTimer = Platform::CreateTimer();
    autosaveTimer-&gt;onTimeout = std::bind(&amp;SolveSpaceUI::Autosave, &amp;SS);

    // The default styles (colors, line widths, etc.) are also stored in the
    // configuration file, but we will automatically load those as we need
    // them.

    ScheduleAutosave();

    NewFile();
    AfterNewFile();

    if(TW.window &amp;&amp; GW.window) {
        TW.window-&gt;ThawPosition(settings, "TextWindow");
        GW.window-&gt;ThawPosition(settings, "GraphicsWindow");
        TW.window-&gt;SetVisible(true);
        GW.window-&gt;SetVisible(true);
        GW.window-&gt;Focus();

        // Do this once the window is created.
        Request3DConnexionEventsForWindow(GW.window);
    }
}

</t>
<t tx="leo.20191228122647.3">class BitmapFont {
public:
    struct Glyph {
        uint8_t  advanceCells;
        uint16_t position;
    };

    std::string                unifontData;
    std::map&lt;char32_t, Glyph&gt;  glyphs;
    std::shared_ptr&lt;Pixmap&gt;    texture;
    bool                       textureUpdated;
    uint16_t                   nextPosition;

    static BitmapFont From(std::string &amp;&amp;unifontData);
    static BitmapFont Create();

    bool IsEmpty() const { return unifontData.empty(); }
    const Glyph &amp;GetGlyph(char32_t codepoint);
    @others
</t>
<t tx="leo.20191228122647.30">bool SolveSpaceUI::LoadAutosaveFor(const Platform::Path &amp;filename) {
    Platform::Path autosaveFile = filename.WithExtension(AUTOSAVE_EXT);

    FILE *f = OpenFile(autosaveFile, "rb");
    if(!f)
        return false;
    fclose(f);

    Platform::MessageDialogRef dialog = CreateMessageDialog(GW.window);

    using Platform::MessageDialog;
    dialog-&gt;SetType(MessageDialog::Type::QUESTION);
    dialog-&gt;SetTitle(C_("title", "Autosave Available"));
    dialog-&gt;SetMessage(C_("dialog", "An autosave file is available for this sketch."));
    dialog-&gt;SetDescription(C_("dialog", "Do you want to load the autosave file instead?"));
    dialog-&gt;AddButton(C_("button", "&amp;Load autosave"), MessageDialog::Response::YES,
                      /*isDefault=*/true);
    dialog-&gt;AddButton(C_("button", "Do&amp;n't Load"), MessageDialog::Response::NO);

    // FIXME(async): asyncify this call
    if(dialog-&gt;RunModal() == MessageDialog::Response::YES) {
        unsaved = true;
        return LoadFromFile(autosaveFile, /*canCancel=*/true);
    }

    return false;
}

</t>
<t tx="leo.20191228122647.31">bool SolveSpaceUI::Load(const Platform::Path &amp;filename) {
    bool autosaveLoaded = LoadAutosaveFor(filename);
    bool fileLoaded = autosaveLoaded || LoadFromFile(filename, /*canCancel=*/true);
    if(fileLoaded) {
        saveFile = filename;
        AddToRecentList(filename);
    } else {
        saveFile.Clear();
        NewFile();
    }
    AfterNewFile();
    unsaved = autosaveLoaded;
    return fileLoaded;
}

</t>
<t tx="leo.20191228122647.32">void SolveSpaceUI::Exit() {
    Platform::SettingsRef settings = Platform::GetSettings();

    GW.window-&gt;FreezePosition(settings, "GraphicsWindow");
    TW.window-&gt;FreezePosition(settings, "TextWindow");

    // Recent files
    for(size_t i = 0; i &lt; MAX_RECENT; i++) {
        std::string rawPath;
        if(recentFiles.size() &gt; i) {
            rawPath = recentFiles[i].raw;
        }
        settings-&gt;FreezeString("RecentFile_" + std::to_string(i), rawPath);
    }
    // Model colors
    for(size_t i = 0; i &lt; MODEL_COLORS; i++)
        settings-&gt;FreezeColor("ModelColor_" + std::to_string(i), modelColor[i]);
    // Light intensities
    settings-&gt;FreezeFloat("LightIntensity_0", (float)lightIntensity[0]);
    settings-&gt;FreezeFloat("LightIntensity_1", (float)lightIntensity[1]);
    // Light directions
    settings-&gt;FreezeFloat("LightDir_0_Right",   (float)lightDir[0].x);
    settings-&gt;FreezeFloat("LightDir_0_Up",      (float)lightDir[0].y);
    settings-&gt;FreezeFloat("LightDir_0_Forward", (float)lightDir[0].z);
    settings-&gt;FreezeFloat("LightDir_1_Right",   (float)lightDir[1].x);
    settings-&gt;FreezeFloat("LightDir_1_Up",      (float)lightDir[1].y);
    settings-&gt;FreezeFloat("LightDir_1_Forward", (float)lightDir[1].z);
    // Chord tolerance
    settings-&gt;FreezeFloat("ChordTolerancePct", (float)chordTol);
    // Max pwl segments to generate
    settings-&gt;FreezeInt("MaxSegments", (uint32_t)maxSegments);
    // Export Chord tolerance
    settings-&gt;FreezeFloat("ExportChordTolerance", (float)exportChordTol);
    // Export Max pwl segments to generate
    settings-&gt;FreezeInt("ExportMaxSegments", (uint32_t)exportMaxSegments);
    // View units
    settings-&gt;FreezeInt("ViewUnits", (uint32_t)viewUnits);
    // Number of digits after the decimal point
    settings-&gt;FreezeInt("AfterDecimalMm",   (uint32_t)afterDecimalMm);
    settings-&gt;FreezeInt("AfterDecimalInch", (uint32_t)afterDecimalInch);
    settings-&gt;FreezeInt("AfterDecimalDegree", (uint32_t)afterDecimalDegree);
    settings-&gt;FreezeBool("UseSIPrefixes", useSIPrefixes);
    // Camera tangent (determines perspective)
    settings-&gt;FreezeFloat("CameraTangent", (float)cameraTangent);
    // Grid spacing
    settings-&gt;FreezeFloat("GridSpacing", gridSpacing);
    // Export scale
    settings-&gt;FreezeFloat("ExportScale", exportScale);
    // Export offset (cutter radius comp)
    settings-&gt;FreezeFloat("ExportOffset", exportOffset);
    // Rewrite exported colors close to white into black (assuming white bg)
    settings-&gt;FreezeBool("FixExportColors", fixExportColors);
    // Draw back faces of triangles (when mesh is leaky/self-intersecting)
    settings-&gt;FreezeBool("DrawBackFaces", drawBackFaces);
    // Draw closed polygons areas
    settings-&gt;FreezeBool("ShowContourAreas", showContourAreas);
    // Check that contours are closed and not self-intersecting
    settings-&gt;FreezeBool("CheckClosedContour", checkClosedContour);
    // Use turntable mouse navigation
    settings-&gt;FreezeBool("TurntableNav", turntableNav);
    // Immediately edit dimensions
    settings-&gt;FreezeBool("ImmediatelyEditDimension", immediatelyEditDimension);
    // Enable automatic constrains for lines
    settings-&gt;FreezeBool("AutomaticLineConstraints", automaticLineConstraints);
    // Export shaded triangles in a 2d view
    settings-&gt;FreezeBool("ExportShadedTriangles", exportShadedTriangles);
    // Export pwl curves (instead of exact) always
    settings-&gt;FreezeBool("ExportPwlCurves", exportPwlCurves);
    // Background color on-screen
    settings-&gt;FreezeColor("BackgroundColor", backgroundColor);
    // Whether export canvas size is fixed or derived from bbox
    settings-&gt;FreezeBool("ExportCanvasSizeAuto", exportCanvasSizeAuto);
    // Margins for automatic canvas size
    settings-&gt;FreezeFloat("ExportMargin_Left",   exportMargin.left);
    settings-&gt;FreezeFloat("ExportMargin_Right",  exportMargin.right);
    settings-&gt;FreezeFloat("ExportMargin_Bottom", exportMargin.bottom);
    settings-&gt;FreezeFloat("ExportMargin_Top",    exportMargin.top);
    // Dimensions for fixed canvas size
    settings-&gt;FreezeFloat("ExportCanvas_Width",  exportCanvas.width);
    settings-&gt;FreezeFloat("ExportCanvas_Height", exportCanvas.height);
    settings-&gt;FreezeFloat("ExportCanvas_Dx",     exportCanvas.dx);
    settings-&gt;FreezeFloat("ExportCanvas_Dy",     exportCanvas.dy);
     // Extra parameters when exporting G code
    settings-&gt;FreezeFloat("GCode_Depth", gCode.depth);
    settings-&gt;FreezeInt("GCode_Passes", gCode.passes);
    settings-&gt;FreezeFloat("GCode_Feed", gCode.feed);
    settings-&gt;FreezeFloat("GCode_PlungeFeed", gCode.plungeFeed);
    // Show toolbar in the graphics window
    settings-&gt;FreezeBool("ShowToolbar", showToolbar);
    // Autosave timer
    settings-&gt;FreezeInt("AutosaveInterval", autosaveInterval);

    // And the default styles, colors and line widths and such.
    Style::FreezeDefaultStyles(settings);

    Platform::ExitGui();
}

</t>
<t tx="leo.20191228122647.33">void SolveSpaceUI::ScheduleGenerateAll() {
    generateAllTimer-&gt;RunAfterProcessingEvents();
}

</t>
<t tx="leo.20191228122647.34">void SolveSpaceUI::ScheduleShowTW() {
    showTWTimer-&gt;RunAfterProcessingEvents();
}

</t>
<t tx="leo.20191228122647.35">void SolveSpaceUI::ScheduleAutosave() {
    autosaveTimer-&gt;RunAfter(autosaveInterval * 60 * 1000);
}

double SolveSpaceUI::MmPerUnit() {
    switch(viewUnits) {
        case Unit::INCHES: return 25.4;
        case Unit::METERS: return 1000.0;
        case Unit::MM: return 1.0;
    }
    return 1.0;
}
</t>
<t tx="leo.20191228122647.36">const char *SolveSpaceUI::UnitName() {
    switch(viewUnits) {
        case Unit::INCHES: return "in";
        case Unit::METERS: return "m";
        case Unit::MM: return "mm";
    }
    return "";
}

std::string SolveSpaceUI::MmToString(double v) {
    v /= MmPerUnit();
    switch(viewUnits) {
        case Unit::INCHES:
            return ssprintf("%.*f", afterDecimalInch, v);
        case Unit::METERS:
        case Unit::MM:
            return ssprintf("%.*f", afterDecimalMm, v);
    }
    return "";
}
</t>
<t tx="leo.20191228122647.37">static const char *DimToString(int dim) {
    switch(dim) {
        case 3: return "³";
        case 2: return "²";
        case 1: return "";
        default: ssassert(false, "Unexpected dimension");
    }
}
</t>
<t tx="leo.20191228122647.38">static std::pair&lt;int, std::string&gt; SelectSIPrefixMm(int deg) {
         if(deg &gt;=  3) return {  3, "km" };
    else if(deg &gt;=  0) return {  0, "m"  };
    else if(deg &gt;= -2) return { -2, "cm" };
    else if(deg &gt;= -3) return { -3, "mm" };
    else if(deg &gt;= -6) return { -6, "µm" };
    else               return { -9, "nm" };
}
</t>
<t tx="leo.20191228122647.39">static std::pair&lt;int, std::string&gt; SelectSIPrefixInch(int deg) {
         if(deg &gt;=  0) return {  0, "in"  };
    else if(deg &gt;= -3) return { -3, "mil" };
    else               return { -6, "µin" };
}
std::string SolveSpaceUI::MmToStringSI(double v, int dim) {
    bool compact = false;
    if(dim == 0) {
        if(!useSIPrefixes) return MmToString(v);
        compact = true;
        dim = 1;
    }

    v /= pow((viewUnits == Unit::INCHES) ? 25.4 : 1000, dim);
    int vdeg = (int)((log10(fabs(v))) / dim);
    std::string unit;
    if(fabs(v) &gt; 0.0) {
        int sdeg = 0;
        std::tie(sdeg, unit) =
            (viewUnits == Unit::INCHES)
            ? SelectSIPrefixInch(vdeg)
            : SelectSIPrefixMm(vdeg);
        v /= pow(10.0, sdeg * dim);
    }
    int pdeg = (int)ceil(log10(fabs(v) + 1e-10));
    return ssprintf("%#.*g%s%s%s", pdeg + UnitDigitsAfterDecimal(), v,
                    compact ? "" : " ", unit.c_str(), DimToString(dim));
}
std::string SolveSpaceUI::DegreeToString(double v) {
    if(fabs(v - floor(v)) &gt; 1e-10) {
        return ssprintf("%.*f", afterDecimalDegree, v);
    } else {
        return ssprintf("%.0f", v);
    }
}
double SolveSpaceUI::ExprToMm(Expr *e) {
    return (e-&gt;Eval()) * MmPerUnit();
}
double SolveSpaceUI::StringToMm(const std::string &amp;str) {
    return std::stod(str) * MmPerUnit();
}
double SolveSpaceUI::ChordTolMm() {
    if(exportMode) return ExportChordTolMm();
    return chordTolCalculated;
}
double SolveSpaceUI::ExportChordTolMm() {
    return exportChordTol / exportScale;
}
</t>
<t tx="leo.20191228122647.4">    void LocateGlyph(char32_t codepoint, double *s0, double *t0, double *s1, double *t1,
                     size_t *advanceWidth, size_t *boundingHeight);

    void AddGlyph(char32_t codepoint, std::shared_ptr&lt;const Pixmap&gt; pixmap);

    size_t GetWidth(char32_t codepoint);
    size_t GetWidth(const std::string &amp;str);
};

class VectorFont {
public:
    struct Contour {
        std::vector&lt;Point2d&gt;   points;
    };

    struct Glyph {
        std::vector&lt;Contour&gt;   contours;
        double                 leftSideBearing;
        double                 boundingWidth;
        double                 advanceWidth;
    };

    std::string                lffData;
    std::map&lt;char32_t, Glyph&gt;  glyphs;
    double                     rightSideBearing;
    double                     capHeight;
    double                     ascender;
    double                     descender;

    static VectorFont From(std::string &amp;&amp;lffData);
    static VectorFont *Builtin();

    bool IsEmpty() const { return lffData.empty(); }
    const Glyph &amp;GetGlyph(char32_t codepoint);

    double GetCapHeight(double forCapHeight) const;
    double GetHeight(double forCapHeight) const;
    double GetWidth(double forCapHeight, const std::string &amp;str);
    Vector GetExtents(double forCapHeight, const std::string &amp;str);

    void Trace(double forCapHeight, Vector o, Vector u, Vector v, const std::string &amp;str,
</t>
<t tx="leo.20191228122647.40">int SolveSpaceUI::GetMaxSegments() {
    if(exportMode) return exportMaxSegments;
    return maxSegments;
}
</t>
<t tx="leo.20191228122647.41">int SolveSpaceUI::UnitDigitsAfterDecimal() {
    return (viewUnits == Unit::INCHES) ? afterDecimalInch : afterDecimalMm;
}
</t>
<t tx="leo.20191228122647.42">void SolveSpaceUI::SetUnitDigitsAfterDecimal(int v) {
    if(viewUnits == Unit::INCHES) {
        afterDecimalInch = v;
    } else {
        afterDecimalMm = v;
    }
}

double SolveSpaceUI::CameraTangent() {
    if(!usePerspectiveProj) {
        return 0;
    } else {
        return cameraTangent;
    }
}

</t>
<t tx="leo.20191228122647.43">void SolveSpaceUI::AfterNewFile() {
    // Clear out the traced point, which is no longer valid
    traced.point = Entity::NO_ENTITY;
    traced.path.l.Clear();
    // and the naked edges
    nakedEdges.Clear();

    // Quit export mode
    justExportedInfo.draw = false;
    centerOfMass.draw = false;
    exportMode = false;

    // GenerateAll() expects the view to be valid, because it uses that to
    // fill in default values for extrusion depths etc. (which won't matter
    // here, but just don't let it work on garbage)
    SS.GW.offset    = Vector::From(0, 0, 0);
    SS.GW.projRight = Vector::From(1, 0, 0);
    SS.GW.projUp    = Vector::From(0, 1, 0);

    GenerateAll(Generate::ALL);

    GW.Init();
    TW.Init();

    unsaved = false;

    GW.ZoomToFit();

    // Create all the default styles; they'll get created on the fly anyways,
    // but can't hurt to do it now.
    Style::CreateAllDefaultStyles();

    UpdateWindowTitles();
}

</t>
<t tx="leo.20191228122647.44">void SolveSpaceUI::AddToRecentList(const Platform::Path &amp;filename) {
    @others
}

</t>
<t tx="leo.20191228122647.45">auto it = std::find_if(recentFiles.begin(), recentFiles.end(),
                       [&amp;](const Platform::Path &amp;p) { return p.Equals(filename); });
if(it != recentFiles.end()) {
    recentFiles.erase(it);
}

if(recentFiles.size() &gt; MAX_RECENT) {
    recentFiles.erase(recentFiles.begin() + MAX_RECENT);
}

recentFiles.insert(recentFiles.begin(), filename);
GW.PopulateRecentFiles();
</t>
<t tx="leo.20191228122647.46">bool SolveSpaceUI::GetFilenameAndSave(bool saveAs) {
    Platform::SettingsRef settings = Platform::GetSettings();
    Platform::Path newSaveFile = saveFile;

    if(saveAs || saveFile.IsEmpty()) {
        Platform::FileDialogRef dialog = Platform::CreateSaveFileDialog(GW.window);
        dialog-&gt;AddFilter(C_("file-type", "SolveSpace models"), { "slvs" });
        dialog-&gt;ThawChoices(settings, "Sketch");
        if(!newSaveFile.IsEmpty()) {
            dialog-&gt;SetFilename(newSaveFile);
        }
        if(dialog-&gt;RunModal()) {
            dialog-&gt;FreezeChoices(settings, "Sketch");
            newSaveFile = dialog-&gt;GetFilename();
        } else {
            return false;
        }
    }

    if(SaveToFile(newSaveFile)) {
        AddToRecentList(newSaveFile);
        RemoveAutosave();
        saveFile = newSaveFile;
        unsaved = false;
        return true;
    } else {
        return false;
    }
}

</t>
<t tx="leo.20191228122647.47">void SolveSpaceUI::Autosave()
{
    ScheduleAutosave();

    if(!saveFile.IsEmpty() &amp;&amp; unsaved) {
        SaveToFile(saveFile.WithExtension(AUTOSAVE_EXT));
    }
}

</t>
<t tx="leo.20191228122647.48">void SolveSpaceUI::RemoveAutosave()
{
    Platform::Path autosaveFile = saveFile.WithExtension(AUTOSAVE_EXT);
    RemoveFile(autosaveFile);
}

</t>
<t tx="leo.20191228122647.49">bool SolveSpaceUI::OkayToStartNewFile() {
    if(!unsaved) return true;

    Platform::MessageDialogRef dialog = CreateMessageDialog(GW.window);

    using Platform::MessageDialog;
    dialog-&gt;SetType(MessageDialog::Type::QUESTION);
    dialog-&gt;SetTitle(C_("title", "Modified File"));
    if(!SolveSpace::SS.saveFile.IsEmpty()) {
        dialog-&gt;SetMessage(ssprintf(C_("dialog", "Do you want to save the changes you made to "
                                                 "the sketch “%s”?"), saveFile.raw.c_str()));
    } else {
        dialog-&gt;SetMessage(C_("dialog", "Do you want to save the changes you made to "
                                        "the new sketch?"));
    }
    dialog-&gt;SetDescription(C_("dialog", "Your changes will be lost if you don't save them."));
    dialog-&gt;AddButton(C_("button", "&amp;Save"), MessageDialog::Response::YES,
                      /*isDefault=*/true);
    dialog-&gt;AddButton(C_("button", "Do&amp;n't Save"), MessageDialog::Response::NO);
    dialog-&gt;AddButton(C_("button", "&amp;Cancel"), MessageDialog::Response::CANCEL);

    // FIXME(async): asyncify this call
    switch(dialog-&gt;RunModal()) {
        case MessageDialog::Response::YES:
            return GetFilenameAndSave(/*saveAs=*/false);

        case MessageDialog::Response::NO:
            RemoveAutosave();
            return true;

        default:
            return false;
    }
}

</t>
<t tx="leo.20191228122647.5">@path ./src/
//-----------------------------------------------------------------------------
// The parametric structure of our sketch, in multiple groups, that generate
// geometric entities and surfaces.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------

#ifndef SOLVESPACE_SKETCH_H
#define SOLVESPACE_SKETCH_H

class hGroup;
class hRequest;
class hEntity;
class hParam;
class hStyle;
class hConstraint;
class hEquation;

class Entity;
class Param;
class Equation;
class Style;

enum class PolyError : uint32_t {
    GOOD              = 0,
    NOT_CLOSED        = 1,
    NOT_COPLANAR      = 2,
    SELF_INTERSECTING = 3,
    ZERO_LEN_EDGE     = 4
};

enum class StipplePattern : uint32_t {
    CONTINUOUS     = 0,
    SHORT_DASH     = 1,
    DASH           = 2,
    LONG_DASH      = 3,
    DASH_DOT       = 4,
    DASH_DOT_DOT   = 5,
    DOT            = 6,
    FREEHAND       = 7,
    ZIGZAG         = 8,

    LAST           = ZIGZAG
};

const std::vector&lt;double&gt; &amp;StipplePatternDashes(StipplePattern pattern);
double StipplePatternLength(StipplePattern pattern);

enum class Command : uint32_t;

// All of the hWhatever handles are a 32-bit ID, that is used to represent
// some data structure in the sketch.
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122647.50">void SolveSpaceUI::UpdateWindowTitles() {
    if(!GW.window || !TW.window) return;

    if(saveFile.IsEmpty()) {
        GW.window-&gt;SetTitle(C_("title", "(new sketch)"));
    } else {
        if(!GW.window-&gt;SetTitleForFilename(saveFile)) {
            GW.window-&gt;SetTitle(saveFile.raw);
        }
    }

    TW.window-&gt;SetTitle(C_("title", "Property Browser"));
}

</t>
<t tx="leo.20191228122647.51">void SolveSpaceUI::MenuFile(Command id) {
    Platform::SettingsRef settings = Platform::GetSettings();

    switch(id) {
        case Command::NEW:
            if(!SS.OkayToStartNewFile()) break;

            SS.saveFile.Clear();
            SS.NewFile();
            SS.AfterNewFile();
            break;

        case Command::OPEN: {
            if(!SS.OkayToStartNewFile()) break;

            Platform::FileDialogRef dialog = Platform::CreateOpenFileDialog(SS.GW.window);
            dialog-&gt;AddFilters(Platform::SolveSpaceModelFileFilters);
            dialog-&gt;ThawChoices(settings, "Sketch");
            if(dialog-&gt;RunModal()) {
                dialog-&gt;FreezeChoices(settings, "Sketch");
                SS.Load(dialog-&gt;GetFilename());
            }
            break;
        }

        case Command::SAVE:
            SS.GetFilenameAndSave(/*saveAs=*/false);
            break;

        case Command::SAVE_AS:
            SS.GetFilenameAndSave(/*saveAs=*/true);
            break;

        case Command::EXPORT_IMAGE: {
            Platform::FileDialogRef dialog = Platform::CreateSaveFileDialog(SS.GW.window);
            dialog-&gt;AddFilters(Platform::RasterFileFilters);
            dialog-&gt;ThawChoices(settings, "ExportImage");
            if(dialog-&gt;RunModal()) {
                dialog-&gt;FreezeChoices(settings, "ExportImage");
                SS.ExportAsPngTo(dialog-&gt;GetFilename());
            }
            break;
        }

        case Command::EXPORT_VIEW: {
            Platform::FileDialogRef dialog = Platform::CreateSaveFileDialog(SS.GW.window);
            dialog-&gt;AddFilters(Platform::VectorFileFilters);
            dialog-&gt;ThawChoices(settings, "ExportView");
            if(!dialog-&gt;RunModal()) break;
            dialog-&gt;FreezeChoices(settings, "ExportView");

            // If the user is exporting something where it would be
            // inappropriate to include the constraints, then warn.
            if(SS.GW.showConstraints &amp;&amp;
                (dialog-&gt;GetFilename().HasExtension("txt") ||
                 fabs(SS.exportOffset) &gt; LENGTH_EPS))
            {
                Message(_("Constraints are currently shown, and will be exported "
                          "in the toolpath. This is probably not what you want; "
                          "hide them by clicking the link at the top of the "
                          "text window."));
            }

            SS.ExportViewOrWireframeTo(dialog-&gt;GetFilename(), /*exportWireframe=*/false);
            break;
        }

        case Command::EXPORT_WIREFRAME: {
            Platform::FileDialogRef dialog = Platform::CreateSaveFileDialog(SS.GW.window);
            dialog-&gt;AddFilters(Platform::Vector3dFileFilters);
            dialog-&gt;ThawChoices(settings, "ExportWireframe");
            if(!dialog-&gt;RunModal()) break;
            dialog-&gt;FreezeChoices(settings, "ExportWireframe");

            SS.ExportViewOrWireframeTo(dialog-&gt;GetFilename(), /*exportWireframe*/true);
            break;
        }

        case Command::EXPORT_SECTION: {
            Platform::FileDialogRef dialog = Platform::CreateSaveFileDialog(SS.GW.window);
            dialog-&gt;AddFilters(Platform::VectorFileFilters);
            dialog-&gt;ThawChoices(settings, "ExportSection");
            if(!dialog-&gt;RunModal()) break;
            dialog-&gt;FreezeChoices(settings, "ExportSection");

            SS.ExportSectionTo(dialog-&gt;GetFilename());
            break;
        }

        case Command::EXPORT_MESH: {
            Platform::FileDialogRef dialog = Platform::CreateSaveFileDialog(SS.GW.window);
            dialog-&gt;AddFilters(Platform::MeshFileFilters);
            dialog-&gt;ThawChoices(settings, "ExportMesh");
            if(!dialog-&gt;RunModal()) break;
            dialog-&gt;FreezeChoices(settings, "ExportMesh");

            SS.ExportMeshTo(dialog-&gt;GetFilename());
            break;
        }

        case Command::EXPORT_SURFACES: {
            Platform::FileDialogRef dialog = Platform::CreateSaveFileDialog(SS.GW.window);
            dialog-&gt;AddFilters(Platform::SurfaceFileFilters);
            dialog-&gt;ThawChoices(settings, "ExportSurfaces");
            if(!dialog-&gt;RunModal()) break;
            dialog-&gt;FreezeChoices(settings, "ExportSurfaces");

            StepFileWriter sfw = {};
            sfw.ExportSurfacesTo(dialog-&gt;GetFilename());
            break;
        }

        case Command::IMPORT: {
            Platform::FileDialogRef dialog = Platform::CreateOpenFileDialog(SS.GW.window);
            dialog-&gt;AddFilters(Platform::ImportFileFilters);
            dialog-&gt;ThawChoices(settings, "Import");
            if(!dialog-&gt;RunModal()) break;
            dialog-&gt;FreezeChoices(settings, "Import");

            Platform::Path importFile = dialog-&gt;GetFilename();
            if(importFile.HasExtension("dxf")) {
                ImportDxf(importFile);
            } else if(importFile.HasExtension("dwg")) {
                ImportDwg(importFile);
            } else {
                Error(_("Can't identify file type from file extension of "
                        "filename '%s'; try .dxf or .dwg."), importFile.raw.c_str());
                break;
            }

            SS.GenerateAll(SolveSpaceUI::Generate::UNTIL_ACTIVE);
            SS.ScheduleShowTW();
            break;
        }

        case Command::EXIT:
            if(!SS.OkayToStartNewFile()) break;
            SS.Exit();
            break;

        default: ssassert(false, "Unexpected menu ID");
    }

    SS.UpdateWindowTitles();
}

</t>
<t tx="leo.20191228122647.52">void SolveSpaceUI::MenuAnalyze(Command id) {
    Platform::SettingsRef settings = Platform::GetSettings();

    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;

    switch(id) {
        case Command::STEP_DIM:
            if(gs.constraints == 1 &amp;&amp; gs.n == 0) {
                Constraint *c = SK.GetConstraint(gs.constraint[0]);
                if(c-&gt;HasLabel() &amp;&amp; !c-&gt;reference) {
                    SS.TW.stepDim.finish = c-&gt;valA;
                    SS.TW.stepDim.steps = 10;
                    SS.TW.stepDim.isDistance =
                        (c-&gt;type != Constraint::Type::ANGLE) &amp;&amp;
                        (c-&gt;type != Constraint::Type::LENGTH_RATIO) &amp;&amp;
                        (c-&gt;type != Constraint::Type::LENGTH_DIFFERENCE);
                    SS.TW.shown.constraint = c-&gt;h;
                    SS.TW.shown.screen = TextWindow::Screen::STEP_DIMENSION;

                    // The step params are specified in the text window,
                    // so force that to be shown.
                    SS.GW.ForceTextWindowShown();

                    SS.ScheduleShowTW();
                    SS.GW.ClearSelection();
                } else {
                    Error(_("Constraint must have a label, and must not be "
                            "a reference dimension."));
                }
            } else {
                Error(_("Bad selection for step dimension; select a constraint."));
            }
            break;

        case Command::NAKED_EDGES: {
            ShowNakedEdges(/*reportOnlyWhenNotOkay=*/false);
            break;
        }

        case Command::INTERFERENCE: {
            SS.nakedEdges.Clear();

            SMesh *m = &amp;(SK.GetGroup(SS.GW.activeGroup)-&gt;displayMesh);
            SKdNode *root = SKdNode::From(m);
            bool inters, leaks;
            root-&gt;MakeCertainEdgesInto(&amp;(SS.nakedEdges),
                EdgeKind::SELF_INTER, /*coplanarIsInter=*/false, &amp;inters, &amp;leaks);

            SS.GW.Invalidate();

            if(inters) {
                Error("%d edges interfere with other triangles, bad.",
                    SS.nakedEdges.l.n);
            } else {
                Message(_("The assembly does not interfere, good."));
            }
            break;
        }

        case Command::CENTER_OF_MASS: {
            SS.UpdateCenterOfMass();
            SS.centerOfMass.draw = true;
            SS.GW.Invalidate();
            break;
        }

        case Command::VOLUME: {
            Group *g = SK.GetGroup(SS.GW.activeGroup);
            double totalVol = g-&gt;displayMesh.CalculateVolume();
            std::string msg = ssprintf(
                _("The volume of the solid model is:\n\n"
                  "    %s"),
                SS.MmToStringSI(totalVol, /*dim=*/3).c_str());

            SMesh curMesh = {};
            g-&gt;thisShell.TriangulateInto(&amp;curMesh);
            double curVol = curMesh.CalculateVolume();
            if(curVol &gt; 0.0) {
                msg += ssprintf(
                    _("\nThe volume of current group mesh is:\n\n"
                      "    %s"),
                    SS.MmToStringSI(curVol, /*dim=*/3).c_str());
            }

            msg += _("\n\nCurved surfaces have been approximated as triangles.\n"
                     "This introduces error, typically of around 1%.");
            Message("%s", msg.c_str());
            break;
        }

        case Command::AREA: {
            Group *g = SK.GetGroup(SS.GW.activeGroup);
            SS.GW.GroupSelection();
            auto const &amp;gs = SS.GW.gs;

            if(gs.faces &gt; 0) {
                std::vector&lt;uint32_t&gt; faces;
                faces.push_back(gs.face[0].v);
                if(gs.faces &gt; 1) faces.push_back(gs.face[1].v);
                double area = g-&gt;displayMesh.CalculateSurfaceArea(faces);
                Message(_("The surface area of the selected faces is:\n\n"
                          "    %s\n\n"
                          "Curves have been approximated as piecewise linear.\n"
                          "This introduces error, typically of around 1%%."),
                    SS.MmToStringSI(area, /*dim=*/2).c_str());
                break;
            }

            if(g-&gt;polyError.how != PolyError::GOOD) {
                Error(_("This group does not contain a correctly-formed "
                        "2d closed area. It is open, not coplanar, or self-"
                        "intersecting."));
                break;
            }
            SEdgeList sel = {};
            g-&gt;polyLoops.MakeEdgesInto(&amp;sel);
            SPolygon sp = {};
            sel.AssemblePolygon(&amp;sp, NULL, /*keepDir=*/true);
            sp.normal = sp.ComputeNormal();
            sp.FixContourDirections();
            double area = sp.SignedArea();
            Message(_("The area of the region sketched in this group is:\n\n"
                      "    %s\n\n"
                      "Curves have been approximated as piecewise linear.\n"
                      "This introduces error, typically of around 1%%."),
                SS.MmToStringSI(area, /*dim=*/2).c_str());
            sel.Clear();
            sp.Clear();
            break;
        }

        case Command::PERIMETER: {
            if(gs.n &gt; 0 &amp;&amp; gs.n == gs.entities) {
                double perimeter = 0.0;
                for(int i = 0; i &lt; gs.entities; i++) {
                    Entity *e = SK.entity.FindById(gs.entity[i]);
                    SEdgeList *el = e-&gt;GetOrGenerateEdges();
                    for(const SEdge &amp;e : el-&gt;l) {
                        perimeter += e.b.Minus(e.a).Magnitude();
                    }
                }
                Message(_("The total length of the selected entities is:\n\n"
                          "    %s\n\n"
                          "Curves have been approximated as piecewise linear.\n"
                          "This introduces error, typically of around 1%%."),
                    SS.MmToStringSI(perimeter, /*dim=*/1).c_str());
            } else {
                Error(_("Bad selection for perimeter; select line segments, arcs, and curves."));
            }
            break;
        }

        case Command::SHOW_DOF:
            // This works like a normal solve, except that it calculates
            // which variables are free/bound at the same time.
            SS.GenerateAll(SolveSpaceUI::Generate::ALL, /*andFindFree=*/true);
            break;

        case Command::TRACE_PT:
            if(gs.points == 1 &amp;&amp; gs.n == 1) {
                SS.traced.point = gs.point[0];
                SS.GW.ClearSelection();
            } else {
                Error(_("Bad selection for trace; select a single point."));
            }
            break;

        case Command::STOP_TRACING: {
            Platform::FileDialogRef dialog = Platform::CreateSaveFileDialog(SS.GW.window);
            dialog-&gt;AddFilters(Platform::CsvFileFilters);
            dialog-&gt;ThawChoices(settings, "Trace");
            if(dialog-&gt;RunModal()) {
                dialog-&gt;FreezeChoices(settings, "Trace");

                FILE *f = OpenFile(dialog-&gt;GetFilename(), "wb");
                if(f) {
                    int i;
                    SContour *sc = &amp;(SS.traced.path);
                    for(i = 0; i &lt; sc-&gt;l.n; i++) {
                        Vector p = sc-&gt;l[i].p;
                        double s = SS.exportScale;
                        fprintf(f, "%.10f, %.10f, %.10f\r\n",
                            p.x/s, p.y/s, p.z/s);
                    }
                    fclose(f);
                } else {
                    Error(_("Couldn't write to '%s'"), dialog-&gt;GetFilename().raw.c_str());
                }
            }
            // Clear the trace, and stop tracing
            SS.traced.point = Entity::NO_ENTITY;
            SS.traced.path.l.Clear();
            SS.GW.Invalidate();
            break;
        }

        default: ssassert(false, "Unexpected menu ID");
    }
}

</t>
<t tx="leo.20191228122647.53">void SolveSpaceUI::ShowNakedEdges(bool reportOnlyWhenNotOkay) {
    SS.nakedEdges.Clear();

    Group *g = SK.GetGroup(SS.GW.activeGroup);
    SMesh *m = &amp;(g-&gt;displayMesh);
    SKdNode *root = SKdNode::From(m);
    bool inters, leaks;
    root-&gt;MakeCertainEdgesInto(&amp;(SS.nakedEdges),
        EdgeKind::NAKED_OR_SELF_INTER, /*coplanarIsInter=*/true, &amp;inters, &amp;leaks);

    if(reportOnlyWhenNotOkay &amp;&amp; !inters &amp;&amp; !leaks &amp;&amp; SS.nakedEdges.l.IsEmpty()) {
        return;
    }
    SS.GW.Invalidate();

    const char *intersMsg = inters ?
    if(SS.nakedEdges.l.IsEmpty()) {
        Message(_("%s\n\n%s\n\nZero problematic edges, good.%s"),
            intersMsg, leaksMsg, cntMsg.c_str());
    } else {
        Error(_("%s\n\n%s\n\n%d problematic edges, bad.%s"),
            intersMsg, leaksMsg, SS.nakedEdges.l.n, cntMsg.c_str());
    }
}

</t>
<t tx="leo.20191228122647.54">void SolveSpaceUI::MenuHelp(Command id) {
    switch(id) {
        case Command::WEBSITE:
            Platform::OpenInBrowser("http://solvespace.com/helpmenu");
            break;

        case Command::ABOUT:
            Message(_(
"This is SolveSpace version %s.\n"
"\n"
"For more information, see http://solvespace.com/\n"
"\n"
"SolveSpace is free software: you are free to modify\n"
"and/or redistribute it under the terms of the GNU\n"
"General Public License (GPL) version 3 or later.\n"
"\n"
"There is NO WARRANTY, to the extent permitted by\n"
"law. For details, visit http://gnu.org/licenses/\n"
"\n"
"© 2008-%d Jonathan Westhues and other authors.\n"),
PACKAGE_VERSION, 2019);
            break;

        default: ssassert(false, "Unexpected menu ID");
    }
}

</t>
<t tx="leo.20191228122647.55">void SolveSpaceUI::Clear() {
    sys.Clear();
    for(int i = 0; i &lt; MAX_UNDO; i++) {
        if(i &lt; undo.cnt) undo.d[i].Clear();
        if(i &lt; redo.cnt) redo.d[i].Clear();
    }
    TW.window = NULL;
    GW.openRecentMenu = NULL;
    GW.linkRecentMenu = NULL;
    GW.showGridMenuItem = NULL;
    GW.perspectiveProjMenuItem = NULL;
    GW.showToolbarMenuItem = NULL;
    GW.showTextWndMenuItem = NULL;
    GW.fullScreenMenuItem = NULL;
    GW.unitsMmMenuItem = NULL;
    GW.unitsMetersMenuItem = NULL;
    GW.unitsInchesMenuItem = NULL;
    GW.inWorkplaneMenuItem = NULL;
    GW.in3dMenuItem = NULL;
    GW.undoMenuItem = NULL;
    GW.redoMenuItem = NULL;
    GW.window = NULL;
}

</t>
<t tx="leo.20191228122647.56">void Sketch::Clear() {
    group.Clear();
    groupOrder.Clear();
    constraint.Clear();
    request.Clear();
    style.Clear();
    entity.Clear();
    param.Clear();
}

BBox Sketch::CalculateEntityBBox(bool includingInvisible) {
    BBox box = {};
    bool first = true;

</t>
<t tx="leo.20191228122647.57">    auto includePoint = [&amp;](const Vector &amp;point) {
        if(first) {
            box.minp = point;
            box.maxp = point;
            first = false;
        } else {
            box.Include(point);
        }
    };

    for(const Entity &amp;e : entity) {
        if(e.construction) continue;
        if(!(includingInvisible || e.IsVisible())) continue;

        // arc center point shouldn't be included in bounding box calculation
        if(e.IsPoint() &amp;&amp; e.h.isFromRequest()) {
            Request *r = SK.GetRequest(e.h.request());
            if(r-&gt;type == Request::Type::ARC_OF_CIRCLE &amp;&amp; e.h == r-&gt;h.entity(1)) {
                continue;
            }
        }

        if(e.IsPoint()) {
            includePoint(e.PointGetNum());
            continue;
        }

        switch(e.type) {
            // Circles and arcs are special cases. We calculate their bounds
            // based on Bezier curve bounds. This is not exact for arcs,
            // but the implementation is rather simple.
            case Entity::Type::CIRCLE:
            case Entity::Type::ARC_OF_CIRCLE: {
                SBezierList sbl = {};
                e.GenerateBezierCurves(&amp;sbl);

                for(const SBezier &amp;sb : sbl.l) {
                    for(int j = 0; j &lt;= sb.deg; j++) {
                        includePoint(sb.ctrl[j]);
                    }
                }
                sbl.Clear();
                continue;
            }

            default:
                continue;
        }
    }

    return box;
}

Group *Sketch::GetRunningMeshGroupFor(hGroup h) {
    Group *g = GetGroup(h);
    while(g != NULL) {
        if(g-&gt;IsMeshGroup()) {
            return g;
        }
        g = g-&gt;PreviousGroup();
    }
    return NULL;
}
</t>
<t tx="leo.20191228122647.58">@path ./src/
//-----------------------------------------------------------------------------
// All declarations not grouped specially elsewhere.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------

#ifndef SOLVESPACE_H
#define SOLVESPACE_H

#include &lt;ctype.h&gt;
#include &lt;limits.h&gt;
#include &lt;math.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;locale&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

// We declare these in advance instead of simply using FT_Library
// (defined as typedef FT_LibraryRec_* FT_Library) because including
// freetype.h invokes indescribable horrors and we would like to avoid
// doing that every time we include solvespace.h.
struct FT_LibraryRec_;
struct FT_FaceRec_;

typedef struct _cairo cairo_t;
typedef struct _cairo_surface cairo_surface_t;

// The few floating-point equality comparisons in SolveSpace have been
// carefully considered, so we disable the -Wfloat-equal warning for them
#ifdef __clang__
#   define EXACT(expr) \
        (_Pragma("clang diagnostic push") \
         _Pragma("clang diagnostic ignored \"-Wfloat-equal\"") \
         (expr) \
         _Pragma("clang diagnostic pop"))
#else
#   define EXACT(expr) (expr)
#endif

// Debugging functions
#if defined(__GNUC__)
#define ssassert(condition, message) \
    do { \
        if(__builtin_expect((condition), true) == false) { \
            SolveSpace::AssertFailure(__FILE__, __LINE__, __func__, #condition, message); \
            __builtin_unreachable(); \
        } \
    } while(0)
#else
#define ssassert(condition, message) \
    do { \
        if((condition) == false) { \
            SolveSpace::AssertFailure(__FILE__, __LINE__, __func__, #condition, message); \
            abort(); \
        } \
    } while(0)
#endif

#ifndef isnan
#   define isnan(x) (((x) != (x)) || (x &gt; 1e11) || (x &lt; -1e11))
#endif

namespace SolveSpace {

using std::min;
using std::max;
using std::swap;

#if defined(__GNUC__)
__attribute__((noreturn))
#endif
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122647.59">void AssertFailure(const char *file, unsigned line, const char *function,
                   const char *condition, const char *message);

#if defined(__GNUC__)
__attribute__((__format__ (__printf__, 1, 2)))
#endif
std::string ssprintf(const char *fmt, ...);

inline int WRAP(int v, int n) {
    // Clamp it to the range [0, n)
    while(v &gt;= n) v -= n;
    while(v &lt; 0) v += n;
    return v;
}
inline double WRAP_NOT_0(double v, double n) {
    // Clamp it to the range (0, n]
    while(v &gt; n) v -= n;
    while(v &lt;= 0) v += n;
    return v;
}
inline double WRAP_SYMMETRIC(double v, double n) {
    // Clamp it to the range (-n/2, n/2]
    while(v &gt;   n/2) v -= n;
    while(v &lt;= -n/2) v += n;
    return v;
}

// Why is this faster than the library function?
inline double ffabs(double v) { return (v &gt; 0) ? v : (-v); }

#define CO(v) (v).x, (v).y, (v).z

#define ANGLE_COS_EPS   (1e-6)
#define LENGTH_EPS      (1e-6)
#define VERY_POSITIVE   (1e10)
#define VERY_NEGATIVE   (-1e10)

inline double Random(double vmax) {
    return (vmax*rand()) / RAND_MAX;
}

class Expr;
class ExprVector;
class ExprQuaternion;
class RgbaColor;
enum class Command : uint32_t;

//================
// From the platform-specific code.

#include "platform/platform.h"
#include "platform/gui.h"

const size_t MAX_RECENT = 8;

#define AUTOSAVE_EXT "slvs~"

void dbp(const char *str, ...);
#define DBPTRI(tri) \
    dbp("tri: (%.3f %.3f %.3f) (%.3f %.3f %.3f) (%.3f %.3f %.3f)", \
        CO((tri).a), CO((tri).b), CO((tri).c))

std::vector&lt;std::string&gt; InitPlatform(int argc, char **argv);

void *AllocTemporary(size_t n);
void FreeAllTemporary();
void *MemAlloc(size_t n);
void MemFree(void *p);
void vl(); // debug function to validate heaps

// End of platform-specific functions
//================

#include "resource.h"

enum class Unit : uint32_t {
    MM = 0,
    INCHES,
    METERS
};

template&lt;class Key, class T&gt;
using handle_map = std::map&lt;Key, T&gt;;

class Group;
class SSurface;
#include "dsc.h"
#include "polygon.h"
#include "srf/surface.h"
#include "render/render.h"

class Entity;
class hEntity;
class Param;
class hParam;
typedef IdList&lt;Entity,hEntity&gt; EntityList;
typedef IdList&lt;Param,hParam&gt; ParamList;

enum class SolveResult : uint32_t {
    OKAY                     = 0,
    DIDNT_CONVERGE           = 10,
    REDUNDANT_OKAY           = 11,
    REDUNDANT_DIDNT_CONVERGE = 12,
    TOO_MANY_UNKNOWNS        = 20
};


#include "sketch.h"
#include "ui.h"
#include "expr.h"


// Utility functions that are provided in the platform-independent code.
</t>
<t tx="leo.20191228122647.6">class hGroup {
public:
    // bits 15: 0   -- group index
    uint32_t v;

    inline hEntity entity(int i) const;
    inline hParam param(int i) const;
    inline hEquation equation(int i) const;
};

template&lt;&gt;
struct IsHandleOracle&lt;hGroup&gt; : std::true_type {};

</t>
<t tx="leo.20191228122647.60">class utf8_iterator : std::iterator&lt;std::forward_iterator_tag, char32_t&gt; {
    const char *p, *n;
public:
    utf8_iterator(const char *p) : p(p), n(NULL) {}
    bool           operator==(const utf8_iterator &amp;i) const { return p==i.p; }
    bool           operator!=(const utf8_iterator &amp;i) const { return p!=i.p; }
    ptrdiff_t      operator- (const utf8_iterator &amp;i) const { return p -i.p; }
    utf8_iterator&amp; operator++()    { **this; p=n; n=NULL; return *this; }
    utf8_iterator  operator++(int) { utf8_iterator t(*this); operator++(); return t; }
    char32_t       operator*();
    const char*    ptr() const { return p; }
};
</t>
<t tx="leo.20191228122647.61">class ReadUTF8 {
    const std::string &amp;str;
public:
    ReadUTF8(const std::string &amp;str) : str(str) {}
    utf8_iterator begin() const { return utf8_iterator(&amp;str[0]); }
    utf8_iterator end()   const { return utf8_iterator(&amp;str[0] + str.length()); }
};


#define arraylen(x) (sizeof((x))/sizeof((x)[0]))
#define PI (3.1415926535897931)
void MakeMatrix(double *mat, double a11, double a12, double a13, double a14,
</t>
<t tx="leo.20191228122647.62">class System {
public:
    enum { MAX_UNKNOWNS = 1024 };

    EntityList                      entity;
    ParamList                       param;
    IdList&lt;Equation,hEquation&gt;      eq;

    // A list of parameters that are being dragged; these are the ones that
    // we should put as close as possible to their initial positions.
    List&lt;hParam&gt;                    dragged;

    enum {
        // In general, the tag indicates the subsys that a variable/equation
        // has been assigned to; these are exceptions for variables:
        VAR_SUBSTITUTED      = 10000,
        VAR_DOF_TEST         = 10001,
        // and for equations:
        EQ_SUBSTITUTED       = 20000
    };

    // The system Jacobian matrix
    struct {
        // The corresponding equation for each row
        hEquation   eq[MAX_UNKNOWNS];

        // The corresponding parameter for each column
        hParam      param[MAX_UNKNOWNS];

        // We're solving AX = B
        int m, n;
        struct {
            Expr        *sym[MAX_UNKNOWNS][MAX_UNKNOWNS];
            double       num[MAX_UNKNOWNS][MAX_UNKNOWNS];
        }           A;

        double      scale[MAX_UNKNOWNS];

        // Some helpers for the least squares solve
        double AAt[MAX_UNKNOWNS][MAX_UNKNOWNS];
        double Z[MAX_UNKNOWNS];

        double      X[MAX_UNKNOWNS];

        struct {
            Expr        *sym[MAX_UNKNOWNS];
            double       num[MAX_UNKNOWNS];
        }           B;
    } mat;

    static const double RANK_MAG_TOLERANCE, CONVERGE_TOLERANCE;
    int CalculateRank();
    bool TestRank(int *rank = NULL);
    static bool SolveLinearSystem(double X[], double A[][MAX_UNKNOWNS],
    bool IsDragged(hParam p);

    bool NewtonSolve(int tag);

    void MarkParamsFree(bool findFree);
    int CalculateDof();

    SolveResult Solve(Group *g, int *rank = NULL, int *dof = NULL,
                      List&lt;hConstraint&gt; *bad = NULL,
                      bool andFindBad = false, bool andFindFree = false,

@others
</t>
<t tx="leo.20191228122647.63">class StepFileWriter {
public:
    void ExportSurfacesTo(const Platform::Path &amp;filename);
    void WriteHeader();
    void WriteProductHeader();
    int ExportCurve(SBezier *sb);
    int ExportCurveLoop(SBezierLoop *loop, bool inner);
    void ExportSurface(SSurface *ss, SBezierList *sbl);
    void WriteWireframe();
    void WriteFooter();

    List&lt;int&gt; curves;
    List&lt;int&gt; advancedFaces;
    FILE *f;
    int id;
};

</t>
<t tx="leo.20191228122647.64">class VectorFileWriter {
protected:
    Vector u, v, n, origin;
    double cameraTan, scale;

public:
    FILE *f;
    Platform::Path filename;
    Vector ptMin, ptMax;

    static double MmToPts(double mm);

    static VectorFileWriter *ForFile(const Platform::Path &amp;filename);

    void SetModelviewProjection(const Vector &amp;u, const Vector &amp;v, const Vector &amp;n,
    virtual void FinishPath(RgbaColor strokeRgb, double lineWidth,
                            bool filled, RgbaColor fillRgb, hStyle hs) = 0;
    virtual void Bezier(SBezier *sb) = 0;
    virtual void Triangle(STriangle *tr) = 0;
    virtual bool OutputConstraints(IdList&lt;Constraint,hConstraint&gt; *) { return false; }
    virtual void StartFile() = 0;
    virtual void FinishAndCloseFile() = 0;
    virtual bool HasCanvasSize() const = 0;
    virtual bool CanOutputMesh() const = 0;
};
</t>
<t tx="leo.20191228122647.65">class DxfFileWriter : public VectorFileWriter {
public:
    struct BezierPath {
        std::vector&lt;SBezier *&gt; beziers;
    };

    std::vector&lt;BezierPath&gt;         paths;
    IdList&lt;Constraint,hConstraint&gt; *constraint;

    static const char *lineTypeName(StipplePattern stippleType);

    bool OutputConstraints(IdList&lt;Constraint,hConstraint&gt; *constraint) override;

    void StartPath( RgbaColor strokeRgb, double lineWidth,
};
</t>
<t tx="leo.20191228122647.66">class EpsFileWriter : public VectorFileWriter {
public:
    Vector prevPt;
    void MaybeMoveTo(Vector s, Vector f);

    void StartPath( RgbaColor strokeRgb, double lineWidth,
@others
</t>
<t tx="leo.20191228122647.67">class PdfFileWriter : public VectorFileWriter {
public:
    uint32_t xref[10];
    uint32_t bodyStart;
    Vector prevPt;
    void MaybeMoveTo(Vector s, Vector f);

    void StartPath( RgbaColor strokeRgb, double lineWidth,
@others
</t>
<t tx="leo.20191228122647.68">class SvgFileWriter : public VectorFileWriter {
public:
    Vector prevPt;
    void MaybeMoveTo(Vector s, Vector f);

    void StartPath( RgbaColor strokeRgb, double lineWidth,
@others
</t>
<t tx="leo.20191228122647.69">class HpglFileWriter : public VectorFileWriter {
public:
    static double MmToHpglUnits(double mm);
    void StartPath( RgbaColor strokeRgb, double lineWidth,
@others
</t>
<t tx="leo.20191228122647.7">class hRequest {
public:
    // bits 15: 0   -- request index
    uint32_t v;

    inline hEntity entity(int i) const;
    inline hParam param(int i) const;

    inline bool IsFromReferences() const;
};

template&lt;&gt;
struct IsHandleOracle&lt;hRequest&gt; : std::true_type {};

</t>
<t tx="leo.20191228122647.70">class Step2dFileWriter : public VectorFileWriter {
    StepFileWriter sfw;
    void StartPath( RgbaColor strokeRgb, double lineWidth,
@others
</t>
<t tx="leo.20191228122647.71">class GCodeFileWriter : public VectorFileWriter {
public:
    SEdgeList sel;
    void StartPath( RgbaColor strokeRgb, double lineWidth,

#ifdef LIBRARY
#   define ENTITY EntityBase
#   define CONSTRAINT ConstraintBase
#else
#   define ENTITY Entity
#   define CONSTRAINT Constraint
#endif
</t>
<t tx="leo.20191228122647.72">class Sketch {
public:
    // These are user-editable, and define the sketch.
    IdList&lt;Group,hGroup&gt;            group;
    List&lt;hGroup&gt;                    groupOrder;
    IdList&lt;CONSTRAINT,hConstraint&gt;  constraint;
    IdList&lt;Request,hRequest&gt;        request;
    IdList&lt;Style,hStyle&gt;            style;

    // These are generated from the above.
    IdList&lt;ENTITY,hEntity&gt;          entity;
    IdList&lt;Param,hParam&gt;            param;

    inline CONSTRAINT *GetConstraint(hConstraint h)
        { return constraint.FindById(h); }
    inline ENTITY  *GetEntity (hEntity  h) { return entity. FindById(h); }
    inline Param   *GetParam  (hParam   h) { return param.  FindById(h); }
    inline Request *GetRequest(hRequest h) { return request.FindById(h); }
    inline Group   *GetGroup  (hGroup   h) { return group.  FindById(h); }
    // Styles are handled a bit differently.

    void Clear();

    BBox CalculateEntityBBox(bool includingInvisible);
    Group *GetRunningMeshGroupFor(hGroup h);
};
#undef ENTITY
#undef CONSTRAINT

</t>
<t tx="leo.20191228122647.73">class SolveSpaceUI {
public:
    TextWindow                 *pTW;
    TextWindow                 &amp;TW;
    GraphicsWindow              GW;

    // The state for undo/redo
    @others
};

void ImportDxf(const Platform::Path &amp;file);
void ImportDwg(const Platform::Path &amp;file);

extern SolveSpaceUI SS;
extern Sketch SK;

}

#ifndef __OBJC__
using namespace SolveSpace;
#endif

#endif
</t>
<t tx="leo.20191228122647.74">typedef struct {
    IdList&lt;Group,hGroup&gt;            group;
    List&lt;hGroup&gt;                    groupOrder;
    IdList&lt;Request,hRequest&gt;        request;
    IdList&lt;Constraint,hConstraint&gt;  constraint;
    IdList&lt;Param,hParam&gt;            param;
    IdList&lt;Style,hStyle&gt;            style;
    hGroup                          activeGroup;

    @others
} UndoState;
enum { MAX_UNDO = 16 };
</t>
<t tx="leo.20191228122647.75">void Clear() {
    group.Clear();
    request.Clear();
    constraint.Clear();
    param.Clear();
    style.Clear();
}
</t>
<t tx="leo.20191228122647.76">typedef struct {
    UndoState   d[MAX_UNDO];
    int         cnt;
    int         write;
} UndoStack;
UndoStack   undo;
UndoStack   redo;

std::map&lt;Platform::Path, std::shared_ptr&lt;Pixmap&gt;, Platform::PathLess&gt; images;
bool ReloadLinkedImage(const Platform::Path &amp;saveFile, Platform::Path *filename,

// Little bits of extra configuration state
enum { MODEL_COLORS = 8 };
RgbaColor modelColor[MODEL_COLORS];
Vector   lightDir[2];
double   lightIntensity[2];
double   ambientIntensity;
double   chordTol;
double   chordTolCalculated;
int      maxSegments;
double   exportChordTol;
int      exportMaxSegments;
double   cameraTangent;
double   gridSpacing;
double   exportScale;
double   exportOffset;
bool     fixExportColors;
bool     drawBackFaces;
bool     showContourAreas;
bool     checkClosedContour;
bool     turntableNav;
bool     immediatelyEditDimension;
bool     automaticLineConstraints;
bool     showToolbar;
Platform::Path screenshotFile;
RgbaColor backgroundColor;
bool     exportShadedTriangles;
bool     exportPwlCurves;
bool     exportCanvasSizeAuto;
bool     exportMode;
struct {
    double  left;
    double  right;
    double  bottom;
    double  top;
}        exportMargin;
struct {
    double  width;
    double  height;
    double  dx;
    double  dy;
}        exportCanvas;
struct {
    double  depth;
    int     passes;
    double  feed;
    double  plungeFeed;
}        gCode;

Unit     viewUnits;
int      afterDecimalMm;
int      afterDecimalInch;
int      afterDecimalDegree;
bool     useSIPrefixes;
int      autosaveInterval; // in minutes

std::string MmToString(double v);
std::string MmToStringSI(double v, int dim = 0);
std::string DegreeToString(double v);
double ExprToMm(Expr *e);
double StringToMm(const std::string &amp;s);
const char *UnitName();
double MmPerUnit();
int UnitDigitsAfterDecimal();
void SetUnitDigitsAfterDecimal(int v);
double ChordTolMm();
double ExportChordTolMm();
int GetMaxSegments();
bool usePerspectiveProj;
double CameraTangent();

// Some stuff relating to the tangent arcs created non-parametrically
// as special requests.
double tangentArcRadius;
bool tangentArcManual;
bool tangentArcModify;

// The platform-dependent code calls this before entering the msg loop
void Init();
void Exit();

// File load/save routines, including the additional files that get
// loaded when we have link groups.
FILE        *fh;
void AfterNewFile();
void AddToRecentList(const Platform::Path &amp;filename);
Platform::Path saveFile;
bool        fileLoadError;
bool        unsaved;
</t>
<t tx="leo.20191228122647.77">typedef struct {
    char        type;
    const char *desc;
    char        fmt;
    void       *ptr;
} SaveTable;
static const SaveTable SAVED[];
void SaveUsingTable(const Platform::Path &amp;filename, int type);
void LoadUsingTable(const Platform::Path &amp;filename, char *key, char *val);
struct {
    Group        g;
    Request      r;
    Entity       e;
    Param        p;
    Constraint   c;
    Style        s;
} sv;
static void MenuFile(Command id);
void Autosave();
void RemoveAutosave();
static const size_t MAX_RECENT = 8;
std::vector&lt;Platform::Path&gt; recentFiles;
bool Load(const Platform::Path &amp;filename);
bool GetFilenameAndSave(bool saveAs);
bool OkayToStartNewFile();
hGroup CreateDefaultDrawingGroup();
void UpdateWindowTitles();
void ClearExisting();
void NewFile();
bool SaveToFile(const Platform::Path &amp;filename);
bool LoadAutosaveFor(const Platform::Path &amp;filename);
bool LoadFromFile(const Platform::Path &amp;filename, bool canCancel = false);
void UpgradeLegacyData();
bool LoadEntitiesFromFile(const Platform::Path &amp;filename, EntityList *le,
void ExportMeshAsVrmlTo(FILE *f, const Platform::Path &amp;filename, SMesh *sm);
void ExportViewOrWireframeTo(const Platform::Path &amp;filename, bool exportWireframe);
void ExportSectionTo(const Platform::Path &amp;filename);
void ExportWireframeCurves(SEdgeList *sel, SBezierList *sbl,
struct {
    SContour    path;
    hEntity     point;
} traced;
SEdgeList nakedEdges;
struct {
    bool        draw;
    Vector      ptA;
    Vector      ptB;
} extraLine;
struct {
    bool        draw, showOrigin;
    Vector      pt, u, v;
} justExportedInfo;
struct {
    bool   draw;
    bool   dirty;
    Vector position;
} centerOfMass;

</t>
<t tx="leo.20191228122647.78">class Clipboard {
public:
    List&lt;ClipboardRequest&gt;  r;
    List&lt;Constraint&gt;        c;

    void Clear();
    bool ContainsEntity(hEntity old);
    hEntity NewEntityFor(hEntity old);
};
Clipboard clipboard;

void MarkGroupDirty(hGroup hg, bool onlyThis = false);
void MarkGroupDirtyByEntity(hEntity he);

// Consistency checking on the sketch: stuff with missing dependencies
// will get deleted automatically.
struct {
    int     requests;
    int     groups;
    int     constraints;
    int     nonTrivialConstraints;
} deleted;
bool GroupExists(hGroup hg);
bool PruneOrphans();
bool EntityExists(hEntity he);
bool GroupsInOrder(hGroup before, hGroup after);
bool PruneGroups(hGroup hg);
bool PruneRequests(hGroup hg);
bool PruneConstraints(hGroup hg);
static void ShowNakedEdges(bool reportOnlyWhenNotOkay);

enum class Generate : uint32_t {
    DIRTY,
    ALL,
    REGEN,
    UNTIL_ACTIVE,
};

void GenerateAll(Generate type = Generate::DIRTY, bool andFindFree = false,

// The system to be solved.
System     *pSys;
System     &amp;sys;

// All the TrueType fonts in memory
TtfFontList fonts;

// Everything has been pruned, so we know there's no dangling references
// to entities that don't exist. Before that, we mustn't try to display
// the sketch!
bool allConsistent;

Platform::TimerRef showTWTimer;
Platform::TimerRef generateAllTimer;
Platform::TimerRef autosaveTimer;
void ScheduleShowTW();
void ScheduleGenerateAll();
void ScheduleAutosave();

static void MenuHelp(Command id);

void Clear();

// We allocate TW and sys on the heap to work around an MSVC problem
// where it puts zero-initialized global data in the binary (~30M of zeroes)
// in release builds.
SolveSpaceUI()
    : pTW(new TextWindow({})), TW(*pTW),
      pSys(new System({})), sys(*pSys) {}

~SolveSpaceUI() {
    delete pTW;
    delete pSys;
}
</t>
<t tx="leo.20191228122647.79">@path ./src/
//-----------------------------------------------------------------------------
// Implementation of a cosmetic line style, which determines the color and
// other appearance of a line or curve on-screen and in exported files. Some
// styles are predefined, and others can be created by the user.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122647.8">class hEntity {
public:
    // bits 15: 0   -- entity index
    //      31:16   -- request index
    uint32_t v;

    inline bool isFromRequest() const;
    inline hRequest request() const;
    inline hGroup group() const;
    inline hEquation equation(int i) const;
};

template&lt;&gt;
struct IsHandleOracle&lt;hEntity&gt; : std::true_type {};

</t>
<t tx="leo.20191228122647.80">const Style::Default Style::Defaults[] = {
    { { ACTIVE_GRP },   "ActiveGrp",    RGBf(1.0, 1.0, 1.0), 1.5, 4 },
    { { CONSTRUCTION }, "Construction", RGBf(0.1, 0.7, 0.1), 1.5, 0 },
    { { INACTIVE_GRP }, "InactiveGrp",  RGBf(0.5, 0.3, 0.0), 1.5, 3 },
    { { DATUM },        "Datum",        RGBf(0.0, 0.8, 0.0), 1.5, 0 },
    { { SOLID_EDGE },   "SolidEdge",    RGBf(0.8, 0.8, 0.8), 1.0, 2 },
    { { CONSTRAINT },   "Constraint",   RGBf(1.0, 0.1, 1.0), 1.0, 0 },
    { { SELECTED },     "Selected",     RGBf(1.0, 0.0, 0.0), 1.5, 0 },
    { { HOVERED },      "Hovered",      RGBf(1.0, 1.0, 0.0), 1.5, 0 },
    { { CONTOUR_FILL }, "ContourFill",  RGBf(0.0, 0.1, 0.1), 1.0, 0 },
    { { NORMALS },      "Normals",      RGBf(0.0, 0.4, 0.4), 1.0, 0 },
    { { ANALYZE },      "Analyze",      RGBf(0.0, 1.0, 1.0), 3.0, 0 },
    { { DRAW_ERROR },   "DrawError",    RGBf(1.0, 0.0, 0.0), 8.0, 0 },
    { { DIM_SOLID },    "DimSolid",     RGBf(0.1, 0.1, 0.1), 1.0, 0 },
    { { HIDDEN_EDGE },  "HiddenEdge",   RGBf(0.8, 0.8, 0.8), 1.0, 1 },
    { { OUTLINE },      "Outline",      RGBf(0.8, 0.8, 0.8), 3.0, 5 },
    { { 0 },            NULL,           RGBf(0.0, 0.0, 0.0), 0.0, 0 }
};

std::string Style::CnfColor(const std::string &amp;prefix) {
    return "Style_" + prefix + "_Color";
}
std::string Style::CnfWidth(const std::string &amp;prefix) {
    return "Style_" + prefix + "_Width";
}
std::string Style::CnfTextHeight(const std::string &amp;prefix) {
    return "Style_" + prefix + "_TextHeight";
}

std::string Style::CnfPrefixToName(const std::string &amp;prefix) {
    std::string name = "#def-";

    for(size_t i = 0; i &lt; prefix.length(); i++) {
        if(isupper(prefix[i]) &amp;&amp; i != 0)
            name += '-';
        name += tolower(prefix[i]);
    }

    return name;
}

</t>
<t tx="leo.20191228122647.81">void Style::CreateAllDefaultStyles() {
    const Default *d;
    for(d = &amp;(Defaults[0]); d-&gt;h.v; d++) {
        (void)Get(d-&gt;h);
    }
}

</t>
<t tx="leo.20191228122647.82">void Style::CreateDefaultStyle(hStyle h) {
    bool isDefaultStyle = true;
    const Default *d;
    for(d = &amp;(Defaults[0]); d-&gt;h.v; d++) {
        if(d-&gt;h == h) break;
    }
    if(!d-&gt;h.v) {
        // Not a default style; so just create it the same as our default
        // active group entity style.
        d = &amp;(Defaults[0]);
        isDefaultStyle = false;
    }

    Style ns = {};
    FillDefaultStyle(&amp;ns, d);
    ns.h = h;
    if(isDefaultStyle) {
        ns.name = CnfPrefixToName(d-&gt;cnfPrefix);
    } else {
        ns.name = "new-custom-style";
    }

    SK.style.Add(&amp;ns);
}

</t>
<t tx="leo.20191228122647.83">void Style::FillDefaultStyle(Style *s, const Default *d, bool factory) {
    Platform::SettingsRef settings = Platform::GetSettings();

    if(d == NULL) d = &amp;Defaults[0];
    s-&gt;color         = (factory)
                        ? d-&gt;color
                        : settings-&gt;ThawColor(CnfColor(d-&gt;cnfPrefix), d-&gt;color);
    s-&gt;width         = (factory)
                        ? d-&gt;width
                        : settings-&gt;ThawFloat(CnfWidth(d-&gt;cnfPrefix), (float)(d-&gt;width));
    s-&gt;widthAs       = UnitsAs::PIXELS;
    s-&gt;textHeight    = (factory) ? 11.5
                                 : settings-&gt;ThawFloat(CnfTextHeight(d-&gt;cnfPrefix), 11.5);
    s-&gt;textHeightAs  = UnitsAs::PIXELS;
    s-&gt;textOrigin    = TextOrigin::NONE;
    s-&gt;textAngle     = 0;
    s-&gt;visible       = true;
    s-&gt;exportable    = true;
    s-&gt;filled        = false;
    s-&gt;fillColor     = RGBf(0.3, 0.3, 0.3);
    s-&gt;stippleType   = (d-&gt;h.v == Style::HIDDEN_EDGE) ? StipplePattern::DASH
                                                      : StipplePattern::CONTINUOUS;
    s-&gt;stippleScale  = 15.0;
    s-&gt;zIndex        = d-&gt;zIndex;
}

</t>
<t tx="leo.20191228122647.84">void Style::LoadFactoryDefaults() {
    const Default *d;
    for(d = &amp;(Defaults[0]); d-&gt;h.v; d++) {
        Style *s = Get(d-&gt;h);
        FillDefaultStyle(s, d, /*factory=*/true);
    }
    SS.backgroundColor = RGBi(0, 0, 0);
}

</t>
<t tx="leo.20191228122647.85">void Style::FreezeDefaultStyles(Platform::SettingsRef settings) {
    const Default *d;
    for(d = &amp;(Defaults[0]); d-&gt;h.v; d++) {
        settings-&gt;FreezeColor(CnfColor(d-&gt;cnfPrefix), Color(d-&gt;h));
        settings-&gt;FreezeFloat(CnfWidth(d-&gt;cnfPrefix), (float)Width(d-&gt;h));
        settings-&gt;FreezeFloat(CnfTextHeight(d-&gt;cnfPrefix), (float)TextHeight(d-&gt;h));
    }
}

uint32_t Style::CreateCustomStyle(bool rememberForUndo) {
    if(rememberForUndo) SS.UndoRemember();
    uint32_t vs = max((uint32_t)Style::FIRST_CUSTOM, SK.style.MaximumId() + 1);
    hStyle hs = { vs };
    (void)Style::Get(hs);
    return hs.v;
}

</t>
<t tx="leo.20191228122647.86">void Style::AssignSelectionToStyle(uint32_t v) {
    bool showError = false;
    SS.GW.GroupSelection();

    SS.UndoRemember();
    int i;
    for(i = 0; i &lt; SS.GW.gs.entities; i++) {
        hEntity he = SS.GW.gs.entity[i];
        Entity *e = SK.GetEntity(he);
        if(!e-&gt;IsStylable()) continue;

        if(!he.isFromRequest()) {
            showError = true;
            continue;
        }

        hRequest hr = he.request();
        Request *r = SK.GetRequest(hr);
        r-&gt;style.v = v;
        SS.MarkGroupDirty(r-&gt;group);
    }
    for(i = 0; i &lt; SS.GW.gs.constraints; i++) {
        hConstraint hc = SS.GW.gs.constraint[i];
        Constraint *c = SK.GetConstraint(hc);
        if(!c-&gt;IsStylable()) continue;

        c-&gt;disp.style.v = v;
        SS.MarkGroupDirty(c-&gt;group);
    }

    if(showError) {
        Error(_("Can't assign style to an entity that's derived from another "
                "entity; try assigning a style to this entity's parent."));
    }

    SS.GW.ClearSelection();
    SS.GW.Invalidate();

    // And show that style's info screen in the text window.
    SS.TW.GoToScreen(TextWindow::Screen::STYLE_INFO);
    SS.TW.shown.style.v = v;
    SS.ScheduleShowTW();
}

//-----------------------------------------------------------------------------
// Look up a style by its handle. If that style does not exist, then create
// the style, according to our table of default styles.
//-----------------------------------------------------------------------------
Style *Style::Get(hStyle h) {
    if(h.v == 0) h.v = ACTIVE_GRP;

    Style *s = SK.style.FindByIdNoOops(h);
    if(s) {
        // It exists, good.
        return s;
    } else {
        // It doesn't exist; so we should create it and then return that.
        CreateDefaultStyle(h);
        return SK.style.FindById(h);
    }
}

//-----------------------------------------------------------------------------
// A couple of wrappers, so that I can call these functions with either an
// hStyle or with the integer corresponding to that hStyle.v.
//-----------------------------------------------------------------------------
RgbaColor Style::Color(int s, bool forExport) {
    hStyle hs = { (uint32_t)s };
    return Color(hs, forExport);
}
double Style::Width(int s) {
    hStyle hs = { (uint32_t)s };
    return Width(hs);
}

//-----------------------------------------------------------------------------
// If a color is almost white, then we can rewrite it to black, just so that
// it won't disappear on file formats with a light background.
//-----------------------------------------------------------------------------
RgbaColor Style::RewriteColor(RgbaColor rgbin) {
    Vector rgb = Vector::From(rgbin.redF(), rgbin.greenF(), rgbin.blueF());
    rgb = rgb.Minus(Vector::From(1, 1, 1));
    if(rgb.Magnitude() &lt; 0.4 &amp;&amp; SS.fixExportColors) {
        // This is an almost-white color in a default style, which is
        // good for the default on-screen view (black bg) but probably
        // not desired in the exported files, which typically are shown
        // against white backgrounds.
        return RGBi(0, 0, 0);
    } else {
        return rgbin;
    }
}

//-----------------------------------------------------------------------------
// Return the stroke color associated with our style as 8-bit RGB.
//-----------------------------------------------------------------------------
RgbaColor Style::Color(hStyle h, bool forExport) {
    Style *s = Get(h);
    if(forExport) {
        return RewriteColor(s-&gt;color);
    } else {
        return s-&gt;color;
    }
}

//-----------------------------------------------------------------------------
// Return the fill color associated with our style as 8-bit RGB.
//-----------------------------------------------------------------------------
RgbaColor Style::FillColor(hStyle h, bool forExport) {
    Style *s = Get(h);
    if(forExport) {
        return RewriteColor(s-&gt;fillColor);
    } else {
        return s-&gt;fillColor;
    }
}

//-----------------------------------------------------------------------------
// Return the width associated with our style in pixels..
//-----------------------------------------------------------------------------
double Style::Width(hStyle h) {
    Style *s = Get(h);
    switch(s-&gt;widthAs) {
        case UnitsAs::MM:     return s-&gt;width * SS.GW.scale;
        case UnitsAs::PIXELS: return s-&gt;width;
    }
    ssassert(false, "Unexpected units");
}

//-----------------------------------------------------------------------------
// Return the width associated with our style in millimeters..
//-----------------------------------------------------------------------------
double Style::WidthMm(int hs) {
    double widthpx = Width(hs);
    return widthpx / SS.GW.scale;
}

//-----------------------------------------------------------------------------
// Return the associated text height, in pixels.
//-----------------------------------------------------------------------------
double Style::TextHeight(hStyle h) {
    Style *s = Get(h);
    switch(s-&gt;textHeightAs) {
        case UnitsAs::MM:     return s-&gt;textHeight * SS.GW.scale;
        case UnitsAs::PIXELS: return s-&gt;textHeight;
    }
    ssassert(false, "Unexpected units");
}

double Style::DefaultTextHeight() {
    hStyle hs { Style::CONSTRAINT };
    return TextHeight(hs);
}

//-----------------------------------------------------------------------------
// Return the parameters of this style, as a canvas stroke.
//-----------------------------------------------------------------------------
Canvas::Stroke Style::Stroke(hStyle hs) {
    Canvas::Stroke stroke = {};
    Style *style = Style::Get(hs);
    stroke.color = style-&gt;color;
    stroke.stipplePattern = style-&gt;stippleType;
    stroke.stippleScale = style-&gt;stippleScale;
    stroke.width = style-&gt;width;
    switch(style-&gt;widthAs) {
        case Style::UnitsAs::PIXELS:
            stroke.unit = Canvas::Unit::PX;
            break;
        case Style::UnitsAs::MM:
            stroke.unit = Canvas::Unit::MM;
            break;
    }
    return stroke;
}

Canvas::Stroke Style::Stroke(int hsv) {
    hStyle hs = { (uint32_t) hsv };
    return Style::Stroke(hs);
}

//-----------------------------------------------------------------------------
// Should lines and curves from this style appear in the output file? Only
// if it's both shown and exportable.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122647.87">bool Style::Exportable(int si) {
    hStyle hs = { (uint32_t)si };
    Style *s = Get(hs);
    return (s-&gt;exportable) &amp;&amp; (s-&gt;visible);
}

//-----------------------------------------------------------------------------
// Return the appropriate style for our entity. If the entity has a style
// explicitly assigned, then it's that style. Otherwise it's the appropriate
// default style.
//-----------------------------------------------------------------------------
hStyle Style::ForEntity(hEntity he) {
    Entity *e = SK.GetEntity(he);
    // If the entity has a special style, use that. If that style doesn't
    // exist yet, then it will get created automatically later.
    if(e-&gt;style.v != 0) {
        return e-&gt;style;
    }

    // Otherwise, we use the default rules.
    hStyle hs;
    if(e-&gt;group != SS.GW.activeGroup) {
        hs.v = INACTIVE_GRP;
    } else if(e-&gt;construction) {
        hs.v = CONSTRUCTION;
    } else {
        hs.v = ACTIVE_GRP;
    }
    return hs;
}

StipplePattern Style::PatternType(hStyle hs) {
    Style *s = Get(hs);
    return s-&gt;stippleType;
}

double Style::StippleScaleMm(hStyle hs) {
    Style *s = Get(hs);
    if(s-&gt;widthAs == UnitsAs::MM) {
        return s-&gt;stippleScale;
    } else if(s-&gt;widthAs == UnitsAs::PIXELS) {
        return s-&gt;stippleScale / SS.GW.scale;
    }
    return 1.0;
}

std::string Style::DescriptionString() const {
    if(name.empty()) {
        return ssprintf("s%03x-(unnamed)", h.v);
    } else {
        return ssprintf("s%03x-%s", h.v, name.c_str());
    }
}


</t>
<t tx="leo.20191228122647.88">void TextWindow::ScreenShowListOfStyles(int link, uint32_t v) {
    SS.TW.GoToScreen(Screen::LIST_OF_STYLES);
}
</t>
<t tx="leo.20191228122647.89">void TextWindow::ScreenShowStyleInfo(int link, uint32_t v) {
    SS.TW.GoToScreen(Screen::STYLE_INFO);
    SS.TW.shown.style.v = v;
}

</t>
<t tx="leo.20191228122647.9">class hParam {
public:
    // bits 15: 0   -- param index
    //      31:16   -- request index
    uint32_t v;

    inline hRequest request() const;
};

template&lt;&gt;
struct IsHandleOracle&lt;hParam&gt; : std::true_type {};

</t>
<t tx="leo.20191228122647.90">void TextWindow::ScreenLoadFactoryDefaultStyles(int link, uint32_t v) {
    Style::LoadFactoryDefaults();
    SS.TW.GoToScreen(Screen::LIST_OF_STYLES);
}

</t>
<t tx="leo.20191228122647.91">void TextWindow::ScreenCreateCustomStyle(int link, uint32_t v) {
    Style::CreateCustomStyle();
}

</t>
<t tx="leo.20191228122647.92">void TextWindow::ScreenChangeBackgroundColor(int link, uint32_t v) {
    RgbaColor rgb = SS.backgroundColor;
    SS.TW.ShowEditControlWithColorPicker(3, rgb);
    SS.TW.edit.meaning = Edit::BACKGROUND_COLOR;
}

</t>
<t tx="leo.20191228122647.93">void TextWindow::ShowListOfStyles() {
    Printf(true, "%Ft color  style-name");

    bool darkbg = false;
    Style *s;
    for(s = SK.style.First(); s; s = SK.style.NextAfter(s)) {
        Printf(false, "%Bp  %Bz   %Bp   %Fl%Ll%f%D%s%E",
            darkbg ? 'd' : 'a',
            &amp;s-&gt;color,
            darkbg ? 'd' : 'a',
            ScreenShowStyleInfo, s-&gt;h.v,
            s-&gt;DescriptionString().c_str());

        darkbg = !darkbg;
    }

    Printf(true, "  %Fl%Ll%fcreate a new custom style%E",
        &amp;ScreenCreateCustomStyle);

    Printf(false, "");

    RgbaColor rgb = SS.backgroundColor;
    Printf(false, "%Ft background color (r, g, b)%E");
    Printf(false, "%Ba   %@, %@, %@ %Fl%D%f%Ll[change]%E",
        rgb.redF(), rgb.greenF(), rgb.blueF(),
        top[rows-1] + 2, &amp;ScreenChangeBackgroundColor);

    Printf(false, "");
    Printf(false, "  %Fl%Ll%fload factory defaults%E",
        &amp;ScreenLoadFactoryDefaultStyles);
}


</t>
<t tx="leo.20191228122647.94">void TextWindow::ScreenChangeStyleName(int link, uint32_t v) {
    hStyle hs = { v };
    Style *s = Style::Get(hs);
    SS.TW.ShowEditControl(12, s-&gt;name);
    SS.TW.edit.style = hs;
    SS.TW.edit.meaning = Edit::STYLE_NAME;
}

</t>
<t tx="leo.20191228122647.95">void TextWindow::ScreenDeleteStyle(int link, uint32_t v) {
    SS.UndoRemember();
    hStyle hs = { v };
    Style *s = SK.style.FindByIdNoOops(hs);
    if(s) {
        SK.style.RemoveById(hs);
        // And it will get recreated automatically if something is still using
        // the style, so no need to do anything else.
    }
    SS.TW.GoToScreen(Screen::LIST_OF_STYLES);
    SS.GW.Invalidate();
}

</t>
<t tx="leo.20191228122647.96">void TextWindow::ScreenChangeStylePatternType(int link, uint32_t v) {
    hStyle hs = { v };
    Style *s = Style::Get(hs);
    s-&gt;stippleType = (StipplePattern)(link - 1);
    SS.GW.persistentDirty = true;
}

</t>
<t tx="leo.20191228122647.97">void TextWindow::ScreenChangeStyleMetric(int link, uint32_t v) {
    hStyle hs = { v };
    Style *s = Style::Get(hs);
    double val;
    Style::UnitsAs units;
    Edit meaning;
    int col;
    switch(link) {
        case 't':
            val = s-&gt;textHeight;
            units = s-&gt;textHeightAs;
            col = 10;
            meaning = Edit::STYLE_TEXT_HEIGHT;
            break;

        case 's':
            val = s-&gt;stippleScale;
            units = s-&gt;widthAs;
            col = 17;
            meaning = Edit::STYLE_STIPPLE_PERIOD;
            break;

        case 'w':
        case 'W':
            val = s-&gt;width;
            units = s-&gt;widthAs;
            col = 9;
            meaning = Edit::STYLE_WIDTH;
            break;

        default: ssassert(false, "Unexpected link");
    }

    std::string edit_value;
    if(units == Style::UnitsAs::PIXELS) {
        edit_value = ssprintf("%.2f", val);
    } else {
        edit_value = SS.MmToString(val);
    }
    SS.TW.ShowEditControl(col, edit_value);
    SS.TW.edit.style = hs;
    SS.TW.edit.meaning = meaning;
}

</t>
<t tx="leo.20191228122647.98">void TextWindow::ScreenChangeStyleTextAngle(int link, uint32_t v) {
    hStyle hs = { v };
    Style *s = Style::Get(hs);
    SS.TW.ShowEditControl(9, ssprintf("%.2f", s-&gt;textAngle));
    SS.TW.edit.style = hs;
    SS.TW.edit.meaning = Edit::STYLE_TEXT_ANGLE;
}

</t>
<t tx="leo.20191228122647.99">void TextWindow::ScreenChangeStyleColor(int link, uint32_t v) {
    hStyle hs = { v };
    Style *s = Style::Get(hs);
    // Same function used for stroke and fill colors
    Edit em;
    RgbaColor rgb;
    if(link == 's') {
        em = Edit::STYLE_COLOR;
        rgb = s-&gt;color;
    } else if(link == 'f') {
        em = Edit::STYLE_FILL_COLOR;
        rgb = s-&gt;fillColor;
    } else ssassert(false, "Unexpected link");
    SS.TW.ShowEditControlWithColorPicker(13, rgb);
    SS.TW.edit.style = hs;
    SS.TW.edit.meaning = em;
}

</t>
<t tx="leo.20191228122648.1">void TextWindow::ScreenAllowRedundant(int link, uint32_t v) {
    SS.UndoRemember();

    Group *g = SK.GetGroup(SS.TW.shown.group);
    g-&gt;allowRedundant = true;
    SS.MarkGroupDirty(SS.TW.shown.group);

    SS.TW.shown.screen = Screen::GROUP_INFO;
    SS.TW.Show();
}
</t>
<t tx="leo.20191228122648.10">@path ./src/
//-----------------------------------------------------------------------------
// Helper functions for the text-based browser window.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

namespace SolveSpace {

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122648.100">bool Vector::OnLineSegment(Vector a, Vector b, double tol) const {
    if(this-&gt;Equals(a, tol) || this-&gt;Equals(b, tol)) return true;

    Vector d = b.Minus(a);

    double m = d.MagSquared();
    double distsq = ((this-&gt;Minus(a)).Cross(d)).MagSquared() / m;

    if(distsq &gt;= tol*tol) return false;

    double t = (this-&gt;Minus(a)).DivProjected(d);
    // On-endpoint already tested
    if(t &lt; 0 || t &gt; 1) return false;
    return true;
}

Vector Vector::ClosestPointOnLine(Vector p0, Vector dp) const {
    dp = dp.WithMagnitude(1);
    // this, p0, and (p0+dp) define a plane; the min distance is in
    // that plane, so calculate its normal
    Vector pn = (this-&gt;Minus(p0)).Cross(dp);
    // The minimum distance line is in that plane, perpendicular
    // to the line
    Vector n = pn.Cross(dp);

    // Calculate the actual distance
    double d = (dp.Cross(p0.Minus(*this))).Magnitude();
    return this-&gt;Plus(n.WithMagnitude(d));
}

double Vector::MagSquared() const {
    return x*x + y*y + z*z;
}

double Vector::Magnitude() const {
    return sqrt(x*x + y*y + z*z);
}

Vector Vector::ScaledBy(double v) const {
    Vector r;

    r.x = x * v;
    r.y = y * v;
    r.z = z * v;

    return r;
}

Vector Vector::WithMagnitude(double v) const {
    double m = Magnitude();
    if(EXACT(m == 0)) {
        // We can do a zero vector with zero magnitude, but not any other cases.
        if(fabs(v) &gt; 1e-100) {
            dbp("Vector::WithMagnitude(%g) of zero vector!", v);
        }
        return From(0, 0, 0);
    } else {
        return ScaledBy(v/m);
    }
}

Vector Vector::ProjectVectorInto(hEntity wrkpl) const {
    EntityBase *w = SK.GetEntity(wrkpl);
    Vector u = w-&gt;Normal()-&gt;NormalU();
    Vector v = w-&gt;Normal()-&gt;NormalV();

    double up = this-&gt;Dot(u);
    double vp = this-&gt;Dot(v);

    return (u.ScaledBy(up)).Plus(v.ScaledBy(vp));
}

Vector Vector::ProjectInto(hEntity wrkpl) const {
    EntityBase *w = SK.GetEntity(wrkpl);
    Vector p0 = w-&gt;WorkplaneGetOffset();

    Vector f = this-&gt;Minus(p0);

    return p0.Plus(f.ProjectVectorInto(wrkpl));
}

Point2d Vector::Project2d(Vector u, Vector v) const {
    Point2d p;
    p.x = this-&gt;Dot(u);
    p.y = this-&gt;Dot(v);
    return p;
}

Point2d Vector::ProjectXy() const {
    Point2d p;
    p.x = x;
    p.y = y;
    return p;
}

Vector4 Vector::Project4d() const {
    return Vector4::From(1, x, y, z);
}

double Vector::DivProjected(Vector delta) const {
    return (x*delta.x + y*delta.y + z*delta.z)
         / (delta.x*delta.x + delta.y*delta.y + delta.z*delta.z);
}

Vector Vector::ClosestOrtho() const {
    double mx = fabs(x), my = fabs(y), mz = fabs(z);

    if(mx &gt; my &amp;&amp; mx &gt; mz) {
        return From((x &gt; 0) ? 1 : -1, 0, 0);
    } else if(my &gt; mz) {
        return From(0, (y &gt; 0) ? 1 : -1, 0);
    } else {
        return From(0, 0, (z &gt; 0) ? 1 : -1);
    }
}

Vector Vector::ClampWithin(double minv, double maxv) const {
    Vector ret = *this;

    if(ret.x &lt; minv) ret.x = minv;
    if(ret.y &lt; minv) ret.y = minv;
    if(ret.z &lt; minv) ret.z = minv;

    if(ret.x &gt; maxv) ret.x = maxv;
    if(ret.y &gt; maxv) ret.y = maxv;
    if(ret.z &gt; maxv) ret.z = maxv;

    return ret;
}

</t>
<t tx="leo.20191228122648.101">void Vector::MakeMaxMin(Vector *maxv, Vector *minv) const {
    maxv-&gt;x = max(maxv-&gt;x, x);
    maxv-&gt;y = max(maxv-&gt;y, y);
    maxv-&gt;z = max(maxv-&gt;z, z);

    minv-&gt;x = min(minv-&gt;x, x);
    minv-&gt;y = min(minv-&gt;y, y);
    minv-&gt;z = min(minv-&gt;z, z);
}

</t>
<t tx="leo.20191228122648.102">bool Vector::OutsideAndNotOn(Vector maxv, Vector minv) const {
    return (x &gt; maxv.x + LENGTH_EPS) || (x &lt; minv.x - LENGTH_EPS) ||
           (y &gt; maxv.y + LENGTH_EPS) || (y &lt; minv.y - LENGTH_EPS) ||
           (z &gt; maxv.z + LENGTH_EPS) || (z &lt; minv.z - LENGTH_EPS);
}

</t>
<t tx="leo.20191228122648.103">bool Vector::BoundingBoxesDisjoint(Vector amax, Vector amin,
                                   Vector bmax, Vector bmin)
{
    int i;
    for(i = 0; i &lt; 3; i++) {
        if(amax.Element(i) &lt; bmin.Element(i) - LENGTH_EPS) return true;
        if(amin.Element(i) &gt; bmax.Element(i) + LENGTH_EPS) return true;
    }
    return false;
}

</t>
<t tx="leo.20191228122648.104">bool Vector::BoundingBoxIntersectsLine(Vector amax, Vector amin,
                                       Vector p0, Vector p1, bool asSegment)
{
    Vector dp = p1.Minus(p0);
    double lp = dp.Magnitude();
    dp = dp.ScaledBy(1.0/lp);

    int i, a;
    for(i = 0; i &lt; 3; i++) {
        int j = WRAP(i+1, 3), k = WRAP(i+2, 3);
        if(lp*fabs(dp.Element(i)) &lt; LENGTH_EPS) continue; // parallel to plane

        for(a = 0; a &lt; 2; a++) {
            double d = (a == 0) ? amax.Element(i) : amin.Element(i);
            // n dot (p0 + t*dp) = d
            // (n dot p0) + t * (n dot dp) = d
            double t = (d - p0.Element(i)) / dp.Element(i);
            Vector p = p0.Plus(dp.ScaledBy(t));

            if(asSegment &amp;&amp; (t &lt; -LENGTH_EPS || t &gt; (lp+LENGTH_EPS))) continue;

            if(p.Element(j) &gt; amax.Element(j) + LENGTH_EPS) continue;
            if(p.Element(k) &gt; amax.Element(k) + LENGTH_EPS) continue;

            if(p.Element(j) &lt; amin.Element(j) - LENGTH_EPS) continue;
            if(p.Element(k) &lt; amin.Element(k) - LENGTH_EPS) continue;

            return true;
        }
    }

    return false;
}

Vector Vector::AtIntersectionOfPlanes(Vector n1, double d1,
                                      Vector n2, double d2)
{
    double det = (n1.Dot(n1))*(n2.Dot(n2)) -
{
    // Make a semi-orthogonal coordinate system from those directions;
    // note that dna and dnb need not be perpendicular.
    Vector dn = da.Cross(db); // normal to both
    Vector dna = dn.Cross(da); // normal to da
    Vector dnb = dn.Cross(db); // normal to db

    // At the intersection of the lines
    //    a0 + pa*da = b0 + pb*db (where pa, pb are scalar params)
    // So dot this equation against dna and dnb to get two equations
    // to solve for da and db
    *tb =  ((a0.Minus(b0)).Dot(dna))/(db.Dot(dna));
    *ta = -((a0.Minus(b0)).Dot(dnb))/(da.Dot(dnb));
}

Vector Vector::AtIntersectionOfLines(Vector a0, Vector a1,
                                     Vector b0, Vector b1,
                                     bool *skew,
                                     double *parama, double *paramb)
{
    Vector da = a1.Minus(a0), db = b1.Minus(b0);

    double pa, pb;
    Vector::ClosestPointBetweenLines(a0, da, b0, db, &amp;pa, &amp;pb);

    if(parama) *parama = pa;
    if(paramb) *paramb = pb;

    // And from either of those, we get the intersection point.
    Vector pi = a0.Plus(da.ScaledBy(pa));

    if(skew) {
        // Check if the intersection points on each line are actually
        // coincident...
        if(pi.Equals(b0.Plus(db.ScaledBy(pb)))) {
            *skew = false;
        } else {
            *skew = true;
        }
    }
    return pi;
}

Vector Vector::AtIntersectionOfPlaneAndLine(Vector n, double d,
                                            Vector p0, Vector p1,
                                            bool *parallel)
{
    Vector dp = p1.Minus(p0);

    if(fabs(n.Dot(dp)) &lt; LENGTH_EPS) {
        if(parallel) *parallel = true;
        return Vector::From(0, 0, 0);
    }

    if(parallel) *parallel = false;

    // n dot (p0 + t*dp) = d
    // (n dot p0) + t * (n dot dp) = d
    double t = (d - n.Dot(p0)) / (n.Dot(dp));

    return p0.Plus(dp.ScaledBy(t));
}

</t>
<t tx="leo.20191228122648.105">static double det2(double a1, double b1,
                   double a2, double b2)
{
    return (a1*b2) - (b1*a2);
}
</t>
<t tx="leo.20191228122648.106">static double det3(double a1, double b1, double c1,
                   double a2, double b2, double c2,
                   double a3, double b3, double c3)
{
    return a1*det2(b2, c2, b3, c3) -
           b1*det2(a2, c2, a3, c3) +
           c1*det2(a2, b2, a3, b3);
}
Vector Vector::AtIntersectionOfPlanes(Vector na, double da,
                                      Vector nb, double db,
                                      Vector nc, double dc,
                                      bool *parallel)
{
</t>
<t tx="leo.20191228122648.107">    double det  = det3(na.x, na.y, na.z,
                       nb.x, nb.y, nb.z,
                       nc.x, nc.y, nc.z);
    if(fabs(det) &lt; 1e-10) { // arbitrary tolerance, not so good
        *parallel = true;
        return Vector::From(0, 0, 0);
    }
    *parallel = false;

    double detx = det3(da,   na.y, na.z,

    return Vector::From(detx/det, dety/det, detz/det);
}

size_t VectorHash::operator()(const Vector &amp;v) const {
    const size_t size = (size_t)pow(std::numeric_limits&lt;size_t&gt;::max(), 1.0 / 3.0) - 1;
    const double eps = 4.0 * LENGTH_EPS;

    double x = fabs(v.x) / eps;
    double y = fabs(v.y) / eps;
    double z = fabs(v.y) / eps;

    size_t xs = size_t(fmod(x, (double)size));
    size_t ys = size_t(fmod(y, (double)size));
    size_t zs = size_t(fmod(z, (double)size));

    return (zs * size + ys) * size + xs;
}

</t>
<t tx="leo.20191228122648.108">bool VectorPred::operator()(Vector a, Vector b) const {
    return a.Equals(b, LENGTH_EPS);
}

Vector4 Vector4::From(double w, double x, double y, double z) {
    Vector4 ret;
    ret.w = w;
    ret.x = x;
    ret.y = y;
    ret.z = z;
    return ret;
}

Vector4 Vector4::From(double w, Vector v) {
    return Vector4::From(w, w*v.x, w*v.y, w*v.z);
}

Vector4 Vector4::Blend(Vector4 a, Vector4 b, double t) {
    return (a.ScaledBy(1 - t)).Plus(b.ScaledBy(t));
}

Vector4 Vector4::Plus(Vector4 b) const {
    return Vector4::From(w + b.w, x + b.x, y + b.y, z + b.z);
}

Vector4 Vector4::Minus(Vector4 b) const {
    return Vector4::From(w - b.w, x - b.x, y - b.y, z - b.z);
}

Vector4 Vector4::ScaledBy(double s) const {
    return Vector4::From(w*s, x*s, y*s, z*s);
}

Vector Vector4::PerspectiveProject() const {
    return Vector::From(x / w, y / w, z / w);
}

Point2d Point2d::From(double x, double y) {
    return { x, y };
}

Point2d Point2d::FromPolar(double r, double a) {
    return { r * cos(a), r * sin(a) };
}

double Point2d::Angle() const {
    double a = atan2(y, x);
    return M_PI + remainder(a - M_PI, 2 * M_PI);
}

double Point2d::AngleTo(const Point2d &amp;p) const {
    return p.Minus(*this).Angle();
}

Point2d Point2d::Plus(const Point2d &amp;b) const {
    return { x + b.x, y + b.y };
}

Point2d Point2d::Minus(const Point2d &amp;b) const {
    return { x - b.x, y - b.y };
}

Point2d Point2d::ScaledBy(double s) const {
    return { x * s, y * s };
}

double Point2d::DivProjected(Point2d delta) const {
    return (x*delta.x + y*delta.y) / (delta.x*delta.x + delta.y*delta.y);
}

double Point2d::MagSquared() const {
    return x*x + y*y;
}

double Point2d::Magnitude() const {
    return sqrt(x*x + y*y);
}

Point2d Point2d::WithMagnitude(double v) const {
    double m = Magnitude();
    if(m &lt; 1e-20) {
        dbp("!!! WithMagnitude() of zero vector");
        return { v, 0 };
    }
    return { x * v / m, y * v / m };
}

double Point2d::DistanceTo(const Point2d &amp;p) const {
    double dx = x - p.x;
    double dy = y - p.y;
    return sqrt(dx*dx + dy*dy);
}

double Point2d::Dot(Point2d p) const {
    return x*p.x + y*p.y;
}

double Point2d::DistanceToLine(const Point2d &amp;p0, const Point2d &amp;dp, bool asSegment) const {
    double m = dp.x*dp.x + dp.y*dp.y;
    if(m &lt; LENGTH_EPS*LENGTH_EPS) return VERY_POSITIVE;

    // Let our line be p = p0 + t*dp, for a scalar t from 0 to 1
    double t = (dp.x*(x - p0.x) + dp.y*(y - p0.y))/m;

    if(asSegment) {
        if(t &lt; 0.0) return DistanceTo(p0);
        if(t &gt; 1.0) return DistanceTo(p0.Plus(dp));
    }
    Point2d closest = p0.Plus(dp.ScaledBy(t));
    return DistanceTo(closest);
}

double Point2d::DistanceToLineSigned(const Point2d &amp;p0, const Point2d &amp;dp, bool asSegment) const {
    double m = dp.x*dp.x + dp.y*dp.y;
    if(m &lt; LENGTH_EPS*LENGTH_EPS) return VERY_POSITIVE;

    Point2d n = dp.Normal().WithMagnitude(1.0);
    double dist = n.Dot(*this) - n.Dot(p0);
    if(asSegment) {
        // Let our line be p = p0 + t*dp, for a scalar t from 0 to 1
        double t = (dp.x*(x - p0.x) + dp.y*(y - p0.y))/m;
        double sign = (dist &gt; 0.0) ? 1.0 : -1.0;
        if(t &lt; 0.0) return DistanceTo(p0) * sign;
        if(t &gt; 1.0) return DistanceTo(p0.Plus(dp)) * sign;
    }

    return dist;
}

Point2d Point2d::Normal() const {
    return { y, -x };
}

</t>
<t tx="leo.20191228122648.109">bool Point2d::Equals(Point2d v, double tol) const {
    double dx = v.x - x; if(dx &lt; -tol || dx &gt; tol) return false;
    double dy = v.y - y; if(dy &lt; -tol || dy &gt; tol) return false;

    return (this-&gt;Minus(v)).MagSquared() &lt; tol*tol;
}

BBox BBox::From(const Vector &amp;p0, const Vector &amp;p1) {
    BBox bbox;
    bbox.minp.x = min(p0.x, p1.x);
    bbox.minp.y = min(p0.y, p1.y);
    bbox.minp.z = min(p0.z, p1.z);

    bbox.maxp.x = max(p0.x, p1.x);
    bbox.maxp.y = max(p0.y, p1.y);
    bbox.maxp.z = max(p0.z, p1.z);
    return bbox;
}

Vector BBox::GetOrigin() const { return minp.Plus(maxp.Minus(minp).ScaledBy(0.5)); }
Vector BBox::GetExtents() const { return maxp.Minus(minp).ScaledBy(0.5); }

</t>
<t tx="leo.20191228122648.11">class Button {
public:
    virtual std::string Tooltip() = 0;
    virtual void Draw(UiCanvas *uiCanvas, int x, int y, bool asHovered) = 0;
    virtual int AdvanceWidth() = 0;
    virtual void Click() = 0;
};

</t>
<t tx="leo.20191228122648.110">void BBox::Include(const Vector &amp;v, double r) {
    minp.x = min(minp.x, v.x - r);
    minp.y = min(minp.y, v.y - r);
    minp.z = min(minp.z, v.z - r);

    maxp.x = max(maxp.x, v.x + r);
    maxp.y = max(maxp.y, v.y + r);
    maxp.z = max(maxp.z, v.z + r);
}

</t>
<t tx="leo.20191228122648.111">bool BBox::Overlaps(const BBox &amp;b1) const {
    Vector t = b1.GetOrigin().Minus(GetOrigin());
    Vector e = b1.GetExtents().Plus(GetExtents());

    return fabs(t.x) &lt; e.x &amp;&amp; fabs(t.y) &lt; e.y &amp;&amp; fabs(t.z) &lt; e.z;
}

</t>
<t tx="leo.20191228122648.112">bool BBox::Contains(const Point2d &amp;p, double r) const {
    return p.x &gt;= (minp.x - r) &amp;&amp;
           p.y &gt;= (minp.y - r) &amp;&amp;
           p.x &lt;= (maxp.x + r) &amp;&amp;
           p.y &lt;= (maxp.y + r);
}

</t>
<t tx="leo.20191228122648.113">const std::vector&lt;double&gt;&amp; SolveSpace::StipplePatternDashes(StipplePattern pattern) {
    static bool initialized;
    static std::vector&lt;double&gt; dashes[(size_t)StipplePattern::LAST + 1];
    if(!initialized) {
        // Inkscape ignores all elements that are exactly zero instead of drawing
        // them as dots, so set those to 1e-6.
        dashes[(size_t)StipplePattern::CONTINUOUS] =
            {};
        dashes[(size_t)StipplePattern::SHORT_DASH] =
            { 1.0, 2.0 };
        dashes[(size_t)StipplePattern::DASH] =
            { 1.0, 1.0 };
        dashes[(size_t)StipplePattern::DASH_DOT] =
            { 1.0, 0.5, 1e-6, 0.5 };
        dashes[(size_t)StipplePattern::DASH_DOT_DOT] =
            { 1.0, 0.5, 1e-6, 0.5, 1e-6, 0.5 };
        dashes[(size_t)StipplePattern::DOT] =
            { 1e-6, 0.5 };
        dashes[(size_t)StipplePattern::LONG_DASH] =
            { 2.0, 0.5 };
        dashes[(size_t)StipplePattern::FREEHAND] =
            { 1.0, 2.0 };
        dashes[(size_t)StipplePattern::ZIGZAG] =
            { 1.0, 2.0 };
    }

    return dashes[(size_t)pattern];
}

double SolveSpace::StipplePatternLength(StipplePattern pattern) {
    static bool initialized;
    static double lengths[(size_t)StipplePattern::LAST + 1];
    if(!initialized) {
        for(size_t i = 0; i &lt; (size_t)StipplePattern::LAST; i++) {
            const std::vector&lt;double&gt; &amp;dashes = StipplePatternDashes((StipplePattern)i);
            double length = 0.0;
            for(double dash : dashes) {
                length += dash;
            }
            lengths[i] = length;
        }
    }

    return lengths[(size_t)pattern];
}
</t>
<t tx="leo.20191228122648.114">@path ./src/
//-----------------------------------------------------------------------------
// The View menu, stuff to snap to certain special vews of the model, and to
// display our current view of the model to the user.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122648.115">void TextWindow::ShowEditView() {
    Printf(true, "%Ft3D VIEW PARAMETERS%E");

    Printf(true,  "%Bd %Ftoverall scale factor%E");
    Printf(false, "%Ba   %# px/%s %Fl%Ll%f[edit]%E",
        SS.GW.scale * SS.MmPerUnit(),
        SS.UnitName(),
        &amp;ScreenChangeViewScale);
    Printf(false, "%Bd   %Fl%Ll%fset to full scale%E",
        &amp;ScreenChangeViewToFullScale);
    Printf(false, "");

    Printf(false, "%Bd %Ftorigin (maps to center of screen)%E");
    Printf(false, "%Ba   (%s, %s, %s) %Fl%Ll%f[edit]%E",
        SS.MmToString(-SS.GW.offset.x).c_str(),
        SS.MmToString(-SS.GW.offset.y).c_str(),
        SS.MmToString(-SS.GW.offset.z).c_str(),
        &amp;ScreenChangeViewOrigin);
    Printf(false, "");

    Vector n = (SS.GW.projRight).Cross(SS.GW.projUp);
    Printf(false, "%Bd %Ftprojection onto screen%E");
    Printf(false, "%Ba   %Ftright%E (%3, %3, %3) %Fl%Ll%f[edit]%E",
        CO(SS.GW.projRight),
        &amp;ScreenChangeViewProjection);
    Printf(false, "%Bd   %Ftup%E    (%3, %3, %3)", CO(SS.GW.projUp));
    Printf(false, "%Ba   %Ftout%E   (%3, %3, %3)", CO(n));
    Printf(false, "");

    Printf(false, "The perspective may be changed in the");
    Printf(false, "configuration screen.");
}

</t>
<t tx="leo.20191228122648.116">void TextWindow::ScreenChangeViewScale(int link, uint32_t v) {
    SS.TW.edit.meaning = Edit::VIEW_SCALE;
    SS.TW.ShowEditControl(3, ssprintf("%.3f", SS.GW.scale * SS.MmPerUnit()));
}

</t>
<t tx="leo.20191228122648.117">void TextWindow::ScreenChangeViewToFullScale(int link, uint32_t v) {
    SS.GW.scale = SS.GW.window-&gt;GetPixelDensity() / 25.4;
}

</t>
<t tx="leo.20191228122648.118">void TextWindow::ScreenChangeViewOrigin(int link, uint32_t v) {
    std::string edit_value =
        ssprintf("%s, %s, %s",
            SS.MmToString(-SS.GW.offset.x).c_str(),
            SS.MmToString(-SS.GW.offset.y).c_str(),
            SS.MmToString(-SS.GW.offset.z).c_str());

    SS.TW.edit.meaning = Edit::VIEW_ORIGIN;
    SS.TW.ShowEditControl(3, edit_value);
}

</t>
<t tx="leo.20191228122648.119">void TextWindow::ScreenChangeViewProjection(int link, uint32_t v) {
    std::string edit_value =
        ssprintf("%.3f, %.3f, %.3f", CO(SS.GW.projRight));
    SS.TW.edit.meaning = Edit::VIEW_PROJ_RIGHT;
    SS.TW.ShowEditControl(10, edit_value);
}

</t>
<t tx="leo.20191228122648.12">class SpacerButton : public Button {
public:
    std::string Tooltip() override { return ""; }

    @others
};

</t>
<t tx="leo.20191228122648.120">bool TextWindow::EditControlDoneForView(const std::string &amp;s) {
    switch(edit.meaning) {
        case Edit::VIEW_SCALE: {
            Expr *e = Expr::From(s, /*popUpError=*/true);
            if(e) {
                double v =  e-&gt;Eval() / SS.MmPerUnit();
                if(v &gt; LENGTH_EPS) {
                    SS.GW.scale = v;
                } else {
                    Error(_("Scale cannot be zero or negative."));
                }
            }
            break;
        }

        case Edit::VIEW_ORIGIN: {
            Vector pt;
            if(sscanf(s.c_str(), "%lf, %lf, %lf", &amp;pt.x, &amp;pt.y, &amp;pt.z) == 3) {
                pt = pt.ScaledBy(SS.MmPerUnit());
                SS.GW.offset = pt.ScaledBy(-1);
            } else {
                Error(_("Bad format: specify x, y, z"));
            }
            break;
        }

        case Edit::VIEW_PROJ_RIGHT:
        case Edit::VIEW_PROJ_UP: {
            Vector pt;
            if(sscanf(s.c_str(), "%lf, %lf, %lf", &amp;pt.x, &amp;pt.y, &amp;pt.z) != 3) {
                Error(_("Bad format: specify x, y, z"));
                break;
            }
            if(edit.meaning == Edit::VIEW_PROJ_RIGHT) {
                SS.GW.projRight = pt;
                SS.GW.NormalizeProjectionVectors();
                edit.meaning = Edit::VIEW_PROJ_UP;
                HideEditControl();
                ShowEditControl(10, ssprintf("%.3f, %.3f, %.3f", CO(SS.GW.projUp)),
                                editControl.halfRow + 2);
                edit.showAgain = true;
            } else {
                SS.GW.projUp = pt;
                SS.GW.NormalizeProjectionVectors();
            }
            break;
        }

        default:
            return false;
    }
    return true;
}

</t>
<t tx="leo.20191228122648.121"></t>
<t tx="leo.20191228122648.122">@path ./src/platform/
//-----------------------------------------------------------------------------
// Our main() function for the command-line interface.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122648.123">static void ShowUsage(const std::string &amp;cmd) {
    fprintf(stderr, "Usage: %s &lt;command&gt; &lt;options&gt; &lt;filename&gt; [filename...]", cmd.c_str());
//-----------------------------------------------------------------------------&gt; 80 col */
    fprintf(stderr, R"(
    When run, performs an action specified by &lt;command&gt; on every &lt;filename&gt;.

Common options:
    -o, --output &lt;pattern&gt;
        For an input file &lt;name&gt;.slvs, replaces the '%%' symbol in &lt;pattern&gt;
        with &lt;name&gt; and uses it as output file. For example, when using
        --output %%-2d.png for input files f/a.slvs and f/b.slvs, output files
        f/a-2d.png and f/b-2d.png will be written.
    -v, --view &lt;direction&gt;
        Selects the camera direction. &lt;direction&gt; can be one of "top", "bottom",
        "left", "right", "front", "back", or "isometric".
    -t, --chord-tol &lt;tolerance&gt;
        Selects the chord tolerance, used for converting exact curves to
        piecewise linear, and exact surfaces into triangle meshes.
        For export commands, the unit is mm, and the default is 1.0 mm.
        For non-export commands, the unit is %%, and the default is 1.0 %%.

Commands:
    thumbnail --output &lt;pattern&gt; --size &lt;size&gt; --view &lt;direction&gt;
              [--chord-tol &lt;tolerance&gt;]
        Outputs a rendered view of the sketch, like the SolveSpace GUI would.
        &lt;size&gt; is &lt;width&gt;x&lt;height&gt;, in pixels. Graphics acceleration is
        not used, and the output may look slightly different from the GUI.
    export-view --output &lt;pattern&gt; --view &lt;direction&gt; [--chord-tol &lt;tolerance&gt;]
        Exports a view of the sketch, in a 2d vector format.
    export-wireframe --output &lt;pattern&gt; [--chord-tol &lt;tolerance&gt;]
        Exports a wireframe of the sketch, in a 3d vector format.
    export-mesh --output &lt;pattern&gt; [--chord-tol &lt;tolerance&gt;]
        Exports a triangle mesh of solids in the sketch, with exact surfaces
        being triangulated first.
    export-surfaces --output &lt;pattern&gt;
        Exports exact surfaces of solids in the sketch, if any.
    regenerate [--chord-tol &lt;tolerance&gt;]
        Reloads all imported files, regenerates the sketch, and saves it.
        Note that, although this is not an export command, it uses absolute
        chord tolerance, and can be used to prepare assemblies for export.
)");

    @others
}

</t>
<t tx="leo.20191228122648.124">    auto FormatListFromFileFilters = [](const std::vector&lt;Platform::FileFilter&gt; &amp;filters) {
        std::string descr;
        for(auto filter : filters) {
            descr += "\n        ";
            descr += filter.name;
            descr += " (";
            bool first = true;
            for(auto extension : filter.extensions) {
                if(!first) {
                    descr += ", ";
                }
                descr += extension;
                first = false;
            }
            descr += ")";
        }
        return descr;
    };

    fprintf(stderr, R"(
File formats:
    thumbnail:%s
    export-view:%s
    export-wireframe:%s
    export-mesh:%s
    export-surfaces:%s
)", FormatListFromFileFilters(Platform::RasterFileFilters).c_str(),
    FormatListFromFileFilters(Platform::VectorFileFilters).c_str(),
    FormatListFromFileFilters(Platform::Vector3dFileFilters).c_str(),
    FormatListFromFileFilters(Platform::MeshFileFilters).c_str(),
    FormatListFromFileFilters(Platform::SurfaceFileFilters).c_str());
</t>
<t tx="leo.20191228122648.125">static bool RunCommand(const std::vector&lt;std::string&gt; args) {
    if(args.size() &lt; 2) return false;

    for(const std::string &amp;arg : args) {
        if(arg == "--help" || arg == "-h") {
            ShowUsage(args[0]);
            return true;
        }
    }

    std::function&lt;void(const Platform::Path &amp;)&gt; runner;

    std::vector&lt;Platform::Path&gt; inputFiles;
    @others
}

</t>
<t tx="leo.20191228122648.126">auto ParseInputFile = [&amp;](size_t &amp;argn) {
    std::string arg = args[argn];
    if(arg[0] != '-') {
        inputFiles.push_back(Platform::Path::From(arg));
        return true;
    } else return false;
};

std::string outputPattern;
</t>
<t tx="leo.20191228122648.127">auto ParseOutputPattern = [&amp;](size_t &amp;argn) {
    if(argn + 1 &lt; args.size() &amp;&amp; (args[argn] == "--output" ||
                                  args[argn] == "-o")) {
        argn++;
        outputPattern = args[argn];
        return true;
    } else return false;
};

Vector projUp = {}, projRight = {};
</t>
<t tx="leo.20191228122648.128">auto ParseViewDirection = [&amp;](size_t &amp;argn) {
    if(argn + 1 &lt; args.size() &amp;&amp; (args[argn] == "--view" ||
                                  args[argn] == "-v")) {
        argn++;
        if(args[argn] == "top") {
            projRight = Vector::From(1, 0, 0);
            projUp    = Vector::From(0, 1, 0);
        } else if(args[argn] == "bottom") {
            projRight = Vector::From(-1, 0, 0);
            projUp    = Vector::From(0, 1, 0);
        } else if(args[argn] == "left") {
            projRight = Vector::From(0, 1, 0);
            projUp    = Vector::From(0, 0, 1);
        } else if(args[argn] == "right") {
            projRight = Vector::From(0, -1, 0);
            projUp    = Vector::From(0, 0, 1);
        } else if(args[argn] == "front") {
            projRight = Vector::From(-1, 0, 0);
            projUp    = Vector::From(0, 0, 1);
        } else if(args[argn] == "back") {
            projRight = Vector::From(1, 0, 0);
            projUp    = Vector::From(0, 0, 1);
        } else if(args[argn] == "isometric") {
            projRight = Vector::From(0.707,  0.000, -0.707);
            projUp    = Vector::From(-0.408, 0.816, -0.408);
        } else {
            fprintf(stderr, "Unrecognized view direction '%s'\n", args[argn].c_str());
        }
        return true;
    } else return false;
};

double chordTol = 1.0;
</t>
<t tx="leo.20191228122648.129">auto ParseChordTolerance = [&amp;](size_t &amp;argn) {
    if(argn + 1 &lt; args.size() &amp;&amp; (args[argn] == "--chord-tol" ||
                                  args[argn] == "-t")) {
        argn++;
        if(sscanf(args[argn].c_str(), "%lf", &amp;chordTol) == 1) {
            return true;
        } else return false;
    } else return false;
};

unsigned width = 0, height = 0;
if(args[1] == "thumbnail") {
</t>
<t tx="leo.20191228122648.13">void Draw(UiCanvas *uiCanvas, int x, int y, bool asHovered) override {
    // Draw a darker-grey spacer in between the groups of icons.
    uiCanvas-&gt;DrawRect(x, x + 4, y, y - 24,
                       /*fillColor=*/{ 45, 45, 45, 255 },
                       /*outlineColor=*/{});
}

int AdvanceWidth() override { return 12; }

</t>
<t tx="leo.20191228122648.130">    auto ParseSize = [&amp;](size_t &amp;argn) {
        if(argn + 1 &lt; args.size() &amp;&amp; args[argn] == "--size") {
            argn++;
            if(sscanf(args[argn].c_str(), "%ux%u", &amp;width, &amp;height) == 2) {
                return true;
            } else return false;
        } else return false;
    };

    for(size_t argn = 2; argn &lt; args.size(); argn++) {
        if(!(ParseInputFile(argn) ||
             ParseOutputPattern(argn) ||
             ParseViewDirection(argn) ||
             ParseChordTolerance(argn) ||
             ParseSize(argn))) {
            fprintf(stderr, "Unrecognized option '%s'.\n", args[argn].c_str());
            return false;
        }
    }

    if(width == 0 || height == 0) {
        fprintf(stderr, "Non-zero viewport size must be specified.\n");
        return false;
    }

    if(EXACT(projUp.Magnitude() == 0 || projRight.Magnitude() == 0)) {
        fprintf(stderr, "View direction must be specified.\n");
        return false;
    }

    runner = [&amp;](const Platform::Path &amp;output) {
        Camera camera = {};
        camera.pixelRatio = 1;
        camera.gridFit    = true;
        camera.width      = width;
        camera.height     = height;
        camera.projUp     = SS.GW.projUp;
        camera.projRight  = SS.GW.projRight;

        SS.GW.projUp      = projUp;
        SS.GW.projRight   = projRight;
        SS.GW.scale       = SS.GW.ZoomToFit(camera);
        camera.scale      = SS.GW.scale;
        SS.GenerateAll();

        CairoPixmapRenderer pixmapCanvas;
        pixmapCanvas.antialias = true;
        pixmapCanvas.SetLighting(SS.GW.GetLighting());
        pixmapCanvas.SetCamera(camera);
        pixmapCanvas.Init();

        pixmapCanvas.StartFrame();
        SS.GW.Draw(&amp;pixmapCanvas);
        pixmapCanvas.FlushFrame();
        pixmapCanvas.FinishFrame();
        pixmapCanvas.ReadFrame()-&gt;WritePng(output, /*flip=*/true);

        pixmapCanvas.Clear();
    };
} else if(args[1] == "export-view") {
    for(size_t argn = 2; argn &lt; args.size(); argn++) {
        if(!(ParseInputFile(argn) ||
             ParseOutputPattern(argn) ||
             ParseViewDirection(argn) ||
             ParseChordTolerance(argn))) {
            fprintf(stderr, "Unrecognized option '%s'.\n", args[argn].c_str());
            return false;
        }
    }

    if(EXACT(projUp.Magnitude() == 0 || projRight.Magnitude() == 0)) {
        fprintf(stderr, "View direction must be specified.\n");
        return false;
    }

    runner = [&amp;](const Platform::Path &amp;output) {
        SS.GW.projRight   = projRight;
        SS.GW.projUp      = projUp;
        SS.exportChordTol = chordTol;

        SS.ExportViewOrWireframeTo(output, /*exportWireframe=*/false);
    };
} else if(args[1] == "export-wireframe") {
    for(size_t argn = 2; argn &lt; args.size(); argn++) {
        if(!(ParseInputFile(argn) ||
             ParseOutputPattern(argn) ||
             ParseChordTolerance(argn))) {
            fprintf(stderr, "Unrecognized option '%s'.\n", args[argn].c_str());
            return false;
        }
    }

    runner = [&amp;](const Platform::Path &amp;output) {
        SS.exportChordTol = chordTol;

        SS.ExportViewOrWireframeTo(output, /*exportWireframe=*/true);
    };
} else if(args[1] == "export-mesh") {
    for(size_t argn = 2; argn &lt; args.size(); argn++) {
        if(!(ParseInputFile(argn) ||
             ParseOutputPattern(argn) ||
             ParseChordTolerance(argn))) {
            fprintf(stderr, "Unrecognized option '%s'.\n", args[argn].c_str());
            return false;
        }
    }

    runner = [&amp;](const Platform::Path &amp;output) {
        SS.exportChordTol = chordTol;

        SS.ExportMeshTo(output);
    };
} else if(args[1] == "export-surfaces") {
    for(size_t argn = 2; argn &lt; args.size(); argn++) {
        if(!(ParseInputFile(argn) ||
             ParseOutputPattern(argn))) {
            fprintf(stderr, "Unrecognized option '%s'.\n", args[argn].c_str());
            return false;
        }
    }

    runner = [&amp;](const Platform::Path &amp;output) {
        StepFileWriter sfw = {};
        sfw.ExportSurfacesTo(output);
    };
} else if(args[1] == "regenerate") {
    for(size_t argn = 2; argn &lt; args.size(); argn++) {
        if(!(ParseInputFile(argn) ||
             ParseChordTolerance(argn))) {
            fprintf(stderr, "Unrecognized option '%s'.\n", args[argn].c_str());
            return false;
        }
    }

    outputPattern = "%.slvs";

    runner = [&amp;](const Platform::Path &amp;output) {
        SS.exportChordTol = chordTol;
        SS.exportMode = true;

        SS.SaveToFile(output);
    };
} else {
    fprintf(stderr, "Unrecognized command '%s'.\n", args[1].c_str());
    return false;
}

if(outputPattern.empty()) {
    fprintf(stderr, "An output pattern must be specified.\n");
    return false;
} else if(outputPattern.find('%') == std::string::npos &amp;&amp; inputFiles.size() &gt; 1) {
    fprintf(stderr,
            "Output pattern must include a %% symbol when using multiple inputs!\n");
    return false;
}

if(inputFiles.empty()) {
    fprintf(stderr, "At least one input file must be specified.\n");
    return false;
}

for(const Platform::Path &amp;inputFile : inputFiles) {
    Platform::Path absInputFile = inputFile.Expand(/*fromCurrentDirectory=*/true);

    Platform::Path outputFile = Platform::Path::From(outputPattern);
    size_t replaceAt = outputFile.raw.find('%');
    if(replaceAt != std::string::npos) {
        Platform::Path outputSubst = inputFile.Parent();
        if(outputSubst.IsEmpty()) {
            outputSubst = Platform::Path::From(inputFile.FileStem());
        } else {
            outputSubst = outputSubst.Join(inputFile.FileStem());
        }
        outputFile.raw.replace(replaceAt, 1, outputSubst.raw);
    }
    Platform::Path absOutputFile = outputFile.Expand(/*fromCurrentDirectory=*/true);

    SS.Init();
    if(!SS.LoadFromFile(absInputFile)) {
        fprintf(stderr, "Cannot load '%s'!\n", inputFile.raw.c_str());
        return false;
    }
    SS.AfterNewFile();
    runner(absOutputFile);
    SK.Clear();
    SS.Clear();

    fprintf(stderr, "Written '%s'.\n", outputFile.raw.c_str());
}

return true;
</t>
<t tx="leo.20191228122648.131">int main(int argc, char **argv) {
    std::vector&lt;std::string&gt; args = InitPlatform(argc, argv);

    if(args.size() == 1) {
        ShowUsage(args[0]);
        return 0;
    }

    if(!RunCommand(args)) {
        return 1;
    } else {
        return 0;
    }
}
</t>
<t tx="leo.20191228122648.14">    void Click() override {}
};

class ShowHideButton : public Button {
public:
    bool        *variable;
    std::string tooltip;
    std::string iconName;
    std::shared_ptr&lt;Pixmap&gt; icon;

    ShowHideButton(bool *variable, std::string iconName, std::string tooltip)
            : variable(variable), tooltip(tooltip), iconName(iconName) {}

    std::string Tooltip() override {
        return ((*variable) ? "Hide " : "Show ") + tooltip;
    }

</t>
<t tx="leo.20191228122648.15">void Draw(UiCanvas *uiCanvas, int x, int y, bool asHovered) override {
    if(icon == NULL) {
        icon = LoadPng("icons/text-window/" + iconName + ".png");
    }

    uiCanvas-&gt;DrawPixmap(icon, x, y - 24);
    if(asHovered) {
        uiCanvas-&gt;DrawRect(x - 2, x + 26, y + 2, y - 26,
                           /*fillColor=*/{ 255, 255, 0, 75 },
                           /*outlineColor=*/{});
    }
    if(!*(variable)) {
        int s = 0, f = 24;
        RgbaColor color = { 255, 0, 0, 150 };
        uiCanvas-&gt;DrawLine(x+s, y-s, x+f, y-f, color, 2);
        uiCanvas-&gt;DrawLine(x+s, y-f, x+f, y-s, color, 2);
    }
}

int AdvanceWidth() override { return 32; }

void Click() override { SS.GW.ToggleBool(variable); }
</t>
<t tx="leo.20191228122648.16">class FacesButton : public ShowHideButton {
public:
    FacesButton()
        : ShowHideButton(&amp;(SS.GW.showFaces), "faces", "") {}

    std::string Tooltip() override {
        if(*variable) {
            return "Don't make faces selectable with mouse";
        } else {
            return "Make faces selectable with mouse";
        }
    }
};

</t>
<t tx="leo.20191228122648.17">class OccludedLinesButton : public Button {
public:
    std::shared_ptr&lt;Pixmap&gt; visibleIcon;
    std::shared_ptr&lt;Pixmap&gt; stippledIcon;
    std::shared_ptr&lt;Pixmap&gt; invisibleIcon;

    std::string Tooltip() override {
        switch(SS.GW.drawOccludedAs) {
            case GraphicsWindow::DrawOccludedAs::INVISIBLE:
                return "Stipple occluded lines";

            case GraphicsWindow::DrawOccludedAs::STIPPLED:
                return "Draw occluded lines";

            case GraphicsWindow::DrawOccludedAs::VISIBLE:
                return "Don't draw occluded lines";

            default: ssassert(false, "Unexpected mode");
        }
    }

    @others
};

static SpacerButton   spacerButton;

static ShowHideButton workplanesButton =
static ShowHideButton shadedButton =
    &amp;workplanesButton,
    &amp;normalsButton,
    &amp;pointsButton,
    &amp;constructionButton,
    &amp;constraintsButton,
    &amp;facesButton,
    &amp;spacerButton,
    &amp;shadedButton,
    &amp;edgesButton,
    &amp;outlinesButton,
    &amp;meshButton,
    &amp;spacerButton,
    &amp;occludedLinesButton,
};

/** Foreground color codes. */
</t>
<t tx="leo.20191228122648.18">void Draw(UiCanvas *uiCanvas, int x, int y, bool asHovered) override {
    if(visibleIcon == NULL) {
        visibleIcon = LoadPng("icons/text-window/occluded-visible.png");
    }
    if(stippledIcon == NULL) {
        stippledIcon = LoadPng("icons/text-window/occluded-stippled.png");
    }
    if(invisibleIcon == NULL) {
        invisibleIcon = LoadPng("icons/text-window/occluded-invisible.png");
    }

    std::shared_ptr&lt;Pixmap&gt; icon;
    switch(SS.GW.drawOccludedAs) {
        case GraphicsWindow::DrawOccludedAs::INVISIBLE: icon = invisibleIcon; break;
        case GraphicsWindow::DrawOccludedAs::STIPPLED:  icon = stippledIcon;  break;
        case GraphicsWindow::DrawOccludedAs::VISIBLE:   icon = visibleIcon;   break;
    }

    uiCanvas-&gt;DrawPixmap(icon, x, y - 24);
    if(asHovered) {
        uiCanvas-&gt;DrawRect(x - 2, x + 26, y + 2, y - 26,
                           /*fillColor=*/{ 255, 255, 0, 75 },
                           /*outlineColor=*/{});
    }
}

int AdvanceWidth() override { return 32; }

</t>
<t tx="leo.20191228122648.19">void Click() override {
    switch(SS.GW.drawOccludedAs) {
        case GraphicsWindow::DrawOccludedAs::INVISIBLE:
            SS.GW.drawOccludedAs = GraphicsWindow::DrawOccludedAs::STIPPLED;
            break;

        case GraphicsWindow::DrawOccludedAs::STIPPLED:
            SS.GW.drawOccludedAs = GraphicsWindow::DrawOccludedAs::VISIBLE;
            break;

        case GraphicsWindow::DrawOccludedAs::VISIBLE:
            SS.GW.drawOccludedAs = GraphicsWindow::DrawOccludedAs::INVISIBLE;
            break;
    }

    SS.GenerateAll();
    SS.GW.Invalidate();
    SS.ScheduleShowTW();
}
</t>
<t tx="leo.20191228122648.2">void TextWindow::ShowGroupSolveInfo() {
    Group *g = SK.GetGroup(shown.group);
    if(g-&gt;IsSolvedOkay()) {
        // Go back to the default group info screen
        shown.screen = Screen::GROUP_INFO;
        Show();
        return;
    }

    Printf(true, "%FtGROUP   %E%s", g-&gt;DescriptionString().c_str());
    switch(g-&gt;solved.how) {
        case SolveResult::DIDNT_CONVERGE:
            Printf(true, "%FxSOLVE FAILED!%Fd unsolvable constraints");
            Printf(true, "the following constraints are incompatible");
            break;

        case SolveResult::REDUNDANT_DIDNT_CONVERGE:
            Printf(true, "%FxSOLVE FAILED!%Fd unsolvable constraints");
            Printf(true, "the following constraints are unsatisfied");
            break;

        case SolveResult::REDUNDANT_OKAY:
            Printf(true, "%FxSOLVE FAILED!%Fd redundant constraints");
            Printf(true, "remove any one of these to fix it");
            break;

        case SolveResult::TOO_MANY_UNKNOWNS:
            Printf(true, "Too many unknowns in a single group!");
            return;

        default: ssassert(false, "Unexpected solve result");
    }

    for(int i = 0; i &lt; g-&gt;solved.remove.n; i++) {
        hConstraint hc = g-&gt;solved.remove[i];
        Constraint *c = SK.constraint.FindByIdNoOops(hc);
        if(!c) continue;

        Printf(false, "%Bp   %Fl%Ll%D%f%h%s%E",
            (i &amp; 1) ? 'd' : 'a',
            c-&gt;h.v, (&amp;TextWindow::ScreenSelectConstraint),
            (&amp;TextWindow::ScreenHoverConstraint),
            c-&gt;DescriptionString().c_str());
    }

    Printf(true,  "It may be possible to fix the problem ");
    Printf(false, "by selecting Edit -&gt; Undo.");

    if(g-&gt;solved.how == SolveResult::REDUNDANT_OKAY) {
        Printf(true,  "It is possible to suppress this error ");
        Printf(false, "by %Fl%f%Llallowing redundant constraints%E in ",
                      &amp;TextWindow::ScreenAllowRedundant);
        Printf(false, "this group.");
    }
}

//-----------------------------------------------------------------------------
// When we're stepping a dimension. User specifies the finish value, and
// how many steps to take in between current and finish, re-solving each
// time.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122648.20">const TextWindow::Color TextWindow::fgColors[] = {
    { 'd', RGBi(255, 255, 255) },  // Default   : white
    { 'l', RGBi(100, 200, 255) },  // links     : blue
    { 't', RGBi(255, 200, 100) },  // tree/text : yellow
    { 'h', RGBi( 90,  90,  90) },
    { 's', RGBi( 40, 255,  40) },  // Ok        : green
    { 'm', RGBi(200, 200,   0) },
    { 'r', RGBi(  0,   0,   0) },  // Reverse   : black
    { 'x', RGBi(255,  20,  20) },  // Error     : red
    { 'i', RGBi(  0, 255, 255) },  // Info      : cyan
    { 'g', RGBi(160, 160, 160) },
    { 'b', RGBi(200, 200, 200) },
    { 0,   RGBi(  0,   0,   0) }
};
/** Background color codes. */
</t>
<t tx="leo.20191228122648.21">const TextWindow::Color TextWindow::bgColors[] = {
    { 'd', RGBi(  0,   0,   0) },  // Default   : black
    { 't', RGBi( 34,  15,  15) },
    { 'a', RGBi( 25,  25,  25) },  // Alternate : dark gray
    { 'r', RGBi(255, 255, 255) },  // Reverse   : white
    { 0,   RGBi(  0,   0,   0) }
};

</t>
<t tx="leo.20191228122648.22">void TextWindow::MakeColorTable(const Color *in, float *out) {
    int i;
    for(i = 0; in[i].c != 0; i++) {
        int c = in[i].c;
        ssassert(c &gt;= 0 &amp;&amp; c &lt;= 255, "Unexpected color index");
        out[c*3 + 0] = in[i].color.redF();
        out[c*3 + 1] = in[i].color.greenF();
        out[c*3 + 2] = in[i].color.blueF();
    }
}

</t>
<t tx="leo.20191228122648.23">void TextWindow::Init() {
    if(!window) {
        window = Platform::CreateWindow(Platform::Window::Kind::TOOL, SS.GW.window);
        if(window) {
            canvas = CreateRenderer();

            using namespace std::placeholders;
            window-&gt;onClose = []() {
                SS.GW.showTextWindow = false;
                SS.GW.EnsureValidActives();
            };
            window-&gt;onMouseEvent = [this](Platform::MouseEvent event) {
                using Platform::MouseEvent;

                if(event.type == MouseEvent::Type::PRESS ||
                   event.type == MouseEvent::Type::DBL_PRESS ||
                   event.type == MouseEvent::Type::MOTION) {
                    bool isClick  = (event.type != MouseEvent::Type::MOTION);
                    bool leftDown = (event.button == MouseEvent::Button::LEFT);
                    this-&gt;MouseEvent(isClick, leftDown, event.x, event.y);
                    return true;
                } else if(event.type == MouseEvent::Type::LEAVE) {
                    MouseLeave();
                    return true;
                } else if(event.type == MouseEvent::Type::SCROLL_VERT) {
                    window-&gt;SetScrollbarPosition(window-&gt;GetScrollbarPosition() -
                                                 LINE_HEIGHT / 2 * event.scrollDelta);
                }
                return false;
            };
            window-&gt;onKeyboardEvent = SS.GW.window-&gt;onKeyboardEvent;
            window-&gt;onRender = std::bind(&amp;TextWindow::Paint, this);
            window-&gt;onEditingDone = std::bind(&amp;TextWindow::EditControlDone, this, _1);
            window-&gt;onScrollbarAdjusted = std::bind(&amp;TextWindow::ScrollbarEvent, this, _1);
            window-&gt;SetMinContentSize(370, 370);
        }
    }

    ClearSuper();
}

</t>
<t tx="leo.20191228122648.24">void TextWindow::ClearSuper() {
    // Ugly hack, but not so ugly as the next line
    Platform::WindowRef oldWindow = std::move(window);
    std::shared_ptr&lt;ViewportCanvas&gt; oldCanvas = canvas;

    // Cannot use *this = {} here because TextWindow instances
    // are 2.4MB long; this causes stack overflows in prologue
    // when built with MSVC, even with optimizations.
    memset(this, 0, sizeof(*this));

    // Return old canvas
    window = std::move(oldWindow);
    canvas = oldCanvas;

    HideEditControl();

    MakeColorTable(fgColors, fgColorTable);
    MakeColorTable(bgColors, bgColorTable);

    ClearScreen();
    Show();
}

</t>
<t tx="leo.20191228122648.25">void TextWindow::HideEditControl() {
    editControl.colorPicker.show = false;
    if(window) {
        window-&gt;HideEditor();
        window-&gt;Invalidate();
    }
}

</t>
<t tx="leo.20191228122648.26">void TextWindow::ShowEditControl(int col, const std::string &amp;str, int halfRow) {
    if(halfRow &lt; 0) halfRow = top[hoveredRow];
    editControl.halfRow = halfRow;
    editControl.col = col;

    int x = LEFT_MARGIN + CHAR_WIDTH_*col;
    int y = (halfRow - SS.TW.scrollPos)*(LINE_HEIGHT/2);

    double width, height;
    window-&gt;GetContentSize(&amp;width, &amp;height);
    window-&gt;ShowEditor(x, y + LINE_HEIGHT - 2, LINE_HEIGHT - 4,
                       width - x, /*isMonospace=*/true, str);
}

</t>
<t tx="leo.20191228122648.27">void TextWindow::ShowEditControlWithColorPicker(int col, RgbaColor rgb) {
    SS.ScheduleShowTW();

    editControl.colorPicker.show = true;
    editControl.colorPicker.rgb = rgb;
    editControl.colorPicker.h = 0;
    editControl.colorPicker.s = 0;
    editControl.colorPicker.v = 1;
    ShowEditControl(col, ssprintf("%.2f, %.2f, %.2f", rgb.redF(), rgb.greenF(), rgb.blueF()));
}

</t>
<t tx="leo.20191228122648.28">void TextWindow::ClearScreen() {
    int i, j;
    for(i = 0; i &lt; MAX_ROWS; i++) {
        for(j = 0; j &lt; MAX_COLS; j++) {
            text[i][j] = ' ';
            meta[i][j].fg = 'd';
            meta[i][j].bg = 'd';
            meta[i][j].link = NOT_A_LINK;
        }
        top[i] = i*2;
    }
    rows = 0;
}

</t>
<t tx="leo.20191228122648.29">void TextWindow::Printf(bool halfLine, const char *fmt, ...) {
    if(!canvas) return;

    if(rows &gt;= MAX_ROWS) return;

    va_list vl;
    va_start(vl, fmt);

    int r, c;
    r = rows;
    top[r] = (r == 0) ? 0 : (top[r-1] + (halfLine ? 3 : 2));
    rows++;

    for(c = 0; c &lt; MAX_COLS; c++) {
        text[r][c] = ' ';
        meta[r][c].link = NOT_A_LINK;
    }

    char fg = 'd';
    char bg = 'd';
    RgbaColor bgRgb = RGBi(0, 0, 0);
    int link = NOT_A_LINK;
    uint32_t data = 0;
    LinkFunction *f = NULL, *h = NULL;

    c = 0;
    while(*fmt) {
        char buf[1024];

        if(*fmt == '%') {
            fmt++;
            if(*fmt == '\0') goto done;
            strcpy(buf, "");
            switch(*fmt) {
                case 'd': {
                    int v = va_arg(vl, int);
                    sprintf(buf, "%d", v);
                    break;
                }
                case 'x': {
                    unsigned int v = va_arg(vl, unsigned int);
                    sprintf(buf, "%08x", v);
                    break;
                }
                case '@': {
                    double v = va_arg(vl, double);
                    sprintf(buf, "%.2f", v);
                    break;
                }
                case '2': {
                    double v = va_arg(vl, double);
                    sprintf(buf, "%s%.2f", v &lt; 0 ? "" : " ", v);
                    break;
                }
                case '3': {
                    double v = va_arg(vl, double);
                    sprintf(buf, "%s%.3f", v &lt; 0 ? "" : " ", v);
                    break;
                }
                case '#': {
                    double v = va_arg(vl, double);
                    sprintf(buf, "%.3f", v);
                    break;
                }
                case 's': {
                    char *s = va_arg(vl, char *);
                    memcpy(buf, s, min(sizeof(buf), strlen(s)+1));
                    break;
                }
                case 'c': {
                    // 'char' is promoted to 'int' when passed through '...'
                    int v = va_arg(vl, int);
                    if(v == 0) {
                        strcpy(buf, "");
                    } else {
                        sprintf(buf, "%c", v);
                    }
                    break;
                }
                case 'E':
                    fg = 'd';
                    // leave the background, though
                    link = NOT_A_LINK;
                    data = 0;
                    f = NULL;
                    h = NULL;
                    break;

                case 'F':
                case 'B': {
                    char cc = fmt[1];  // color code
                    RgbaColor *rgbPtr = NULL;
                    switch(cc) {
                        case 0:   goto done;  // truncated directive
                        case 'p': cc = (char)va_arg(vl, int); break;
                        case 'z': rgbPtr = va_arg(vl, RgbaColor *); break;
                    }
                    if(*fmt == 'F') {
                        fg = cc;
                    } else {
                        bg = cc;
                        if(rgbPtr) bgRgb = *rgbPtr;
                    }
                    fmt++;
                    break;
                }
                case 'L':
                    if(fmt[1] == '\0') goto done;
                    fmt++;
                    if(*fmt == 'p') {
                        link = va_arg(vl, int);
                    } else {
                        link = *fmt;
                    }
                    break;

                case 'f':
                    f = va_arg(vl, LinkFunction *);
                    break;

                case 'h':
                    h = va_arg(vl, LinkFunction *);
                    break;

                case 'D': {
                    unsigned int v = va_arg(vl, unsigned int);
                    data = (uint32_t)v;
                    break;
                }
                case '%':
                    strcpy(buf, "%");
                    break;
            }
        } else {
            utf8_iterator it2(fmt), it1 = it2++;
            strncpy(buf, fmt, it2 - it1);
            buf[it2 - it1] = '\0';
        }

        for(utf8_iterator it(buf); *it; ++it) {
            for(size_t i = 0; i &lt; canvas-&gt;GetBitmapFont()-&gt;GetWidth(*it); i++) {
                if(c &gt;= MAX_COLS) goto done;
                text[r][c] = (i == 0) ? *it : ' ';
                meta[r][c].fg = fg;
                meta[r][c].bg = bg;
                meta[r][c].bgRgb = bgRgb;
                meta[r][c].link = link;
                meta[r][c].data = data;
                meta[r][c].f = f;
                meta[r][c].h = h;
                c++;
            }
        }

        utf8_iterator it(fmt);
        it++;
        fmt = it.ptr();
    }
    while(c &lt; MAX_COLS) {
        meta[r][c].fg = fg;
        meta[r][c].bg = bg;
        meta[r][c].bgRgb = bgRgb;
        c++;
    }

done:
    va_end(vl);
}

</t>
<t tx="leo.20191228122648.3">void TextWindow::ScreenStepDimFinish(int link, uint32_t v) {
    SS.TW.edit.meaning = Edit::STEP_DIM_FINISH;
    std::string edit_value;
    if(SS.TW.stepDim.isDistance) {
        edit_value = SS.MmToString(SS.TW.stepDim.finish);
    } else {
        edit_value = ssprintf("%.3f", SS.TW.stepDim.finish);
    }
    SS.TW.ShowEditControl(12, edit_value);
}
</t>
<t tx="leo.20191228122648.30">void TextWindow::Show() {
    if(SS.GW.pending.operation == GraphicsWindow::Pending::NONE) {
        SS.GW.ClearPending(/*scheduleShowTW=*/false);
    }

    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;

    // Make sure these tests agree with test used to draw indicator line on
    // main list of groups screen.
    if(SS.GW.pending.description) {
        // A pending operation (that must be completed with the mouse in
        // the graphics window) will preempt our usual display.
        HideEditControl();
        ShowHeader(false);
        Printf(false, "");
        Printf(false, "%s", SS.GW.pending.description);
        Printf(true, "%Fl%f%Ll(cancel operation)%E",
            &amp;TextWindow::ScreenUnselectAll);
    } else if((gs.n &gt; 0 || gs.constraints &gt; 0) &amp;&amp;
                                    shown.screen != Screen::PASTE_TRANSFORMED)
    {
        if(edit.meaning != Edit::TTF_TEXT) HideEditControl();
        ShowHeader(false);
        DescribeSelection();
    } else {
        if(edit.meaning == Edit::TTF_TEXT) HideEditControl();
        ShowHeader(true);
        switch(shown.screen) {
            default:
                shown.screen = Screen::LIST_OF_GROUPS;
                // fall through
            case Screen::LIST_OF_GROUPS:     ShowListOfGroups();     break;
            case Screen::GROUP_INFO:         ShowGroupInfo();        break;
            case Screen::GROUP_SOLVE_INFO:   ShowGroupSolveInfo();   break;
            case Screen::CONFIGURATION:      ShowConfiguration();    break;
            case Screen::STEP_DIMENSION:     ShowStepDimension();    break;
            case Screen::LIST_OF_STYLES:     ShowListOfStyles();     break;
            case Screen::STYLE_INFO:         ShowStyleInfo();        break;
            case Screen::PASTE_TRANSFORMED:  ShowPasteTransformed(); break;
            case Screen::EDIT_VIEW:          ShowEditView();         break;
            case Screen::TANGENT_ARC:        ShowTangentArc();       break;
        }
    }
    Printf(false, "");

    // Make sure there's room for the color picker
    if(editControl.colorPicker.show) {
        int pickerHeight = 25;
        int halfRow = editControl.halfRow;
        if(top[rows-1] - halfRow &lt; pickerHeight &amp;&amp; rows &lt; MAX_ROWS) {
            rows++;
            top[rows-1] = halfRow + pickerHeight;
        }
    }

    if(window) Resize();
}

</t>
<t tx="leo.20191228122648.31">void TextWindow::Resize()
{
    double width, height;
    window-&gt;GetContentSize(&amp;width, &amp;height);

    halfRows = (int)height / (LINE_HEIGHT/2);

    int bottom = top[rows-1] + 2;
    scrollPos = min(scrollPos, bottom - halfRows);
    scrollPos = max(scrollPos, 0);

    window-&gt;ConfigureScrollbar(0, top[rows - 1] + 1, halfRows);
    window-&gt;SetScrollbarPosition(scrollPos);
    window-&gt;SetScrollbarVisible(top[rows - 1] + 1 &gt; halfRows);
    window-&gt;Invalidate();
}

</t>
<t tx="leo.20191228122648.32">void TextWindow::DrawOrHitTestIcons(UiCanvas *uiCanvas, TextWindow::DrawOrHitHow how,
                                    double mx, double my)
{
    double width, height;
    window-&gt;GetContentSize(&amp;width, &amp;height);

    int x = 20, y = 33 + LINE_HEIGHT;
    y -= scrollPos*(LINE_HEIGHT/2);

    if(how == PAINT) {
        int top = y - 28, bot = y + 4;
        uiCanvas-&gt;DrawRect(0, (int)width, top, bot,
                           /*fillColor=*/{ 30, 30, 30, 255 }, /*outlineColor=*/{});
    }

    Button *oldHovered = hoveredButton;
    if(how != PAINT) {
        hoveredButton = NULL;
    }

    double hoveredX, hoveredY;
    for(Button *button : buttons) {
        if(how == PAINT) {
            button-&gt;Draw(uiCanvas, x, y, (button == hoveredButton));
        } else if(mx &gt; x - 2 &amp;&amp; mx &lt; x + 26 &amp;&amp;
                  my &lt; y + 2 &amp;&amp; my &gt; y - 26) {
            hoveredButton = button;
            hoveredX = x - 2;
            hoveredY = y - 26;
            if(how == CLICK) {
                button-&gt;Click();
            }
        }

        x += button-&gt;AdvanceWidth();
    }

    if(how != PAINT &amp;&amp; hoveredButton != oldHovered) {
        if(hoveredButton == NULL) {
            window-&gt;SetTooltip("", 0, 0, 0, 0);
        } else {
            window-&gt;SetTooltip(hoveredButton-&gt;Tooltip(), hoveredX, hoveredY, 28, 28);
        }
        window-&gt;Invalidate();
    }
}

//----------------------------------------------------------------------------
// Given (x, y, z) = (h, s, v) in [0,6), [0,1], [0,1], return (x, y, z) =
// (r, g, b) all in [0, 1].
//----------------------------------------------------------------------------
Vector TextWindow::HsvToRgb(Vector hsv) {
    if(hsv.x &gt;= 6) hsv.x -= 6;

    Vector rgb;
    double hmod2 = hsv.x;
    while(hmod2 &gt;= 2) hmod2 -= 2;
    double x = (1 - fabs(hmod2 - 1));
    if(hsv.x &lt; 1) {
        rgb = Vector::From(1, x, 0);
    } else if(hsv.x &lt; 2) {
        rgb = Vector::From(x, 1, 0);
    } else if(hsv.x &lt; 3) {
        rgb = Vector::From(0, 1, x);
    } else if(hsv.x &lt; 4) {
        rgb = Vector::From(0, x, 1);
    } else if(hsv.x &lt; 5) {
        rgb = Vector::From(x, 0, 1);
    } else {
        rgb = Vector::From(1, 0, x);
    }
    double c = hsv.y*hsv.z;
    double m = 1 - hsv.z;
    rgb = rgb.ScaledBy(c);
    rgb = rgb.Plus(Vector::From(m, m, m));

    return rgb;
}

std::shared_ptr&lt;Pixmap&gt; TextWindow::HsvPattern2d(int w, int h) {
    std::shared_ptr&lt;Pixmap&gt; pixmap = Pixmap::Create(Pixmap::Format::RGB, w, h);
    for(size_t j = 0; j &lt; pixmap-&gt;height; j++) {
        size_t p = pixmap-&gt;stride * j;
        for(size_t i = 0; i &lt; pixmap-&gt;width; i++) {
            Vector hsv = Vector::From(6.0*i/(pixmap-&gt;width-1), 1.0*j/(pixmap-&gt;height-1), 1);
            Vector rgb = HsvToRgb(hsv);
            rgb = rgb.ScaledBy(255);
            pixmap-&gt;data[p++] = (uint8_t)rgb.x;
            pixmap-&gt;data[p++] = (uint8_t)rgb.y;
            pixmap-&gt;data[p++] = (uint8_t)rgb.z;
        }
    }
    return pixmap;
}

std::shared_ptr&lt;Pixmap&gt; TextWindow::HsvPattern1d(double hue, double sat, int w, int h) {
    std::shared_ptr&lt;Pixmap&gt; pixmap = Pixmap::Create(Pixmap::Format::RGB, w, h);
    for(size_t i = 0; i &lt; pixmap-&gt;height; i++) {
        size_t p = i * pixmap-&gt;stride;
        for(size_t j = 0; j &lt; pixmap-&gt;width; j++) {
            Vector hsv = Vector::From(6*hue, sat, 1.0*(pixmap-&gt;width - 1 - j)/pixmap-&gt;width);
            Vector rgb = HsvToRgb(hsv);
            rgb = rgb.ScaledBy(255);
            pixmap-&gt;data[p++] = (uint8_t)rgb.x;
            pixmap-&gt;data[p++] = (uint8_t)rgb.y;
            pixmap-&gt;data[p++] = (uint8_t)rgb.z;
        }
    }
    return pixmap;
}

</t>
<t tx="leo.20191228122648.33">void TextWindow::ColorPickerDone() {
    RgbaColor rgb = editControl.colorPicker.rgb;
    EditControlDone(ssprintf("%.2f, %.2f, %.3f", rgb.redF(), rgb.greenF(), rgb.blueF()));
}

</t>
<t tx="leo.20191228122648.34">bool TextWindow::DrawOrHitTestColorPicker(UiCanvas *uiCanvas, DrawOrHitHow how, bool leftDown,
                                          double x, double y)
{
    using Platform::Window;

    bool mousePointerAsHand = false;

    if(how == HOVER &amp;&amp; !leftDown) {
        editControl.colorPicker.picker1dActive = false;
        editControl.colorPicker.picker2dActive = false;
    }

    if(!editControl.colorPicker.show) return false;
    if(how == CLICK || (how == HOVER &amp;&amp; leftDown)) window-&gt;Invalidate();

    @others
}

</t>
<t tx="leo.20191228122648.35">static const RgbaColor BaseColor[12] = {
    RGBi(255,   0,   0),
    RGBi(  0, 255,   0),
    RGBi(  0,   0, 255),

    RGBi(  0, 255, 255),
    RGBi(255,   0, 255),
    RGBi(255, 255,   0),

    RGBi(255, 127,   0),
    RGBi(255,   0, 127),
    RGBi(  0, 255, 127),
    RGBi(127, 255,   0),
    RGBi(127,   0, 255),
    RGBi(  0, 127, 255),
};

double width, height;
window-&gt;GetContentSize(&amp;width, &amp;height);

int px = LEFT_MARGIN + CHAR_WIDTH_*editControl.col;
int py = (editControl.halfRow - SS.TW.scrollPos)*(LINE_HEIGHT/2);

py += LINE_HEIGHT + 5;

static const int WIDTH = 16, HEIGHT = 12;
static const int PITCH = 18, SIZE = 15;

px = min(px, (int)width - (WIDTH*PITCH + 40));

</t>
<t tx="leo.20191228122648.36">int pxm = px + WIDTH*PITCH + 11,
    pym = py + HEIGHT*PITCH + 7;

int bw = 6;
if(how == PAINT) {
    uiCanvas-&gt;DrawRect(px, pxm+bw, py, pym+bw,
                       /*fillColor=*/{ 50, 50, 50, 255 },
                       /*outlineColor=*/{},
                       /*zIndex=*/1);
    uiCanvas-&gt;DrawRect(px+(bw/2), pxm+(bw/2), py+(bw/2), pym+(bw/2),
                       /*fillColor=*/{ 0, 0, 0, 255 },
                       /*outlineColor=*/{},
                       /*zIndex=*/1);
} else {
    if(x &lt; px || x &gt; pxm+(bw/2) ||
       y &lt; py || y &gt; pym+(bw/2))
    {
        return false;
    }
}
px += (bw/2);
py += (bw/2);

int i, j;
for(i = 0; i &lt; WIDTH/2; i++) {
    for(j = 0; j &lt; HEIGHT; j++) {
        Vector rgb;
        RgbaColor d;
        if(i == 0 &amp;&amp; j &lt; 8) {
            d = SS.modelColor[j];
            rgb = Vector::From(d.redF(), d.greenF(), d.blueF());
        } else if(i == 0) {
            double a = (j - 8.0)/3.0;
            rgb = Vector::From(a, a, a);
        } else {
            d = BaseColor[j];
            rgb = Vector::From(d.redF(), d.greenF(), d.blueF());
            if(i &gt;= 2 &amp;&amp; i &lt;= 4) {
                double a = (i == 2) ? 0.2 : (i == 3) ? 0.3 : 0.4;
                rgb = rgb.Plus(Vector::From(a, a, a));
            }
            if(i &gt;= 5 &amp;&amp; i &lt;= 7) {
                double a = (i == 5) ? 0.7 : (i == 6) ? 0.4 : 0.18;
                rgb = rgb.ScaledBy(a);
            }
        }

        rgb = rgb.ClampWithin(0, 1);
        int sx = px + 5 + PITCH*(i + 8) + 4, sy = py + 5 + PITCH*j;

        if(how == PAINT) {
            uiCanvas-&gt;DrawRect(sx, sx+SIZE, sy, sy+SIZE,
                               /*fillColor=*/RGBf(rgb.x, rgb.y, rgb.z),
                               /*outlineColor=*/{},
                               /*zIndex=*/2);
        } else if(how == CLICK) {
            if(x &gt;= sx &amp;&amp; x &lt;= sx+SIZE &amp;&amp; y &gt;= sy &amp;&amp; y &lt;= sy+SIZE) {
                editControl.colorPicker.rgb = RGBf(rgb.x, rgb.y, rgb.z);
                ColorPickerDone();
            }
        } else if(how == HOVER) {
            if(x &gt;= sx &amp;&amp; x &lt;= sx+SIZE &amp;&amp; y &gt;= sy &amp;&amp; y &lt;= sy+SIZE) {
                mousePointerAsHand = true;
            }
        }
    }
}

int hxm, hym;
int hx = px + 5, hy = py + 5;
hxm = hx + PITCH*7 + SIZE;
hym = hy + PITCH*2 + SIZE;
if(how == PAINT) {
    uiCanvas-&gt;DrawRect(hx, hxm, hy, hym,
                       /*fillColor=*/editControl.colorPicker.rgb,
                       /*outlineColor=*/{},
                       /*zIndex=*/2);
} else if(how == CLICK) {
    if(x &gt;= hx &amp;&amp; x &lt;= hxm &amp;&amp; y &gt;= hy &amp;&amp; y &lt;= hym) {
        ColorPickerDone();
    }
} else if(how == HOVER) {
    if(x &gt;= hx &amp;&amp; x &lt;= hxm &amp;&amp; y &gt;= hy &amp;&amp; y &lt;= hym) {
        mousePointerAsHand = true;
    }
}

hy += PITCH*3;

hxm = hx + PITCH*7 + SIZE;
hym = hy + PITCH*1 + SIZE;
// The one-dimensional thing to pick the color's value
if(how == PAINT) {
    uiCanvas-&gt;DrawPixmap(HsvPattern1d(editControl.colorPicker.h,
                                      editControl.colorPicker.s,
                                      hxm-hx, hym-hy),
                         hx, hy, /*zIndex=*/2);

    int cx = hx+(int)((hxm-hx)*(1.0 - editControl.colorPicker.v));
    uiCanvas-&gt;DrawLine(cx, hy, cx, hym,
                       /*fillColor=*/{ 0, 0, 0, 255 },
                       /*outlineColor=*/{},
                       /*zIndex=*/3);
} else if(how == CLICK ||
      (how == HOVER &amp;&amp; leftDown &amp;&amp; editControl.colorPicker.picker1dActive))
{
    if(x &gt;= hx &amp;&amp; x &lt;= hxm &amp;&amp; y &gt;= hy &amp;&amp; y &lt;= hym) {
        editControl.colorPicker.v = 1 - (x - hx)/(hxm - hx);

        Vector rgb = HsvToRgb(Vector::From(
                        6*editControl.colorPicker.h,
                        editControl.colorPicker.s,
                        editControl.colorPicker.v));
        editControl.colorPicker.rgb = RGBf(rgb.x, rgb.y, rgb.z);

        editControl.colorPicker.picker1dActive = true;
    }
}
// and advance our vertical position
hy += PITCH*2;

hxm = hx + PITCH*7 + SIZE;
hym = hy + PITCH*6 + SIZE;
// Two-dimensional thing to pick a color by hue and saturation
if(how == PAINT) {
    uiCanvas-&gt;DrawPixmap(HsvPattern2d(hxm-hx, hym-hy), hx, hy,
                         /*zIndex=*/2);

    int cx = hx+(int)((hxm-hx)*editControl.colorPicker.h),
      (how == HOVER &amp;&amp; leftDown &amp;&amp; editControl.colorPicker.picker2dActive))
{
    if(x &gt;= hx &amp;&amp; x &lt;= hxm &amp;&amp; y &gt;= hy &amp;&amp; y &lt;= hym) {
        double h = (x - hx)/(hxm - hx),
        editControl.colorPicker.picker2dActive = true;
    }
}

window-&gt;SetCursor(mousePointerAsHand ?
                  Window::Cursor::HAND :
                  Window::Cursor::POINTER);
return true;
</t>
<t tx="leo.20191228122648.37">void TextWindow::Paint() {
    if (!canvas) return;

    double width, height;
    window-&gt;GetContentSize(&amp;width, &amp;height);
    if(halfRows != (int)height / (LINE_HEIGHT/2))
        Resize();

    Camera camera = {};
    camera.width      = width;
    camera.height     = height;
    camera.pixelRatio = window-&gt;GetDevicePixelRatio();
    camera.gridFit    = (window-&gt;GetDevicePixelRatio() == 1);
    camera.LoadIdentity();
    camera.offset.x   = -camera.width  / 2.0;
    camera.offset.y   = -camera.height / 2.0;

    Lighting lighting = {};
    lighting.backgroundColor = RGBi(0, 0, 0);

    canvas-&gt;SetLighting(lighting);
    canvas-&gt;SetCamera(camera);
    canvas-&gt;StartFrame();

    UiCanvas uiCanvas = {};
    uiCanvas.canvas = canvas;
    uiCanvas.flip = true;

    int r, c, a;
    for(a = 0; a &lt; 2; a++) {
        for(r = 0; r &lt; rows; r++) {
            int ltop = top[r];
            if(ltop &lt; (scrollPos-1)) continue;
            if(ltop &gt; scrollPos+halfRows) break;

            for(c = 0; c &lt; min(((int)width/CHAR_WIDTH_)+1, (int) MAX_COLS); c++) {
                int x = LEFT_MARGIN + c*CHAR_WIDTH_;
                int y = (ltop-scrollPos)*(LINE_HEIGHT/2) + 4;

                int fg = meta[r][c].fg;
                int bg = meta[r][c].bg;

                // On the first pass, all the background quads; on the next
                // pass, all the foreground (i.e., font) quads.
                if(a == 0) {
                    RgbaColor bgRgb = meta[r][c].bgRgb;
                    int bh = LINE_HEIGHT, adj = 0;
                    if(bg == 'z') {
                        bh = CHAR_HEIGHT;
                        adj += 2;
                    } else {
                        bgRgb = RgbaColor::FromFloat(bgColorTable[bg*3+0],
                                                     bgColorTable[bg*3+1],
                                                     bgColorTable[bg*3+2]);
                    }

                    if(bg != 'd') {
                        // Move the quad down a bit, so that the descenders
                        // still have the correct background.
                        uiCanvas.DrawRect(x, x + CHAR_WIDTH_, y + adj, y + adj + bh,
                                          /*fillColor=*/bgRgb, /*outlineColor=*/{});
                    }
                } else if(a == 1) {
                    RgbaColor fgRgb = RgbaColor::FromFloat(fgColorTable[fg*3+0],
                                                           fgColorTable[fg*3+1],
                                                           fgColorTable[fg*3+2]);
                    if(text[r][c] != ' ') {
                        uiCanvas.DrawBitmapChar(text[r][c], x, y + CHAR_HEIGHT, fgRgb);
                    }

                    // If this is a link and it's hovered, then draw the
                    // underline
                    if(meta[r][c].link &amp;&amp; meta[r][c].link != 'n' &amp;&amp;
                        (r == hoveredRow &amp;&amp; c == hoveredCol))
                    {
                        int cs = c, cf = c;
                        while(cs &gt;= 0 &amp;&amp; meta[r][cs].link &amp;&amp;
                                         meta[r][cs].f    == meta[r][c].f &amp;&amp;
                                         meta[r][cs].data == meta[r][c].data)
                        {
                            cs--;
                        }
                        cs++;

                        while(          meta[r][cf].link &amp;&amp;
                                        meta[r][cf].f    == meta[r][c].f &amp;&amp;
                                        meta[r][cf].data == meta[r][c].data)
                        {
                            cf++;
                        }

                        // But don't underline checkboxes or radio buttons
                        while(((text[r][cs] &gt;= 0xe000 &amp;&amp; text[r][cs] &lt;= 0xefff) ||
                                text[r][cs] == ' ') &amp;&amp;
                              cs &lt; cf)
                        {
                            cs++;
                        }

                        // Always use the color of the rightmost character
                        // in the link, so that underline is consistent color
                        fg = meta[r][cf-1].fg;
                        fgRgb = RgbaColor::FromFloat(fgColorTable[fg*3+0],
                                                     fgColorTable[fg*3+1],
                                                     fgColorTable[fg*3+2]);
                        int yp = y + CHAR_HEIGHT;
                        uiCanvas.DrawLine(LEFT_MARGIN + cs*CHAR_WIDTH_, yp,
                                          LEFT_MARGIN + cf*CHAR_WIDTH_, yp,
                                          fgRgb);
                    }
                }
            }
        }
    }

    // The line to indicate the column of radio buttons that indicates the
    // active group.
    SS.GW.GroupSelection();
    auto const &amp;gs = SS.GW.gs;
    // Make sure this test agrees with test to determine which screen is drawn
    if(!SS.GW.pending.description &amp;&amp; gs.n == 0 &amp;&amp; gs.constraints == 0 &amp;&amp;
        shown.screen == Screen::LIST_OF_GROUPS)
    {
        int x = 29, y = 70 + LINE_HEIGHT;
        y -= scrollPos*(LINE_HEIGHT/2);

        RgbaColor color = RgbaColor::FromFloat(fgColorTable['t'*3+0],
                                               fgColorTable['t'*3+1],
                                               fgColorTable['t'*3+2]);
        uiCanvas.DrawLine(x, y, x, y+40, color);
    }

    // The header has some icons that are drawn separately from the text
    DrawOrHitTestIcons(&amp;uiCanvas, PAINT, 0, 0);

    // And we may show a color picker for certain editable fields
    DrawOrHitTestColorPicker(&amp;uiCanvas, PAINT, false, 0, 0);

    canvas-&gt;FlushFrame();
    canvas-&gt;FinishFrame();
    canvas-&gt;Clear();
}

</t>
<t tx="leo.20191228122648.38">void TextWindow::MouseEvent(bool leftClick, bool leftDown, double x, double y) {
    using Platform::Window;

    if(SS.TW.window-&gt;IsEditorVisible() || SS.GW.window-&gt;IsEditorVisible()) {
        if(DrawOrHitTestColorPicker(NULL, leftClick ? CLICK : HOVER, leftDown, x, y)) {
            return;
        }

        if(leftClick) {
            HideEditControl();
            SS.GW.window-&gt;HideEditor();
        } else {
            window-&gt;SetCursor(Window::Cursor::POINTER);
        }
        return;
    }

    DrawOrHitTestIcons(NULL, leftClick ? CLICK : HOVER, x, y);

    GraphicsWindow::Selection ps = SS.GW.hover;
    SS.GW.hover.Clear();

    int prevHoveredRow = hoveredRow,
        if(y &gt;= top[r]*hh &amp;&amp; y &lt;= (top[r]+2)*hh) {
            break;
        }
    }
    if(r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; rows &amp;&amp; c &lt; MAX_COLS) {
        window-&gt;SetCursor(Window::Cursor::POINTER);

        hoveredRow = r;
        hoveredCol = c;

        const auto &amp;item = meta[r][c];
        if(leftClick) {
            if(item.link &amp;&amp; item.f) {
                (item.f)(item.link, item.data);
                Show();
                SS.GW.Invalidate();
            }
        } else {
            if(item.link) {
                window-&gt;SetCursor(Window::Cursor::HAND);
                if(item.h) {
                    (item.h)(item.link, item.data);
                }
            } else {
                window-&gt;SetCursor(Window::Cursor::POINTER);
            }
        }
    }

    if((!ps.Equals(&amp;(SS.GW.hover))) ||
        prevHoveredRow != hoveredRow ||
        prevHoveredCol != hoveredCol)
    {
        SS.GW.Invalidate();
        window-&gt;Invalidate();
    }
}

</t>
<t tx="leo.20191228122648.39">void TextWindow::MouseLeave() {
    hoveredButton = NULL;
    hoveredRow = 0;
    hoveredCol = 0;
    window-&gt;Invalidate();
}

</t>
<t tx="leo.20191228122648.4">void TextWindow::ScreenStepDimSteps(int link, uint32_t v) {
    SS.TW.edit.meaning = Edit::STEP_DIM_STEPS;
    SS.TW.ShowEditControl(12, ssprintf("%d", SS.TW.stepDim.steps));
}
</t>
<t tx="leo.20191228122648.40">void TextWindow::ScrollbarEvent(double newPos) {
    if(window-&gt;IsEditorVisible()) {
        window-&gt;SetScrollbarPosition(scrollPos);
        return;
    }

    int bottom = top[rows-1] + 2;
    newPos = min((int)newPos, bottom - halfRows);
    newPos = max((int)newPos, 0);

    if(newPos != scrollPos) {
        scrollPos = (int)newPos;
        window-&gt;Invalidate();
    }
}

}
</t>
<t tx="leo.20191228122648.41">@path ./src/
//-----------------------------------------------------------------------------
// The toolbar that appears at the top left of the graphics window, where the
// user can select icons with the mouse, to perform operations equivalent to
// selecting a menu item or using a keyboard shortcut.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

struct ToolIcon {
    std::string name;
    Command     command;
    const char *tooltip;
    std::shared_ptr&lt;Pixmap&gt; pixmap;
};
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122648.42">static ToolIcon Toolbar[] = {
    { "line",            Command::LINE_SEGMENT,
      N_("Sketch line segment"),                              {} },
    { "rectangle",       Command::RECTANGLE,
      N_("Sketch rectangle"),                                 {} },
    { "circle",          Command::CIRCLE,
      N_("Sketch circle"),                                    {} },
    { "arc",             Command::ARC,
      N_("Sketch arc of a circle"),                           {} },
    { "text",            Command::TTF_TEXT,
      N_("Sketch curves from text in a TrueType font"),       {} },
    { "image",           Command::IMAGE,
      N_("Sketch image from a file"),                         {} },
    { "tangent-arc",     Command::TANGENT_ARC,
      N_("Create tangent arc at selected point"),             {} },
    { "bezier",          Command::CUBIC,
      N_("Sketch cubic Bezier spline"),                       {} },
    { "point",           Command::DATUM_POINT,
      N_("Sketch datum point"),                               {} },
    { "construction",    Command::CONSTRUCTION,
      N_("Toggle construction"),                              {} },
    { "trim",            Command::SPLIT_CURVES,
      N_("Split lines / curves where they intersect"),        {} },
    { "",                Command::NONE, "",                   {} },

    { "length",          Command::DISTANCE_DIA,
      N_("Constrain distance / diameter / length"),           {} },
    { "angle",           Command::ANGLE,
      N_("Constrain angle"),                                  {} },
    { "horiz",           Command::HORIZONTAL,
      N_("Constrain to be horizontal"),                       {} },
    { "vert",            Command::VERTICAL,
      N_("Constrain to be vertical"),                         {} },
    { "parallel",        Command::PARALLEL,
      N_("Constrain to be parallel or tangent"),              {} },
    { "perpendicular",   Command::PERPENDICULAR,
      N_("Constrain to be perpendicular"),                    {} },
    { "pointonx",        Command::ON_ENTITY,
      N_("Constrain point on line / curve / plane / point"),  {} },
    { "symmetric",       Command::SYMMETRIC,
      N_("Constrain symmetric"),                              {} },
    { "equal",           Command::EQUAL,
      N_("Constrain equal length / radius / angle"),          {} },
    { "same-orientation",Command::ORIENTED_SAME,
      N_("Constrain normals in same orientation"),            {} },
    { "other-supp",      Command::OTHER_ANGLE,
      N_("Other supplementary angle"),                        {} },
    { "ref",             Command::REFERENCE,
      N_("Toggle reference dimension"),                       {} },
    { "",                Command::NONE, "",                   {} },

    { "extrude",         Command::GROUP_EXTRUDE,
      N_("New group extruding active sketch"),                {} },
    { "lathe",           Command::GROUP_LATHE,
      N_("New group rotating active sketch"),                 {} },
    { "step-rotate",     Command::GROUP_ROT,
      N_("New group step and repeat rotating"),               {} },
    { "step-translate",  Command::GROUP_TRANS,
      N_("New group step and repeat translating"),            {} },
    { "sketch-in-plane", Command::GROUP_WRKPL,
      N_("New group in new workplane (thru given entities)"), {} },
    { "sketch-in-3d",    Command::GROUP_3D,
      N_("New group in 3d"),                                  {} },
    { "assemble",        Command::GROUP_LINK,
      N_("New group linking / assembling file"),              {} },
    { "",                Command::NONE, "",                   {} },

    { "in3d",            Command::NEAREST_ISO,
      N_("Nearest isometric view"),                           {} },
    { "ontoworkplane",   Command::ONTO_WORKPLANE,
      N_("Align view to active workplane"),                   {} },
};

</t>
<t tx="leo.20191228122648.43">void GraphicsWindow::ToolbarDraw(UiCanvas *canvas) {
    ToolbarDrawOrHitTest(0, 0, canvas, NULL, NULL, NULL);
}

</t>
<t tx="leo.20191228122648.44">bool GraphicsWindow::ToolbarMouseMoved(int x, int y) {
    double width, height;
    window-&gt;GetContentSize(&amp;width, &amp;height);

    x += ((int)width/2);
    y += ((int)height/2);

    Command hitCommand;
    int hitX, hitY;
    bool withinToolbar = ToolbarDrawOrHitTest(x, y, NULL, &amp;hitCommand, &amp;hitX, &amp;hitY);

    if(hitCommand != toolbarHovered) {
        toolbarHovered = hitCommand;
        Invalidate();
    }

    if(toolbarHovered != Command::NONE) {
        std::string tooltip;
        for(ToolIcon &amp;icon : Toolbar) {
            if(toolbarHovered == icon.command) {
                tooltip = Translate(icon.tooltip);
            }
        }

        Platform::KeyboardEvent accel = SS.GW.AcceleratorForCommand(toolbarHovered);
        std::string accelDesc = Platform::AcceleratorDescription(accel);
        if(!accelDesc.empty()) {
            tooltip += ssprintf(" (%s)", accelDesc.c_str());
        }

        window-&gt;SetTooltip(tooltip, hitX, hitY, 32, 32);
    } else {
        window-&gt;SetTooltip("", 0, 0, 0, 0);
    }

    return withinToolbar;
}

</t>
<t tx="leo.20191228122648.45">bool GraphicsWindow::ToolbarMouseDown(int x, int y) {
    double width, height;
    window-&gt;GetContentSize(&amp;width, &amp;height);

    x += ((int)width/2);
    y += ((int)height/2);

    Command hitCommand;
    bool withinToolbar = ToolbarDrawOrHitTest(x, y, NULL, &amp;hitCommand, NULL, NULL);
    if(hitCommand != Command::NONE) {
        SS.GW.ActivateCommand(hitCommand);
    }
    return withinToolbar;
}

</t>
<t tx="leo.20191228122648.46">bool GraphicsWindow::ToolbarDrawOrHitTest(int mx, int my, UiCanvas *canvas,
                                          Command *hitCommand, int *hitX, int *hitY)
{
    double width, height;
    window-&gt;GetContentSize(&amp;width, &amp;height);

    int x = 17, y = (int)(height - 52);

    // When changing these values, also change the asReference drawing code in drawentity.cpp.
    int fudge = 8;
    int h = 34*16 + 3*16 + fudge;
    int aleft = 0, aright = 66, atop = y+16+fudge/2, abot = y+16-h;

    @others
}
</t>
<t tx="leo.20191228122648.47">bool withinToolbar =
    (mx &gt;= aleft &amp;&amp; mx &lt;= aright &amp;&amp; my &lt;= atop &amp;&amp; my &gt;= abot);

// Initialize/clear hitCommand.
if(hitCommand) *hitCommand = Command::NONE;

if(!canvas &amp;&amp; !withinToolbar) {
    // This gets called every MouseMove event, so return quickly.
    return false;
}

if(canvas) {
    canvas-&gt;DrawRect(aleft, aright, atop, abot,
                    /*fillColor=*/{ 30, 30, 30, 255 },
                    /*outlineColor=*/{});
}

bool leftpos = true;
for(ToolIcon &amp;icon : Toolbar) {
    if(icon.name.empty()) { // spacer
        if(!leftpos) {
            leftpos = true;
            y -= 32;
            x -= 32;
        }
        y -= 16;

        if(canvas) {
            // Draw a separator bar in a slightly different color.
            int divw = 30, divh = 2;
            canvas-&gt;DrawRect(x+16+divw, x+16-divw, y+24+divh, y+24-divh,
                             /*fillColor=*/{ 45, 45, 45, 255 },
                             /*outlineColor=*/{});
        }

        continue;
    }

    if(icon.pixmap == nullptr) {
        icon.pixmap = LoadPng("icons/graphics-window/" + icon.name + ".png");
    }

    if(canvas) {
        canvas-&gt;DrawPixmap(icon.pixmap,
                           x - (int)icon.pixmap-&gt;width  / 2,
                           y - (int)icon.pixmap-&gt;height / 2);

        if(toolbarHovered == icon.command ||
           (pending.operation == Pending::COMMAND &amp;&amp;
            pending.command == icon.command)) {
            // Highlight the hovered or pending item.
            const int boxhw = 15;
            canvas-&gt;DrawRect(x+boxhw, x-boxhw, y+boxhw, y-boxhw,
                             /*fillColor=*/{ 255, 255, 0, 75 },
                             /*outlineColor=*/{});
        }
    } else {
        const int boxhw = 16;
        if(mx &lt; (x+boxhw) &amp;&amp; mx &gt; (x - boxhw) &amp;&amp;
           my &lt; (y+boxhw) &amp;&amp; my &gt; (y - boxhw))
        {
            if(hitCommand) *hitCommand = icon.command;
            if(hitX) *hitX = x - boxhw;
            if(hitY) *hitY = (int)height - (y + boxhw);
        }
    }

    if(leftpos) {
        x += 32;
        leftpos = false;
    } else {
        x -= 32;
        y -= 32;
        leftpos = true;
    }
}

return withinToolbar;
</t>
<t tx="leo.20191228122648.48">@path ./src/
//-----------------------------------------------------------------------------
// Routines to read a TrueType font as vector outlines, and generate them
// as entities, since they're always representable as either lines or
// quadratic Bezier curves.
//
// Copyright 2016 whitequark, Peter Barfuss.
//-----------------------------------------------------------------------------
#include &lt;ft2build.h&gt;
#include FT_FREETYPE_H
#include FT_OUTLINE_H
#include FT_ADVANCES_H

/* Yecch. Irritatingly, you need to do this nonsense to get the error string table,
   since nobody thought to put this exact function into FreeType itsself. */
#undef __FTERRORS_H__
#define FT_ERRORDEF(e, v, s) { (e), (s) },
#define FT_ERROR_START_LIST
#define FT_ERROR_END_LIST { 0, NULL }

struct ft_error {
    int err;
    const char *str;
};

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122648.49">static const struct ft_error ft_errors[] = {
#include FT_ERRORS_H
};

</t>
<t tx="leo.20191228122648.5">void TextWindow::ScreenStepDimGo(int link, uint32_t v) {
    hConstraint hc = SS.TW.shown.constraint;
    Constraint *c = SK.constraint.FindByIdNoOops(hc);
    if(c) {
        SS.UndoRemember();

        double start = c-&gt;valA, finish = SS.TW.stepDim.finish;
        SS.TW.stepDim.time = GetMilliseconds();
        SS.TW.stepDim.step = 1;

        if(!SS.TW.stepDim.timer) {
            SS.TW.stepDim.timer = Platform::CreateTimer();
        }
        SS.TW.stepDim.timer-&gt;onTimeout = [=] {
            if(SS.TW.stepDim.step &lt;= SS.TW.stepDim.steps) {
                c-&gt;valA = start + ((finish - start)*SS.TW.stepDim.step)/SS.TW.stepDim.steps;
                SS.MarkGroupDirty(c-&gt;group);
                SS.GenerateAll();
                if(!SS.ActiveGroupsOkay()) {
                    // Failed to solve, so quit
                    return;
                }
                SS.TW.stepDim.step++;

                const int64_t STEP_MILLIS = 50;
                int64_t time = GetMilliseconds();
                if(time - SS.TW.stepDim.time &lt; STEP_MILLIS) {
                    SS.TW.stepDim.timer-&gt;RunAfterNextFrame();
                } else {
                    SS.TW.stepDim.timer-&gt;RunAfter(time - SS.TW.stepDim.time - STEP_MILLIS);
                }
                SS.TW.stepDim.time = time;
            } else {
                SS.TW.GoToScreen(Screen::LIST_OF_GROUPS);
                SS.ScheduleShowTW();
            }
            SS.GW.Invalidate();
        };
        SS.TW.stepDim.timer-&gt;RunAfterNextFrame();
    }
}
</t>
<t tx="leo.20191228122648.50">extern "C" const char *ft_error_string(int err) {
    const struct ft_error *e;
    for(e = ft_errors; e-&gt;str; e++)
        if(e-&gt;err == err)
            return e-&gt;str;
    return "Unknown error";
}

/* Okay, we're done with that. */
#undef FT_ERRORDEF
#undef FT_ERROR_START_LIST
#undef FT_ERROR_END_LIST

#include "solvespace.h"

//-----------------------------------------------------------------------------
// Get the list of available font filenames, and load the name for each of
// them. Only that, though, not the glyphs too.
//-----------------------------------------------------------------------------
TtfFontList::TtfFontList() {
    FT_Init_FreeType(&amp;fontLibrary);
}

TtfFontList::~TtfFontList() {
    FT_Done_FreeType(fontLibrary);
}

</t>
<t tx="leo.20191228122648.51">void TtfFontList::LoadAll() {
    if(loaded) return;

    for(const Platform::Path &amp;font : Platform::GetFontFiles()) {
        TtfFont tf = {};
        tf.fontFile = font;
        if(tf.LoadFromFile(fontLibrary))
            l.Add(&amp;tf);
    }

    // Add builtin font to end of font list so it is displayed first in the UI
    {
        TtfFont tf = {};
        tf.SetResourceID("fonts/BitstreamVeraSans-Roman-builtin.ttf");
        if(tf.LoadFromResource(fontLibrary))
            l.Add(&amp;tf);
    }

    // Sort fonts according to their actual name, not filename.
    std::sort(l.begin(), l.end(),
        [](const TtfFont &amp;a, const TtfFont &amp;b) { return a.name &lt; b.name; });

    // Filter out fonts with the same family and style name. This is not
    // strictly necessarily the exact same font, but it will almost always be.
    TtfFont *it = std::unique(l.begin(), l.end(),
                              [](const TtfFont &amp;a, const TtfFont &amp;b) { return a.name == b.name; });
    l.RemoveLast(&amp;l[l.n] - it);

    //! @todo identify fonts by their name and not filename, which may change
    //! between OSes.

    loaded = true;
}

TtfFont *TtfFontList::LoadFont(const std::string &amp;font)
{
    LoadAll();

    TtfFont *tf = std::find_if(l.begin(), l.end(),
        [&amp;font](const TtfFont &amp;tf) { return tf.FontFileBaseName() == font; });

    if(tf != l.end()) {
        if(tf-&gt;fontFace == NULL) {
            if(tf-&gt;IsResource())
                tf-&gt;LoadFromResource(fontLibrary, /*keepOpen=*/true);
            else
                tf-&gt;LoadFromFile(fontLibrary, /*keepOpen=*/true);
        }
        return tf;
    } else {
        return NULL;
    }
}

</t>
<t tx="leo.20191228122648.52">void TtfFontList::PlotString(const std::string &amp;font, const std::string &amp;str,
                             SBezierList *sbl, Vector origin, Vector u, Vector v)
{
    TtfFont *tf = LoadFont(font);
    if(!str.empty() &amp;&amp; tf != NULL) {
        tf-&gt;PlotString(str, sbl, origin, u, v);
    } else {
        // No text or no font; so draw a big X for an error marker.
        SBezier sb;
        sb = SBezier::From(origin, origin.Plus(u).Plus(v));
        sbl-&gt;l.Add(&amp;sb);
        sb = SBezier::From(origin.Plus(v), origin.Plus(u));
        sbl-&gt;l.Add(&amp;sb);
    }
}

double TtfFontList::AspectRatio(const std::string &amp;font, const std::string &amp;str)
{
    TtfFont *tf = LoadFont(font);
    if(tf != NULL) {
        return tf-&gt;AspectRatio(str);
    }

    return 0.0;
}

//-----------------------------------------------------------------------------
// Return the basename of our font filename; that's how the requests and
// entities that reference us will store it.
//-----------------------------------------------------------------------------
std::string TtfFont::FontFileBaseName() const {
    return fontFile.FileName();
}

//-----------------------------------------------------------------------------
// Convenience method to set fontFile for resource-loaded fonts as res://&lt;path&gt;
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122648.53">void TtfFont::SetResourceID(const std::string &amp;resource) {
    fontFile = { "res://" + resource };
}

</t>
<t tx="leo.20191228122648.54">bool TtfFont::IsResource() const {
    return fontFile.raw.compare(0, 6, "res://") == 0;
}

//-----------------------------------------------------------------------------
// Load a TrueType font into memory.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122648.55">bool TtfFont::LoadFromFile(FT_Library fontLibrary, bool keepOpen) {
    ssassert(!IsResource(), "Cannot load a font provided by a resource as a file.");

    FT_Open_Args args = {};
    args.flags    = FT_OPEN_PATHNAME;
    args.pathname = &amp;fontFile.raw[0]; // FT_String is char* for historical reasons

    // We don't use OpenFile() here to let freetype do its own memory management.
    // This is OK because on Linux/OS X we just delegate to fopen and on Windows
    // we only look into C:\Windows\Fonts, which has a known short path.
    if(int fterr = FT_Open_Face(fontLibrary, &amp;args, 0, &amp;fontFace)) {
        dbp("freetype: loading font from file '%s' failed: %s",
            fontFile.raw.c_str(), ft_error_string(fterr));
        return false;
    }

    return ExtractTTFData(keepOpen);
}

//-----------------------------------------------------------------------------
// Load a TrueType from resource in memory. Implemented to load bundled fonts
// through theresource system.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122648.56">bool TtfFont::LoadFromResource(FT_Library fontLibrary, bool keepOpen) {
    ssassert(IsResource(), "Font to be loaded as resource is not provided by a resource "
             "or does not have the 'res://' prefix.");

    size_t _size;
    // substr to cut off 'res://' (length: 6)
    @others
}

//-----------------------------------------------------------------------------
// Extract font information. We care about the font name and unit size.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122648.57">const void *_buffer = Platform::LoadResource(fontFile.raw.substr(6, fontFile.raw.size()),
                                             &amp;_size);

FT_Long size = static_cast&lt;FT_Long&gt;(_size);
const FT_Byte *buffer = reinterpret_cast&lt;const FT_Byte*&gt;(_buffer);

if(int fterr = FT_New_Memory_Face(fontLibrary, buffer, size, 0, &amp;fontFace)) {
        dbp("freetype: loading font '%s' from memory failed: %s",
            fontFile.raw.c_str(), ft_error_string(fterr));
        return false;
}

return ExtractTTFData(keepOpen);
</t>
<t tx="leo.20191228122648.58">bool TtfFont::ExtractTTFData(bool keepOpen) {
    if(int fterr = FT_Select_Charmap(fontFace, FT_ENCODING_UNICODE)) {
        dbp("freetype: loading unicode CMap for file '%s' failed: %s",
            fontFile.raw.c_str(), ft_error_string(fterr));
        FT_Done_Face(fontFace);
        fontFace = NULL;
        return false;
    }

    name = std::string(fontFace-&gt;family_name) +
           " (" + std::string(fontFace-&gt;style_name) + ")";

    // We always ask Freetype to give us a unit size character.
    // It uses fixed point; put the unit size somewhere in the middle of the dynamic
    // range of its 26.6 fixed point type, and adjust the factors so that the unit
    // matches cap height.
    FT_Size_RequestRec sizeRequest;
    sizeRequest.type           = FT_SIZE_REQUEST_TYPE_REAL_DIM;
    sizeRequest.width          = 1 &lt;&lt; 16;
    sizeRequest.height         = 1 &lt;&lt; 16;
    sizeRequest.horiResolution = 128;
    sizeRequest.vertResolution = 128;
    if(int fterr = FT_Request_Size(fontFace, &amp;sizeRequest)) {
        dbp("freetype: size request for file '%s' failed: %s",
            fontFile.raw.c_str(), ft_error_string(fterr));
        FT_Done_Face(fontFace);
        fontFace = NULL;
        return false;
    }

    char chr = 'A';
    uint32_t gid = FT_Get_Char_Index(fontFace, 'A');
    if (gid == 0) {
        dbp("freetype: CID-to-GID mapping for CID 0x%04x in file '%s' failed: %s; "
            "using CID as GID",
            chr, fontFile.raw.c_str(), ft_error_string(gid));
        dbp("Assuming cap height is the same as requested height (this is likely wrong).");
        capHeight = (double)sizeRequest.height;
    }

    if(gid) {
        if(int fterr = FT_Load_Glyph(fontFace, gid, FT_LOAD_NO_BITMAP | FT_LOAD_NO_HINTING)) {
            dbp("freetype: cannot load glyph for GID 0x%04x in file '%s': %s",
                gid, fontFile.raw.c_str(), ft_error_string(fterr));
            FT_Done_Face(fontFace);
            fontFace = NULL;
            return false;
        }

        FT_BBox bbox;
        FT_Outline_Get_CBox(&amp;fontFace-&gt;glyph-&gt;outline, &amp;bbox);
        capHeight = (double)bbox.yMax;
    }

    // If we just wanted to get the font's name and figure out if it's actually usable, close
    // it now. If we don't do this, and there are a lot of fonts, we can bump into the file
    // descriptor limit (especially on Windows), breaking all file operations.
    if(!keepOpen) {
        FT_Done_Face(fontFace);
        fontFace = NULL;
        return true;
    }

    return true;
}

</t>
<t tx="leo.20191228122648.59">typedef struct OutlineData {
    Vector       origin, u, v; // input parameters
    SBezierList *beziers;      // output bezier list
    float        factor;       // ratio between freetype and solvespace coordinates
    FT_Pos       bx;           // x offset of the current glyph
    FT_Pos       px, py;       // current point
} OutlineData;

</t>
<t tx="leo.20191228122648.6">void TextWindow::ShowStepDimension() {
    Constraint *c = SK.constraint.FindByIdNoOops(shown.constraint);
    if(!c) {
        shown.screen = Screen::LIST_OF_GROUPS;
        Show();
        return;
    }

    Printf(true, "%FtSTEP DIMENSION%E %s", c-&gt;DescriptionString().c_str());

    if(stepDim.isDistance) {
        Printf(true,  "%Ba   %Ftstart%E    %s", SS.MmToString(c-&gt;valA).c_str());
        Printf(false, "%Bd   %Ftfinish%E   %s %Fl%Ll%f[change]%E",
            SS.MmToString(stepDim.finish).c_str(), &amp;ScreenStepDimFinish);
    } else {
        Printf(true,  "%Ba   %Ftstart%E    %@", c-&gt;valA);
        Printf(false, "%Bd   %Ftfinish%E   %@ %Fl%Ll%f[change]%E",
            stepDim.finish, &amp;ScreenStepDimFinish);
    }
    Printf(false, "%Ba   %Ftsteps%E    %d %Fl%Ll%f%D[change]%E",
        stepDim.steps, &amp;ScreenStepDimSteps);

    Printf(true, " %Fl%Ll%fstep dimension now%E", &amp;ScreenStepDimGo);

    Printf(true, "(or %Fl%Ll%fcancel operation%E)", &amp;ScreenHome);
}

//-----------------------------------------------------------------------------
// When we're creating tangent arcs (as requests, not as some parametric
// thing). User gets to specify the radius, and whether the old untrimmed
// curves are kept or deleted.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122648.60">static Vector Transform(OutlineData *data, FT_Pos x, FT_Pos y) {
    Vector r = data-&gt;origin;
    r = r.Plus(data-&gt;u.ScaledBy((float)(data-&gt;bx + x) * data-&gt;factor));
    r = r.Plus(data-&gt;v.ScaledBy((float)y * data-&gt;factor));
    return r;
}

</t>
<t tx="leo.20191228122648.61">static int MoveTo(const FT_Vector *p, void *cc)
{
    OutlineData *data = (OutlineData *) cc;
    data-&gt;px = p-&gt;x;
    data-&gt;py = p-&gt;y;
    return 0;
}

</t>
<t tx="leo.20191228122648.62">static int LineTo(const FT_Vector *p, void *cc)
{
    OutlineData *data = (OutlineData *) cc;
    SBezier sb = SBezier::From(
        Transform(data, data-&gt;px, data-&gt;py),
        Transform(data, p-&gt;x,     p-&gt;y));
    data-&gt;beziers-&gt;l.Add(&amp;sb);
    data-&gt;px = p-&gt;x;
    data-&gt;py = p-&gt;y;
    return 0;
}

</t>
<t tx="leo.20191228122648.63">static int ConicTo(const FT_Vector *c, const FT_Vector *p, void *cc)
{
    OutlineData *data = (OutlineData *) cc;
    SBezier sb = SBezier::From(
        Transform(data, data-&gt;px, data-&gt;py),
        Transform(data, c-&gt;x,     c-&gt;y),
        Transform(data, p-&gt;x,     p-&gt;y));
    data-&gt;beziers-&gt;l.Add(&amp;sb);
    data-&gt;px = p-&gt;x;
    data-&gt;py = p-&gt;y;
    return 0;
}

</t>
<t tx="leo.20191228122648.64">static int CubicTo(const FT_Vector *c1, const FT_Vector *c2, const FT_Vector *p, void *cc)
{
    OutlineData *data = (OutlineData *) cc;
    SBezier sb = SBezier::From(
        Transform(data, data-&gt;px, data-&gt;py),
        Transform(data, c1-&gt;x,    c1-&gt;y),
        Transform(data, c2-&gt;x,    c2-&gt;y),
        Transform(data, p-&gt;x,     p-&gt;y));
    data-&gt;beziers-&gt;l.Add(&amp;sb);
    data-&gt;px = p-&gt;x;
    data-&gt;py = p-&gt;y;
    return 0;
}

</t>
<t tx="leo.20191228122648.65">void TtfFont::PlotString(const std::string &amp;str,
                         SBezierList *sbl, Vector origin, Vector u, Vector v)
{
    ssassert(fontFace != NULL, "Expected font face to be loaded");

    FT_Outline_Funcs outlineFuncs;
    outlineFuncs.move_to  = MoveTo;
    outlineFuncs.line_to  = LineTo;
    outlineFuncs.conic_to = ConicTo;
    outlineFuncs.cubic_to = CubicTo;
    outlineFuncs.shift    = 0;
    outlineFuncs.delta    = 0;

    FT_Pos dx = 0;
    for(char32_t cid : ReadUTF8(str)) {
        uint32_t gid = FT_Get_Char_Index(fontFace, cid);
        if (gid == 0) {
            dbp("freetype: CID-to-GID mapping for CID 0x%04x in file '%s' failed: %s; "
                "using CID as GID",
                cid, fontFile.raw.c_str(), ft_error_string(gid));
            gid = cid;
        }

        /*
         * Stupid hacks:
         *  - if we want fake-bold, use FT_Outline_Embolden(). This actually looks
         *    quite good.
         *  - if we want fake-italic, apply a shear transform [1 s s 1 0 0] here using
         *    FT_Set_Transform. This looks decent at small font sizes and bad at larger
         *    ones, antialiasing mitigates this considerably though.
         */
        if(int fterr = FT_Load_Glyph(fontFace, gid, FT_LOAD_NO_BITMAP | FT_LOAD_NO_HINTING)) {
            dbp("freetype: cannot load glyph for GID 0x%04x in file '%s': %s",
                gid, fontFile.raw.c_str(), ft_error_string(fterr));
            return;
        }

        /* A point that has x = xMin should be plotted at (dx0 + lsb); fix up
         * our x-position so that the curve-generating code will put stuff
         * at the right place.
         *
         * There's no point in getting the glyph BBox here - not only can it be
         * needlessly slow sometimes, but because we're about to render a single glyph,
         * what we want actually *is* the CBox.
         *
         * This is notwithstanding that this makes extremely little sense, this
         * looks like a workaround for either mishandling the start glyph on a line,
         * or as a really hacky pseudo-track-kerning (in which case it works better than
         * one would expect! especially since most fonts don't set track kerning).
         */
        FT_BBox cbox;
        FT_Outline_Get_CBox(&amp;fontFace-&gt;glyph-&gt;outline, &amp;cbox);
        FT_Pos bx = dx - cbox.xMin;
        // Yes, this is what FreeType calls left-side bearing.
        // Then interchangeably uses that with "left-side bearing". Sigh.
        bx += fontFace-&gt;glyph-&gt;metrics.horiBearingX;

        OutlineData data = {};
        data.origin  = origin;
        data.u       = u;
        data.v       = v;
        data.beziers = sbl;
        data.factor  = (float)(1.0 / capHeight);
        data.bx      = bx;
        if(int fterr = FT_Outline_Decompose(&amp;fontFace-&gt;glyph-&gt;outline, &amp;outlineFuncs, &amp;data)) {
            dbp("freetype: bezier decomposition failed for GID 0x%4x in file '%s': %s",
                gid, fontFile.raw.c_str(), ft_error_string(fterr));
        }

        // And we're done, so advance our position by the requested advance
        // width, plus the user-requested extra advance.
        dx += fontFace-&gt;glyph-&gt;advance.x;
    }
}

double TtfFont::AspectRatio(const std::string &amp;str) {
    ssassert(fontFace != NULL, "Expected font face to be loaded");

    // We always request a unit size character, so the aspect ratio is the same as advance length.
    double dx = 0;
    for(char32_t chr : ReadUTF8(str)) {
        uint32_t gid = FT_Get_Char_Index(fontFace, chr);
        if (gid == 0) {
            dbp("freetype: CID-to-GID mapping for CID 0x%04x in file '%s' failed: %s; "
                "using CID as GID",
                chr, fontFile.raw.c_str(), ft_error_string(gid));
        }

        if(int fterr = FT_Load_Glyph(fontFace, gid, FT_LOAD_NO_BITMAP | FT_LOAD_NO_HINTING)) {
            dbp("freetype: cannot load glyph for GID 0x%04x in file '%s': %s",
                gid, fontFile.raw.c_str(), ft_error_string(fterr));
            break;
        }

        dx += (double)fontFace-&gt;glyph-&gt;advance.x / capHeight;
    }

    return dx;
}
</t>
<t tx="leo.20191228122648.66">@path ./src/
//-----------------------------------------------------------------------------
// Routines to read a TrueType font as vector outlines, and generate them
// as entities, since they're always representable as either lines or
// quadratic Bezier curves.
//
// Copyright 2016 whitequark, Peter Barfuss.
//-----------------------------------------------------------------------------

#ifndef SOLVESPACE_TTF_H
#define SOLVESPACE_TTF_H

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122648.67">class TtfFont {
public:
    Platform::Path  fontFile; // or resource path/name as res://&lt;path&gt;
    std::string     name;
    FT_FaceRec_    *fontFace;
    double          capHeight;

    void SetResourceID(const std::string &amp;resource);
    bool IsResource() const;

    std::string FontFileBaseName() const;
    bool LoadFromFile(FT_LibraryRec_ *fontLibrary, bool keepOpen = false);
    bool LoadFromResource(FT_LibraryRec_ *fontLibrary, bool keepOpen = false);

    @others
</t>
<t tx="leo.20191228122648.68">    void PlotString(const std::string &amp;str,
                    SBezierList *sbl, Vector origin, Vector u, Vector v);
    double AspectRatio(const std::string &amp;str);

    bool ExtractTTFData(bool keepOpen);
};

class TtfFontList {
public:
    FT_LibraryRec_ *fontLibrary;
    bool            loaded;
    List&lt;TtfFont&gt;   l;

    TtfFontList();
    ~TtfFontList();

    void LoadAll();
    TtfFont *LoadFont(const std::string &amp;font);

    void PlotString(const std::string &amp;font, const std::string &amp;str,
</t>
<t tx="leo.20191228122648.69">@path ./src/
//-----------------------------------------------------------------------------
// Declarations relating to our user interface, in both the graphics and
// text browser window.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------

#ifndef SOLVESPACE_UI_H
#define SOLVESPACE_UI_H

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122648.7">void TextWindow::ScreenChangeTangentArc(int link, uint32_t v) {
    switch(link) {
        case 'r': {
            SS.TW.edit.meaning = Edit::TANGENT_ARC_RADIUS;
            SS.TW.ShowEditControl(3, SS.MmToString(SS.tangentArcRadius));
            break;
        }

        case 'a': SS.tangentArcManual = !SS.tangentArcManual; break;
        case 'm': SS.tangentArcModify = !SS.tangentArcModify; break;
    }
}
</t>
<t tx="leo.20191228122648.70">class Locale {
public:
    std::string language;
    std::string region;
    uint16_t    lcid;
    std::string displayName;

    std::string Culture() const {
        return language + "-" + region;
    }
};

struct LocaleLess {
</t>
<t tx="leo.20191228122648.71">    bool operator()(const Locale &amp;a, const Locale &amp;b) const {
        return a.language &lt; b.language ||
            (a.language == b.language &amp;&amp; a.region &lt; b.region);
    }
};

const std::set&lt;Locale, LocaleLess&gt; &amp;Locales();
bool SetLocale(const std::string &amp;name);
bool SetLocale(uint16_t lcid);

const std::string &amp;Translate(const char *msgid);
const std::string &amp;Translate(const char *msgctxt, const char *msgid);
const std::string &amp;TranslatePlural(const char *msgid, unsigned n);
const std::string &amp;TranslatePlural(const char *msgctxt, const char *msgid, unsigned n);

inline const char *N_(const char *msgid) {
    return msgid;
}
inline const char *CN_(const char *msgctxt, const char *msgid) {
    return msgid;
}
#if defined(LIBRARY)
inline const char *_(const char *msgid) {
    return msgid;
}
inline const char *C_(const char *msgctxt, const char *msgid) {
    return msgid;
}
#else
inline const char *_(const char *msgid) {
    return Translate(msgid).c_str();
}
inline const char *C_(const char *msgctxt, const char *msgid) {
    return Translate(msgctxt, msgid).c_str();
}
#endif

// This table describes the top-level menus in the graphics window.
enum class Command : uint32_t {
    NONE = 0,
    // File
    NEW = 100,
    OPEN,
    OPEN_RECENT,
    SAVE,
    SAVE_AS,
    EXPORT_IMAGE,
    EXPORT_MESH,
    EXPORT_SURFACES,
    EXPORT_VIEW,
    EXPORT_SECTION,
    EXPORT_WIREFRAME,
    IMPORT,
    EXIT,
    // View
    ZOOM_IN,
    ZOOM_OUT,
    ZOOM_TO_FIT,
    SHOW_GRID,
    PERSPECTIVE_PROJ,
    ONTO_WORKPLANE,
    NEAREST_ORTHO,
    NEAREST_ISO,
    CENTER_VIEW,
    SHOW_TOOLBAR,
    SHOW_TEXT_WND,
    UNITS_INCHES,
    UNITS_MM,
    UNITS_METERS,
    FULL_SCREEN,
    // Edit
    UNDO,
    REDO,
    CUT,
    COPY,
    PASTE,
    PASTE_TRANSFORM,
    DELETE,
    SELECT_CHAIN,
    SELECT_ALL,
    SNAP_TO_GRID,
    ROTATE_90,
    UNSELECT_ALL,
    REGEN_ALL,
    // Request
    SEL_WORKPLANE,
    FREE_IN_3D,
    DATUM_POINT,
    WORKPLANE,
    LINE_SEGMENT,
    CONSTR_SEGMENT,
    CIRCLE,
    ARC,
    RECTANGLE,
    CUBIC,
    TTF_TEXT,
    IMAGE,
    SPLIT_CURVES,
    TANGENT_ARC,
    CONSTRUCTION,
    // Group
    GROUP_3D,
    GROUP_WRKPL,
    GROUP_EXTRUDE,
    GROUP_HELIX,
    GROUP_LATHE,
    GROUP_REVOLVE,
    GROUP_ROT,
    GROUP_TRANS,
    GROUP_LINK,
    GROUP_RECENT,
    // Constrain
    DISTANCE_DIA,
    REF_DISTANCE,
    ANGLE,
    REF_ANGLE,
    OTHER_ANGLE,
    REFERENCE,
    EQUAL,
    RATIO,
    DIFFERENCE,
    ON_ENTITY,
    SYMMETRIC,
    AT_MIDPOINT,
    HORIZONTAL,
    VERTICAL,
    PARALLEL,
    PERPENDICULAR,
    ORIENTED_SAME,
    WHERE_DRAGGED,
    COMMENT,
    // Analyze
    VOLUME,
    AREA,
    PERIMETER,
    INTERFERENCE,
    NAKED_EDGES,
    SHOW_DOF,
    CENTER_OF_MASS,
    TRACE_PT,
    STOP_TRACING,
    STEP_DIM,
    // Help
    LOCALE,
    WEBSITE,
    ABOUT,
};

class Button;

</t>
<t tx="leo.20191228122648.72">class TextWindow {
public:
    enum {
        MAX_COLS = 100,
        MIN_COLS = 45,
        MAX_ROWS = 2000
    };

    @others
};

</t>
<t tx="leo.20191228122648.73">    typedef struct {
        char      c;
        RgbaColor color;
    } Color;
    static const Color fgColors[];
    static const Color bgColors[];

    float bgColorTable[256*3];
    float fgColorTable[256*3];

    enum {
        CHAR_WIDTH_    = 9,
        CHAR_HEIGHT    = 16,
        LINE_HEIGHT    = 20,
        LEFT_MARGIN    = 6,
    };

#define CHECK_FALSE "\xEE\x80\x80" // U+E000
#define CHECK_TRUE  "\xEE\x80\x81"
#define RADIO_FALSE "\xEE\x80\x82"
#define RADIO_TRUE  "\xEE\x80\x83"

    int scrollPos;      // The scrollbar position, in half-row units
    int halfRows;       // The height of our window, in half-row units

    uint32_t text[MAX_ROWS][MAX_COLS];
    typedef void LinkFunction(int link, uint32_t v);
    enum { NOT_A_LINK = 0 };
    struct {
        char            fg;
        char            bg;
        RgbaColor       bgRgb;
        int             link;
        uint32_t        data;
        LinkFunction   *f;
        LinkFunction   *h;
    }       meta[MAX_ROWS][MAX_COLS];
    int hoveredRow, hoveredCol;

    int top[MAX_ROWS]; // in half-line units, or -1 for unused
    int rows;

    Platform::WindowRef window;
    std::shared_ptr&lt;ViewportCanvas&gt; canvas;

    void Draw(Canvas *canvas);

    void Paint();
    void MouseEvent(bool isClick, bool leftDown, double x, double y);
    void MouseLeave();
    void ScrollbarEvent(double newPos);

    enum DrawOrHitHow : uint32_t {
        PAINT = 0,
        HOVER = 1,
        CLICK = 2
    };
    void DrawOrHitTestIcons(UiCanvas *canvas, DrawOrHitHow how,
    void Init();
    void MakeColorTable(const Color *in, float *out);
    void Printf(bool half, const char *fmt, ...);
    void ClearScreen();

    void Show();
    void Resize();

    // State for the screen that we are showing in the text window.
    enum class Screen : uint32_t {
        LIST_OF_GROUPS      = 0,
        GROUP_INFO          = 1,
        GROUP_SOLVE_INFO    = 2,
        CONFIGURATION       = 3,
        STEP_DIMENSION      = 4,
        LIST_OF_STYLES      = 5,
        STYLE_INFO          = 6,
        PASTE_TRANSFORMED   = 7,
        EDIT_VIEW           = 8,
        TANGENT_ARC         = 9
    };
</t>
<t tx="leo.20191228122648.74">typedef struct {
    Screen  screen;

    hGroup      group;
    hStyle      style;

    hConstraint constraint;

    struct {
        int         times;
        Vector      trans;
        double      theta;
        Vector      origin;
        double      scale;
    }           paste;
} ShownState;
ShownState shown;

enum class Edit : uint32_t {
    NOTHING               = 0,
    // For multiple groups
    TIMES_REPEATED        = 1,
    GROUP_NAME            = 2,
    GROUP_SCALE           = 3,
    GROUP_COLOR           = 4,
    GROUP_OPACITY         = 5,
    // For the configuration screen
    LIGHT_DIRECTION       = 100,
    LIGHT_INTENSITY       = 101,
    COLOR                 = 102,
    CHORD_TOLERANCE       = 103,
    MAX_SEGMENTS          = 104,
    CAMERA_TANGENT        = 105,
    GRID_SPACING          = 106,
    DIGITS_AFTER_DECIMAL  = 107,
    DIGITS_AFTER_DECIMAL_DEGREE = 108,
    EXPORT_SCALE          = 109,
    EXPORT_OFFSET         = 110,
    CANVAS_SIZE           = 111,
    G_CODE_DEPTH          = 112,
    G_CODE_PASSES         = 113,
    G_CODE_FEED           = 114,
    G_CODE_PLUNGE_FEED    = 115,
    AUTOSAVE_INTERVAL     = 116,
    // For TTF text
    TTF_TEXT              = 300,
    // For the step dimension screen
    STEP_DIM_FINISH       = 400,
    STEP_DIM_STEPS        = 401,
    // For the styles stuff
    STYLE_WIDTH           = 500,
    STYLE_TEXT_HEIGHT     = 501,
    STYLE_TEXT_ANGLE      = 502,
    STYLE_COLOR           = 503,
    STYLE_FILL_COLOR      = 504,
    STYLE_NAME            = 505,
    BACKGROUND_COLOR      = 506,
    STYLE_STIPPLE_PERIOD  = 508,
    // For paste transforming
    PASTE_TIMES_REPEATED  = 600,
    PASTE_ANGLE           = 601,
    PASTE_SCALE           = 602,
    // For view
    VIEW_SCALE            = 700,
    VIEW_ORIGIN           = 701,
    VIEW_PROJ_RIGHT       = 702,
    VIEW_PROJ_UP          = 703,
    // For tangent arc
    TANGENT_ARC_RADIUS    = 800
};
struct {
    bool        showAgain;
    Edit        meaning;
    int         i;
    hGroup      group;
    hRequest    request;
    hStyle      style;
} edit;

static void ReportHowGroupSolved(hGroup hg);

struct {
    int     halfRow;
    int     col;

    struct {
        RgbaColor rgb;
        double    h, s, v;
        bool      show;
        bool      picker1dActive;
        bool      picker2dActive;
    }       colorPicker;
} editControl;

void HideEditControl();
void ShowEditControl(int col, const std::string &amp;str, int halfRow = -1);
void ShowEditControlWithColorPicker(int col, RgbaColor rgb);

void ClearSuper();

void ShowHeader(bool withNav);
// These are self-contained screens, that show some information about
// the sketch.
void ShowListOfGroups();
void ShowGroupInfo();
void ShowGroupSolveInfo();
void ShowConfiguration();
void ShowListOfStyles();
void ShowStyleInfo();
void ShowStepDimension();
void ShowPasteTransformed();
void ShowEditView();
void ShowTangentArc();
// Special screen, based on selection
void DescribeSelection();

void GoToScreen(Screen screen);

// All of these are callbacks from the GUI code; first from when
// we're describing an entity
static void ScreenEditTtfText(int link, uint32_t v);
static void ScreenSetTtfFont(int link, uint32_t v);
static void ScreenUnselectAll(int link, uint32_t v);

// when we're describing a constraint
static void ScreenConstraintShowAsRadius(int link, uint32_t v);

// and the rest from the stuff in textscreens.cpp
static void ScreenSelectGroup(int link, uint32_t v);
static void ScreenActivateGroup(int link, uint32_t v);
static void ScreenToggleGroupShown(int link, uint32_t v);
static void ScreenHowGroupSolved(int link, uint32_t v);
static void ScreenShowGroupsSpecial(int link, uint32_t v);
static void ScreenDeleteGroup(int link, uint32_t v);

static void ScreenHoverConstraint(int link, uint32_t v);
static void ScreenHoverRequest(int link, uint32_t v);
static void ScreenSelectRequest(int link, uint32_t v);
static void ScreenSelectConstraint(int link, uint32_t v);

static void ScreenChangeGroupOption(int link, uint32_t v);
static void ScreenColor(int link, uint32_t v);
static void ScreenOpacity(int link, uint32_t v);

static void ScreenShowListOfStyles(int link, uint32_t v);
static void ScreenShowStyleInfo(int link, uint32_t v);
static void ScreenDeleteStyle(int link, uint32_t v);
static void ScreenChangeStylePatternType(int link, uint32_t v);
static void ScreenChangeStyleYesNo(int link, uint32_t v);
static void ScreenCreateCustomStyle(int link, uint32_t v);
static void ScreenLoadFactoryDefaultStyles(int link, uint32_t v);
static void ScreenAssignSelectionToStyle(int link, uint32_t v);

static void ScreenShowConfiguration(int link, uint32_t v);
static void ScreenShowEditView(int link, uint32_t v);
static void ScreenGoToWebsite(int link, uint32_t v);

static void ScreenChangeFixExportColors(int link, uint32_t v);
static void ScreenChangeBackFaces(int link, uint32_t v);
static void ScreenChangeShowContourAreas(int link, uint32_t v);
static void ScreenChangeCheckClosedContour(int link, uint32_t v);
static void ScreenChangeTurntableNav(int link, uint32_t v);
static void ScreenChangeImmediatelyEditDimension(int link, uint32_t v);
static void ScreenChangeAutomaticLineConstraints(int link, uint32_t v);
static void ScreenChangePwlCurves(int link, uint32_t v);
static void ScreenChangeCanvasSizeAuto(int link, uint32_t v);
static void ScreenChangeCanvasSize(int link, uint32_t v);
static void ScreenChangeShadedTriangles(int link, uint32_t v);

static void ScreenAllowRedundant(int link, uint32_t v);

struct {
    bool    isDistance;
    double  finish;
    int     steps;

    Platform::TimerRef timer;
    int64_t time;
    int     step;
} stepDim;
static void ScreenStepDimSteps(int link, uint32_t v);
static void ScreenStepDimFinish(int link, uint32_t v);
static void ScreenStepDimGo(int link, uint32_t v);

static void ScreenChangeTangentArc(int link, uint32_t v);

static void ScreenPasteTransformed(int link, uint32_t v);

static void ScreenHome(int link, uint32_t v);

// These ones do stuff with the edit control
static void ScreenChangeExprA(int link, uint32_t v);
static void ScreenChangeGroupName(int link, uint32_t v);
static void ScreenChangeGroupScale(int link, uint32_t v);
static void ScreenChangeLightDirection(int link, uint32_t v);
static void ScreenChangeLightIntensity(int link, uint32_t v);
static void ScreenChangeColor(int link, uint32_t v);
static void ScreenChangeChordTolerance(int link, uint32_t v);
static void ScreenChangeMaxSegments(int link, uint32_t v);
static void ScreenChangeExportChordTolerance(int link, uint32_t v);
static void ScreenChangeExportMaxSegments(int link, uint32_t v);
static void ScreenChangeCameraTangent(int link, uint32_t v);
static void ScreenChangeGridSpacing(int link, uint32_t v);
static void ScreenChangeDigitsAfterDecimal(int link, uint32_t v);
static void ScreenChangeDigitsAfterDecimalDegree(int link, uint32_t v);
static void ScreenChangeUseSIPrefixes(int link, uint32_t v);
static void ScreenChangeExportScale(int link, uint32_t v);
static void ScreenChangeExportOffset(int link, uint32_t v);
static void ScreenChangeGCodeParameter(int link, uint32_t v);
static void ScreenChangeAutosaveInterval(int link, uint32_t v);
static void ScreenChangeStyleName(int link, uint32_t v);
static void ScreenChangeStyleMetric(int link, uint32_t v);
static void ScreenChangeStyleTextAngle(int link, uint32_t v);
static void ScreenChangeStyleColor(int link, uint32_t v);
static void ScreenChangeBackgroundColor(int link, uint32_t v);
static void ScreenChangePasteTransformed(int link, uint32_t v);
static void ScreenChangeViewScale(int link, uint32_t v);
static void ScreenChangeViewToFullScale(int link, uint32_t v);
static void ScreenChangeViewOrigin(int link, uint32_t v);
static void ScreenChangeViewProjection(int link, uint32_t v);

bool EditControlDoneForStyles(const std::string &amp;s);
bool EditControlDoneForConfiguration(const std::string &amp;s);
bool EditControlDoneForPaste(const std::string &amp;s);
bool EditControlDoneForView(const std::string &amp;s);
void EditControlDone(std::string s);
</t>
<t tx="leo.20191228122648.75">class GraphicsWindow {
public:
    void Init();

    Platform::WindowRef   window;

    void PopulateMainMenu();
    void PopulateRecentFiles();

    Platform::KeyboardEvent AcceleratorForCommand(Command id);
    void ActivateCommand(Command id);

    static void MenuView(Command id);
    static void MenuEdit(Command id);
    static void MenuRequest(Command id);
    void DeleteSelection();
    void CopySelection();
    void PasteClipboard(Vector trans, double theta, double scale);
    static void MenuClipboard(Command id);

    Platform::MenuRef openRecentMenu;
    Platform::MenuRef linkRecentMenu;

    Platform::MenuItemRef showGridMenuItem;
    Platform::MenuItemRef perspectiveProjMenuItem;
    Platform::MenuItemRef showToolbarMenuItem;
    Platform::MenuItemRef showTextWndMenuItem;
    Platform::MenuItemRef fullScreenMenuItem;

    Platform::MenuItemRef unitsMmMenuItem;
    Platform::MenuItemRef unitsMetersMenuItem;
    Platform::MenuItemRef unitsInchesMenuItem;

    Platform::MenuItemRef inWorkplaneMenuItem;
    Platform::MenuItemRef in3dMenuItem;

    Platform::MenuItemRef undoMenuItem;
    Platform::MenuItemRef redoMenuItem;

    std::shared_ptr&lt;ViewportCanvas&gt; canvas;
    std::shared_ptr&lt;BatchCanvas&gt;    persistentCanvas;
    bool persistentDirty;

    // These parameters define the map from 2d screen coordinates to the
    // coordinates of the 3d sketch points. We will use an axonometric
    // projection.
    Vector  offset;
    Vector  projRight;
    Vector  projUp;
    double  scale;
    struct {
        bool    mouseDown;
        Vector  offset;
        Vector  projRight;
        Vector  projUp;
        Point2d mouse;
        Point2d mouseOnButtonDown;
        Vector  marqueePoint;
        bool    startedMoving;
    }       orig;
    // We need to detect when the projection is changed to invalidate
    // caches for drawn items.
    struct {
        Vector  offset;
        Vector  projRight;
        Vector  projUp;
        double  scale;
    }       cached;

    // Most recent mouse position, updated every time the mouse moves.
    Point2d currentMousePosition;

    // When the user is dragging a point, don't solve multiple times without
    // allowing a paint in between. The extra solves are wasted if they're
    // not displayed.
    bool    havePainted;

    // Some state for the context menu.
    struct {
        bool        active;
    }       context;

    Camera GetCamera() const;
    Lighting GetLighting() const;

    void NormalizeProjectionVectors();
    Point2d ProjectPoint(Vector p);
    Vector ProjectPoint3(Vector p);
    Vector ProjectPoint4(Vector p, double *w);
    Vector UnProjectPoint(Point2d p);
    Vector UnProjectPoint3(Vector p);

    Platform::TimerRef animateTimer;
    void AnimateOnto(Quaternion quatf, Vector offsetf);
    void AnimateOntoWorkplane();

    Vector VectorFromProjs(Vector rightUpForward);
    void HandlePointForZoomToFit(Vector p, Point2d *pmax, Point2d *pmin,
                     bool includingInvisibles = false, bool useSelection = false);

    hGroup  activeGroup;
    void EnsureValidActives();
    bool LockedInWorkplane();
    void SetWorkplaneFreeIn3d();
    hEntity ActiveWorkplane();
    void ForceTextWindowShown();

    // Operations that must be completed by doing something with the mouse
    // are noted here.
    enum class Pending : uint32_t {
        NONE                        = 0,
        COMMAND                     = 1,
        DRAGGING_POINTS             = 2,
        DRAGGING_NEW_POINT          = 3,
        DRAGGING_NEW_LINE_POINT     = 4,
        DRAGGING_NEW_CUBIC_POINT    = 5,
        DRAGGING_NEW_ARC_POINT      = 6,
        DRAGGING_CONSTRAINT         = 7,
        DRAGGING_RADIUS             = 8,
        DRAGGING_NORMAL             = 9,
        DRAGGING_NEW_RADIUS         = 10,
        DRAGGING_MARQUEE            = 11,
    };

    struct {
        Pending              operation;
        Command              command;

        hRequest             request;
        hEntity              point;
        List&lt;hEntity&gt;        points;
        List&lt;hRequest&gt;       requests;
        hEntity              circle;
        hEntity              normal;
        hConstraint          constraint;

        const char          *description;
        Platform::Path       filename;

        bool                 hasSuggestion;
        Constraint::Type     suggestion;
    } pending;
    void ClearPending(bool scheduleShowTW = true);
    bool IsFromPending(hRequest r);
    void AddToPending(hRequest r);
    void ReplacePending(hRequest before, hRequest after);

    // The constraint that is being edited with the on-screen textbox.
    hConstraint constraintBeingEdited;

    bool SuggestLineConstraint(hRequest lineSegment, ConstraintBase::Type *type);

    Vector SnapToGrid(Vector p);
    Vector SnapToEntityByScreenPoint(Point2d pp, hEntity he);
    bool ConstrainPointByHovered(hEntity pt, const Point2d *projected = NULL);
    void DeleteTaggedRequests();
    hRequest AddRequest(Request::Type type, bool rememberForUndo);
    hRequest AddRequest(Request::Type type);

    @others
};


#endif
</t>
<t tx="leo.20191228122648.76">class ParametricCurve {
public:
    bool isLine; // else circle
    Vector p0, p1;
    Vector u, v;
    double r, theta0, theta1, dtheta;

    void MakeFromEntity(hEntity he, bool reverse);
    Vector PointAt(double t);
    Vector TangentAt(double t);
    double LengthForAuto();

    void CreateRequestTrimmedTo(double t, bool reuseOrig,
void RemoveConstraintsForPointBeingDeleted(hEntity hpt);
void FixConstraintsForRequestBeingDeleted(hRequest hr);
void FixConstraintsForPointBeingDeleted(hEntity hpt);
void EditConstraint(hConstraint constraint);

// A selected entity.
</t>
<t tx="leo.20191228122648.77">class Selection {
public:
    int         tag;

    hEntity     entity;
    hConstraint constraint;
    bool        emphasized;

    void Draw(bool isHovered, Canvas *canvas);

    void Clear();
    bool IsEmpty();
    bool Equals(Selection *b);
    bool HasEndpoints();
};

// A hovered entity, with its location relative to the cursor.
</t>
<t tx="leo.20191228122648.78">class Hover {
public:
    int         zIndex;
    double      distance;
    Selection   selection;
};

List&lt;Hover&gt; hoverList;
Selection hover;
bool hoverWasSelectedOnMousedown;
List&lt;Selection&gt; selection;

Selection ChooseFromHoverToSelect();
Selection ChooseFromHoverToDrag();
void HitTestMakeSelection(Point2d mp);
void ClearSelection();
void ClearNonexistentSelectionItems();
/// This structure is filled by a call to GroupSelection().
struct {
    std::vector&lt;hEntity&gt;     point;
    std::vector&lt;hEntity&gt;     entity;
    std::vector&lt;hEntity&gt;     anyNormal;
    std::vector&lt;hEntity&gt;     vector;
    std::vector&lt;hEntity&gt;     face;
    std::vector&lt;hConstraint&gt; constraint;
    int         points;
    int         entities;
    int         workplanes;
    int         faces;
    int         lineSegments;
    int         circlesOrArcs;
    int         arcs;
    int         cubics;
    int         periodicCubics;
    int         anyNormals;
    int         vectors;
    int         constraints;
    int         stylables;
    int         constraintLabels;
    int         withEndpoints;
    int         n;                 ///&lt; Number of selected items
} gs;
void GroupSelection();
bool IsSelected(Selection *s);
bool IsSelected(hEntity he);
void MakeSelected(hEntity he);
void MakeSelected(hConstraint hc);
void MakeSelected(Selection *s);
void MakeUnselected(hEntity he, bool coincidentPointTrick);
void MakeUnselected(Selection *s, bool coincidentPointTrick);
void SelectByMarquee();
void ClearSuper();

// The toolbar, in toolbar.cpp
bool ToolbarDrawOrHitTest(int x, int y, UiCanvas *canvas,
bool    showConstruction;
bool    showConstraints;
bool    showTextWindow;
bool    showShaded;
bool    showEdges;
bool    showOutlines;
bool    showFaces;
bool    showMesh;
void ToggleBool(bool *v);

enum class DrawOccludedAs { INVISIBLE, STIPPLED, VISIBLE };
DrawOccludedAs drawOccludedAs;

bool    showSnapGrid;
void DrawSnapGrid(Canvas *canvas);

void AddPointToDraggedList(hEntity hp);
void StartDraggingByEntity(hEntity he);
void StartDraggingBySelection();
void UpdateDraggedNum(Vector *pos, double mx, double my);
void UpdateDraggedPoint(hEntity hp, double mx, double my);

void Invalidate(bool clearPersistent = false);
void DrawEntities(Canvas *canvas, bool persistent);
void DrawPersistent(Canvas *canvas);
void Draw(Canvas *canvas);
void Paint();

bool MouseEvent(Platform::MouseEvent event);
void MouseMoved(double x, double y, bool leftDown, bool middleDown,

int64_t last6DofTime;
hGroup last6DofGroup;
void SixDofEvent(Platform::SixDofEvent event);
</t>
<t tx="leo.20191228122648.79">@path ./src/
//-----------------------------------------------------------------------------
// The user-visible undo/redo operation; whenever they change something, we
// record our state and push it on a stack, and we pop the stack when they
// select undo.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122648.8">void TextWindow::ShowTangentArc() {
    Printf(true, "%FtTANGENT ARC PARAMETERS%E");

    Printf(true,  "%Ft radius of created arc%E");
    if(SS.tangentArcManual) {
        Printf(false, "%Ba   %s %Fl%Lr%f[change]%E",
            SS.MmToString(SS.tangentArcRadius).c_str(),
            &amp;(TextWindow::ScreenChangeTangentArc));
    } else {
        Printf(false, "%Ba   automatic");
    }

    Printf(false, "");
    Printf(false, "  %Fd%f%La%s  choose radius automatically%E",
        &amp;ScreenChangeTangentArc,
        !SS.tangentArcManual ? CHECK_TRUE : CHECK_FALSE);
    Printf(false, "  %Fd%f%Lm%s  modify original entities%E",
        &amp;ScreenChangeTangentArc,
        SS.tangentArcModify ? CHECK_TRUE : CHECK_FALSE);

    Printf(false, "");
    Printf(false, "To create a tangent arc at a point,");
    Printf(false, "select that point and then choose");
    Printf(false, "Sketch -&gt; Tangent Arc at Point.");
    Printf(true, "(or %Fl%Ll%fback to home screen%E)", &amp;ScreenHome);
}

//-----------------------------------------------------------------------------
// The edit control is visible, and the user just pressed enter.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122648.80">void SolveSpaceUI::UndoRemember() {
    unsaved = true;
    PushFromCurrentOnto(&amp;undo);
    UndoClearStack(&amp;redo);
    UndoEnableMenus();
}

</t>
<t tx="leo.20191228122648.81">void SolveSpaceUI::UndoUndo() {
    if(undo.cnt &lt;= 0) return;

    PushFromCurrentOnto(&amp;redo);
    PopOntoCurrentFrom(&amp;undo);
    UndoEnableMenus();
}

</t>
<t tx="leo.20191228122648.82">void SolveSpaceUI::UndoRedo() {
    if(redo.cnt &lt;= 0) return;

    PushFromCurrentOnto(&amp;undo);
    PopOntoCurrentFrom(&amp;redo);
    UndoEnableMenus();
}

</t>
<t tx="leo.20191228122648.83">void SolveSpaceUI::UndoEnableMenus() {
    SS.GW.undoMenuItem-&gt;SetEnabled(undo.cnt &gt; 0);
    SS.GW.redoMenuItem-&gt;SetEnabled(redo.cnt &gt; 0);
}

</t>
<t tx="leo.20191228122648.84">void SolveSpaceUI::PushFromCurrentOnto(UndoStack *uk) {
    if(uk-&gt;cnt == MAX_UNDO) {
        UndoClearState(&amp;(uk-&gt;d[uk-&gt;write]));
        // And then write in to this one again
    } else {
        (uk-&gt;cnt)++;
    }

    UndoState *ut = &amp;(uk-&gt;d[uk-&gt;write]);
    *ut = {};
    ut-&gt;group.ReserveMore(SK.group.n);
    for(Group &amp;src : SK.group) {
        // Shallow copy
        Group dest(src);
        // And then clean up all the stuff that needs to be a deep copy,
        // and zero out all the dynamic stuff that will get regenerated.
        dest.clean = false;
        dest.solved = {};
        dest.polyLoops = {};
        dest.bezierLoops = {};
        dest.bezierOpens = {};
        dest.polyError = {};
        dest.thisMesh = {};
        dest.runningMesh = {};
        dest.thisShell = {};
        dest.runningShell = {};
        dest.displayMesh = {};
        dest.displayOutlines = {};

        dest.remap = src.remap;

        dest.impMesh = {};
        dest.impShell = {};
        dest.impEntity = {};
        ut-&gt;group.Add(&amp;dest);
    }
    for(auto &amp;src : SK.groupOrder) { ut-&gt;groupOrder.Add(&amp;src); }
    ut-&gt;request.ReserveMore(SK.request.n);
    for(auto &amp;src : SK.request) { ut-&gt;request.Add(&amp;src); }
    ut-&gt;constraint.ReserveMore(SK.constraint.n);
    for(auto &amp;src : SK.constraint) {
        // Shallow copy
        Constraint dest(src);
        ut-&gt;constraint.Add(&amp;dest);
    }
    ut-&gt;param.ReserveMore(SK.param.n);
    for(auto &amp;src : SK.param) { ut-&gt;param.Add(&amp;src); }
    ut-&gt;style.ReserveMore(SK.style.n);
    for(auto &amp;src : SK.style) { ut-&gt;style.Add(&amp;src); }
    ut-&gt;activeGroup = SS.GW.activeGroup;

    uk-&gt;write = WRAP(uk-&gt;write + 1, MAX_UNDO);
}

</t>
<t tx="leo.20191228122648.85">void SolveSpaceUI::PopOntoCurrentFrom(UndoStack *uk) {
    ssassert(uk-&gt;cnt &gt; 0, "Cannot pop from empty undo stack");
    (uk-&gt;cnt)--;
    uk-&gt;write = WRAP(uk-&gt;write - 1, MAX_UNDO);

    UndoState *ut = &amp;(uk-&gt;d[uk-&gt;write]);

    // Free everything in the main copy of the program before replacing it
    for(hGroup hg : SK.groupOrder) {
        Group *g = SK.GetGroup(hg);
        g-&gt;Clear();
    }
    SK.group.Clear();
    SK.groupOrder.Clear();
    SK.request.Clear();
    SK.constraint.Clear();
    SK.param.Clear();
    SK.style.Clear();

    // And then do a shallow copy of the state from the undo list
    ut-&gt;group.MoveSelfInto(&amp;(SK.group));
    for(auto &amp;gh : ut-&gt;groupOrder) { SK.groupOrder.Add(&amp;gh); }
    ut-&gt;request.MoveSelfInto(&amp;(SK.request));
    ut-&gt;constraint.MoveSelfInto(&amp;(SK.constraint));
    ut-&gt;param.MoveSelfInto(&amp;(SK.param));
    ut-&gt;style.MoveSelfInto(&amp;(SK.style));
    SS.GW.activeGroup = ut-&gt;activeGroup;

    // No need to free it, since a shallow copy was made above
    *ut = {};

    // And reset the state everywhere else in the program, since the
    // sketch just changed a lot.
    SS.GW.ClearSuper();
    SS.TW.ClearSuper();
    SS.ReloadAllLinked(SS.saveFile);
    SS.GenerateAll(SolveSpaceUI::Generate::ALL);
    SS.ScheduleShowTW();

    // Activate the group that was active before.
    Group *activeGroup = SK.GetGroup(SS.GW.activeGroup);
    activeGroup-&gt;Activate();
}

</t>
<t tx="leo.20191228122648.86">void SolveSpaceUI::UndoClearStack(UndoStack *uk) {
    while(uk-&gt;cnt &gt; 0) {
        uk-&gt;write = WRAP(uk-&gt;write - 1, MAX_UNDO);
        (uk-&gt;cnt)--;
        UndoClearState(&amp;(uk-&gt;d[uk-&gt;write]));
    }
    *uk = {}; // for good measure
}

</t>
<t tx="leo.20191228122648.87">void SolveSpaceUI::UndoClearState(UndoState *ut) {
    for(auto &amp;g : ut-&gt;group) { g.remap.clear(); }
    ut-&gt;group.Clear();
    ut-&gt;request.Clear();
    ut-&gt;constraint.Clear();
    ut-&gt;param.Clear();
    ut-&gt;style.Clear();
    *ut = {};
}

</t>
<t tx="leo.20191228122648.88">@path ./src/
//-----------------------------------------------------------------------------
// Utility functions, mostly various kinds of vector math (working on real
// numbers, not working on quantities in the symbolic algebra system).
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122648.89">void SolveSpace::AssertFailure(const char *file, unsigned line, const char *function,
                               const char *condition, const char *message) {
    std::string formattedMsg;
    formattedMsg += ssprintf("File %s, line %u, function %s:\n", file, line, function);
    formattedMsg += ssprintf("Assertion failed: %s.\n", condition);
    formattedMsg += ssprintf("Message: %s.\n", message);
    SolveSpace::Platform::FatalError(formattedMsg);
}

std::string SolveSpace::ssprintf(const char *fmt, ...)
{
    va_list va;

    va_start(va, fmt);
    int size = vsnprintf(NULL, 0, fmt, va);
    ssassert(size &gt;= 0, "vsnprintf could not encode string");
    va_end(va);

    std::string result;
    result.resize(size + 1);

    va_start(va, fmt);
    vsnprintf(&amp;result[0], size + 1, fmt, va);
    va_end(va);

    result.resize(size);
    return result;
}

</t>
<t tx="leo.20191228122648.9">void TextWindow::EditControlDone(std::string s) {
    edit.showAgain = false;

    switch(edit.meaning) {
        case Edit::TIMES_REPEATED:
            if(Expr *e = Expr::From(s, /*popUpError=*/true)) {
                SS.UndoRemember();

                double ev = e-&gt;Eval();
                if((int)ev &lt; 1) {
                    Error(_("Can't repeat fewer than 1 time."));
                    break;
                }
                if((int)ev &gt; 999) {
                    Error(_("Can't repeat more than 999 times."));
                    break;
                }

                Group *g = SK.GetGroup(edit.group);
                g-&gt;valA = ev;

                if(g-&gt;type == Group::Type::ROTATE) {
                    // If the group does not contain any constraints, then
                    // set the numerical guess to space the copies uniformly
                    // over one rotation. Don't touch the guess if we're
                    // already constrained, because that would break
                    // convergence.
                    if(g-&gt;GetNumConstraints() == 0) {
                        double copies = (g-&gt;skipFirst) ? (ev + 1) : ev;
                        SK.GetParam(g-&gt;h.param(3))-&gt;val = PI/(2*copies);
                    }
                }

                SS.MarkGroupDirty(g-&gt;h);
            }
            break;

        case Edit::GROUP_NAME:
            if(s.empty()) {
                Error(_("Group name cannot be empty"));
            } else {
                SS.UndoRemember();

                Group *g = SK.GetGroup(edit.group);
                g-&gt;name = s;
            }
            break;

        case Edit::GROUP_SCALE:
            if(Expr *e = Expr::From(s, /*popUpError=*/true)) {
                double ev = e-&gt;Eval();
                if(fabs(ev) &lt; 1e-6) {
                    Error(_("Scale cannot be zero."));
                } else {
                    Group *g = SK.GetGroup(edit.group);
                    g-&gt;scale = ev;
                    SS.MarkGroupDirty(g-&gt;h);
                }
            }
            break;

        case Edit::GROUP_COLOR: {
            Vector rgb;
            if(sscanf(s.c_str(), "%lf, %lf, %lf", &amp;rgb.x, &amp;rgb.y, &amp;rgb.z)==3) {
                rgb = rgb.ClampWithin(0, 1);

                Group *g = SK.group.FindByIdNoOops(SS.TW.shown.group);
                if(!g) break;
                g-&gt;color = RgbaColor::FromFloat(rgb.x, rgb.y, rgb.z, g-&gt;color.alphaF());

                SS.MarkGroupDirty(g-&gt;h);
                SS.GW.ClearSuper();
            } else {
                Error(_("Bad format: specify color as r, g, b"));
            }
            break;
        }
        case Edit::GROUP_OPACITY:
            if(Expr *e = Expr::From(s, /*popUpError=*/true)) {
                double alpha = e-&gt;Eval();
                if(alpha &lt; 0 || alpha &gt; 1) {
                    Error(_("Opacity must be between zero and one."));
                } else {
                    Group *g = SK.GetGroup(edit.group);
                    g-&gt;color.alpha = (int)(255.1f * alpha);
                    SS.MarkGroupDirty(g-&gt;h);
                    SS.GW.ClearSuper();
                }
            }
            break;

        case Edit::TTF_TEXT:
            SS.UndoRemember();
            if(Request *r = SK.request.FindByIdNoOops(edit.request)) {
                r-&gt;str = s;
                SS.MarkGroupDirty(r-&gt;group);
            }
            break;

        case Edit::STEP_DIM_FINISH:
            if(Expr *e = Expr::From(s, /*popUpError=*/true)) {
                if(stepDim.isDistance) {
                    stepDim.finish = SS.ExprToMm(e);
                } else {
                    stepDim.finish = e-&gt;Eval();
                }
            }
            break;

        case Edit::STEP_DIM_STEPS:
            stepDim.steps = min(300, max(1, atoi(s.c_str())));
            break;

        case Edit::TANGENT_ARC_RADIUS:
            if(Expr *e = Expr::From(s, /*popUpError=*/true)) {
                if(e-&gt;Eval() &lt; LENGTH_EPS) {
                    Error(_("Radius cannot be zero or negative."));
                    break;
                }
                SS.tangentArcRadius = SS.ExprToMm(e);
            }
            break;

        default: {
            int cnt = 0;
            if(EditControlDoneForStyles(s))         cnt++;
            if(EditControlDoneForConfiguration(s))  cnt++;
            if(EditControlDoneForPaste(s))          cnt++;
            if(EditControlDoneForView(s))           cnt++;
            ssassert(cnt == 1, "Expected exactly one parameter to be edited");
            break;
        }
    }
    SS.GW.Invalidate();
    SS.ScheduleShowTW();

    if(!edit.showAgain) {
        HideEditControl();
        edit.meaning = Edit::NOTHING;
    }
}

</t>
<t tx="leo.20191228122648.90">char32_t utf8_iterator::operator*()
{
    const uint8_t *it = (const uint8_t*) this-&gt;p;
    char32_t result = *it;

    if((result &amp; 0x80) != 0) {
      unsigned int mask = 0x40;

      do {
        result &lt;&lt;= 6;
        unsigned int c = (*++it);
        mask   &lt;&lt;= 5;
        result  += c - 0x80;
      } while((result &amp; mask) != 0);

      result &amp;= mask - 1;
    }

    this-&gt;n = (const char*) (it + 1);
    return result;
}

</t>
<t tx="leo.20191228122648.91">int64_t SolveSpace::GetMilliseconds()
{
    auto timestamp = std::chrono::steady_clock::now().time_since_epoch();
    return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timestamp).count();
}

</t>
<t tx="leo.20191228122648.92">void SolveSpace::MakeMatrix(double *mat,
                            double a11, double a12, double a13, double a14,
                            double a21, double a22, double a23, double a24,
                            double a31, double a32, double a33, double a34,
                            double a41, double a42, double a43, double a44)
{
    mat[ 0] = a11;
    mat[ 1] = a21;
    mat[ 2] = a31;
    mat[ 3] = a41;
    mat[ 4] = a12;
    mat[ 5] = a22;
    mat[ 6] = a32;
    mat[ 7] = a42;
    mat[ 8] = a13;
    mat[ 9] = a23;
    mat[10] = a33;
    mat[11] = a43;
    mat[12] = a14;
    mat[13] = a24;
    mat[14] = a34;
    mat[15] = a44;
}

</t>
<t tx="leo.20191228122648.93">void SolveSpace::MultMatrix(double *mata, double *matb, double *matr) {
    for(int i = 0; i &lt; 4; i++) {
        for(int j = 0; j &lt; 4; j++) {
            double s = 0.0;
            for(int k = 0; k &lt; 4; k++) {
                s += mata[k * 4 + j] * matb[i * 4 + k];
            }
           matr[i * 4 + j] = s;
        }
    }
}

//-----------------------------------------------------------------------------
// Format the string for our message box appropriately, and then display
// that string.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122648.94">static void MessageBox(const char *fmt, va_list va, bool error,
                       std::function&lt;void()&gt; onDismiss = std::function&lt;void()&gt;())
{
#ifndef LIBRARY
    va_list va_size;
    va_copy(va_size, va);
    int size = vsnprintf(NULL, 0, fmt, va_size);
    ssassert(size &gt;= 0, "vsnprintf could not encode string");
    va_end(va_size);

    std::string text;
    text.resize(size);

    vsnprintf(&amp;text[0], size + 1, fmt, va);

    // Split message text using a heuristic for better presentation.
    size_t separatorAt = 0;
    while(separatorAt != std::string::npos) {
        size_t dotAt = text.find('.', separatorAt + 1),
               colonAt = text.find(':', separatorAt + 1);
        separatorAt = min(dotAt, colonAt);
        if(separatorAt == std::string::npos ||
                (separatorAt + 1 &lt; text.size() &amp;&amp; isspace(text[separatorAt + 1]))) {
            break;
        }
    }
    std::string message = text;
    std::string description;
    if(separatorAt != std::string::npos) {
        message = text.substr(0, separatorAt + 1);
        if(separatorAt + 1 &lt; text.size()) {
            description = text.substr(separatorAt + 1);
        }
    }

    std::string::iterator it = description.begin();
    while(isspace(*it)) it++;
    description = description.substr(it - description.begin());

    Platform::MessageDialogRef dialog = CreateMessageDialog(SS.GW.window);
    if (!dialog) {
        if (error) {
            fprintf(stderr, "Error: %s\n", message.c_str());
        } else {
            fprintf(stderr, "Message: %s\n", message.c_str());
        }
        if(onDismiss) {
            onDismiss();
        }
        return;
    }
    using Platform::MessageDialog;
    if(error) {
        dialog-&gt;SetType(MessageDialog::Type::ERROR);
    } else {
        dialog-&gt;SetType(MessageDialog::Type::INFORMATION);
    }
    dialog-&gt;SetTitle(error ? C_("title", "Error") : C_("title", "Message"));
    dialog-&gt;SetMessage(message);
    if(!description.empty()) {
        dialog-&gt;SetDescription(description);
    }
    dialog-&gt;AddButton(C_("button", "&amp;OK"), MessageDialog::Response::OK,
                      /*isDefault=*/true);

    dialog-&gt;onResponse = [=](MessageDialog::Response _response) {
        if(onDismiss) {
            onDismiss();
        }
    };
    dialog-&gt;ShowModal();
#endif
}
</t>
<t tx="leo.20191228122648.95">void SolveSpace::Error(const char *fmt, ...)
{
    va_list f;
    va_start(f, fmt);
    MessageBox(fmt, f, /*error=*/true);
    va_end(f);
}
</t>
<t tx="leo.20191228122648.96">void SolveSpace::Message(const char *fmt, ...)
{
    va_list f;
    va_start(f, fmt);
    MessageBox(fmt, f, /*error=*/false);
    va_end(f);
}
</t>
<t tx="leo.20191228122648.97">void SolveSpace::MessageAndRun(std::function&lt;void()&gt; onDismiss, const char *fmt, ...)
{
    va_list f;
    va_start(f, fmt);
    MessageBox(fmt, f, /*error=*/false, onDismiss);
    va_end(f);
}

//-----------------------------------------------------------------------------
// Solve a mostly banded matrix. In a given row, there are LEFT_OF_DIAG
// elements to the left of the diagonal element, and RIGHT_OF_DIAG elements to
// the right (so that the total band width is LEFT_OF_DIAG + RIGHT_OF_DIAG + 1).
// There also may be elements in the last two columns of any row. We solve
// without pivoting.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122648.98">void BandedMatrix::Solve() {
    int i, ip, j, jp;
    double temp;

    // Reduce the matrix to upper triangular form.
    for(i = 0; i &lt; n; i++) {
        for(ip = i+1; ip &lt; n &amp;&amp; ip &lt;= (i + LEFT_OF_DIAG); ip++) {
            temp = A[ip][i]/A[i][i];

            for(jp = i; jp &lt; (n - 2) &amp;&amp; jp &lt;= (i + RIGHT_OF_DIAG); jp++) {
                A[ip][jp] -= temp*(A[i][jp]);
            }
            A[ip][n-2] -= temp*(A[i][n-2]);
            A[ip][n-1] -= temp*(A[i][n-1]);

            B[ip] -= temp*B[i];
        }
    }

    // And back-substitute.
    for(i = n - 1; i &gt;= 0; i--) {
        temp = B[i];

        if(i &lt; n-1) temp -= X[n-1]*A[i][n-1];
        if(i &lt; n-2) temp -= X[n-2]*A[i][n-2];

        for(j = min(n - 3, i + RIGHT_OF_DIAG); j &gt; i; j--) {
            temp -= X[j]*A[i][j];
        }
        X[i] = temp / A[i][i];
    }
}

const Quaternion Quaternion::IDENTITY = { 1, 0, 0, 0 };

Quaternion Quaternion::From(double w, double vx, double vy, double vz) {
    Quaternion q;
    q.w  = w;
    q.vx = vx;
    q.vy = vy;
    q.vz = vz;
    return q;
}

Quaternion Quaternion::From(hParam w, hParam vx, hParam vy, hParam vz) {
    Quaternion q;
    q.w  = SK.GetParam(w )-&gt;val;
    q.vx = SK.GetParam(vx)-&gt;val;
    q.vy = SK.GetParam(vy)-&gt;val;
    q.vz = SK.GetParam(vz)-&gt;val;
    return q;
}

Quaternion Quaternion::From(Vector axis, double dtheta) {
    Quaternion q;
    double c = cos(dtheta / 2), s = sin(dtheta / 2);
    axis = axis.WithMagnitude(s);
    q.w  = c;
    q.vx = axis.x;
    q.vy = axis.y;
    q.vz = axis.z;
    return q;
}

Quaternion Quaternion::From(Vector u, Vector v)
{
    Vector n = u.Cross(v);

    Quaternion q;
    double s, tr = 1 + u.x + v.y + n.z;
    if(tr &gt; 1e-4) {
        s = 2*sqrt(tr);
        q.w  = s/4;
        q.vx = (v.z - n.y)/s;
        q.vy = (n.x - u.z)/s;
        q.vz = (u.y - v.x)/s;
    } else {
        if(u.x &gt; v.y &amp;&amp; u.x &gt; n.z) {
            s = 2*sqrt(1 + u.x - v.y - n.z);
            q.w  = (v.z - n.y)/s;
            q.vx = s/4;
            q.vy = (u.y + v.x)/s;
            q.vz = (n.x + u.z)/s;
        } else if(v.y &gt; n.z) {
            s = 2*sqrt(1 - u.x + v.y - n.z);
            q.w  = (n.x - u.z)/s;
            q.vx = (u.y + v.x)/s;
            q.vy = s/4;
            q.vz = (v.z + n.y)/s;
        } else {
            s = 2*sqrt(1 - u.x - v.y + n.z);
            q.w  = (u.y - v.x)/s;
            q.vx = (n.x + u.z)/s;
            q.vy = (v.z + n.y)/s;
            q.vz = s/4;
        }
    }

    return q.WithMagnitude(1);
}

Quaternion Quaternion::Plus(Quaternion b) const {
    Quaternion q;
    q.w  = w  + b.w;
    q.vx = vx + b.vx;
    q.vy = vy + b.vy;
    q.vz = vz + b.vz;
    return q;
}

Quaternion Quaternion::Minus(Quaternion b) const {
    Quaternion q;
    q.w  = w  - b.w;
    q.vx = vx - b.vx;
    q.vy = vy - b.vy;
    q.vz = vz - b.vz;
    return q;
}

Quaternion Quaternion::ScaledBy(double s) const {
    Quaternion q;
    q.w  = w*s;
    q.vx = vx*s;
    q.vy = vy*s;
    q.vz = vz*s;
    return q;
}

double Quaternion::Magnitude() const {
    return sqrt(w*w + vx*vx + vy*vy + vz*vz);
}

Quaternion Quaternion::WithMagnitude(double s) const {
    return ScaledBy(s/Magnitude());
}

Vector Quaternion::RotationU() const {
    Vector v;
    v.x = w*w + vx*vx - vy*vy - vz*vz;
    v.y = 2*w *vz + 2*vx*vy;
    v.z = 2*vx*vz - 2*w *vy;
    return v;
}

Vector Quaternion::RotationV() const {
    Vector v;
    v.x = 2*vx*vy - 2*w*vz;
    v.y = w*w - vx*vx + vy*vy - vz*vz;
    v.z = 2*w*vx + 2*vy*vz;
    return v;
}

Vector Quaternion::RotationN() const {
    Vector v;
    v.x = 2*w*vy + 2*vx*vz;
    v.y = 2*vy*vz - 2*w*vx;
    v.z = w*w - vx*vx - vy*vy + vz*vz;
    return v;
}

Vector Quaternion::Rotate(Vector p) const {
    // Express the point in the new basis
    return (RotationU().ScaledBy(p.x)).Plus(
            RotationV().ScaledBy(p.y)).Plus(
            RotationN().ScaledBy(p.z));
}

Quaternion Quaternion::Inverse() const {
    Quaternion r;
    r.w = w;
    r.vx = -vx;
    r.vy = -vy;
    r.vz = -vz;
    return r.WithMagnitude(1); // not that the normalize should be reqd
}

Quaternion Quaternion::ToThe(double p) const {
    // Avoid division by zero, or arccos of something not in its domain
    if(w &gt;= (1 - 1e-6)) {
        return From(1, 0, 0, 0);
    } else if(w &lt;= (-1 + 1e-6)) {
        return From(-1, 0, 0, 0);
    }

    Quaternion r;
    Vector axis = Vector::From(vx, vy, vz);
    double theta = acos(w); // okay, since magnitude is 1, so -1 &lt;= w &lt;= 1
    theta *= p;
    r.w = cos(theta);
    axis = axis.WithMagnitude(sin(theta));
    r.vx = axis.x;
    r.vy = axis.y;
    r.vz = axis.z;
    return r;
}

Quaternion Quaternion::Times(Quaternion b) const {
    double sa = w, sb = b.w;
    Vector va = { vx, vy, vz };
    Vector vb = { b.vx, b.vy, b.vz };

    Quaternion r;
    r.w = sa*sb - va.Dot(vb);
    Vector vr = vb.ScaledBy(sa).Plus(
                va.ScaledBy(sb).Plus(
                va.Cross(vb)));
    r.vx = vr.x;
    r.vy = vr.y;
    r.vz = vr.z;
    return r;
}

Quaternion Quaternion::Mirror() const {
    Vector u = RotationU(),
           v = RotationV();
    u = u.ScaledBy(-1);
    v = v.ScaledBy(-1);
    return Quaternion::From(u, v);
}


Vector Vector::From(double x, double y, double z) {
    Vector v;
    v.x = x; v.y = y; v.z = z;
    return v;
}

Vector Vector::From(hParam x, hParam y, hParam z) {
    Vector v;
    v.x = SK.GetParam(x)-&gt;val;
    v.y = SK.GetParam(y)-&gt;val;
    v.z = SK.GetParam(z)-&gt;val;
    return v;
}

</t>
<t tx="leo.20191228122648.99">bool Vector::EqualsExactly(Vector v) const {
    return EXACT(x == v.x &amp;&amp;
                 y == v.y &amp;&amp;
                 z == v.z);
}

Vector Vector::Plus(Vector b) const {
    Vector r;

    r.x = x + b.x;
    r.y = y + b.y;
    r.z = z + b.z;

    return r;
}

Vector Vector::Minus(Vector b) const {
    Vector r;

    r.x = x - b.x;
    r.y = y - b.y;
    r.z = z - b.z;

    return r;
}

Vector Vector::Negated() const {
    Vector r;

    r.x = -x;
    r.y = -y;
    r.z = -z;

    return r;
}

Vector Vector::Cross(Vector b) const {
    Vector r;

    r.x = -(z*b.y) + (y*b.z);
    r.y =  (z*b.x) - (x*b.z);
    r.z = -(y*b.x) + (x*b.y);

    return r;
}

double Vector::Dot(Vector b) const {
    return (x*b.x + y*b.y + z*b.z);
}

double Vector::DirectionCosineWith(Vector b) const {
    Vector a = this-&gt;WithMagnitude(1);
    b = b.WithMagnitude(1);
    return a.Dot(b);
}

Vector Vector::Normal(int which) const {
    Vector n;

    // Arbitrarily choose one vector that's normal to us, pivoting
    // appropriately.
    double xa = fabs(x), ya = fabs(y), za = fabs(z);
    if(this-&gt;Equals(Vector::From(0, 0, 1))) {
        // Make DXFs exported in the XY plane work nicely...
        n = Vector::From(1, 0, 0);
    } else if(xa &lt; ya &amp;&amp; xa &lt; za) {
        n.x = 0;
        n.y = z;
        n.z = -y;
    } else if(ya &lt; za) {
        n.x = -z;
        n.y = 0;
        n.z = x;
    } else {
        n.x = y;
        n.y = -x;
        n.z = 0;
    }

    if(which == 0) {
        // That's the vector we return.
    } else if(which == 1) {
        n = this-&gt;Cross(n);
    } else ssassert(false, "Unexpected vector normal index");

    n = n.WithMagnitude(1);

    return n;
}

Vector Vector::RotatedAbout(Vector orig, Vector axis, double theta) const {
    Vector r = this-&gt;Minus(orig);
    r = r.RotatedAbout(axis, theta);
    return r.Plus(orig);
}

Vector Vector::RotatedAbout(Vector axis, double theta) const {
    double c = cos(theta);
    double s = sin(theta);

    axis = axis.WithMagnitude(1);

    Vector r;

    r.x =   (x)*(c + (1 - c)*(axis.x)*(axis.x)) +
            (y)*((1 - c)*(axis.x)*(axis.y) - s*(axis.z)) +
            (z)*((1 - c)*(axis.x)*(axis.z) + s*(axis.y));

    r.y =   (x)*((1 - c)*(axis.y)*(axis.x) + s*(axis.z)) +
            (y)*(c + (1 - c)*(axis.y)*(axis.y)) +
            (z)*((1 - c)*(axis.y)*(axis.z) - s*(axis.x));

    r.z =   (x)*((1 - c)*(axis.z)*(axis.x) - s*(axis.y)) +
            (y)*((1 - c)*(axis.z)*(axis.y) + s*(axis.x)) +
            (z)*(c + (1 - c)*(axis.z)*(axis.z));

    return r;
}

Vector Vector::DotInToCsys(Vector u, Vector v, Vector n) const {
    Vector r = {
        this-&gt;Dot(u),
        this-&gt;Dot(v),
        this-&gt;Dot(n)
    };
    return r;
}

Vector Vector::ScaleOutOfCsys(Vector u, Vector v, Vector n) const {
    Vector r = u.ScaledBy(x).Plus(
               v.ScaledBy(y).Plus(
               n.ScaledBy(z)));
    return r;
}

Vector Vector::InPerspective(Vector u, Vector v, Vector n,
                             Vector origin, double cameraTan) const
{
    Vector r = this-&gt;Minus(origin);
    r = r.DotInToCsys(u, v, n);
    // yes, minus; we are assuming a csys where u cross v equals n, backwards
    // from the display stuff
    double w = (1 - r.z*cameraTan);
    r = r.ScaledBy(1/w);

    return r;
}

double Vector::DistanceToLine(Vector p0, Vector dp) const {
    double m = dp.Magnitude();
    return ((this-&gt;Minus(p0)).Cross(dp)).Magnitude() / m;
}

double Vector::DistanceToPlane(Vector normal, Vector origin) const {
    return this-&gt;Dot(normal) - origin.Dot(normal);
}

</t>
<t tx="leo.20191228122649.1">@path ./src/platform/
//-----------------------------------------------------------------------------
// Our main() function for the graphical interface.
//
// Copyright 2018 &lt;whitequark@whitequark.org&gt;
//-----------------------------------------------------------------------------
#include "solvespace.h"
#if defined(WIN32)
#   include &lt;windows.h&gt;
#endif

using namespace SolveSpace;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122649.10">@path ./src/platform/
//-----------------------------------------------------------------------------
// An abstraction for platform-dependent GUI functionality.
//
// Copyright 2018 whitequark
//-----------------------------------------------------------------------------

#ifndef SOLVESPACE_GUI_H
#define SOLVESPACE_GUI_H

namespace Platform {

//-----------------------------------------------------------------------------
// Events
//-----------------------------------------------------------------------------

// A mouse input event.
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122649.100">void SetTooltip(const std::string &amp;text, double x, double y,
                double width, double height) override {
    gtkWindow.set_tooltip(text, { (int)x, (int)y, (int)width, (int)height });
}

</t>
<t tx="leo.20191228122649.101">bool IsEditorVisible() override {
    return gtkWindow.get_editor_overlay().is_editing();
}

</t>
<t tx="leo.20191228122649.102">void ShowEditor(double x, double y, double fontHeight, double minWidth,
                bool isMonospace, const std::string &amp;text) override {
    gtkWindow.get_editor_overlay().start_editing(
        (int)x, (int)y, (int)fontHeight, (int)minWidth, isMonospace, text);
}

</t>
<t tx="leo.20191228122649.103">void HideEditor() override {
    gtkWindow.get_editor_overlay().stop_editing();
}

</t>
<t tx="leo.20191228122649.104">void SetScrollbarVisible(bool visible) override {
    if(visible) {
        gtkWindow.get_scrollbar().show();
    } else {
        gtkWindow.get_scrollbar().hide();
    }
}

</t>
<t tx="leo.20191228122649.105">void ConfigureScrollbar(double min, double max, double pageSize) override {
    auto adjustment = gtkWindow.get_scrollbar().get_adjustment();
    adjustment-&gt;configure(adjustment-&gt;get_value(), min, max, 1, 4, pageSize);
}

</t>
<t tx="leo.20191228122649.106">double GetScrollbarPosition() override {
    return gtkWindow.get_scrollbar().get_adjustment()-&gt;get_value();
}

</t>
<t tx="leo.20191228122649.107">void SetScrollbarPosition(double pos) override {
    return gtkWindow.get_scrollbar().get_adjustment()-&gt;set_value(pos);
}

</t>
<t tx="leo.20191228122649.108">void Invalidate() override {
    gtkWindow.get_gl_widget().queue_render();
}
</t>
<t tx="leo.20191228122649.109">void Open3DConnexion() {}
void Close3DConnexion() {}

#if defined(HAVE_SPACEWARE) &amp;&amp; defined(GDK_WINDOWING_X11)
static GdkFilterReturn GdkSpnavFilter(GdkXEvent *gdkXEvent, GdkEvent *gdkEvent, gpointer data) {
    XEvent *xEvent = (XEvent *)gdkXEvent;
    WindowImplGtk *window = (WindowImplGtk *)data;

    spnav_event spnavEvent;
    if(!spnav_x11_event(xEvent, &amp;spnavEvent)) {
        return GDK_FILTER_CONTINUE;
    }

    switch(spnavEvent.type) {
        case SPNAV_EVENT_MOTION: {
            SixDofEvent event = {};
            event.type = SixDofEvent::Type::MOTION;
            event.translationX = (double)spnavEvent.motion.x;
            event.translationY = (double)spnavEvent.motion.y;
            event.translationZ = (double)spnavEvent.motion.z  * -1.0;
            event.rotationX    = (double)spnavEvent.motion.rx *  0.001;
            event.rotationY    = (double)spnavEvent.motion.ry *  0.001;
            event.rotationZ    = (double)spnavEvent.motion.rz * -0.001;
            event.shiftDown    = xEvent-&gt;xmotion.state &amp; ShiftMask;
            event.controlDown  = xEvent-&gt;xmotion.state &amp; ControlMask;
            if(window-&gt;onSixDofEvent) {
                window-&gt;onSixDofEvent(event);
            }
            break;
        }

        case SPNAV_EVENT_BUTTON:
            SixDofEvent event = {};
            if(spnavEvent.button.press) {
                event.type = SixDofEvent::Type::PRESS;
            } else {
                event.type = SixDofEvent::Type::RELEASE;
            }
            switch(spnavEvent.button.bnum) {
                case 0:  event.button = SixDofEvent::Button::FIT; break;
                default: return GDK_FILTER_REMOVE;
            }
            event.shiftDown   = xEvent-&gt;xmotion.state &amp; ShiftMask;
            event.controlDown = xEvent-&gt;xmotion.state &amp; ControlMask;
            if(window-&gt;onSixDofEvent) {
                window-&gt;onSixDofEvent(event);
            }
            break;
    }

    return GDK_FILTER_REMOVE;
}

</t>
<t tx="leo.20191228122649.11">class MouseEvent {
public:
    enum class Type {
        MOTION,
        PRESS,
        DBL_PRESS,
        RELEASE,
        SCROLL_VERT,
        LEAVE,
    };

    enum class Button {
        NONE,
        LEFT,
        MIDDLE,
        RIGHT,
    };

    Type        type;
    double      x;
    double      y;
    bool        shiftDown;
    bool        controlDown;
    union {
        Button      button;       // for Type::{MOTION,PRESS,DBL_PRESS,RELEASE}
        double      scrollDelta;  // for Type::SCROLL_VERT
    };
};

// A 3-DOF input event.
struct SixDofEvent {
    enum class Type {
        MOTION,
        PRESS,
        RELEASE,
    };

    enum class Button {
        FIT,
    };

    Type   type;
    bool   shiftDown;
    bool   controlDown;
    double translationX, translationY, translationZ; // for Type::MOTION
    double rotationX,    rotationY,    rotationZ;    // for Type::MOTION
    Button button;                                   // for Type::{PRESS,RELEASE}
};

// A keyboard input event.
struct KeyboardEvent {
    enum class Type {
        PRESS,
        RELEASE,
    };

    enum class Key {
        CHARACTER,
        FUNCTION,
    };

    Type        type;
    Key         key;
    union {
        char32_t    chr; // for Key::CHARACTER
        int         num; // for Key::FUNCTION
    };
    bool        shiftDown;
    bool        controlDown;

</t>
<t tx="leo.20191228122649.110">void Request3DConnexionEventsForWindow(WindowRef window) {
    std::shared_ptr&lt;WindowImplGtk&gt; windowImpl =
        std::static_pointer_cast&lt;WindowImplGtk&gt;(window);

    Glib::RefPtr&lt;Gdk::Window&gt; gdkWindow = windowImpl-&gt;gtkWindow.get_window();
    if(GDK_IS_X11_DISPLAY(gdkWindow-&gt;get_display()-&gt;gobj())) {
        gdkWindow-&gt;add_filter(GdkSpnavFilter, windowImpl.get());
        spnav_x11_open(gdk_x11_get_default_xdisplay(),
                       gdk_x11_window_get_xid(gdkWindow-&gt;gobj()));
    }
}
#else
void Request3DConnexionEventsForWindow(WindowRef window) {}
</t>
<t tx="leo.20191228122649.111">class MessageDialogImplGtk final : public MessageDialog,
                                   public std::enable_shared_from_this&lt;MessageDialogImplGtk&gt; {
public:
    Gtk::Image         gtkImage;
    Gtk::MessageDialog gtkDialog;

    MessageDialogImplGtk(Gtk::Window &amp;parent)
        : gtkDialog(parent, "", /*use_markup=*/false, Gtk::MESSAGE_INFO,
                    Gtk::BUTTONS_NONE, /*modal=*/true)
    {
        SetTitle("Message");
    }

    @others
};

MessageDialogRef CreateMessageDialog(WindowRef parentWindow) {
    return std::make_shared&lt;MessageDialogImplGtk&gt;(
                std::static_pointer_cast&lt;WindowImplGtk&gt;(parentWindow)-&gt;gtkWindow);
}

//-----------------------------------------------------------------------------
// File dialogs
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.112">void SetType(Type type) override {
    switch(type) {
        case Type::INFORMATION:
            gtkImage.set_from_icon_name("dialog-information", Gtk::ICON_SIZE_DIALOG);
            break;

        case Type::QUESTION:
            gtkImage.set_from_icon_name("dialog-question", Gtk::ICON_SIZE_DIALOG);
            break;

        case Type::WARNING:
            gtkImage.set_from_icon_name("dialog-warning", Gtk::ICON_SIZE_DIALOG);
            break;

        case Type::ERROR:
            gtkImage.set_from_icon_name("dialog-error", Gtk::ICON_SIZE_DIALOG);
            break;
    }
    gtkDialog.set_image(gtkImage);
}

</t>
<t tx="leo.20191228122649.113">void SetTitle(std::string title) override {
    gtkDialog.set_title(PrepareTitle(title));
}

</t>
<t tx="leo.20191228122649.114">void SetMessage(std::string message) override {
    gtkDialog.set_message(message);
}

</t>
<t tx="leo.20191228122649.115">void SetDescription(std::string description) override {
    gtkDialog.set_secondary_text(description);
}

</t>
<t tx="leo.20191228122649.116">void AddButton(std::string label, Response response, bool isDefault) override {
    int responseId = 0;
    switch(response) {
        case Response::NONE:   ssassert(false, "Unexpected response");
        case Response::OK:     responseId = Gtk::RESPONSE_OK;     break;
        case Response::YES:    responseId = Gtk::RESPONSE_YES;    break;
        case Response::NO:     responseId = Gtk::RESPONSE_NO;     break;
        case Response::CANCEL: responseId = Gtk::RESPONSE_CANCEL; break;
    }
    gtkDialog.add_button(PrepareMnemonics(label), responseId);
    if(isDefault) {
        gtkDialog.set_default_response(responseId);
    }
}

Response ProcessResponse(int gtkResponse) {
    Response response;
    switch(gtkResponse) {
        case Gtk::RESPONSE_OK:     response = Response::OK;     break;
        case Gtk::RESPONSE_YES:    response = Response::YES;    break;
        case Gtk::RESPONSE_NO:     response = Response::NO;     break;
        case Gtk::RESPONSE_CANCEL: response = Response::CANCEL; break;

        case Gtk::RESPONSE_NONE:
        case Gtk::RESPONSE_CLOSE:
        case Gtk::RESPONSE_DELETE_EVENT:
            response = Response::NONE;
            break;

        default: ssassert(false, "Unexpected response");
    }

    if(onResponse) {
        onResponse(response);
    }
    return response;
}

</t>
<t tx="leo.20191228122649.117">void ShowModal() override {
    gtkDialog.signal_hide().connect([this] {
        @others
}

Response RunModal() override {
    return ProcessResponse(gtkDialog.run());
}
</t>
<t tx="leo.20191228122649.118">    auto it = std::remove(shownMessageDialogs.begin(), shownMessageDialogs.end(),
                          shared_from_this());
    shownMessageDialogs.erase(it);
});
shownMessageDialogs.push_back(shared_from_this());

gtkDialog.signal_response().connect([this](int gtkResponse) {
    ProcessResponse(gtkResponse);
    gtkDialog.hide();
});
gtkDialog.show();
</t>
<t tx="leo.20191228122649.119">class FileDialogImplGtk : public FileDialog {
public:
    Gtk::FileChooser           *gtkChooser;
    std::vector&lt;std::string&gt;    extensions;

    @others
};

</t>
<t tx="leo.20191228122649.12">    bool Equals(const KeyboardEvent &amp;other) {
        return type == other.type &amp;&amp; key == other.key &amp;&amp;
            shiftDown == other.shiftDown &amp;&amp; controlDown == other.controlDown &amp;&amp;
            ((key == Key::CHARACTER &amp;&amp; chr == other.chr) ||
             (key == Key::FUNCTION &amp;&amp; num == other.num));
    }
};

std::string AcceleratorDescription(const KeyboardEvent &amp;accel);

//-----------------------------------------------------------------------------
// Interfaces
//-----------------------------------------------------------------------------

// Handling fatal errors.
#if defined(__GNUC__)
__attribute__((noreturn))
#endif
void FatalError(const std::string &amp;message);

// A native settings store.
</t>
<t tx="leo.20191228122649.120">void InitFileChooser(Gtk::FileChooser &amp;chooser) {
    gtkChooser = &amp;chooser;
    gtkChooser-&gt;property_filter().signal_changed().
        connect(sigc::mem_fun(this, &amp;FileDialogImplGtk::FilterChanged));
}

</t>
<t tx="leo.20191228122649.121">void SetCurrentName(std::string name) override {
    gtkChooser-&gt;set_current_name(name);
}

Platform::Path GetFilename() override {
    return Path::From(gtkChooser-&gt;get_filename());
}

</t>
<t tx="leo.20191228122649.122">void SetFilename(Platform::Path path) override {
    gtkChooser-&gt;set_filename(path.raw);
}

</t>
<t tx="leo.20191228122649.123">void AddFilter(std::string name, std::vector&lt;std::string&gt; extensions) override {
    Glib::RefPtr&lt;Gtk::FileFilter&gt; gtkFilter = Gtk::FileFilter::create();
    Glib::ustring desc;
    for(auto extension : extensions) {
        Glib::ustring pattern = "*";
        if(!extension.empty()) {
            pattern = "*." + extension;
            gtkFilter-&gt;add_pattern(pattern);
            gtkFilter-&gt;add_pattern(Glib::ustring(pattern).uppercase());
        }
        if(!desc.empty()) {
            desc += ", ";
        }
        desc += pattern;
    }
    gtkFilter-&gt;set_name(name + " (" + desc + ")");

    this-&gt;extensions.push_back(extensions.front());
    gtkChooser-&gt;add_filter(gtkFilter);
}

std::string GetExtension() {
    auto filters = gtkChooser-&gt;list_filters();
    size_t filterIndex =
        std::find(filters.begin(), filters.end(), gtkChooser-&gt;get_filter()) -
        filters.begin();
    if(filterIndex &lt; extensions.size()) {
        return extensions[filterIndex];
    } else {
        return extensions.front();
    }
}

</t>
<t tx="leo.20191228122649.124">void SetExtension(std::string extension) {
    auto filters = gtkChooser-&gt;list_filters();
    size_t extensionIndex =
        std::find(extensions.begin(), extensions.end(), extension) -
        extensions.begin();
    if(extensionIndex &lt; filters.size()) {
        gtkChooser-&gt;set_filter(filters[extensionIndex]);
    } else {
        gtkChooser-&gt;set_filter(filters.front());
    }
}

</t>
<t tx="leo.20191228122649.125">void FilterChanged() {
    std::string extension = GetExtension();
    if(extension.empty())
        return;

    Platform::Path path = GetFilename();
    SetCurrentName(path.WithExtension(extension).FileName());
}

</t>
<t tx="leo.20191228122649.126">void FreezeChoices(SettingsRef settings, const std::string &amp;key) override {
    settings-&gt;FreezeString("Dialog_" + key + "_Folder",
                           gtkChooser-&gt;get_current_folder());
    settings-&gt;FreezeString("Dialog_" + key + "_Filter", GetExtension());
}

</t>
<t tx="leo.20191228122649.127">void ThawChoices(SettingsRef settings, const std::string &amp;key) override {
    gtkChooser-&gt;set_current_folder(settings-&gt;ThawString("Dialog_" + key + "_Folder"));
    SetExtension(settings-&gt;ThawString("Dialog_" + key + "_Filter"));
}

</t>
<t tx="leo.20191228122649.128">void CheckForUntitledFile() {
    if(gtkChooser-&gt;get_action() == Gtk::FILE_CHOOSER_ACTION_SAVE &amp;&amp;
            Path::From(gtkChooser-&gt;get_current_name()).FileStem().empty()) {
        gtkChooser-&gt;set_current_name(std::string(_("untitled")) + "." + GetExtension());
    }
}
</t>
<t tx="leo.20191228122649.129">class FileDialogGtkImplGtk final : public FileDialogImplGtk {
public:
    Gtk::FileChooserDialog      gtkDialog;

    FileDialogGtkImplGtk(Gtk::Window &amp;gtkParent, bool isSave)
        : gtkDialog(gtkParent,
                    isSave ? C_("title", "Save File")
                           : C_("title", "Open File"),
                    isSave ? Gtk::FILE_CHOOSER_ACTION_SAVE
                           : Gtk::FILE_CHOOSER_ACTION_OPEN) {
        gtkDialog.add_button(C_("button", "_Cancel"), Gtk::RESPONSE_CANCEL);
        gtkDialog.add_button(isSave ? C_("button", "_Save")
                                    : C_("button", "_Open"), Gtk::RESPONSE_OK);
        gtkDialog.set_default_response(Gtk::RESPONSE_OK);
        InitFileChooser(gtkDialog);
    }

    @others
};

#if defined(HAVE_GTK_FILECHOOSERNATIVE)

</t>
<t tx="leo.20191228122649.13">class Settings {
public:
    virtual ~Settings() = default;

    virtual void FreezeInt(const std::string &amp;key, uint32_t value) = 0;
    virtual uint32_t ThawInt(const std::string &amp;key, uint32_t defaultValue = 0) = 0;

    virtual void FreezeFloat(const std::string &amp;key, double value) = 0;
    virtual double ThawFloat(const std::string &amp;key, double defaultValue = 0.0) = 0;

    virtual void FreezeString(const std::string &amp;key, const std::string &amp;value) = 0;
    virtual std::string ThawString(const std::string &amp;key,
                                   const std::string &amp;defaultValue = "") = 0;

    virtual void FreezeBool(const std::string &amp;key, bool value);
    virtual bool ThawBool(const std::string &amp;key, bool defaultValue = false);

    virtual void FreezeColor(const std::string &amp;key, RgbaColor value);
    virtual RgbaColor ThawColor(const std::string &amp;key, RgbaColor defaultValue);
};

typedef std::shared_ptr&lt;Settings&gt; SettingsRef;

SettingsRef GetSettings();

// A native single-shot timer.
</t>
<t tx="leo.20191228122649.130">void SetTitle(std::string title) override {
    gtkDialog.set_title(PrepareTitle(title));
}

</t>
<t tx="leo.20191228122649.131">bool RunModal() override {
    CheckForUntitledFile();
    if(gtkDialog.run() == Gtk::RESPONSE_OK) {
        return true;
    } else {
        return false;
    }
}
</t>
<t tx="leo.20191228122649.132">class FileDialogNativeImplGtk final : public FileDialogImplGtk {
public:
    Glib::RefPtr&lt;Gtk::FileChooserNative&gt; gtkNative;

    FileDialogNativeImplGtk(Gtk::Window &amp;gtkParent, bool isSave) {
        gtkNative = Gtk::FileChooserNative::create(
            isSave ? C_("title", "Save File")
                   : C_("title", "Open File"),
            gtkParent,
            isSave ? Gtk::FILE_CHOOSER_ACTION_SAVE
                   : Gtk::FILE_CHOOSER_ACTION_OPEN,
            isSave ? C_("button", "_Save")
                   : C_("button", "_Open"),
            C_("button", "_Cancel"));
        // Seriously, GTK?!
        InitFileChooser(*gtkNative.operator-&gt;());
    }

    @others
};

#endif

#if defined(HAVE_GTK_FILECHOOSERNATIVE)
#   define FILE_DIALOG_IMPL FileDialogNativeImplGtk
#else
#   define FILE_DIALOG_IMPL FileDialogGtkImplGtk
#endif

FileDialogRef CreateOpenFileDialog(WindowRef parentWindow) {
    Gtk::Window &amp;gtkParent = std::static_pointer_cast&lt;WindowImplGtk&gt;(parentWindow)-&gt;gtkWindow;
    return std::make_shared&lt;FILE_DIALOG_IMPL&gt;(gtkParent, /*isSave=*/false);
}

FileDialogRef CreateSaveFileDialog(WindowRef parentWindow) {
    Gtk::Window &amp;gtkParent = std::static_pointer_cast&lt;WindowImplGtk&gt;(parentWindow)-&gt;gtkWindow;
    return std::make_shared&lt;FILE_DIALOG_IMPL&gt;(gtkParent, /*isSave=*/true);
}

//-----------------------------------------------------------------------------
// Application-wide APIs
//-----------------------------------------------------------------------------

std::vector&lt;Platform::Path&gt; GetFontFiles() {
    std::vector&lt;Platform::Path&gt; fonts;

    // fontconfig is already initialized by GTK
    FcPattern   *pat = FcPatternCreate();
    FcObjectSet *os  = FcObjectSetBuild(FC_FILE, (char *)0);
    FcFontSet   *fs  = FcFontList(0, pat, os);

    for(int i = 0; i &lt; fs-&gt;nfont; i++) {
        FcChar8 *filenameFC = FcPatternFormat(fs-&gt;fonts[i], (const FcChar8*) "%{file}");
        fonts.push_back(Platform::Path::From((const char *)filenameFC));
        FcStrFree(filenameFC);
    }

    FcFontSetDestroy(fs);
    FcObjectSetDestroy(os);
    FcPatternDestroy(pat);

    return fonts;
}

</t>
<t tx="leo.20191228122649.133">void SetTitle(std::string title) override {
    gtkNative-&gt;set_title(PrepareTitle(title));
}

</t>
<t tx="leo.20191228122649.134">bool RunModal() override {
    CheckForUntitledFile();
    if(gtkNative-&gt;run() == Gtk::RESPONSE_ACCEPT) {
        return true;
    } else {
        return false;
    }
}
</t>
<t tx="leo.20191228122649.135">void OpenInBrowser(const std::string &amp;url) {
    gtk_show_uri(Gdk::Screen::get_default()-&gt;gobj(), url.c_str(), GDK_CURRENT_TIME, NULL);
}

Gtk::Main *gtkMain;

</t>
<t tx="leo.20191228122649.136">void InitGui(int argc, char **argv) {
    // It would in principle be possible to judiciously use Glib::filename_{from,to}_utf8,
    // but it's not really worth the effort.
    // The setlocale() call is necessary for Glib::get_charset() to detect the system
    // character set; otherwise it thinks it is always ANSI_X3.4-1968.
    // We set it back to C after all so that printf() and friends behave in a consistent way.
    setlocale(LC_ALL, "");
    if(!Glib::get_charset()) {
        dbp("Sorry, only UTF-8 locales are supported.");
        exit(1);
    }
    setlocale(LC_ALL, "C");

    gtkMain = new Gtk::Main(argc, argv, /*set_locale=*/false);

    // Add our application-specific styles, to override GTK defaults.
    Glib::RefPtr&lt;Gtk::CssProvider&gt; style_provider = Gtk::CssProvider::create();
    style_provider-&gt;load_from_data(R"(
    entry {
        background: white;
        color: black;
    }
    )");
    Gtk::StyleContext::add_provider_for_screen(
        Gdk::Screen::get_default(), style_provider,
        600 /*Gtk::STYLE_PROVIDER_PRIORITY_APPLICATION*/);

    // Set locale from user preferences.
    // This apparently only consults the LANGUAGE environment variable.
    const char* const* langNames = g_get_language_names();
    while(*langNames) {
        if(SetLocale(*langNames++)) break;
    }
    if(!*langNames) {
        SetLocale("en_US");
    }
}

</t>
<t tx="leo.20191228122649.137">void RunGui() {
    Gtk::Main::run();
}

</t>
<t tx="leo.20191228122649.138">void ExitGui() {
    Gtk::Main::quit();
}

</t>
<t tx="leo.20191228122649.139">void ClearGui() {
    delete gtkMain;
}

}
}
</t>
<t tx="leo.20191228122649.14">class Timer {
public:
    std::function&lt;void()&gt;   onTimeout;

    virtual ~Timer() = default;

    virtual void RunAfter(unsigned milliseconds) = 0;
    virtual void RunAfterNextFrame() { RunAfter(1); }
    virtual void RunAfterProcessingEvents() { RunAfter(0); }
};

typedef std::shared_ptr&lt;Timer&gt; TimerRef;

TimerRef CreateTimer();

// A native menu item.
</t>
<t tx="leo.20191228122649.140">@path ./src/platform/
//-----------------------------------------------------------------------------
// Our platform support functions for the headless (no OpenGL) test runner.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include "solvespace.h"
#include &lt;cairo.h&gt;

namespace SolveSpace {

//-----------------------------------------------------------------------------
// Rendering
//-----------------------------------------------------------------------------

std::shared_ptr&lt;ViewportCanvas&gt; CreateRenderer() {
    return std::make_shared&lt;CairoPixmapRenderer&gt;();
}

namespace Platform {

//-----------------------------------------------------------------------------
// Fatal errors
//-----------------------------------------------------------------------------

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122649.141">void FatalError(const std::string &amp;message) {
    fprintf(stderr, "%s", message.c_str());

#if !defined(LIBRARY) &amp;&amp; defined(HAVE_BACKTRACE)
    static void *ptrs[1024] = {};
    size_t nptrs = backtrace(ptrs, sizeof(ptrs) / sizeof(ptrs[0]));
    char **syms = backtrace_symbols(ptrs, nptrs);

    fprintf(stderr, "Backtrace:\n");
    if(syms != NULL) {
        for(size_t i = 0; i &lt; nptrs; i++) {
            fprintf(stderr, "%2zu: %s\n", i, syms[i]);
        }
    } else {
        for(size_t i = 0; i &lt; nptrs; i++) {
            fprintf(stderr, "%2zu: %p\n", i, ptrs[i]);
        }
    }
#else
    fprintf(stderr, "Backtrace support not compiled in.\n");
#endif

    abort();
}

//-----------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.142">class SettingsImplDummy final : public Settings {
public:
    @others
};

SettingsRef GetSettings() {
</t>
<t tx="leo.20191228122649.143">void FreezeInt(const std::string &amp;key, uint32_t value) override {
}

uint32_t ThawInt(const std::string &amp;key, uint32_t defaultValue = 0) override {
    return defaultValue;
}

</t>
<t tx="leo.20191228122649.144">void FreezeFloat(const std::string &amp;key, double value) override {
}

</t>
<t tx="leo.20191228122649.145">double ThawFloat(const std::string &amp;key, double defaultValue = 0.0) override {
    return defaultValue;
}

</t>
<t tx="leo.20191228122649.146">void FreezeString(const std::string &amp;key, const std::string &amp;value) override {
}

std::string ThawString(const std::string &amp;key, const std::string &amp;defaultValue = "") override {
    return defaultValue;
}
</t>
<t tx="leo.20191228122649.147">    static std::shared_ptr&lt;SettingsImplDummy&gt; settings =
                std::make_shared&lt;SettingsImplDummy&gt;();
    return settings;
}

//-----------------------------------------------------------------------------
// Timers
//-----------------------------------------------------------------------------

class TimerImplDummy final : public Timer {
public:
</t>
<t tx="leo.20191228122649.148">    void RunAfter(unsigned milliseconds) override {}
};

TimerRef CreateTimer() {
    return std::make_shared&lt;TimerImplDummy&gt;();
}

//-----------------------------------------------------------------------------
// Menus
//-----------------------------------------------------------------------------

MenuRef CreateMenu() {
    return std::shared_ptr&lt;Menu&gt;();
}

MenuBarRef GetOrCreateMainMenu(bool *unique) {
    *unique = false;
    return std::shared_ptr&lt;MenuBar&gt;();
}

//-----------------------------------------------------------------------------
// Windows
//-----------------------------------------------------------------------------

WindowRef CreateWindow(Window::Kind kind, WindowRef parentWindow) {
    return std::shared_ptr&lt;Window&gt;();
}

</t>
<t tx="leo.20191228122649.149">void Request3DConnexionEventsForWindow(WindowRef window) {}

//-----------------------------------------------------------------------------
// Message dialogs
//-----------------------------------------------------------------------------

MessageDialogRef CreateMessageDialog(WindowRef parentWindow) {
    return std::shared_ptr&lt;MessageDialog&gt;();
}

//-----------------------------------------------------------------------------
// File dialogs
//-----------------------------------------------------------------------------

FileDialogRef CreateOpenFileDialog(WindowRef parentWindow) {
    return std::shared_ptr&lt;FileDialog&gt;();
}

FileDialogRef CreateSaveFileDialog(WindowRef parentWindow) {
    return std::shared_ptr&lt;FileDialog&gt;();
}

//-----------------------------------------------------------------------------
// Application-wide APIs
//-----------------------------------------------------------------------------

std::vector&lt;Platform::Path&gt; fontFiles;
std::vector&lt;Platform::Path&gt; GetFontFiles() {
    return fontFiles;
}

</t>
<t tx="leo.20191228122649.15">class MenuItem {
public:
    enum class Indicator {
        NONE,
        CHECK_MARK,
        RADIO_MARK,
    };

    std::function&lt;void()&gt;   onTrigger;

    virtual ~MenuItem() = default;

    virtual void SetAccelerator(KeyboardEvent accel) = 0;
    virtual void SetIndicator(Indicator type) = 0;
    virtual void SetEnabled(bool enabled) = 0;
    virtual void SetActive(bool active) = 0;
};

typedef std::shared_ptr&lt;MenuItem&gt; MenuItemRef;

// A native menu.
</t>
<t tx="leo.20191228122649.150">void OpenInBrowser(const std::string &amp;url) {}

void InitGui(int argc, char **argv) {}

void RunGui() {}

void ExitGui() {
    exit(0);
}

void ClearGui() {}
</t>
<t tx="leo.20191228122649.151">@path ./src/platform/
//-----------------------------------------------------------------------------
// The Win32-based implementation of platform-dependent GUI functionality.
//
// Copyright 2018 whitequark
//-----------------------------------------------------------------------------
#include "config.h"
#include "solvespace.h"
// Include after solvespace.h to avoid identifier clashes.
#include &lt;windows.h&gt;
#include &lt;windowsx.h&gt;
#include &lt;commctrl.h&gt;
#include &lt;commdlg.h&gt;
#include &lt;shellapi.h&gt;

// Macros to compile under XP
#if !defined(LSTATUS)
#   define LSTATUS LONG
#endif

#if !defined(MAPVK_VK_TO_CHAR)
#   define MAPVK_VK_TO_CHAR 2
#endif

#if !defined(USER_DEFAULT_SCREEN_DPI)
#   define USER_DEFAULT_SCREEN_DPI 96
#endif

#if !defined(TTM_POPUP)
#   define TTM_POPUP (WM_USER + 34)
#endif
// End macros to compile under XP

#if !defined(WM_DPICHANGED)
#   define WM_DPICHANGED 0x02E0
#endif

// These interfere with our identifiers.
#undef CreateWindow
#undef ERROR

#if HAVE_OPENGL == 3
#   define EGLAPI /*static linkage*/
#   define EGL_EGLEXT_PROTOTYPES
#   include &lt;EGL/egl.h&gt;
#   include &lt;EGL/eglext.h&gt;
#endif

#if defined(HAVE_SPACEWARE)
#   include &lt;si.h&gt;
#   include &lt;siapp.h&gt;
#   undef uint32_t
#endif

#if defined(__GNUC__)
// Disable bogus warning emitted by GCC on GetProcAddress, since there seems to be no way
// of restructuring the code to easily disable it just at the call site.
#pragma GCC diagnostic ignored "-Wcast-function-type"
#endif

namespace SolveSpace {
namespace Platform {

//-----------------------------------------------------------------------------
// Windows API bridging
//-----------------------------------------------------------------------------

#define sscheck(expr) do {                                                    \
        SetLastError(0);                                                      \
        if(!(expr))                                                           \
            CheckLastError(__FILE__, __LINE__, __func__, #expr);              \
    } while(0)

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122649.152">void CheckLastError(const char *file, int line, const char *function, const char *expr) {
    if(GetLastError() != S_OK) {
        LPWSTR messageW;
        FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
                       NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       (LPWSTR)&amp;messageW, 0, NULL);

        std::string message;
        message += ssprintf("File %s, line %u, function %s:\n", file, line, function);
        message += ssprintf("Win32 API call failed: %s.\n", expr);
        message += ssprintf("Error: %s", Narrow(messageW).c_str());
        FatalError(message);
    }
}

typedef UINT (WINAPI *LPFNGETDPIFORWINDOW)(HWND);

UINT ssGetDpiForWindow(HWND hwnd) {
    static bool checked;
    static LPFNGETDPIFORWINDOW lpfnGetDpiForWindow;
    if(!checked) {
        checked = true;
        lpfnGetDpiForWindow = (LPFNGETDPIFORWINDOW)
            GetProcAddress(GetModuleHandleW(L"user32.dll"), "GetDpiForWindow");
    }
    if(lpfnGetDpiForWindow) {
        return lpfnGetDpiForWindow(hwnd);
    } else {
        HDC hDc;
        sscheck(hDc = GetDC(HWND_DESKTOP));
        UINT dpi;
        sscheck(dpi = GetDeviceCaps(hDc, LOGPIXELSX));
        sscheck(ReleaseDC(HWND_DESKTOP, hDc));
        return dpi;
    }
}

typedef BOOL (WINAPI *LPFNADJUSTWINDOWRECTEXFORDPI)(LPRECT, DWORD, BOOL, DWORD, UINT);

BOOL ssAdjustWindowRectExForDpi(LPRECT lpRect, DWORD dwStyle, BOOL bMenu,
                                DWORD dwExStyle, UINT dpi) {
    static bool checked;
    static LPFNADJUSTWINDOWRECTEXFORDPI lpfnAdjustWindowRectExForDpi;
    if(!checked) {
        checked = true;
        lpfnAdjustWindowRectExForDpi = (LPFNADJUSTWINDOWRECTEXFORDPI)
            GetProcAddress(GetModuleHandleW(L"user32.dll"), "AdjustWindowRectExForDpi");
    }
    if(lpfnAdjustWindowRectExForDpi) {
        return lpfnAdjustWindowRectExForDpi(lpRect, dwStyle, bMenu, dwExStyle, dpi);
    } else {
        return AdjustWindowRectEx(lpRect, dwStyle, bMenu, dwExStyle);
    }
}

//-----------------------------------------------------------------------------
// Utility functions
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.153">static std::wstring PrepareTitle(const std::string &amp;s) {
    return Widen("SolveSpace - " + s);
}

</t>
<t tx="leo.20191228122649.154">static std::string NegateMnemonics(const std::string &amp;label) {
    std::string newLabel;
    for(char c : label) {
        newLabel.push_back(c);
        if(c == '&amp;') newLabel.push_back(c);
    }
    return newLabel;
}

</t>
<t tx="leo.20191228122649.155">static int Clamp(int x, int a, int b) {
    return max(a, min(x, b));
}

//-----------------------------------------------------------------------------
// Fatal errors
//-----------------------------------------------------------------------------

bool handlingFatalError = false;

</t>
<t tx="leo.20191228122649.156">void FatalError(const std::string &amp;message) {
    // Indicate that we're handling a fatal error, to avoid re-entering application code
    // and potentially crashing even harder.
    handlingFatalError = true;

    switch(MessageBoxW(NULL, Platform::Widen(message + "\nGenerate debug report?").c_str(),
                       L"Fatal error — SolveSpace",
                       MB_ICONERROR|MB_TASKMODAL|MB_SETFOREGROUND|MB_TOPMOST|
                       MB_OKCANCEL|MB_DEFBUTTON2)) {
        case IDOK:
            abort();

        case IDCANCEL:
        default: {
            WCHAR appPath[MAX_PATH] = {};
            GetModuleFileNameW(NULL, appPath, sizeof(appPath));
            ShellExecuteW(NULL, L"open", appPath, NULL, NULL, SW_SHOW);
            _exit(1);
        }
    }
}
//-----------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.157">class SettingsImplWin32 final : public Settings {
public:
    HKEY hKey = NULL;

    HKEY GetKey() {
        if(hKey == NULL) {
            sscheck(RegCreateKeyExW(HKEY_CURRENT_USER, L"Software\\SolveSpace", 0, NULL, 0,
                                    KEY_ALL_ACCESS, NULL, &amp;hKey, NULL));
        }
        return hKey;
    }

    ~SettingsImplWin32() {
        if(hKey != NULL) {
            sscheck(RegCloseKey(hKey));
        }
    }

    @others
};

SettingsRef GetSettings() {
    return std::make_shared&lt;SettingsImplWin32&gt;();
}

//-----------------------------------------------------------------------------
// Timers
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.158">void FreezeInt(const std::string &amp;key, uint32_t value) {
    sscheck(RegSetValueExW(GetKey(), &amp;Widen(key)[0], 0,
                           REG_DWORD, (const BYTE *)&amp;value, sizeof(value)));
}

uint32_t ThawInt(const std::string &amp;key, uint32_t defaultValue) {
    DWORD value;
    DWORD type, length = sizeof(value);
    LSTATUS result = RegQueryValueExW(GetKey(), &amp;Widen(key)[0], 0,
                                      &amp;type, (BYTE *)&amp;value, &amp;length);
    if(result == ERROR_SUCCESS &amp;&amp; type == REG_DWORD) {
        return value;
    }
    return defaultValue;
}

</t>
<t tx="leo.20191228122649.159">void FreezeFloat(const std::string &amp;key, double value) {
    sscheck(RegSetValueExW(GetKey(), &amp;Widen(key)[0], 0,
                           REG_QWORD, (const BYTE *)&amp;value, sizeof(value)));
}

</t>
<t tx="leo.20191228122649.16">class Menu {
public:
    virtual ~Menu() = default;

    virtual std::shared_ptr&lt;MenuItem&gt; AddItem(
        const std::string &amp;label, std::function&lt;void()&gt; onTrigger = std::function&lt;void()&gt;(),

// A native menu bar.
@others
</t>
<t tx="leo.20191228122649.160">double ThawFloat(const std::string &amp;key, double defaultValue) {
    double value;
    DWORD type, length = sizeof(value);
    LSTATUS result = RegQueryValueExW(GetKey(), &amp;Widen(key)[0], 0,
                                      &amp;type, (BYTE *)&amp;value, &amp;length);
    if(result == ERROR_SUCCESS &amp;&amp; type == REG_QWORD) {
        return value;
    }
    return defaultValue;
}

</t>
<t tx="leo.20191228122649.161">void FreezeString(const std::string &amp;key, const std::string &amp;value) {
    ssassert(value.length() == strlen(value.c_str()),
             "illegal null byte in middle of a string setting");
    std::wstring valueW = Widen(value);
    sscheck(RegSetValueExW(GetKey(), &amp;Widen(key)[0], 0,
                           REG_SZ, (const BYTE *)&amp;valueW[0], (valueW.length() + 1) * 2));
}

std::string ThawString(const std::string &amp;key, const std::string &amp;defaultValue) {
    DWORD type, length = 0;
    LSTATUS result = RegQueryValueExW(GetKey(), &amp;Widen(key)[0], 0,
                                      &amp;type, NULL, &amp;length);
    if(result == ERROR_SUCCESS &amp;&amp; type == REG_SZ) {
        std::wstring valueW;
        valueW.resize(length / 2 - 1);
        sscheck(RegQueryValueExW(GetKey(), &amp;Widen(key)[0], 0,
                                 &amp;type, (BYTE *)&amp;valueW[0], &amp;length));
        return Narrow(valueW);
    }
    return defaultValue;
}
</t>
<t tx="leo.20191228122649.162">class TimerImplWin32 final : public Timer {
public:
    @others
};

TimerRef CreateTimer() {
    return std::make_shared&lt;TimerImplWin32&gt;();
}

//-----------------------------------------------------------------------------
// Menus
//-----------------------------------------------------------------------------

class MenuImplWin32;

</t>
<t tx="leo.20191228122649.163">static HWND WindowHandle() {
    static HWND hTimerWnd;
    if(hTimerWnd == NULL) {
        sscheck(hTimerWnd = CreateWindowExW(0, L"Message", NULL, 0, 0, 0, 0, 0,
                                            HWND_MESSAGE, NULL, NULL, NULL));
    }
    return hTimerWnd;
}

</t>
<t tx="leo.20191228122649.164">static void CALLBACK TimerFunc(HWND hwnd, UINT msg, UINT_PTR event, DWORD time) {
    sscheck(KillTimer(WindowHandle(), event));

    TimerImplWin32 *timer = (TimerImplWin32*)event;
    if(timer-&gt;onTimeout) {
        timer-&gt;onTimeout();
    }
}

</t>
<t tx="leo.20191228122649.165">void RunAfter(unsigned milliseconds) override {
    // FIXME(platform/gui): use SetCoalescableTimer when it's available (8+)
    sscheck(SetTimer(WindowHandle(), (UINT_PTR)this,
                     milliseconds, &amp;TimerImplWin32::TimerFunc));
}

~TimerImplWin32() {
    // FIXME(platform/gui): there's a race condition here--WM_TIMER messages already
    // posted to the queue are not removed, so this destructor is at most "best effort".
    KillTimer(WindowHandle(), (UINT_PTR)this);
}
</t>
<t tx="leo.20191228122649.166">class MenuItemImplWin32 final : public MenuItem {
public:
    std::shared_ptr&lt;MenuImplWin32&gt; menu;

    HMENU Handle();

    MENUITEMINFOW GetInfo(UINT mask) {
        MENUITEMINFOW mii = {};
        mii.cbSize = sizeof(mii);
        mii.fMask  = mask;
        sscheck(GetMenuItemInfoW(Handle(), (UINT_PTR)this, FALSE, &amp;mii));
        return mii;
    }

    @others
};

int64_t contextMenuPopTime = 0;

</t>
<t tx="leo.20191228122649.167">void SetAccelerator(KeyboardEvent accel) override {
    MENUITEMINFOW mii = GetInfo(MIIM_TYPE);

    std::wstring nameW(mii.cch, L'\0');
    mii.dwTypeData = &amp;nameW[0];
    mii.cch++;
    sscheck(GetMenuItemInfoW(Handle(), (UINT_PTR)this, FALSE, &amp;mii));

    std::string name = Narrow(nameW);
    if(name.find('\t') != std::string::npos) {
        name = name.substr(0, name.find('\t'));
    }
    name += '\t';
    name += AcceleratorDescription(accel);

    nameW = Widen(name);
    mii.fMask      = MIIM_STRING;
    mii.dwTypeData = &amp;nameW[0];
    sscheck(SetMenuItemInfoW(Handle(), (UINT_PTR)this, FALSE, &amp;mii));
}

</t>
<t tx="leo.20191228122649.168">void SetIndicator(Indicator type) override {
    MENUITEMINFOW mii = GetInfo(MIIM_FTYPE);
    switch(type) {
        case Indicator::NONE:
        case Indicator::CHECK_MARK:
            mii.fType &amp;= ~MFT_RADIOCHECK;
            break;

        case Indicator::RADIO_MARK:
            mii.fType |= MFT_RADIOCHECK;
            break;
    }
    sscheck(SetMenuItemInfoW(Handle(), (UINT_PTR)this, FALSE, &amp;mii));
}

</t>
<t tx="leo.20191228122649.169">void SetActive(bool active) override {
    MENUITEMINFOW mii = GetInfo(MIIM_STATE);
    if(active) {
        mii.fState |= MFS_CHECKED;
    } else {
        mii.fState &amp;= ~MFS_CHECKED;
    }
    sscheck(SetMenuItemInfoW(Handle(), (UINT_PTR)this, FALSE, &amp;mii));
}

</t>
<t tx="leo.20191228122649.17">class MenuBar {
public:
    virtual ~MenuBar() = default;

    virtual std::shared_ptr&lt;Menu&gt; AddSubMenu(const std::string &amp;label) = 0;

    virtual void Clear() = 0;
};

typedef std::shared_ptr&lt;MenuBar&gt; MenuBarRef;

MenuRef CreateMenu();
MenuBarRef GetOrCreateMainMenu(bool *unique);

// A native top-level window, with an OpenGL context, and an editor overlay.
</t>
<t tx="leo.20191228122649.170">void SetEnabled(bool enabled) override {
    MENUITEMINFOW mii = GetInfo(MIIM_STATE);
    if(enabled) {
        mii.fState &amp;= ~(MFS_DISABLED|MFS_GRAYED);
    } else {
        mii.fState |= MFS_DISABLED|MFS_GRAYED;
    }
    sscheck(SetMenuItemInfoW(Handle(), (UINT_PTR)this, FALSE, &amp;mii));
}
</t>
<t tx="leo.20191228122649.171">class MenuImplWin32 final : public Menu {
public:
    HMENU hMenu;

    std::weak_ptr&lt;MenuImplWin32&gt; weakThis;
    std::vector&lt;std::shared_ptr&lt;MenuItemImplWin32&gt;&gt; menuItems;
    std::vector&lt;std::shared_ptr&lt;MenuImplWin32&gt;&gt;     subMenus;

    MenuImplWin32() {
        sscheck(hMenu = CreatePopupMenu());
    }

    MenuItemRef AddItem(const std::string &amp;label,
                        std::function&lt;void()&gt; onTrigger = NULL,
                        @others
};

HMENU MenuItemImplWin32::Handle() {
    return menu-&gt;hMenu;
}

MenuRef CreateMenu() {
    auto menu = std::make_shared&lt;MenuImplWin32&gt;();
    // std::enable_shared_from_this fails for some reason, not sure why
    menu-&gt;weakThis = menu;
    return menu;
}

</t>
<t tx="leo.20191228122649.172">                    bool mnemonics = true) override {
    auto menuItem = std::make_shared&lt;MenuItemImplWin32&gt;();
    menuItem-&gt;menu = weakThis.lock();
    menuItem-&gt;onTrigger = onTrigger;
    menuItems.push_back(menuItem);

    sscheck(AppendMenuW(hMenu, MF_STRING, (UINT_PTR)menuItem.get(),
                        Widen(mnemonics ? label : NegateMnemonics(label)).c_str()));

    // uID is just an UINT, which isn't large enough to hold a pointer on 64-bit Windows,
    // so we use dwItemData, which is.
    MENUITEMINFOW mii = {};
    mii.cbSize     = sizeof(mii);
    mii.fMask      = MIIM_DATA;
    mii.dwItemData = (LONG_PTR)menuItem.get();
    sscheck(SetMenuItemInfoW(hMenu, (UINT_PTR)menuItem.get(), FALSE, &amp;mii));

    return menuItem;
}

MenuRef AddSubMenu(const std::string &amp;label) override {
    auto subMenu = std::make_shared&lt;MenuImplWin32&gt;();
    subMenu-&gt;weakThis = subMenu;
    subMenus.push_back(subMenu);

    sscheck(AppendMenuW(hMenu, MF_STRING|MF_POPUP,
                        (UINT_PTR)subMenu-&gt;hMenu, Widen(label).c_str()));

    return subMenu;
}

</t>
<t tx="leo.20191228122649.173">void AddSeparator() override {
    sscheck(AppendMenuW(hMenu, MF_SEPARATOR, 0, L""));
}

</t>
<t tx="leo.20191228122649.174">void PopUp() override {
    MENUINFO mi = {};
    mi.cbSize  = sizeof(mi);
    mi.fMask   = MIM_APPLYTOSUBMENUS|MIM_STYLE;
    mi.dwStyle = MNS_NOTIFYBYPOS;
    sscheck(SetMenuInfo(hMenu, &amp;mi));

    POINT pt;
    sscheck(GetCursorPos(&amp;pt));

    sscheck(TrackPopupMenu(hMenu, TPM_TOPALIGN, pt.x, pt.y, 0, GetActiveWindow(), NULL));
    contextMenuPopTime = GetMilliseconds();
}

</t>
<t tx="leo.20191228122649.175">void Clear() override {
    for(int n = GetMenuItemCount(hMenu) - 1; n &gt;= 0; n--) {
        sscheck(RemoveMenu(hMenu, n, MF_BYPOSITION));
    }
    menuItems.clear();
    subMenus.clear();
}

~MenuImplWin32() {
    Clear();
    sscheck(DestroyMenu(hMenu));
}
</t>
<t tx="leo.20191228122649.176">class MenuBarImplWin32 final : public MenuBar {
public:
    HMENU hMenuBar;

    std::vector&lt;std::shared_ptr&lt;MenuImplWin32&gt;&gt; subMenus;

    MenuBarImplWin32() {
        sscheck(hMenuBar = ::CreateMenu());
    }

    MenuRef AddSubMenu(const std::string &amp;label) override {
        auto subMenu = std::make_shared&lt;MenuImplWin32&gt;();
        subMenu-&gt;weakThis = subMenu;
        subMenus.push_back(subMenu);

        sscheck(AppendMenuW(hMenuBar, MF_STRING|MF_POPUP,
                            (UINT_PTR)subMenu-&gt;hMenu, Widen(label).c_str()));

        return subMenu;
    }

    @others
};

MenuBarRef GetOrCreateMainMenu(bool *unique) {
    *unique = false;
    return std::make_shared&lt;MenuBarImplWin32&gt;();
}

//-----------------------------------------------------------------------------
// Windows
//-----------------------------------------------------------------------------

#define SCROLLBAR_UNIT 65536

</t>
<t tx="leo.20191228122649.177">void Clear() override {
    for(int n = GetMenuItemCount(hMenuBar) - 1; n &gt;= 0; n--) {
        sscheck(RemoveMenu(hMenuBar, n, MF_BYPOSITION));
    }
    subMenus.clear();
}

~MenuBarImplWin32() {
    Clear();
    sscheck(DestroyMenu(hMenuBar));
}
</t>
<t tx="leo.20191228122649.178">class WindowImplWin32 final : public Window {
public:
    HWND hWindow  = NULL;
    HWND hTooltip = NULL;
    HWND hEditor  = NULL;
    WNDPROC editorWndProc = NULL;

#if HAVE_OPENGL == 1
    HGLRC hGlRc = NULL;
#elif HAVE_OPENGL == 3
    static EGLDisplay eglDisplay;
    EGLSurface eglSurface = EGL_NO_SURFACE;
    EGLContext eglContext = EGL_NO_CONTEXT;
#endif

    WINDOWPLACEMENT placement = {};
    int minWidth = 0, minHeight = 0;

#if defined(HAVE_SPACEWARE)
    SiOpenData sod = {};
    SiHdl hSpaceWare = SI_NO_HANDLE;
#endif

    std::shared_ptr&lt;MenuBarImplWin32&gt; menuBar;
    std::string tooltipText;
    bool scrollbarVisible = false;

    @others
};

#if HAVE_OPENGL == 3
EGLDisplay WindowImplWin32::eglDisplay = EGL_NO_DISPLAY;
#endif

WindowRef CreateWindow(Window::Kind kind, WindowRef parentWindow) {
    return std::make_shared&lt;WindowImplWin32&gt;(kind,
                std::static_pointer_cast&lt;WindowImplWin32&gt;(parentWindow));
}

//-----------------------------------------------------------------------------
// 3DConnexion support
//-----------------------------------------------------------------------------

#if defined(HAVE_SPACEWARE)
static HWND hSpaceWareDriverClass;

</t>
<t tx="leo.20191228122649.179">    static void RegisterWindowClass() {
        static bool registered;
        if(registered) return;

        WNDCLASSEXW wc = {};
        wc.cbSize        = sizeof(wc);
        wc.style         = CS_BYTEALIGNCLIENT|CS_BYTEALIGNWINDOW|CS_OWNDC|CS_DBLCLKS;
        wc.lpfnWndProc   = WndProc;
        wc.cbWndExtra    = sizeof(WindowImplWin32 *);
        wc.hIcon         = (HICON)LoadImage(GetModuleHandle(NULL), MAKEINTRESOURCE(4000),
                                            IMAGE_ICON, 32, 32, 0);
        wc.hIconSm       = (HICON)LoadImage(GetModuleHandle(NULL), MAKEINTRESOURCE(4000),
                                            IMAGE_ICON, 16, 16, 0);
        wc.hCursor       = LoadCursorW(NULL, IDC_ARROW);
        wc.lpszClassName = L"SolveSpace";
        sscheck(RegisterClassExW(&amp;wc));
        registered = true;
    }

    WindowImplWin32(Window::Kind kind, std::shared_ptr&lt;WindowImplWin32&gt; parentWindow) {
        placement.length = sizeof(placement);

        RegisterWindowClass();

        HWND hParentWindow = NULL;
        if(parentWindow) {
            hParentWindow = parentWindow-&gt;hWindow;
        }

        DWORD style = WS_SIZEBOX|WS_CLIPCHILDREN;
        switch(kind) {
            case Window::Kind::TOPLEVEL:
                style |= WS_OVERLAPPEDWINDOW|WS_CLIPSIBLINGS;
                break;

            case Window::Kind::TOOL:
                style |= WS_POPUPWINDOW|WS_CAPTION;
                break;
        }
        sscheck(hWindow = CreateWindowExW(0, L"SolveSpace", L"", style,
                                          CW_USEDEFAULT, CW_USEDEFAULT,
                                          CW_USEDEFAULT, CW_USEDEFAULT,
                                          hParentWindow, NULL, NULL, NULL));
        sscheck(SetWindowLongPtr(hWindow, 0, (LONG_PTR)this));

        sscheck(hTooltip = CreateWindowExW(0, TOOLTIPS_CLASS, NULL,
                                           WS_POPUP|TTS_NOPREFIX|TTS_ALWAYSTIP,
                                           CW_USEDEFAULT, CW_USEDEFAULT,
                                           CW_USEDEFAULT, CW_USEDEFAULT,
                                           hWindow, NULL, NULL, NULL));
        sscheck(SetWindowPos(hTooltip, HWND_TOPMOST, 0, 0, 0, 0,
                             SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE));

        TOOLINFOW ti = {};
        ti.cbSize   = sizeof(ti);
        ti.uFlags   = TTF_SUBCLASS;
        ti.hwnd     = hWindow;
        ti.lpszText = (LPWSTR)L"";
        sscheck(SendMessageW(hTooltip, TTM_ADDTOOLW, 0, (LPARAM)&amp;ti));
        sscheck(SendMessageW(hTooltip, TTM_ACTIVATE, FALSE, 0));

        DWORD editorStyle = WS_CLIPSIBLINGS|WS_CHILD|WS_TABSTOP|ES_AUTOHSCROLL;
        sscheck(hEditor = CreateWindowExW(WS_EX_CLIENTEDGE, WC_EDIT, L"", editorStyle,
                                          0, 0, 0, 0, hWindow, NULL, NULL, NULL));
        sscheck(editorWndProc =
                (WNDPROC)SetWindowLongPtr(hEditor, GWLP_WNDPROC, (LONG_PTR)EditorWndProc));

        HDC hDc;
        sscheck(hDc = GetDC(hWindow));

#if HAVE_OPENGL == 1
        PIXELFORMATDESCRIPTOR pfd = {};
        pfd.nSize        = sizeof(PIXELFORMATDESCRIPTOR);
        pfd.nVersion     = 1;
        pfd.dwFlags      = PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL|PFD_DOUBLEBUFFER;
        pfd.dwLayerMask  = PFD_MAIN_PLANE;
        pfd.iPixelType   = PFD_TYPE_RGBA;
        pfd.cColorBits   = 32;
        pfd.cDepthBits   = 24;
        pfd.cAccumBits   = 0;
        pfd.cStencilBits = 0;
        int pixelFormat;
        sscheck(pixelFormat = ChoosePixelFormat(hDc, &amp;pfd));
        sscheck(SetPixelFormat(hDc, pixelFormat, &amp;pfd));

        sscheck(hGlRc = wglCreateContext(hDc));
#elif HAVE_OPENGL == 3
        if(eglDisplay == EGL_NO_DISPLAY) {
            ssassert(eglBindAPI(EGL_OPENGL_ES_API), "Cannot bind EGL API");

            EGLBoolean initialized = EGL_FALSE;
            for(auto &amp;platformType : {
                // Try platform types from least to most amount of software translation required.
                std::make_pair("OpenGL ES",   EGL_PLATFORM_ANGLE_TYPE_OPENGLES_ANGLE),
                std::make_pair("OpenGL",      EGL_PLATFORM_ANGLE_TYPE_OPENGL_ANGLE),
                std::make_pair("Direct3D 11", EGL_PLATFORM_ANGLE_TYPE_D3D11_ANGLE),
                std::make_pair("Direct3D 9",  EGL_PLATFORM_ANGLE_TYPE_D3D9_ANGLE),
            }) {
                dbp("Initializing ANGLE with %s backend", platformType.first);
                EGLint displayAttributes[] = {
                    EGL_PLATFORM_ANGLE_TYPE_ANGLE, platformType.second,
                    EGL_NONE
                };
                eglDisplay = eglGetPlatformDisplayEXT(EGL_PLATFORM_ANGLE_ANGLE, hDc,
                                                      displayAttributes);
                if(eglDisplay != EGL_NO_DISPLAY) {
                    initialized = eglInitialize(eglDisplay, NULL, NULL);
                    if(initialized) break;
                    eglTerminate(eglDisplay);
                }
            }
            ssassert(initialized, "Cannot find a suitable EGL display");
        }

        EGLint configAttributes[] = {
            EGL_COLOR_BUFFER_TYPE,  EGL_RGB_BUFFER,
            EGL_RED_SIZE,           8,
            EGL_GREEN_SIZE,         8,
            EGL_BLUE_SIZE,          8,
            EGL_DEPTH_SIZE,         24,
            EGL_RENDERABLE_TYPE,    EGL_OPENGL_ES2_BIT,
            EGL_SURFACE_TYPE,       EGL_WINDOW_BIT,
            EGL_NONE
        };
        EGLint numConfigs;
        EGLConfig windowConfig;
        ssassert(eglChooseConfig(eglDisplay, configAttributes, &amp;windowConfig, 1, &amp;numConfigs),
                 "Cannot choose EGL configuration");

        EGLint surfaceAttributes[] = {
            EGL_NONE
        };
        eglSurface = eglCreateWindowSurface(eglDisplay, windowConfig, hWindow, surfaceAttributes);
        ssassert(eglSurface != EGL_NO_SURFACE, "Cannot create EGL window surface");

        EGLint contextAttributes[] = {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL_NONE
        };
        eglContext = eglCreateContext(eglDisplay, windowConfig, NULL, contextAttributes);
        ssassert(eglContext != EGL_NO_CONTEXT, "Cannot create EGL context");
#endif

        sscheck(ReleaseDC(hWindow, hDc));
    }

    ~WindowImplWin32() {
        // Make sure any of our child windows get destroyed before we call DestroyWindow, or their
        // own destructors may fail.
        menuBar.reset();

        sscheck(DestroyWindow(hWindow));
#if defined(HAVE_SPACEWARE)
        if(hSpaceWare != SI_NO_HANDLE) {
            SiClose(hSpaceWare);
        }
#endif
    }

</t>
<t tx="leo.20191228122649.18">class Window {
public:
    enum class Kind {
        TOPLEVEL,
        TOOL,
    };

    enum class Cursor {
        POINTER,
        HAND
    };

    std::function&lt;void()&gt;               onClose;
    std::function&lt;void(bool)&gt;           onFullScreen;
    std::function&lt;bool(MouseEvent)&gt;     onMouseEvent;
    std::function&lt;void(SixDofEvent)&gt;    onSixDofEvent;
    std::function&lt;bool(KeyboardEvent)&gt;  onKeyboardEvent;
    std::function&lt;void(std::string)&gt;    onEditingDone;
    std::function&lt;void(double)&gt;         onScrollbarAdjusted;
    std::function&lt;void()&gt;               onRender;

    virtual ~Window() = default;

    // Returns physical display DPI.
    virtual double GetPixelDensity() = 0;
    // Returns raster graphics and coordinate scale (already applied on the platform side),
    // i.e. size of logical pixel in physical pixels, or device pixel ratio.
    virtual int GetDevicePixelRatio() = 0;
    // Returns (fractional) font scale, to be applied on top of (integral) device pixel ratio.
    virtual double GetDeviceFontScale() {
        return GetPixelDensity() / GetDevicePixelRatio() / 96.0;
    }

    virtual bool IsVisible() = 0;
    virtual void SetVisible(bool visible) = 0;
    virtual void Focus() = 0;

    virtual bool IsFullScreen() = 0;
    virtual void SetFullScreen(bool fullScreen) = 0;

    virtual void SetTitle(const std::string &amp;title) = 0;
    virtual bool SetTitleForFilename(const Path &amp;filename) { return false; }

    virtual void SetMenuBar(MenuBarRef menuBar) = 0;

    virtual void GetContentSize(double *width, double *height) = 0;
    virtual void SetMinContentSize(double width, double height) = 0;

    virtual void FreezePosition(SettingsRef settings, const std::string &amp;key) = 0;
    virtual void ThawPosition(SettingsRef settings, const std::string &amp;key) = 0;

    virtual void SetCursor(Cursor cursor) = 0;
    virtual void SetTooltip(const std::string &amp;text, double x, double y,
                            double width, double height) = 0;

    virtual bool IsEditorVisible() = 0;
    virtual void ShowEditor(double x, double y, double fontHeight, double minWidth,
                            bool isMonospace, const std::string &amp;text) = 0;
    virtual void HideEditor() = 0;

    virtual void SetScrollbarVisible(bool visible) = 0;
    virtual void ConfigureScrollbar(double min, double max, double pageSize) = 0;
    virtual double GetScrollbarPosition() = 0;
    virtual void SetScrollbarPosition(double pos) = 0;

    virtual void Invalidate() = 0;
};

typedef std::shared_ptr&lt;Window&gt; WindowRef;

WindowRef CreateWindow(Window::Kind kind = Window::Kind::TOPLEVEL,
                       WindowRef parentWindow = NULL);

// 3DConnexion support.
void Open3DConnexion();
void Close3DConnexion();
void Request3DConnexionEventsForWindow(WindowRef window);

// A native dialog that asks for one choice out of several.
</t>
<t tx="leo.20191228122649.180">    static LRESULT CALLBACK WndProc(HWND h, UINT msg, WPARAM wParam, LPARAM lParam) {
        if(handlingFatalError) return TRUE;

        WindowImplWin32 *window;
        sscheck(window = (WindowImplWin32 *)GetWindowLongPtr(h, 0));

        // The wndproc may be called from within CreateWindowEx, and before we've associated
        // the window with the WindowImplWin32. In that case, just defer to the default wndproc.
        if(window == NULL) {
            return DefWindowProcW(h, msg, wParam, lParam);
        }

#if defined(HAVE_SPACEWARE)
        if(window-&gt;hSpaceWare != SI_NO_HANDLE) {
            SiGetEventData sged;
            SiGetEventWinInit(&amp;sged, msg, wParam, lParam);

            SiSpwEvent sse;
            if(SiGetEvent(window-&gt;hSpaceWare, 0, &amp;sged, &amp;sse) == SI_IS_EVENT) {
                SixDofEvent event = {};
                event.shiftDown    = ((GetAsyncKeyState(VK_SHIFT) &amp; 0x8000) != 0);
                event.controlDown  = ((GetAsyncKeyState(VK_SHIFT) &amp; 0x8000) != 0);
                if(sse.type == SI_MOTION_EVENT) {
                    // The Z axis translation and rotation are both
                    // backwards in the default mapping.
                    event.type         = SixDofEvent::Type::MOTION;
                    event.translationX =  sse.u.spwData.mData[SI_TX]*1.0,
                    event.translationY =  sse.u.spwData.mData[SI_TY]*1.0,
                    event.translationZ = -sse.u.spwData.mData[SI_TZ]*1.0,
                    event.rotationX    =  sse.u.spwData.mData[SI_RX]*0.001,
                    event.rotationY    =  sse.u.spwData.mData[SI_RY]*0.001,
                    event.rotationZ    = -sse.u.spwData.mData[SI_RZ]*0.001;
                } else if(sse.type == SI_BUTTON_EVENT) {
                    if(SiButtonPressed(&amp;sse) == SI_APP_FIT_BUTTON) {
                        event.type   = SixDofEvent::Type::PRESS;
                        event.button = SixDofEvent::Button::FIT;
                    }
                    if(SiButtonReleased(&amp;sse) == SI_APP_FIT_BUTTON) {
                        event.type   = SixDofEvent::Type::RELEASE;
                        event.button = SixDofEvent::Button::FIT;
                    }
                }
                return 0;
            }
        }
#endif

        switch (msg) {
            case WM_ERASEBKGND:
                break;

            case WM_PAINT: {
                PAINTSTRUCT ps;
                HDC hDc = BeginPaint(window-&gt;hWindow, &amp;ps);
                if(window-&gt;onRender) {
#if HAVE_OPENGL == 1
                    wglMakeCurrent(hDc, window-&gt;hGlRc);
#elif HAVE_OPENGL == 3
                    eglMakeCurrent(window-&gt;eglDisplay, window-&gt;eglSurface,
                                   window-&gt;eglSurface, window-&gt;eglContext);
#endif
                    window-&gt;onRender();
#if HAVE_OPENGL == 1
                    SwapBuffers(hDc);
#elif HAVE_OPENGL == 3
                    eglSwapBuffers(window-&gt;eglDisplay, window-&gt;eglSurface);
                    (void)hDc;
#endif
                }
                EndPaint(window-&gt;hWindow, &amp;ps);
                break;
            }

            case WM_CLOSE:
                if(window-&gt;onClose) {
                    window-&gt;onClose();
                }
                break;

            case WM_SIZE:
                window-&gt;Invalidate();
                break;

            case WM_SIZING: {
                int pixelRatio = window-&gt;GetDevicePixelRatio();

                RECT rcw, rcc;
                sscheck(GetWindowRect(window-&gt;hWindow, &amp;rcw));
                sscheck(GetClientRect(window-&gt;hWindow, &amp;rcc));
                int nonClientWidth  = (rcw.right - rcw.left) - (rcc.right - rcc.left);
                int nonClientHeight = (rcw.bottom - rcw.top) - (rcc.bottom - rcc.top);

                RECT *rc = (RECT *)lParam;
                int adjWidth  = rc-&gt;right - rc-&gt;left;
                int adjHeight = rc-&gt;bottom - rc-&gt;top;

                adjWidth  -= nonClientWidth;
                adjWidth   = max(window-&gt;minWidth * pixelRatio, adjWidth);
                adjWidth  += nonClientWidth;
                adjHeight -= nonClientHeight;
                adjHeight  = max(window-&gt;minHeight * pixelRatio, adjHeight);
                adjHeight += nonClientHeight;
                switch(wParam) {
                    case WMSZ_RIGHT:
                    case WMSZ_BOTTOMRIGHT:
                    case WMSZ_TOPRIGHT:
                        rc-&gt;right = rc-&gt;left + adjWidth;
                        break;

                    case WMSZ_LEFT:
                    case WMSZ_BOTTOMLEFT:
                    case WMSZ_TOPLEFT:
                        rc-&gt;left = rc-&gt;right - adjWidth;
                        break;
                }
                switch(wParam) {
                    case WMSZ_BOTTOM:
                    case WMSZ_BOTTOMLEFT:
                    case WMSZ_BOTTOMRIGHT:
                        rc-&gt;bottom = rc-&gt;top + adjHeight;
                        break;

                    case WMSZ_TOP:
                    case WMSZ_TOPLEFT:
                    case WMSZ_TOPRIGHT:
                        rc-&gt;top = rc-&gt;bottom - adjHeight;
                        break;
                }
                break;
            }

            case WM_DPICHANGED: {
                RECT rc = *(RECT *)lParam;
                sscheck(SendMessage(window-&gt;hWindow, WM_SIZING, WMSZ_BOTTOMRIGHT, (LPARAM)&amp;rc));
                sscheck(SetWindowPos(window-&gt;hWindow, NULL, rc.left, rc.top,
                                     rc.right - rc.left, rc.bottom - rc.top,
                                     SWP_NOZORDER|SWP_NOACTIVATE));
                window-&gt;Invalidate();
                break;
            }

            case WM_LBUTTONDOWN:
            case WM_MBUTTONDOWN:
            case WM_RBUTTONDOWN:
            case WM_LBUTTONDBLCLK:
            case WM_MBUTTONDBLCLK:
            case WM_RBUTTONDBLCLK:
            case WM_LBUTTONUP:
            case WM_MBUTTONUP:
            case WM_RBUTTONUP:
                if(GetMilliseconds() - Platform::contextMenuPopTime &lt; 100) {
                    // Ignore the mouse click that dismisses a context menu, to avoid
                    // (e.g.) clearing a selection.
                    return 0;
                }
                // fallthrough
            case WM_MOUSEMOVE:
            case WM_MOUSEWHEEL:
            case WM_MOUSELEAVE: {
                int pixelRatio = window-&gt;GetDevicePixelRatio();

                MouseEvent event = {};
                event.x = GET_X_LPARAM(lParam) / pixelRatio;
                event.y = GET_Y_LPARAM(lParam) / pixelRatio;
                event.button = MouseEvent::Button::NONE;

                event.shiftDown   = (wParam &amp; MK_SHIFT) != 0;
                event.controlDown = (wParam &amp; MK_CONTROL) != 0;

                bool consumed = false;
                switch(msg) {
                    case WM_LBUTTONDOWN:
                        event.button = MouseEvent::Button::LEFT;
                        event.type = MouseEvent::Type::PRESS;
                        break;
                    case WM_MBUTTONDOWN:
                        event.button = MouseEvent::Button::MIDDLE;
                        event.type = MouseEvent::Type::PRESS;
                        break;
                    case WM_RBUTTONDOWN:
                        event.button = MouseEvent::Button::RIGHT;
                        event.type = MouseEvent::Type::PRESS;
                        break;

                    case WM_LBUTTONDBLCLK:
                        event.button = MouseEvent::Button::LEFT;
                        event.type = MouseEvent::Type::DBL_PRESS;
                        break;
                    case WM_MBUTTONDBLCLK:
                        event.button = MouseEvent::Button::MIDDLE;
                        event.type = MouseEvent::Type::DBL_PRESS;
                        break;
                    case WM_RBUTTONDBLCLK:
                        event.button = MouseEvent::Button::RIGHT;
                        event.type = MouseEvent::Type::DBL_PRESS;
                        break;

                    case WM_LBUTTONUP:
                        event.button = MouseEvent::Button::LEFT;
                        event.type = MouseEvent::Type::RELEASE;
                        break;
                    case WM_MBUTTONUP:
                        event.button = MouseEvent::Button::MIDDLE;
                        event.type = MouseEvent::Type::RELEASE;
                        break;
                    case WM_RBUTTONUP:
                        event.button = MouseEvent::Button::RIGHT;
                        event.type = MouseEvent::Type::RELEASE;
                        break;

                    case WM_MOUSEWHEEL:
                        // Make the mousewheel work according to which window the mouse is
                        // over, not according to which window is active.
                        POINT pt;
                        pt.x = LOWORD(lParam);
                        pt.y = HIWORD(lParam);
                        HWND hWindowUnderMouse;
                        sscheck(hWindowUnderMouse = WindowFromPoint(pt));
                        if(hWindowUnderMouse &amp;&amp; hWindowUnderMouse != h) {
                            SendMessageW(hWindowUnderMouse, msg, wParam, lParam);
                            consumed = true;
                            break;
                        }

                        event.type = MouseEvent::Type::SCROLL_VERT;
                        event.scrollDelta = GET_WHEEL_DELTA_WPARAM(wParam) &gt; 0 ? 1 : -1;
                        break;

                    case WM_MOUSELEAVE:
                        event.type = MouseEvent::Type::LEAVE;
                        break;
                    case WM_MOUSEMOVE: {
                        event.type = MouseEvent::Type::MOTION;

                        if(wParam &amp; MK_LBUTTON) {
                            event.button = MouseEvent::Button::LEFT;
                        } else if(wParam &amp; MK_MBUTTON) {
                            event.button = MouseEvent::Button::MIDDLE;
                        } else if(wParam &amp; MK_RBUTTON) {
                            event.button = MouseEvent::Button::RIGHT;
                        }

                        // We need this in order to get the WM_MOUSELEAVE
                        TRACKMOUSEEVENT tme = {};
                        tme.cbSize    = sizeof(tme);
                        tme.dwFlags   = TME_LEAVE;
                        tme.hwndTrack = window-&gt;hWindow;
                        sscheck(TrackMouseEvent(&amp;tme));
                        break;
                    }
                }

                if(!consumed &amp;&amp; window-&gt;onMouseEvent) {
                    window-&gt;onMouseEvent(event);
                }
                break;
            }

            case WM_KEYDOWN:
            case WM_KEYUP: {
                Platform::KeyboardEvent event = {};
                if(msg == WM_KEYDOWN) {
                    event.type = Platform::KeyboardEvent::Type::PRESS;
                } else if(msg == WM_KEYUP) {
                    event.type = Platform::KeyboardEvent::Type::RELEASE;
                }

                if(GetKeyState(VK_SHIFT) &amp; 0x8000)
                    event.shiftDown = true;
                if(GetKeyState(VK_CONTROL) &amp; 0x8000)
                    event.controlDown = true;

                if(wParam &gt;= VK_F1 &amp;&amp; wParam &lt;= VK_F12) {
                    event.key = Platform::KeyboardEvent::Key::FUNCTION;
                    event.num = wParam - VK_F1 + 1;
                } else {
                    event.key = Platform::KeyboardEvent::Key::CHARACTER;
                    event.chr = tolower(MapVirtualKeyW(wParam, MAPVK_VK_TO_CHAR));
                    if(event.chr == 0) {
                        if(wParam == VK_DELETE) {
                            event.chr = '\x7f';
                        } else {
                            // Non-mappable key.
                            break;
                        }
                    } else if(event.chr == '.' &amp;&amp; event.shiftDown) {
                        event.chr = '&gt;';
                        event.shiftDown = false;;
                    }
                }

                if(window-&gt;onKeyboardEvent) {
                    window-&gt;onKeyboardEvent(event);
                }
                break;
            }

            case WM_SYSKEYDOWN: {
                HWND hParent;
                sscheck(hParent = GetParent(h));
                if(hParent != NULL) {
                    // If the user presses the Alt key when a tool window has focus,
                    // then that should probably go to the main window instead.
                    sscheck(SetForegroundWindow(hParent));
                    break;
                } else {
                    return DefWindowProcW(h, msg, wParam, lParam);
                }
            }

            case WM_VSCROLL: {
                SCROLLINFO si = {};
                si.cbSize = sizeof(si);
                si.fMask  = SIF_POS|SIF_TRACKPOS|SIF_RANGE|SIF_PAGE;
                sscheck(GetScrollInfo(window-&gt;hWindow, SB_VERT, &amp;si));

                switch(LOWORD(wParam)) {
                    case SB_LINEUP:         si.nPos -= SCROLLBAR_UNIT; break;
                    case SB_PAGEUP:         si.nPos -= si.nPage;       break;
                    case SB_LINEDOWN:       si.nPos += SCROLLBAR_UNIT; break;
                    case SB_PAGEDOWN:       si.nPos += si.nPage;       break;
                    case SB_TOP:            si.nPos  = si.nMin;        break;
                    case SB_BOTTOM:         si.nPos  = si.nMax;        break;
                    case SB_THUMBTRACK:
                    case SB_THUMBPOSITION:  si.nPos  = si.nTrackPos;   break;
                }

                si.nPos = min((UINT)si.nPos, (UINT)(si.nMax - si.nPage));

                if(window-&gt;onScrollbarAdjusted) {
                    window-&gt;onScrollbarAdjusted((double)si.nPos / SCROLLBAR_UNIT);
                }
                break;
            }

            case WM_MENUCOMMAND: {
                MENUITEMINFOW mii = {};
                mii.cbSize = sizeof(mii);
                mii.fMask  = MIIM_DATA;
                sscheck(GetMenuItemInfoW((HMENU)lParam, wParam, TRUE, &amp;mii));

                MenuItemImplWin32 *menuItem = (MenuItemImplWin32 *)mii.dwItemData;
                if(menuItem-&gt;onTrigger) {
                    menuItem-&gt;onTrigger();
                }
                break;
            }

            default:
                return DefWindowProcW(h, msg, wParam, lParam);
        }

        return 0;
    }

</t>
<t tx="leo.20191228122649.181">static LRESULT CALLBACK EditorWndProc(HWND h, UINT msg, WPARAM wParam, LPARAM lParam) {
    if(handlingFatalError) return 0;

    HWND hWindow;
    sscheck(hWindow = GetParent(h));

    WindowImplWin32 *window;
    sscheck(window = (WindowImplWin32 *)GetWindowLongPtr(hWindow, 0));

    switch(msg) {
        case WM_KEYDOWN:
            if(wParam == VK_RETURN) {
                if(window-&gt;onEditingDone) {
                    int length;
                    sscheck(length = GetWindowTextLength(h));

                    std::wstring resultW;
                    resultW.resize(length);
                    sscheck(GetWindowTextW(h, &amp;resultW[0], resultW.length() + 1));

                    window-&gt;onEditingDone(Narrow(resultW));
                    return 0;
                }
            } else if(wParam == VK_ESCAPE) {
                sscheck(SendMessageW(hWindow, msg, wParam, lParam));
                return 0;
            }
    }

    return CallWindowProc(window-&gt;editorWndProc, h, msg, wParam, lParam);
}

</t>
<t tx="leo.20191228122649.182">double GetPixelDensity() override {
    UINT dpi;
    sscheck(dpi = ssGetDpiForWindow(hWindow));
    return (double)dpi;
}

</t>
<t tx="leo.20191228122649.183">int GetDevicePixelRatio() override {
    UINT dpi;
    sscheck(dpi = ssGetDpiForWindow(hWindow));
    return dpi / USER_DEFAULT_SCREEN_DPI;
}

</t>
<t tx="leo.20191228122649.184">bool IsVisible() override {
    BOOL isVisible;
    sscheck(isVisible = IsWindowVisible(hWindow));
    return isVisible == TRUE;
}

</t>
<t tx="leo.20191228122649.185">void SetVisible(bool visible) override {
    sscheck(ShowWindow(hWindow, visible ? SW_SHOW : SW_HIDE));
}

</t>
<t tx="leo.20191228122649.186">void Focus() override {
    sscheck(SetActiveWindow(hWindow));
}

</t>
<t tx="leo.20191228122649.187">bool IsFullScreen() override {
    DWORD style;
    sscheck(style = GetWindowLongPtr(hWindow, GWL_STYLE));
    return !(style &amp; WS_OVERLAPPEDWINDOW);
}

</t>
<t tx="leo.20191228122649.188">void SetFullScreen(bool fullScreen) override {
    DWORD style;
    sscheck(style = GetWindowLongPtr(hWindow, GWL_STYLE));
    if(fullScreen) {
        sscheck(GetWindowPlacement(hWindow, &amp;placement));

        MONITORINFO mi;
        mi.cbSize = sizeof(mi);
        sscheck(GetMonitorInfo(MonitorFromWindow(hWindow, MONITOR_DEFAULTTONEAREST), &amp;mi));

        sscheck(SetWindowLong(hWindow, GWL_STYLE, style &amp; ~WS_OVERLAPPEDWINDOW));
        sscheck(SetWindowPos(hWindow, HWND_TOP,
                             mi.rcMonitor.left, mi.rcMonitor.top,
                             mi.rcMonitor.right - mi.rcMonitor.left,
                             mi.rcMonitor.bottom - mi.rcMonitor.top,
                             SWP_NOOWNERZORDER|SWP_FRAMECHANGED));
    } else {
        sscheck(SetWindowLong(hWindow, GWL_STYLE, style | WS_OVERLAPPEDWINDOW));
        sscheck(SetWindowPlacement(hWindow, &amp;placement));
        sscheck(SetWindowPos(hWindow, NULL, 0, 0, 0, 0,
                             SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|
                             SWP_NOOWNERZORDER|SWP_FRAMECHANGED));
    }
}

</t>
<t tx="leo.20191228122649.189">void SetTitle(const std::string &amp;title) override {
    sscheck(SetWindowTextW(hWindow, PrepareTitle(title).c_str()));
}

</t>
<t tx="leo.20191228122649.19">class MessageDialog {
public:
    enum class Type {
        INFORMATION,
        QUESTION,
        WARNING,
        ERROR
    };

    enum class Response {
        NONE,
        OK,
        YES,
        NO,
        CANCEL
    };

    std::function&lt;void(Response)&gt; onResponse;

    virtual ~MessageDialog() = default;

    virtual void SetType(Type type) = 0;
    virtual void SetTitle(std::string title) = 0;
    virtual void SetMessage(std::string message) = 0;
    virtual void SetDescription(std::string description) = 0;

    virtual void AddButton(std::string label, Response response, bool isDefault = false) = 0;

    virtual Response RunModal() = 0;
    virtual void ShowModal() {
        Response response = RunModal();
        if(onResponse) {
            onResponse(response);
        }
    }
};

typedef std::shared_ptr&lt;MessageDialog&gt; MessageDialogRef;

MessageDialogRef CreateMessageDialog(WindowRef parentWindow);

// A file filter.
struct FileFilter {
    std::string                 name;
    std::vector&lt;std::string&gt;    extensions;
};

// SolveSpace's native file format
extern std::vector&lt;FileFilter&gt; SolveSpaceModelFileFilters;
// Raster image
extern std::vector&lt;FileFilter&gt; RasterFileFilters;
// Triangle mesh
extern std::vector&lt;FileFilter&gt; MeshFileFilters;
// NURBS surfaces
extern std::vector&lt;FileFilter&gt; SurfaceFileFilters;
// 2d vector (lines and curves) format
extern std::vector&lt;FileFilter&gt; VectorFileFilters;
// 3d vector (wireframe lines and curves) format
extern std::vector&lt;FileFilter&gt; Vector3dFileFilters;
// Any importable format
extern std::vector&lt;FileFilter&gt; ImportFileFilters;
// Comma-separated value, like a spreadsheet would use
extern std::vector&lt;FileFilter&gt; CsvFileFilters;

// A native dialog that asks to choose a file.
</t>
<t tx="leo.20191228122649.190">void SetMenuBar(MenuBarRef newMenuBar) override {
    menuBar = std::static_pointer_cast&lt;MenuBarImplWin32&gt;(newMenuBar);

    MENUINFO mi = {};
    mi.cbSize  = sizeof(mi);
    mi.fMask   = MIM_APPLYTOSUBMENUS|MIM_STYLE;
    mi.dwStyle = MNS_NOTIFYBYPOS;
    sscheck(SetMenuInfo(menuBar-&gt;hMenuBar, &amp;mi));

    sscheck(SetMenu(hWindow, menuBar-&gt;hMenuBar));
}

</t>
<t tx="leo.20191228122649.191">void GetContentSize(double *width, double *height) override {
    int pixelRatio = GetDevicePixelRatio();

    RECT rc;
    sscheck(GetClientRect(hWindow, &amp;rc));
    *width  = (rc.right  - rc.left) / pixelRatio;
    *height = (rc.bottom - rc.top)  / pixelRatio;
}

</t>
<t tx="leo.20191228122649.192">void SetMinContentSize(double width, double height) {
    minWidth  = (int)width;
    minHeight = (int)height;

    int pixelRatio = GetDevicePixelRatio();

    RECT rc;
    sscheck(GetClientRect(hWindow, &amp;rc));
    if(rc.right  - rc.left &lt; minWidth * pixelRatio) {
        rc.right  = rc.left + minWidth  * pixelRatio;
    }
    if(rc.bottom - rc.top &lt; minHeight * pixelRatio) {
        rc.bottom = rc.top  + minHeight * pixelRatio;
    }
}

</t>
<t tx="leo.20191228122649.193">void FreezePosition(SettingsRef settings, const std::string &amp;key) override {
    sscheck(GetWindowPlacement(hWindow, &amp;placement));

    BOOL isMaximized;
    sscheck(isMaximized = IsZoomed(hWindow));

    RECT rc = placement.rcNormalPosition;
    settings-&gt;FreezeInt(key + "_Left",       rc.left);
    settings-&gt;FreezeInt(key + "_Right",      rc.right);
    settings-&gt;FreezeInt(key + "_Top",        rc.top);
    settings-&gt;FreezeInt(key + "_Bottom",     rc.bottom);
    settings-&gt;FreezeBool(key + "_Maximized", isMaximized == TRUE);
}

</t>
<t tx="leo.20191228122649.194">void ThawPosition(SettingsRef settings, const std::string &amp;key) override {
    sscheck(GetWindowPlacement(hWindow, &amp;placement));

    RECT rc = placement.rcNormalPosition;
    rc.left   = settings-&gt;ThawInt(key + "_Left",   rc.left);
    rc.right  = settings-&gt;ThawInt(key + "_Right",  rc.right);
    rc.top    = settings-&gt;ThawInt(key + "_Top",    rc.top);
    rc.bottom = settings-&gt;ThawInt(key + "_Bottom", rc.bottom);

    MONITORINFO mi;
    mi.cbSize = sizeof(mi);
    sscheck(GetMonitorInfo(MonitorFromRect(&amp;rc, MONITOR_DEFAULTTONEAREST), &amp;mi));

    // If it somehow ended up off-screen, then put it back.
    RECT mrc = mi.rcMonitor;
    rc.left   = Clamp(rc.left,   mrc.left, mrc.right);
    rc.right  = Clamp(rc.right,  mrc.left, mrc.right);
    rc.top    = Clamp(rc.top,    mrc.top,  mrc.bottom);
    rc.bottom = Clamp(rc.bottom, mrc.top,  mrc.bottom);

    // And make sure the minimum size is respected. (We can freeze a size smaller
    // than minimum size if the DPI changed between runs.)
    sscheck(SendMessageW(hWindow, WM_SIZING, WMSZ_BOTTOMRIGHT, (LPARAM)&amp;rc));

    placement.flags = 0;
    if(settings-&gt;ThawBool(key + "_Maximized", false)) {
        placement.showCmd = SW_SHOWMAXIMIZED;
    } else {
        placement.showCmd = SW_SHOW;
    }
    placement.rcNormalPosition = rc;
    sscheck(SetWindowPlacement(hWindow, &amp;placement));
}

</t>
<t tx="leo.20191228122649.195">void SetCursor(Cursor cursor) override {
    LPWSTR cursorName;
    switch(cursor) {
        case Cursor::POINTER: cursorName = IDC_ARROW; break;
        case Cursor::HAND:    cursorName = IDC_HAND;  break;
    }

    HCURSOR hCursor;
    sscheck(hCursor = LoadCursorW(NULL, cursorName));
    sscheck(::SetCursor(hCursor));
}

</t>
<t tx="leo.20191228122649.196">void SetTooltip(const std::string &amp;newText, double x, double y,
                double width, double height) override {
    if(newText == tooltipText) return;
    tooltipText = newText;

    if(!newText.empty()) {
        int pixelRatio = GetDevicePixelRatio();
        RECT toolRect;
        toolRect.left   = (int)(x * pixelRatio);
        toolRect.top    = (int)(y * pixelRatio);
        toolRect.right  = toolRect.left + (int)(width  * pixelRatio);
        toolRect.bottom = toolRect.top  + (int)(height * pixelRatio);

        std::wstring newTextW = Widen(newText);
        TOOLINFOW ti = {};
        ti.cbSize   = sizeof(ti);
        ti.hwnd     = hWindow;
        ti.rect     = toolRect;
        ti.lpszText = &amp;newTextW[0];
        sscheck(SendMessageW(hTooltip, TTM_UPDATETIPTEXTW, 0, (LPARAM)&amp;ti));
        sscheck(SendMessageW(hTooltip, TTM_NEWTOOLRECTW, 0, (LPARAM)&amp;ti));
    }
    // The following SendMessage call sometimes fails with ERROR_ACCESS_DENIED for
    // no discernible reason, but only on wine.
    SendMessageW(hTooltip, TTM_ACTIVATE, !newText.empty(), 0);
}

</t>
<t tx="leo.20191228122649.197">bool IsEditorVisible() override {
    BOOL visible;
    sscheck(visible = IsWindowVisible(hEditor));
    return visible == TRUE;
}

</t>
<t tx="leo.20191228122649.198">void ShowEditor(double x, double y, double fontHeight, double minWidth,
                bool isMonospace, const std::string &amp;text) override {
    if(IsEditorVisible()) return;

    int pixelRatio = GetDevicePixelRatio();

    HFONT hFont = CreateFontW(-(LONG)fontHeight * GetDevicePixelRatio(), 0, 0, 0,
        FW_REGULAR, FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
        DEFAULT_QUALITY, FF_DONTCARE, isMonospace ? L"Lucida Console" : L"Arial");
    if(hFont == NULL) {
        sscheck(hFont = (HFONT)GetStockObject(SYSTEM_FONT));
    }
    sscheck(SendMessageW(hEditor, WM_SETFONT, (WPARAM)hFont, FALSE));
    sscheck(SendMessageW(hEditor, EM_SETMARGINS, EC_LEFTMARGIN|EC_RIGHTMARGIN, 0));

    std::wstring textW = Widen(text);

    HDC hDc;
    TEXTMETRICW tm;
    SIZE ts;
    sscheck(hDc = GetDC(hEditor));
    sscheck(SelectObject(hDc, hFont));
    sscheck(GetTextMetricsW(hDc, &amp;tm));
    sscheck(GetTextExtentPoint32W(hDc, textW.c_str(), textW.length(), &amp;ts));
    sscheck(ReleaseDC(hEditor, hDc));

    RECT rc;
    rc.left   = (LONG)x * pixelRatio;
    rc.top    = (LONG)y * pixelRatio - tm.tmAscent;
    // Add one extra char width to avoid scrolling.
    rc.right  = (LONG)x * pixelRatio +
                std::max((LONG)minWidth * pixelRatio, ts.cx + tm.tmAveCharWidth);
    rc.bottom = (LONG)y * pixelRatio + tm.tmDescent;
    sscheck(ssAdjustWindowRectExForDpi(&amp;rc, 0, /*bMenu=*/FALSE, WS_EX_CLIENTEDGE,
                                       ssGetDpiForWindow(hWindow)));

    sscheck(MoveWindow(hEditor, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
                       /*bRepaint=*/true));
    sscheck(ShowWindow(hEditor, SW_SHOW));
    if(!textW.empty()) {
        sscheck(SendMessageW(hEditor, WM_SETTEXT, 0, (LPARAM)textW.c_str()));
        sscheck(SendMessageW(hEditor, EM_SETSEL, 0, textW.length()));
        sscheck(SetFocus(hEditor));
    }
}

</t>
<t tx="leo.20191228122649.199">void HideEditor() override {
    if(!IsEditorVisible()) return;

    sscheck(ShowWindow(hEditor, SW_HIDE));
}

</t>
<t tx="leo.20191228122649.2">int main(int argc, char** argv) {
    std::vector&lt;std::string&gt; args = InitPlatform(argc, argv);

    Platform::InitGui(argc, argv);
    Platform::Open3DConnexion();
    SS.Init();

    if(args.size() &gt;= 2) {
        if(args.size() &gt; 2) {
            dbp("Only the first file passed on command line will be opened.");
        }

        SS.Load(Platform::Path::From(args.back()).Expand(/*fromCurrentDirectory=*/true));
    }

    Platform::RunGui();

    Platform::Close3DConnexion();
    SS.Clear();
    SK.Clear();
    Platform::ClearGui();

    return 0;
}

#if defined(WIN32)
</t>
<t tx="leo.20191228122649.20">class FileDialog {
public:
    virtual ~FileDialog() = default;

    virtual void SetTitle(std::string title) = 0;
    virtual void SetCurrentName(std::string name) = 0;

    virtual Platform::Path GetFilename() = 0;
    virtual void SetFilename(Platform::Path path) = 0;

    virtual void AddFilter(std::string name, std::vector&lt;std::string&gt; extensions) = 0;
    void AddFilter(const FileFilter &amp;filter);
    void AddFilters(const std::vector&lt;FileFilter&gt; &amp;filters);

    virtual void FreezeChoices(SettingsRef settings, const std::string &amp;key) = 0;
    virtual void ThawChoices(SettingsRef settings, const std::string &amp;key) = 0;

    virtual bool RunModal() = 0;
};

typedef std::shared_ptr&lt;FileDialog&gt; FileDialogRef;

FileDialogRef CreateOpenFileDialog(WindowRef parentWindow);
FileDialogRef CreateSaveFileDialog(WindowRef parentWindow);

//-----------------------------------------------------------------------------
// Application-wide APIs
//-----------------------------------------------------------------------------

std::vector&lt;Platform::Path&gt; GetFontFiles();
void OpenInBrowser(const std::string &amp;url);

void InitGui(int argc, char **argv);
void RunGui();
void ExitGui();
void ClearGui();

}

#endif
</t>
<t tx="leo.20191228122649.200">void SetScrollbarVisible(bool visible) override {
    scrollbarVisible = visible;
    sscheck(ShowScrollBar(hWindow, SB_VERT, visible));
}

</t>
<t tx="leo.20191228122649.201">void ConfigureScrollbar(double min, double max, double pageSize) override {
    SCROLLINFO si = {};
    si.cbSize = sizeof(si);
    si.fMask  = SIF_RANGE|SIF_PAGE;
    si.nMin   = (UINT)(min * SCROLLBAR_UNIT);
    si.nMax   = (UINT)(max * SCROLLBAR_UNIT);
    si.nPage  = (UINT)(pageSize * SCROLLBAR_UNIT);
    sscheck(SetScrollInfo(hWindow, SB_VERT, &amp;si, /*redraw=*/TRUE));
}

</t>
<t tx="leo.20191228122649.202">double GetScrollbarPosition() override {
    if(!scrollbarVisible) return 0.0;

    SCROLLINFO si = {};
    si.cbSize = sizeof(si);
    si.fMask  = SIF_POS;
    sscheck(GetScrollInfo(hWindow, SB_VERT, &amp;si));
    return (double)si.nPos / SCROLLBAR_UNIT;
}

</t>
<t tx="leo.20191228122649.203">void SetScrollbarPosition(double pos) override {
    if(!scrollbarVisible) return;

    SCROLLINFO si = {};
    si.cbSize = sizeof(si);
    si.fMask  = SIF_POS;
    sscheck(GetScrollInfo(hWindow, SB_VERT, &amp;si));
    if(si.nPos == (int)(pos * SCROLLBAR_UNIT))
        return;

    si.nPos   = (int)(pos * SCROLLBAR_UNIT);
    sscheck(SetScrollInfo(hWindow, SB_VERT, &amp;si, /*redraw=*/TRUE));

    // Windows won't synthesize a WM_VSCROLL for us here.
    if(onScrollbarAdjusted) {
        onScrollbarAdjusted((double)si.nPos / SCROLLBAR_UNIT);
    }
}

</t>
<t tx="leo.20191228122649.204">void Invalidate() override {
    sscheck(InvalidateRect(hWindow, NULL, /*bErase=*/FALSE));
}
</t>
<t tx="leo.20191228122649.205">void Open3DConnexion() {
    HWND hSpaceWareDriverClass = FindWindowW(L"SpaceWare Driver Class", NULL);
    if(hSpaceWareDriverClass != NULL) {
        SiInitialize();
    }
}

</t>
<t tx="leo.20191228122649.206">void Close3DConnexion() {
    if(hSpaceWareDriverClass != NULL) {
        SiTerminate();
    }
}

</t>
<t tx="leo.20191228122649.207">void Request3DConnexionEventsForWindow(WindowRef window) {
    std::shared_ptr&lt;WindowImplWin32&gt; windowImpl =
        std::static_pointer_cast&lt;WindowImplWin32&gt;(window);
    if(hSpaceWareDriverClass != NULL) {
        SiOpenWinInit(&amp;windowImpl-&gt;sod, windowImpl-&gt;hWindow);
        windowImpl-&gt;hSpaceWare = SiOpen("SolveSpace", SI_ANY_DEVICE, SI_NO_MASK, SI_EVENT,
                                        &amp;windowImpl-&gt;sod);
        SiSetUiMode(windowImpl-&gt;hSpaceWare, SI_UI_NO_CONTROLS);
    }
}
#else
</t>
<t tx="leo.20191228122649.208">void Open3DConnexion() {}
void Close3DConnexion() {}
void Request3DConnexionEventsForWindow(WindowRef window) {}
#endif

//-----------------------------------------------------------------------------
// Message dialogs
//-----------------------------------------------------------------------------

class MessageDialogImplWin32 final : public MessageDialog {
public:
    MSGBOXPARAMSW       mbp = {};

    int                 style;

    std::wstring        titleW;
    std::wstring        messageW;
    std::wstring        descriptionW;
    std::wstring        textW;

    std::vector&lt;int&gt;    buttons;
    int                 defaultButton;

    MessageDialogImplWin32() {
        mbp.cbSize = sizeof(mbp);
        SetTitle("Message");
    }

    @others
};

MessageDialogRef CreateMessageDialog(WindowRef parentWindow) {
    std::shared_ptr&lt;MessageDialogImplWin32&gt; dialog = std::make_shared&lt;MessageDialogImplWin32&gt;();
    dialog-&gt;mbp.hwndOwner = std::static_pointer_cast&lt;WindowImplWin32&gt;(parentWindow)-&gt;hWindow;
    return dialog;
}

//-----------------------------------------------------------------------------
// File dialogs
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.209">void SetType(Type type) override {
    switch(type) {
        case Type::INFORMATION:
            style = MB_ICONINFORMATION;
            break;

        case Type::QUESTION:
            style = MB_ICONQUESTION;
            break;

        case Type::WARNING:
            style = MB_ICONWARNING;
            break;

        case Type::ERROR:
            style = MB_ICONERROR;
            break;
    }
}

</t>
<t tx="leo.20191228122649.21">@path ./src/platform/
//-----------------------------------------------------------------------------
// The GTK-based implementation of platform-dependent GUI functionality.
//
// Copyright 2018 whitequark
//-----------------------------------------------------------------------------
#include &lt;errno.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;json-c/json_object.h&gt;
#include &lt;json-c/json_util.h&gt;
#include &lt;glibmm/convert.h&gt;
#include &lt;glibmm/main.h&gt;
#include &lt;gtkmm/box.h&gt;
#include &lt;gtkmm/checkmenuitem.h&gt;
#include &lt;gtkmm/cssprovider.h&gt;
#include &lt;gtkmm/entry.h&gt;
#include &lt;gtkmm/filechooserdialog.h&gt;
#include &lt;gtkmm/fixed.h&gt;
#include &lt;gtkmm/glarea.h&gt;
#include &lt;gtkmm/main.h&gt;
#include &lt;gtkmm/menu.h&gt;
#include &lt;gtkmm/menubar.h&gt;
#include &lt;gtkmm/messagedialog.h&gt;
#include &lt;gtkmm/scrollbar.h&gt;
#include &lt;gtkmm/separatormenuitem.h&gt;
#include &lt;gtkmm/tooltip.h&gt;
#include &lt;gtkmm/window.h&gt;

#include "config.h"
#if defined(HAVE_GTK_FILECHOOSERNATIVE)
#   include &lt;gtkmm/filechoosernative.h&gt;
#endif

#if defined(HAVE_SPACEWARE)
#   include &lt;spnav.h&gt;
#   include &lt;gdk/gdkx.h&gt;
#endif

#include "solvespace.h"

namespace SolveSpace {
namespace Platform {

//-----------------------------------------------------------------------------
// Utility functions
//-----------------------------------------------------------------------------

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122649.210">void SetTitle(std::string title) override {
    titleW = PrepareTitle(title);
    mbp.lpszCaption = titleW.c_str();
}

</t>
<t tx="leo.20191228122649.211">void SetMessage(std::string message) override {
    messageW = Widen(message);
    UpdateText();
}

</t>
<t tx="leo.20191228122649.212">void SetDescription(std::string description) override {
    descriptionW = Widen(description);
    UpdateText();
}

</t>
<t tx="leo.20191228122649.213">void UpdateText() {
    textW = messageW + L"\n\n" + descriptionW;
    mbp.lpszText = textW.c_str();
}

</t>
<t tx="leo.20191228122649.214">void AddButton(std::string _label, Response response, bool isDefault) override {
    int button;
    switch(response) {
        case Response::NONE:   ssassert(false, "Invalid response");
        case Response::OK:     button = IDOK;     break;
        case Response::YES:    button = IDYES;    break;
        case Response::NO:     button = IDNO;     break;
        case Response::CANCEL: button = IDCANCEL; break;
    }
    buttons.push_back(button);
    if(isDefault) {
        defaultButton = button;
    }
}

Response RunModal() override {
    mbp.dwStyle = style;

    std::sort(buttons.begin(), buttons.end());
    if(buttons == std::vector&lt;int&gt;({ IDOK })) {
        mbp.dwStyle |= MB_OK;
    } else if(buttons == std::vector&lt;int&gt;({ IDOK, IDCANCEL })) {
        mbp.dwStyle |= MB_OKCANCEL;
    } else if(buttons == std::vector&lt;int&gt;({ IDYES, IDNO })) {
        mbp.dwStyle |= MB_YESNO;
    } else if(buttons == std::vector&lt;int&gt;({ IDCANCEL, IDYES, IDNO })) {
        mbp.dwStyle |= MB_YESNOCANCEL;
    } else {
        ssassert(false, "Unexpected button set");
    }

    switch(MessageBoxIndirectW(&amp;mbp)) {
        case IDOK:     return Response::OK;     break;
        case IDYES:    return Response::YES;    break;
        case IDNO:     return Response::NO;     break;
        case IDCANCEL: return Response::CANCEL; break;
        default: ssassert(false, "Unexpected response");
    }
}
</t>
<t tx="leo.20191228122649.215">class FileDialogImplWin32 final : public FileDialog {
public:
    OPENFILENAMEW   ofn = {};
    bool            isSaveDialog;
    std::wstring    titleW;
    std::wstring    filtersW;
    std::wstring    defExtW;
    std::wstring    initialDirW;
    // UNC paths may be as long as 32767 characters.
    // Unfortunately, the Get*FileName API does not provide any way to use it
    // except with a preallocated buffer of fixed size, so we use something
    // reasonably large.
    wchar_t         filenameWC[32768] = {};

    FileDialogImplWin32() {
        ofn.lStructSize = sizeof(ofn);
        ofn.lpstrFile   = filenameWC;
        ofn.nMaxFile    = sizeof(filenameWC) / sizeof(wchar_t);
        ofn.Flags       = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY |
                          OFN_OVERWRITEPROMPT;
        if(isSaveDialog) {
            SetTitle(C_("title", "Save File"));
        } else {
            SetTitle(C_("title", "Open File"));
        }
    }

    @others
};

FileDialogRef CreateOpenFileDialog(WindowRef parentWindow) {
    std::shared_ptr&lt;FileDialogImplWin32&gt; dialog = std::make_shared&lt;FileDialogImplWin32&gt;();
    dialog-&gt;ofn.hwndOwner = std::static_pointer_cast&lt;WindowImplWin32&gt;(parentWindow)-&gt;hWindow;
    dialog-&gt;isSaveDialog = false;
    return dialog;
}

FileDialogRef CreateSaveFileDialog(WindowRef parentWindow) {
    std::shared_ptr&lt;FileDialogImplWin32&gt; dialog = std::make_shared&lt;FileDialogImplWin32&gt;();
    dialog-&gt;ofn.hwndOwner = std::static_pointer_cast&lt;WindowImplWin32&gt;(parentWindow)-&gt;hWindow;
    dialog-&gt;isSaveDialog = true;
    return dialog;
}

//-----------------------------------------------------------------------------
// Application-wide APIs
//-----------------------------------------------------------------------------

std::vector&lt;Platform::Path&gt; GetFontFiles() {
    std::vector&lt;Platform::Path&gt; fonts;

    std::wstring fontsDirW(MAX_PATH, '\0');
    fontsDirW.resize(GetWindowsDirectoryW(&amp;fontsDirW[0], fontsDirW.length()));
    fontsDirW += L"\\fonts\\";
    Platform::Path fontsDir = Platform::Path::From(Narrow(fontsDirW));

    WIN32_FIND_DATAW wfd;
    HANDLE h = FindFirstFileW((fontsDirW + L"*").c_str(), &amp;wfd);
    while(h != INVALID_HANDLE_VALUE) {
        fonts.push_back(fontsDir.Join(Narrow(wfd.cFileName)));
        if(!FindNextFileW(h, &amp;wfd)) break;
    }

    return fonts;
}

</t>
<t tx="leo.20191228122649.216">void SetTitle(std::string title) override {
    titleW = PrepareTitle(title);
    ofn.lpstrTitle = titleW.c_str();
}

</t>
<t tx="leo.20191228122649.217">void SetCurrentName(std::string name) override {
    SetFilename(GetFilename().Parent().Join(name));
}

Platform::Path GetFilename() override {
    return Path::From(Narrow(filenameWC));
}

</t>
<t tx="leo.20191228122649.218">void SetFilename(Platform::Path path) override {
    wcsncpy(filenameWC, Widen(path.raw).c_str(), sizeof(filenameWC) / sizeof(wchar_t) - 1);
}

</t>
<t tx="leo.20191228122649.219">void AddFilter(std::string name, std::vector&lt;std::string&gt; extensions) override {
    std::string desc, patterns;
    for(auto extension : extensions) {
        std::string pattern = "*." + extension;
        if(!desc.empty()) desc += ", ";
        desc += pattern;
        if(!patterns.empty()) patterns += ";";
        patterns += pattern;
    }
    filtersW += Widen(name + " (" + desc + ")" + '\0' + patterns + '\0');
    ofn.lpstrFilter = filtersW.c_str();
    if(ofn.lpstrDefExt == NULL) {
        defExtW = Widen(extensions.front());
        ofn.lpstrDefExt = defExtW.c_str();
    }
}

</t>
<t tx="leo.20191228122649.22">static std::string PrepareMnemonics(std::string label) {
    std::replace(label.begin(), label.end(), '&amp;', '_');
    return label;
}

</t>
<t tx="leo.20191228122649.220">void FreezeChoices(SettingsRef settings, const std::string &amp;key) override {
    settings-&gt;FreezeString("Dialog_" + key + "_Folder", GetFilename().Parent().raw);
    settings-&gt;FreezeInt("Dialog_" + key + "_Filter", ofn.nFilterIndex);
}

</t>
<t tx="leo.20191228122649.221">void ThawChoices(SettingsRef settings, const std::string &amp;key) override {
    initialDirW = Widen(settings-&gt;ThawString("Dialog_" + key + "_Folder", ""));
    ofn.lpstrInitialDir = initialDirW.c_str();
    ofn.nFilterIndex = settings-&gt;ThawInt("Dialog_" + key + "_Filter", 0);
}

</t>
<t tx="leo.20191228122649.222">bool RunModal() override {
    if(GetFilename().IsEmpty()) {
        SetFilename(Path::From(_("untitled")));
    }

    if(isSaveDialog) {
        return GetSaveFileNameW(&amp;ofn) == TRUE;
    } else {
        return GetOpenFileNameW(&amp;ofn) == TRUE;
    }
}
</t>
<t tx="leo.20191228122649.223">void OpenInBrowser(const std::string &amp;url) {
    ShellExecuteW(NULL, L"open", Widen(url).c_str(), NULL, NULL, SW_SHOWNORMAL);
}

</t>
<t tx="leo.20191228122649.224">void InitGui(int argc, char **argv) {
    INITCOMMONCONTROLSEX icc;
    icc.dwSize = sizeof(icc);
    icc.dwICC  = ICC_STANDARD_CLASSES|ICC_BAR_CLASSES;
    InitCommonControlsEx(&amp;icc);

    if(!SetLocale((uint16_t)GetUserDefaultLCID())) {
        SetLocale("en_US");
    }
}

</t>
<t tx="leo.20191228122649.225">void RunGui() {
    MSG msg;
    // The return value of the following functions doesn't indicate success or failure.
    while(GetMessage(&amp;msg, NULL, 0, 0)) {
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
    }
}

</t>
<t tx="leo.20191228122649.226">void ExitGui() {
    PostQuitMessage(0);
}

void ClearGui() {}
</t>
<t tx="leo.20191228122649.227">@path ./src/platform/
//-----------------------------------------------------------------------------
// Platform-dependent functionality.
//
// Copyright 2017 whitequark
//-----------------------------------------------------------------------------
#if defined(__APPLE__)
// Include Apple headers before solvespace.h to avoid identifier clashes.
#   include &lt;CoreFoundation/CFString.h&gt;
#   include &lt;CoreFoundation/CFURL.h&gt;
#   include &lt;CoreFoundation/CFBundle.h&gt;
#endif
#include "solvespace.h"
#include "config.h"
#if defined(WIN32)
// Conversely, include Microsoft headers after solvespace.h to avoid clashes.
#   include &lt;windows.h&gt;
#else
#   include &lt;unistd.h&gt;
#   include &lt;sys/stat.h&gt;
#endif

namespace SolveSpace {
namespace Platform {

//-----------------------------------------------------------------------------
// UTF-8 ⟷ UTF-16 conversion, on Windows.
//-----------------------------------------------------------------------------

#if defined(WIN32)

std::string Narrow(const wchar_t *in)
{
    std::string out;
    DWORD len = WideCharToMultiByte(CP_UTF8, 0, in, -1, NULL, 0, NULL, NULL);
    out.resize(len - 1);
    ssassert(WideCharToMultiByte(CP_UTF8, 0, in, -1, &amp;out[0], len, NULL, NULL),
             "Invalid UTF-16");
    return out;
}

std::string Narrow(const std::wstring &amp;in)
{
    if(in == L"") return "";

    std::string out;
    out.resize(WideCharToMultiByte(CP_UTF8, 0, &amp;in[0], (int)in.length(),
                                   NULL, 0, NULL, NULL));
    ssassert(WideCharToMultiByte(CP_UTF8, 0, &amp;in[0], (int)in.length(),
                                 &amp;out[0], (int)out.length(), NULL, NULL),
             "Invalid UTF-16");
    return out;
}

std::wstring Widen(const char *in)
{
    std::wstring out;
    DWORD len = MultiByteToWideChar(CP_UTF8, 0, in, -1, NULL, 0);
    out.resize(len - 1);
    ssassert(MultiByteToWideChar(CP_UTF8, 0, in, -1, &amp;out[0], len),
             "Invalid UTF-8");
    return out;
}

std::wstring Widen(const std::string &amp;in)
{
    if(in == "") return L"";

    std::wstring out;
    out.resize(MultiByteToWideChar(CP_UTF8, 0, &amp;in[0], (int)in.length(), NULL, 0));
    ssassert(MultiByteToWideChar(CP_UTF8, 0, &amp;in[0], (int)in.length(),
                                 &amp;out[0], (int)out.length()),
             "Invalid UTF-8");
    return out;
}

#endif

//-----------------------------------------------------------------------------
// Path utility functions.
//-----------------------------------------------------------------------------

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122649.228">static std::vector&lt;std::string&gt; Split(const std::string &amp;joined, char separator) {
    std::vector&lt;std::string&gt; parts;

    size_t oldpos = 0, pos = 0;
    while(true) {
        oldpos = pos;
        pos = joined.find(separator, pos);
        if(pos == std::string::npos) break;
        parts.push_back(joined.substr(oldpos, pos - oldpos));
        pos += 1;
    }

    if(oldpos != joined.length() - 1) {
        parts.push_back(joined.substr(oldpos));
    }

    return parts;
}

</t>
<t tx="leo.20191228122649.229">static std::string Concat(const std::vector&lt;std::string&gt; &amp;parts, char separator) {
    std::string joined;

    bool first = true;
    for(auto &amp;part : parts) {
        if(!first) joined += separator;
        joined += part;
        first = false;
    }

    return joined;
}

//-----------------------------------------------------------------------------
// Path manipulation.
//-----------------------------------------------------------------------------

#if defined(WIN32)
const char SEPARATOR = '\\';
#else
const char SEPARATOR = '/';
#endif

Path Path::From(std::string raw) {
    Path path = { raw };
    return path;
}

Path Path::CurrentDirectory() {
#if defined(WIN32)
    // On Windows, OpenFile needs an absolute UNC path proper, so get that.
    std::wstring rawW;
    rawW.resize(GetCurrentDirectoryW(0, NULL));
    DWORD length = GetCurrentDirectoryW((int)rawW.length(), &amp;rawW[0]);
    ssassert(length &gt; 0 &amp;&amp; length == rawW.length() - 1, "Cannot get current directory");
    rawW.resize(length);
    return From(Narrow(rawW));
#else
    char *raw = getcwd(NULL, 0);
    ssassert(raw != NULL, "Cannot get current directory");
    Path path = From(raw);
    free(raw);
    return path;
#endif
}

std::string Path::FileName() const {
    std::string fileName = raw;
    size_t slash = fileName.rfind(SEPARATOR);
    if(slash != std::string::npos) {
        fileName = fileName.substr(slash + 1);
    }
    return fileName;
}

std::string Path::FileStem() const {
    std::string baseName = FileName();
    size_t dot = baseName.rfind('.');
    if(dot != std::string::npos) {
        baseName = baseName.substr(0, dot);
    }
    return baseName;
}

std::string Path::Extension() const {
    size_t dot = raw.rfind('.');
    if(dot != std::string::npos) {
        return raw.substr(dot + 1);
    }
    return "";
}

</t>
<t tx="leo.20191228122649.23">static std::string PrepareTitle(const std::string &amp;title) {
    return title + " — SolveSpace";
}

//-----------------------------------------------------------------------------
// Fatal errors
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.230">bool Path::HasExtension(std::string theirExt) const {
    std::string ourExt = Extension();
    std::transform(ourExt.begin(),   ourExt.end(),   ourExt.begin(),   ::tolower);
    std::transform(theirExt.begin(), theirExt.end(), theirExt.begin(), ::tolower);
    return ourExt == theirExt;
}

Path Path::WithExtension(std::string ext) const {
    Path withExt = *this;
    size_t dot = withExt.raw.rfind('.');
    if(dot != std::string::npos) {
        withExt.raw.erase(dot);
    }
    withExt.raw += ".";
    withExt.raw += ext;
    return withExt;
}

</t>
<t tx="leo.20191228122649.231">static void FindPrefix(const std::string &amp;raw, size_t *pos) {
    *pos = std::string::npos;
#if defined(WIN32)
    if(raw.size() &gt;= 7 &amp;&amp; raw[2] == '?' &amp;&amp; raw[3] == '\\' &amp;&amp;
            isalpha(raw[4]) &amp;&amp; raw[5] == ':' &amp;&amp; raw[6] == '\\') {
        *pos = 7;
    } else if(raw.size() &gt;= 3 &amp;&amp; isalpha(raw[0]) &amp;&amp; raw[1] == ':' &amp;&amp; raw[2] == '\\') {
        *pos = 3;
    } else if(raw.size() &gt;= 2 &amp;&amp; raw[0] == '\\' &amp;&amp; raw[1] == '\\') {
        size_t slashAt = raw.find('\\', 2);
        if(slashAt != std::string::npos) {
            *pos = raw.find('\\', slashAt + 1);
        }
    }
#else
    if(!raw.empty() &amp;&amp; raw[0] == '/') {
        *pos = 1;
    }
#endif
}

</t>
<t tx="leo.20191228122649.232">bool Path::IsAbsolute() const {
    size_t pos;
    FindPrefix(raw, &amp;pos);
    return pos != std::string::npos;
}

// Removes one component from the end of the path.
// Returns an empty path if the path consists only of a root.
Path Path::Parent() const {
    Path parent = { raw };
    if(!parent.raw.empty() &amp;&amp; parent.raw.back() == SEPARATOR) {
        parent.raw.pop_back();
    }
    size_t slash = parent.raw.rfind(SEPARATOR);
    if(slash != std::string::npos) {
        parent.raw = parent.raw.substr(0, slash + 1);
    } else {
        parent.raw.clear();
    }
    if(IsAbsolute() &amp;&amp; !parent.IsAbsolute()) {
        return From("");
    }
    return parent;
}

// Concatenates a component to this path.
// Returns an empty path if this path or the component is empty.
Path Path::Join(const std::string &amp;component) const {
    ssassert(component.find(SEPARATOR) == std::string::npos,
             "Use the Path::Join(const Path &amp;) overload to append an entire path");
    return Join(Path::From(component));
}

// Concatenates a relative path to this path.
// Returns an empty path if either path is empty, or the other path is absolute.
Path Path::Join(const Path &amp;other) const {
    if(IsEmpty() || other.IsEmpty() || other.IsAbsolute()) {
        return From("");
    }

    Path joined = { raw };
    if(joined.raw.back() != SEPARATOR) {
        joined.raw += SEPARATOR;
    }
    joined.raw += other.raw;
    return joined;
}

// Expands the "." and ".." components in this path.
// On Windows, additionally prepends the UNC prefix to absolute paths without one.
// Returns an empty path if a ".." component would escape from the root.
Path Path::Expand(bool fromCurrentDirectory) const {
    Path source;
    Path expanded;

    if(fromCurrentDirectory &amp;&amp; !IsAbsolute()) {
        source = CurrentDirectory().Join(*this);
    } else {
        source = *this;
    }

    size_t splitAt;
    FindPrefix(source.raw, &amp;splitAt);
    if(splitAt != std::string::npos) {
        expanded.raw = source.raw.substr(0, splitAt);
    } else {
        splitAt = 0;
    }

    std::vector&lt;std::string&gt; expandedComponents;
    for(std::string component : Split(source.raw.substr(splitAt), SEPARATOR)) {
        if(component == ".") {
            // skip
        } else if(component == "..") {
            if(!expandedComponents.empty()) {
                expandedComponents.pop_back();
            } else {
                return From("");
            }
        } else if(!component.empty()) {
            expandedComponents.push_back(component);
        }
    }

    if(expanded.IsEmpty()) {
        if(expandedComponents.empty()) {
            expandedComponents.emplace_back(".");
        }
        expanded = From(Concat(expandedComponents, SEPARATOR));
    } else if(!expandedComponents.empty()) {
        expanded = expanded.Join(From(Concat(expandedComponents, SEPARATOR)));
    }

#if defined(WIN32)
    if(expanded.IsAbsolute() &amp;&amp; expanded.raw.substr(0, 2) != "\\\\") {
        expanded.raw = "\\\\?\\" + expanded.raw;
    }
#endif

    return expanded;
}

</t>
<t tx="leo.20191228122649.233">static std::string FilesystemNormalize(const std::string &amp;str) {
#if defined(WIN32)
    std::wstring strW = Widen(str);
    std::transform(strW.begin(), strW.end(), strW.begin(), towlower);
    return Narrow(strW);
#elif defined(__APPLE__)
    CFMutableStringRef cfStr =
        CFStringCreateMutableCopy(NULL, 0,
            CFStringCreateWithBytesNoCopy(NULL, (const UInt8*)str.data(), str.size(),
                kCFStringEncodingUTF8, /*isExternalRepresentation=*/false, kCFAllocatorNull));
    CFStringLowercase(cfStr, NULL);
    std::string normalizedStr;
    normalizedStr.resize(CFStringGetMaximumSizeOfFileSystemRepresentation(cfStr));
    CFStringGetFileSystemRepresentation(cfStr, &amp;normalizedStr[0], normalizedStr.size());
    normalizedStr.erase(normalizedStr.find('\0'));
    return normalizedStr;
#else
    return str;
#endif
}

</t>
<t tx="leo.20191228122649.234">bool Path::Equals(const Path &amp;other) const {
    return FilesystemNormalize(raw) == FilesystemNormalize(other.raw);
}

// Returns a relative path from a given base path.
// Returns an empty path if any of the paths is not absolute, or
// if they belong to different roots, or
// if they cannot be expanded.
Path Path::RelativeTo(const Path &amp;base) const {
    Path expanded = Expand();
    Path baseExpanded = base.Expand();
    if(!(expanded.IsAbsolute() &amp;&amp; baseExpanded.IsAbsolute())){
        return From("");
    }

    size_t splitAt;
    FindPrefix(expanded.raw, &amp;splitAt);
    size_t baseSplitAt;
    FindPrefix(baseExpanded.raw, &amp;baseSplitAt);
    if(FilesystemNormalize(expanded.raw.substr(0, splitAt)) !=
            FilesystemNormalize(baseExpanded.raw.substr(0, splitAt))) {
        return From("");
    }

    std::vector&lt;std::string&gt; components =
        Split(expanded.raw.substr(splitAt), SEPARATOR);
    std::vector&lt;std::string&gt; baseComponents =
        Split(baseExpanded.raw.substr(baseSplitAt), SEPARATOR);
    size_t common;
    for(common = 0; common &lt; baseComponents.size() &amp;&amp;
                    common &lt; components.size(); common++) {
        if(FilesystemNormalize(baseComponents[common]) !=
                FilesystemNormalize(components[common])) {
            break;
        }
    }

    std::vector&lt;std::string&gt; resultComponents;
    for(size_t i = common; i &lt; baseComponents.size(); i++) {
        resultComponents.emplace_back("..");
    }
    resultComponents.insert(resultComponents.end(),
                            components.begin() + common, components.end());
    if(resultComponents.empty()) {
        resultComponents.emplace_back(".");
    }
    return From(Concat(resultComponents, SEPARATOR));
}

Path Path::FromPortable(const std::string &amp;repr) {
    return From(Concat(Split(repr, '/'), SEPARATOR));
}

std::string Path::ToPortable() const {
    ssassert(!IsAbsolute(), "absolute paths cannot be made portable");

    return Concat(Split(raw, SEPARATOR), '/');
}

//-----------------------------------------------------------------------------
// File manipulation.
//-----------------------------------------------------------------------------

FILE *OpenFile(const Platform::Path &amp;filename, const char *mode) {
    ssassert(filename.raw.length() == strlen(filename.raw.c_str()),
             "Unexpected null byte in middle of a path");
#if defined(WIN32)
    return _wfopen(Widen(filename.Expand().raw).c_str(), Widen(mode).c_str());
#else
    return fopen(filename.raw.c_str(), mode);
#endif
}

</t>
<t tx="leo.20191228122649.235">bool FileExists(const Platform::Path &amp;filename) {
    FILE *f = OpenFile(filename, "rb");
    if(f == NULL) return false;
    fclose(f);
    return true;
}

</t>
<t tx="leo.20191228122649.236">void RemoveFile(const Platform::Path &amp;filename) {
    ssassert(filename.raw.length() == strlen(filename.raw.c_str()),
             "Unexpected null byte in middle of a path");
#if defined(WIN32)
    _wremove(Widen(filename.Expand().raw).c_str());
#else
    remove(filename.raw.c_str());
#endif
}

</t>
<t tx="leo.20191228122649.237">bool ReadFile(const Platform::Path &amp;filename, std::string *data) {
    FILE *f = OpenFile(filename, "rb");
    if(f == NULL) return false;

    if(fseek(f, 0, SEEK_END) != 0)
        return false;
    data-&gt;resize(ftell(f));
    if(fseek(f, 0, SEEK_SET) != 0)
        return false;
    if(fread(&amp;(*data)[0], 1, data-&gt;size(), f) != data-&gt;size())
        return false;
    if(fclose(f) != 0)
        return false;

    return true;
}

</t>
<t tx="leo.20191228122649.238">bool WriteFile(const Platform::Path &amp;filename, const std::string &amp;data) {
    FILE *f = OpenFile(filename, "wb");
    if(f == NULL) return false;

    if(fwrite(&amp;data[0], 1, data.size(), f) != data.size())
        return false;
    if(fclose(f) != 0)
        return false;

    return true;
}

//-----------------------------------------------------------------------------
// Loading resources, on Windows
//-----------------------------------------------------------------------------

#if defined(WIN32)

</t>
<t tx="leo.20191228122649.239">const void *LoadResource(const std::string &amp;name, size_t *size) {
    HRSRC hres = FindResourceW(NULL, Widen(name).c_str(), (LPWSTR)RT_RCDATA);
    ssassert(hres != NULL, "Cannot find resource");
    HGLOBAL res = ::LoadResource(NULL, hres);
    ssassert(res != NULL, "Cannot load resource");

    *size = SizeofResource(NULL, hres);
    return LockResource(res);
}

#endif

//-----------------------------------------------------------------------------
// Loading resources, on *nix
//-----------------------------------------------------------------------------

#if defined(__APPLE__)

</t>
<t tx="leo.20191228122649.24">void FatalError(const std::string &amp;message) {
    fprintf(stderr, "%s", message.c_str());
    abort();
}

//-----------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.240">static Platform::Path PathFromCFURL(CFURLRef cfUrl) {
    Path path;
    CFStringRef cfPath = CFURLCopyFileSystemPath(cfUrl, kCFURLPOSIXPathStyle);
    path.raw.resize(CFStringGetMaximumSizeOfFileSystemRepresentation(cfPath));
    CFStringGetFileSystemRepresentation(cfPath, &amp;path.raw[0], path.raw.size());
    path.raw.erase(path.raw.find('\0'));
    CFRelease(cfPath);
    return path;
}

</t>
<t tx="leo.20191228122649.241">static Platform::Path ResourcePath(const std::string &amp;name) {
    Path path;

    // First, try to get the URL from the bundle.
    CFStringRef cfName = CFStringCreateWithCString(kCFAllocatorDefault, name.c_str(),
                                                   kCFStringEncodingUTF8);
    CFURLRef cfUrl = CFBundleCopyResourceURL(CFBundleGetMainBundle(), cfName, NULL, NULL);
    if(cfUrl != NULL) {
        path = PathFromCFURL(cfUrl);
        CFRelease(cfUrl);
    }
    CFRelease(cfName);

    if(!path.IsEmpty()) return path;

    // If that failed, it means we aren't running from the bundle.
    // Reference off the executable path, then.
    cfUrl = CFBundleCopyExecutableURL(CFBundleGetMainBundle());
    if(cfUrl != NULL) {
        path = PathFromCFURL(cfUrl).Parent().Parent().Join("res");
        path = path.Join(Path::FromPortable(name));
        CFRelease(cfUrl);
    }

    return path;
}

#elif !defined(WIN32)

#    if defined(__linux__)
static const char *selfSymlink = "/proc/self/exe";
#    elif defined(__NetBSD__)
static const char *selfSymlink = "/proc/curproc/exe";
#    elif defined(__OpenBSD__) || defined(__FreeBSD__)
static const char *selfSymlink = "/proc/curproc/file";
#    else
static const char *selfSymlink = "";
#    endif

</t>
<t tx="leo.20191228122649.242">static Platform::Path FindLocalResourceDir() {
    // Find out the path to the running binary.
    Platform::Path selfPath;
    char *expandedSelfPath = realpath(selfSymlink, NULL);
    if(expandedSelfPath != NULL) {
        selfPath = Path::From(expandedSelfPath);
    }
    free(expandedSelfPath);

    Platform::Path resourceDir;
    if(selfPath.IsEmpty()) {
        // We don't know how to find the local resource directory on this platform,
        // so use the global one (by returning an empty string).
        return Path::From(UNIX_DATADIR);
    } else {
        resourceDir = selfPath.Parent().Parent().Join("res");
    }

    struct stat st;
    if(stat(resourceDir.raw.c_str(), &amp;st) != -1) {
        // An executable-adjacent resource directory exists, good.
        return resourceDir;
    }

    resourceDir = selfPath.Parent().Parent().Join("share").Join("solvespace");
    if(stat(resourceDir.raw.c_str(), &amp;st) != -1) {
        // A resource directory exists at a relative path, good.
        return resourceDir;
    }

    // No executable-adjacent resource directory; use the one from compile-time prefix.
    return Path::From(UNIX_DATADIR);
}

</t>
<t tx="leo.20191228122649.243">static Platform::Path ResourcePath(const std::string &amp;name) {
    static Platform::Path resourceDir;
    if(resourceDir.IsEmpty()) {
        resourceDir = FindLocalResourceDir();
    }

    return resourceDir.Join(Path::FromPortable(name));
}

#endif

#if !defined(WIN32)

</t>
<t tx="leo.20191228122649.244">const void *LoadResource(const std::string &amp;name, size_t *size) {
    static std::map&lt;std::string, std::string&gt; cache;

    auto it = cache.find(name);
    if(it == cache.end()) {
        ssassert(ReadFile(ResourcePath(name), &amp;cache[name]), "Cannot read resource");
        it = cache.find(name);
    }

    const std::string &amp;content = (*it).second;
    *size = content.size();
    return (const void*)content.data();
}

#endif

//-----------------------------------------------------------------------------
// Command-line argument handling
//-----------------------------------------------------------------------------

}
}
</t>
<t tx="leo.20191228122649.245">@path ./src/platform/
//-----------------------------------------------------------------------------
// Platform-dependent functionality.
//
// Copyright 2017 whitequark
//-----------------------------------------------------------------------------

#ifndef SOLVESPACE_PLATFORM_H
#define SOLVESPACE_PLATFORM_H

namespace Platform {

// UTF-8 ⟷ UTF-16 conversion, for Windows.
#if defined(WIN32)
std::string Narrow(const wchar_t *s);
std::wstring Widen(const char *s);
std::string Narrow(const std::wstring &amp;s);
std::wstring Widen(const std::string &amp;s);
#endif

// A filesystem path, respecting the conventions of the current platform.
// Transformation functions return an empty path on error.
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122649.246">class Path {
public:
    std::string raw;

    static Path From(std::string raw);
    static Path CurrentDirectory();

    void Clear() { raw.clear(); }

    bool Equals(const Path &amp;other) const;
    bool IsEmpty() const { return raw.empty(); }
    bool IsAbsolute() const;
    bool HasExtension(std::string ext) const;

    std::string FileName() const;
    std::string FileStem() const;
    std::string Extension() const;

    Path WithExtension(std::string ext) const;
    Path Parent() const;
    Path Join(const std::string &amp;component) const;
    Path Join(const Path &amp;other) const;
    Path Expand(bool fromCurrentDirectory = false) const;
    Path RelativeTo(const Path &amp;base) const;

    // Converting to and from a platform-independent representation
    // (conventionally, the Unix one).
    static Path FromPortable(const std::string &amp;repr);
    std::string ToPortable() const;
};

struct PathLess {
    bool operator()(const Path &amp;a, const Path &amp;b) const { return a.raw &lt; b.raw; }
};

// File manipulation functions.
bool FileExists(const Platform::Path &amp;filename);
FILE *OpenFile(const Platform::Path &amp;filename, const char *mode);
bool ReadFile(const Platform::Path &amp;filename, std::string *data);
bool WriteFile(const Platform::Path &amp;filename, const std::string &amp;data);
void RemoveFile(const Platform::Path &amp;filename);

// Resource loading function.
const void *LoadResource(const std::string &amp;name, size_t *size);

}

#endif
</t>
<t tx="leo.20191228122649.247">@path ./src/platform/
//-----------------------------------------------------------------------------
// Utility functions used by the Unix port. Notably, our memory allocation;
// we use two separate allocators, one for long-lived stuff and one for
// stuff that gets freed after every regeneration of the model, to save us
// the trouble of freeing the latter explicitly.
//
// Copyright 2008-2013 Jonathan Westhues.
// Copyright 2013 Daniel Richard G. &lt;skunk@iSKUNK.ORG&gt;
//-----------------------------------------------------------------------------
#include "config.h"
#include "solvespace.h"
#if defined(HAVE_BACKTRACE)
#  include BACKTRACE_HEADER
#endif

namespace SolveSpace {

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122649.248">void dbp(const char *fmt, ...)
{
    va_list va;
    va_start(va, fmt);
    vfprintf(stdout, fmt, va);
    fputc('\n', stdout);
    va_end(va);

    fflush(stdout);
}

//-----------------------------------------------------------------------------
// A separate heap, on which we allocate expressions. Maybe a bit faster,
// since fragmentation is less of a concern, and it also makes it possible
// to be sloppy with our memory management, and just free everything at once
// at the end.
//-----------------------------------------------------------------------------

typedef struct _AllocTempHeader AllocTempHeader;

</t>
<t tx="leo.20191228122649.25">class SettingsImplGtk final : public Settings {
public:
    // Why aren't we using GSettings? Two reasons. It doesn't allow to easily see whether
    // the setting had the default value, and it requires to install a schema globally.
    Path         _path;
    json_object *_json = NULL;

    @others
};

SettingsRef GetSettings() {
    static std::shared_ptr&lt;SettingsImplGtk&gt; settings;
    if(!settings) {
        settings = std::make_shared&lt;SettingsImplGtk&gt;();
    }
    return settings;
}

//-----------------------------------------------------------------------------
// Timers
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.26">static Path GetConfigPath() {
    Path configHome;
    if(getenv("XDG_CONFIG_HOME")) {
        configHome = Path::From(getenv("XDG_CONFIG_HOME"));
    } else if(getenv("HOME")) {
        configHome = Path::From(getenv("HOME")).Join(".config");
    } else {
        dbp("neither XDG_CONFIG_HOME nor HOME are set");
        return Path::From("");
    }
    if(!configHome.IsEmpty()) {
        configHome = configHome.Join("solvespace");
    }

    const char *configHomeC = configHome.raw.c_str();
    struct stat st;
    if(stat(configHomeC, &amp;st)) {
        if(errno == ENOENT) {
            if(mkdir(configHomeC, 0777)) {
                dbp("cannot mkdir %s: %s", configHomeC, strerror(errno));
                return Path::From("");
            }
        } else {
            dbp("cannot stat %s: %s", configHomeC, strerror(errno));
            return Path::From("");
        }
    } else if(!S_ISDIR(st.st_mode)) {
        dbp("%s is not a directory", configHomeC);
        return Path::From("");
    }

    return configHome.Join("settings.json");
}

SettingsImplGtk() {
    _path = GetConfigPath();
    if(_path.IsEmpty()) {
        dbp("settings will not be saved");
    } else {
        _json = json_object_from_file(_path.raw.c_str());
        if(!_json &amp;&amp; errno != ENOENT) {
            dbp("cannot load settings: %s", strerror(errno));
        }
    }

    if(_json == NULL) {
        _json = json_object_new_object();
    }
}

~SettingsImplGtk() override {
    if(!_path.IsEmpty()) {
        // json-c &lt;0.12 has the first argument non-const
        if(json_object_to_file_ext((char *)_path.raw.c_str(), _json,
                                   JSON_C_TO_STRING_PRETTY)) {
            dbp("cannot save settings: %s", strerror(errno));
        }
    }

    json_object_put(_json);
}

</t>
<t tx="leo.20191228122649.27">void FreezeInt(const std::string &amp;key, uint32_t value) override {
    struct json_object *jsonValue = json_object_new_int(value);
    json_object_object_add(_json, key.c_str(), jsonValue);
}

uint32_t ThawInt(const std::string &amp;key, uint32_t defaultValue) override {
    struct json_object *jsonValue;
    if(json_object_object_get_ex(_json, key.c_str(), &amp;jsonValue)) {
        return json_object_get_int(jsonValue);
    }
    return defaultValue;
}

</t>
<t tx="leo.20191228122649.28">void FreezeBool(const std::string &amp;key, bool value) override {
    struct json_object *jsonValue = json_object_new_boolean(value);
    json_object_object_add(_json, key.c_str(), jsonValue);
}

</t>
<t tx="leo.20191228122649.29">bool ThawBool(const std::string &amp;key, bool defaultValue) override {
    struct json_object *jsonValue;
    if(json_object_object_get_ex(_json, key.c_str(), &amp;jsonValue)) {
        return json_object_get_boolean(jsonValue);
    }
    return defaultValue;
}

</t>
<t tx="leo.20191228122649.3">int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine, INT nCmdShow) {
    return main(0, NULL);
}
#endif
</t>
<t tx="leo.20191228122649.30">void FreezeFloat(const std::string &amp;key, double value) override {
    struct json_object *jsonValue = json_object_new_double(value);
    json_object_object_add(_json, key.c_str(), jsonValue);
}

</t>
<t tx="leo.20191228122649.31">double ThawFloat(const std::string &amp;key, double defaultValue) override {
    struct json_object *jsonValue;
    if(json_object_object_get_ex(_json, key.c_str(), &amp;jsonValue)) {
        return json_object_get_double(jsonValue);
    }
    return defaultValue;
}

</t>
<t tx="leo.20191228122649.32">void FreezeString(const std::string &amp;key, const std::string &amp;value) override {
    struct json_object *jsonValue = json_object_new_string(value.c_str());
    json_object_object_add(_json, key.c_str(), jsonValue);
}

std::string ThawString(const std::string &amp;key,
</t>
<t tx="leo.20191228122649.33">                       const std::string &amp;defaultValue = "") override {
    struct json_object *jsonValue;
    if(json_object_object_get_ex(_json, key.c_str(), &amp;jsonValue)) {
        return json_object_get_string(jsonValue);
    }
    return defaultValue;
}
</t>
<t tx="leo.20191228122649.34">class TimerImplGtk final : public Timer {
public:
    sigc::connection    _connection;

    @others
};

TimerRef CreateTimer() {
    return std::make_shared&lt;TimerImplGtk&gt;();
}

//-----------------------------------------------------------------------------
// GTK menu extensions
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.35">void RunAfter(unsigned milliseconds) override {
    if(!_connection.empty()) {
        _connection.disconnect();
    }

    @others
}
</t>
<t tx="leo.20191228122649.36">auto handler = [this]() {
    if(this-&gt;onTimeout) {
        this-&gt;onTimeout();
    }
    return false;
};
_connection = Glib::signal_timeout().connect(handler, milliseconds);
</t>
<t tx="leo.20191228122649.37">class GtkMenuItem : public Gtk::CheckMenuItem {
    Platform::MenuItem *_receiver;
    bool                _has_indicator;
    bool                _synthetic_event;

public:
    GtkMenuItem(Platform::MenuItem *receiver) :
        _receiver(receiver), _has_indicator(false), _synthetic_event(false) {
    }

    @others
};

//-----------------------------------------------------------------------------
// Menus
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.38">void set_accel_key(const Gtk::AccelKey &amp;accel_key) {
    Gtk::CheckMenuItem::set_accel_key(accel_key);
}

</t>
<t tx="leo.20191228122649.39">bool has_indicator() const {
    return _has_indicator;
}

</t>
<t tx="leo.20191228122649.4">@path ./src/platform/
//-----------------------------------------------------------------------------
// Platform-dependent GUI functionality that has only minor differences.
//
// Copyright 2018 whitequark
//-----------------------------------------------------------------------------
#include "solvespace.h"

namespace SolveSpace {
namespace Platform {

//-----------------------------------------------------------------------------
// Keyboard events
//-----------------------------------------------------------------------------

std::string AcceleratorDescription(const KeyboardEvent &amp;accel) {
    std::string label;
    if(accel.controlDown) {
#ifdef __APPLE__
        label += "⌘+";
#else
        label += "Ctrl+";
#endif
    }

    if(accel.shiftDown) {
        label += "Shift+";
    }

    switch(accel.key) {
        case KeyboardEvent::Key::FUNCTION:
            label += ssprintf("F%d", accel.num);
            break;

        case KeyboardEvent::Key::CHARACTER:
            if(accel.chr == '\t') {
                label += "Tab";
            } else if(accel.chr == ' ') {
                label += "Space";
            } else if(accel.chr == '\x1b') {
                label += "Esc";
            } else if(accel.chr == '\x7f') {
                label += "Del";
            } else if(accel.chr != 0) {
                label += toupper((char)(accel.chr &amp; 0xff));
            }
            break;
    }

    return label;
}

//-----------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122649.40">void set_has_indicator(bool has_indicator) {
    _has_indicator = has_indicator;
}

</t>
<t tx="leo.20191228122649.41">    void set_active(bool active) {
        if(Gtk::CheckMenuItem::get_active() == active)
            return;

        _synthetic_event = true;
        Gtk::CheckMenuItem::set_active(active);
        _synthetic_event = false;
    }

protected:
</t>
<t tx="leo.20191228122649.42">void on_activate() override {
    Gtk::CheckMenuItem::on_activate();

    if(!_synthetic_event &amp;&amp; _receiver-&gt;onTrigger) {
        _receiver-&gt;onTrigger();
    }
}

</t>
<t tx="leo.20191228122649.43">void draw_indicator_vfunc(const Cairo::RefPtr&lt;Cairo::Context&gt; &amp;cr) override {
    if(_has_indicator) {
        Gtk::CheckMenuItem::draw_indicator_vfunc(cr);
    }
}
</t>
<t tx="leo.20191228122649.44">class MenuItemImplGtk final : public MenuItem {
public:
    GtkMenuItem gtkMenuItem;

    MenuItemImplGtk() : gtkMenuItem(this) {}

    @others
};

</t>
<t tx="leo.20191228122649.45">void SetAccelerator(KeyboardEvent accel) override {
    guint accelKey = 0;
    if(accel.key == KeyboardEvent::Key::CHARACTER) {
        if(accel.chr == '\t') {
            accelKey = GDK_KEY_Tab;
        } else if(accel.chr == '\x1b') {
            accelKey = GDK_KEY_Escape;
        } else if(accel.chr == '\x7f') {
            accelKey = GDK_KEY_Delete;
        } else {
            accelKey = gdk_unicode_to_keyval(accel.chr);
        }
    } else if(accel.key == KeyboardEvent::Key::FUNCTION) {
        accelKey = GDK_KEY_F1 + accel.num - 1;
    }

    Gdk::ModifierType accelMods = {};
    if(accel.shiftDown) {
        accelMods |= Gdk::SHIFT_MASK;
    }
    if(accel.controlDown) {
        accelMods |= Gdk::CONTROL_MASK;
    }

    gtkMenuItem.set_accel_key(Gtk::AccelKey(accelKey, accelMods));
}

</t>
<t tx="leo.20191228122649.46">void SetIndicator(Indicator type) override {
    switch(type) {
        case Indicator::NONE:
            gtkMenuItem.set_has_indicator(false);
            break;

        case Indicator::CHECK_MARK:
            gtkMenuItem.set_has_indicator(true);
            gtkMenuItem.set_draw_as_radio(false);
            break;

        case Indicator::RADIO_MARK:
            gtkMenuItem.set_has_indicator(true);
            gtkMenuItem.set_draw_as_radio(true);
            break;
    }
}

</t>
<t tx="leo.20191228122649.47">void SetActive(bool active) override {
    ssassert(gtkMenuItem.has_indicator(),
             "Cannot change state of a menu item without indicator");
    gtkMenuItem.set_active(active);
}

</t>
<t tx="leo.20191228122649.48">void SetEnabled(bool enabled) override {
    gtkMenuItem.set_sensitive(enabled);
}
</t>
<t tx="leo.20191228122649.49">class MenuImplGtk final : public Menu {
public:
    Gtk::Menu   gtkMenu;
    std::vector&lt;std::shared_ptr&lt;MenuItemImplGtk&gt;&gt;   menuItems;
    std::vector&lt;std::shared_ptr&lt;MenuImplGtk&gt;&gt;       subMenus;

    MenuItemRef AddItem(const std::string &amp;label,
                        std::function&lt;void()&gt; onTrigger = NULL,
                        @others
};

MenuRef CreateMenu() {
    return std::make_shared&lt;MenuImplGtk&gt;();
}

</t>
<t tx="leo.20191228122649.5">void Settings::FreezeBool(const std::string &amp;key, bool value) {
    FreezeInt(key, (int)value);
}

</t>
<t tx="leo.20191228122649.50">                    bool mnemonics = true) override {
    auto menuItem = std::make_shared&lt;MenuItemImplGtk&gt;();
    menuItems.push_back(menuItem);

    menuItem-&gt;gtkMenuItem.set_label(mnemonics ? PrepareMnemonics(label) : label);
    menuItem-&gt;gtkMenuItem.set_use_underline(mnemonics);
    menuItem-&gt;gtkMenuItem.show();
    menuItem-&gt;onTrigger = onTrigger;
    gtkMenu.append(menuItem-&gt;gtkMenuItem);

    return menuItem;
}

MenuRef AddSubMenu(const std::string &amp;label) override {
    auto menuItem = std::make_shared&lt;MenuItemImplGtk&gt;();
    menuItems.push_back(menuItem);

    auto subMenu = std::make_shared&lt;MenuImplGtk&gt;();
    subMenus.push_back(subMenu);

    menuItem-&gt;gtkMenuItem.set_label(PrepareMnemonics(label));
    menuItem-&gt;gtkMenuItem.set_use_underline(true);
    menuItem-&gt;gtkMenuItem.set_submenu(subMenu-&gt;gtkMenu);
    menuItem-&gt;gtkMenuItem.show_all();
    gtkMenu.append(menuItem-&gt;gtkMenuItem);

    return subMenu;
}

</t>
<t tx="leo.20191228122649.51">void AddSeparator() override {
    Gtk::SeparatorMenuItem *gtkMenuItem = Gtk::manage(new Gtk::SeparatorMenuItem());
    gtkMenuItem-&gt;show();
    gtkMenu.append(*Gtk::manage(gtkMenuItem));
}

</t>
<t tx="leo.20191228122649.52">void PopUp() override {
    Glib::RefPtr&lt;Glib::MainLoop&gt; loop = Glib::MainLoop::create();
    auto signal = gtkMenu.signal_deactivate().connect([&amp;]() { loop-&gt;quit(); });

    gtkMenu.show_all();
    gtkMenu.popup(0, GDK_CURRENT_TIME);
    loop-&gt;run();
    signal.disconnect();
}

</t>
<t tx="leo.20191228122649.53">void Clear() override {
    gtkMenu.foreach([&amp;](Gtk::Widget &amp;w) { gtkMenu.remove(w); });
    menuItems.clear();
    subMenus.clear();
}
</t>
<t tx="leo.20191228122649.54">class MenuBarImplGtk final : public MenuBar {
public:
    Gtk::MenuBar    gtkMenuBar;
    std::vector&lt;std::shared_ptr&lt;MenuImplGtk&gt;&gt;       subMenus;

    MenuRef AddSubMenu(const std::string &amp;label) override {
        auto subMenu = std::make_shared&lt;MenuImplGtk&gt;();
        subMenus.push_back(subMenu);

        Gtk::MenuItem *gtkMenuItem = Gtk::manage(new Gtk::MenuItem);
        gtkMenuItem-&gt;set_label(PrepareMnemonics(label));
        gtkMenuItem-&gt;set_use_underline(true);
        gtkMenuItem-&gt;set_submenu(subMenu-&gt;gtkMenu);
        gtkMenuItem-&gt;show_all();
        gtkMenuBar.append(*gtkMenuItem);

        return subMenu;
    }

    @others
};

MenuBarRef GetOrCreateMainMenu(bool *unique) {
    *unique = false;
    return std::make_shared&lt;MenuBarImplGtk&gt;();
}

//-----------------------------------------------------------------------------
// GTK GL and window extensions
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.55">void Clear() override {
    gtkMenuBar.foreach([&amp;](Gtk::Widget &amp;w) { gtkMenuBar.remove(w); });
    subMenus.clear();
}
</t>
<t tx="leo.20191228122649.56">class GtkGLWidget : public Gtk::GLArea {
    Window *_receiver;

public:
    GtkGLWidget(Platform::Window *receiver) : _receiver(receiver) {
        set_has_depth_buffer(true);
        set_can_focus(true);
        set_events(Gdk::POINTER_MOTION_MASK |
                   Gdk::BUTTON_PRESS_MASK |
                   Gdk::BUTTON_RELEASE_MASK |
                   Gdk::BUTTON_MOTION_MASK |
                   Gdk::SCROLL_MASK |
                   Gdk::LEAVE_NOTIFY_MASK |
                   Gdk::KEY_PRESS_MASK |
                   Gdk::KEY_RELEASE_MASK);
    }

protected:
    // Work around a bug fixed in GTKMM 3.22:
    // https://mail.gnome.org/archives/gtkmm-list/2016-April/msg00020.html
    Glib::RefPtr&lt;Gdk::GLContext&gt; on_create_context() override {
        return get_window()-&gt;create_gl_context();
    }

    @others
};

</t>
<t tx="leo.20191228122649.57">bool on_render(const Glib::RefPtr&lt;Gdk::GLContext&gt; &amp;context) override {
    if(_receiver-&gt;onRender) {
        _receiver-&gt;onRender();
    }
    return true;
}

</t>
<t tx="leo.20191228122649.58">bool process_pointer_event(MouseEvent::Type type, double x, double y,
                           guint state, guint button = 0, int scroll_delta = 0) {
    MouseEvent event = {};
    event.type = type;
    event.x = x;
    event.y = y;
    if(button == 1 || (state &amp; GDK_BUTTON1_MASK) != 0) {
        event.button = MouseEvent::Button::LEFT;
    } else if(button == 2 || (state &amp; GDK_BUTTON2_MASK) != 0) {
        event.button = MouseEvent::Button::MIDDLE;
    } else if(button == 3 || (state &amp; GDK_BUTTON3_MASK) != 0) {
        event.button = MouseEvent::Button::RIGHT;
    }
    if((state &amp; GDK_SHIFT_MASK) != 0) {
        event.shiftDown = true;
    }
    if((state &amp; GDK_CONTROL_MASK) != 0) {
        event.controlDown = true;
    }
    if(scroll_delta != 0) {
        event.scrollDelta = scroll_delta;
    }

    if(_receiver-&gt;onMouseEvent) {
        return _receiver-&gt;onMouseEvent(event);
    }

    return false;
}

</t>
<t tx="leo.20191228122649.59">bool on_motion_notify_event(GdkEventMotion *gdk_event) override {
    if(process_pointer_event(MouseEvent::Type::MOTION,
                             gdk_event-&gt;x, gdk_event-&gt;y, gdk_event-&gt;state))
        return true;

    return Gtk::GLArea::on_motion_notify_event(gdk_event);
}

</t>
<t tx="leo.20191228122649.6">bool Settings::ThawBool(const std::string &amp;key, bool defaultValue) {
    return ThawInt(key, (int)defaultValue) != 0;
}

</t>
<t tx="leo.20191228122649.60">bool on_button_press_event(GdkEventButton *gdk_event) override {
    MouseEvent::Type type;
    if(gdk_event-&gt;type == GDK_BUTTON_PRESS) {
        type = MouseEvent::Type::PRESS;
    } else if(gdk_event-&gt;type == GDK_2BUTTON_PRESS) {
        type = MouseEvent::Type::DBL_PRESS;
    } else {
        return Gtk::GLArea::on_button_press_event(gdk_event);
    }

    if(process_pointer_event(type, gdk_event-&gt;x, gdk_event-&gt;y,
                             gdk_event-&gt;state, gdk_event-&gt;button))
        return true;

    return Gtk::GLArea::on_button_press_event(gdk_event);
}

</t>
<t tx="leo.20191228122649.61">bool on_button_release_event(GdkEventButton *gdk_event) override {
    if(process_pointer_event(MouseEvent::Type::RELEASE,
                             gdk_event-&gt;x, gdk_event-&gt;y,
                             gdk_event-&gt;state, gdk_event-&gt;button))
        return true;

    return Gtk::GLArea::on_button_release_event(gdk_event);
}

</t>
<t tx="leo.20191228122649.62">bool on_scroll_event(GdkEventScroll *gdk_event) override {
    int delta;
    if(gdk_event-&gt;delta_y &lt; 0 || gdk_event-&gt;direction == GDK_SCROLL_UP) {
        delta = 1;
    } else if(gdk_event-&gt;delta_y &gt; 0 || gdk_event-&gt;direction == GDK_SCROLL_DOWN) {
        delta = -1;
    } else {
        return false;
    }

    if(process_pointer_event(MouseEvent::Type::SCROLL_VERT,
                             gdk_event-&gt;x, gdk_event-&gt;y,
                             gdk_event-&gt;state, 0, delta))
        return true;

    return Gtk::GLArea::on_scroll_event(gdk_event);
}

</t>
<t tx="leo.20191228122649.63">bool on_leave_notify_event(GdkEventCrossing *gdk_event) override {
    if(process_pointer_event(MouseEvent::Type::LEAVE,
                             gdk_event-&gt;x, gdk_event-&gt;y, gdk_event-&gt;state))
        return true;

    return Gtk::GLArea::on_leave_notify_event(gdk_event);
}

</t>
<t tx="leo.20191228122649.64">bool process_key_event(KeyboardEvent::Type type, GdkEventKey *gdk_event) {
    KeyboardEvent event = {};
    event.type = type;

    if(gdk_event-&gt;state &amp; ~(GDK_SHIFT_MASK|GDK_CONTROL_MASK)) {
        return false;
    }

    event.shiftDown   = (gdk_event-&gt;state &amp; GDK_SHIFT_MASK)   != 0;
    event.controlDown = (gdk_event-&gt;state &amp; GDK_CONTROL_MASK) != 0;

    char32_t chr = gdk_keyval_to_unicode(gdk_keyval_to_lower(gdk_event-&gt;keyval));
    if(chr != 0) {
        event.key = KeyboardEvent::Key::CHARACTER;
        event.chr = chr;
    } else if(gdk_event-&gt;keyval &gt;= GDK_KEY_F1 &amp;&amp;
              gdk_event-&gt;keyval &lt;= GDK_KEY_F12) {
        event.key = KeyboardEvent::Key::FUNCTION;
        event.num = gdk_event-&gt;keyval - GDK_KEY_F1 + 1;
    } else {
        return false;
    }

    if(_receiver-&gt;onKeyboardEvent) {
        return _receiver-&gt;onKeyboardEvent(event);
    }

    return false;
}

</t>
<t tx="leo.20191228122649.65">bool on_key_press_event(GdkEventKey *gdk_event) override {
    if(process_key_event(KeyboardEvent::Type::PRESS, gdk_event))
        return true;

    return Gtk::GLArea::on_key_press_event(gdk_event);
}

</t>
<t tx="leo.20191228122649.66">bool on_key_release_event(GdkEventKey *gdk_event) override {
    if(process_key_event(KeyboardEvent::Type::RELEASE, gdk_event))
        return true;

    return Gtk::GLArea::on_key_release_event(gdk_event);
}
</t>
<t tx="leo.20191228122649.67">class GtkEditorOverlay : public Gtk::Fixed {
    Window      *_receiver;
    GtkGLWidget _gl_widget;
    Gtk::Entry  _entry;

public:
    GtkEditorOverlay(Platform::Window *receiver) : _receiver(receiver), _gl_widget(receiver) {
        add(_gl_widget);

        _entry.set_no_show_all(true);
        _entry.set_has_frame(false);
        add(_entry);

        _entry.signal_activate().
            connect(sigc::mem_fun(this, &amp;GtkEditorOverlay::on_activate));
    }

    @others
};

</t>
<t tx="leo.20191228122649.68">bool is_editing() const {
    return _entry.is_visible();
}

</t>
<t tx="leo.20191228122649.69">void start_editing(int x, int y, int font_height, int min_width, bool is_monospace,
                   const std::string &amp;val) {
    Pango::FontDescription font_desc;
    font_desc.set_family(is_monospace ? "monospace" : "normal");
    font_desc.set_absolute_size(font_height * Pango::SCALE);
    _entry.override_font(font_desc);

    // The y coordinate denotes baseline.
    Pango::FontMetrics font_metrics = get_pango_context()-&gt;get_metrics(font_desc);
    y -= font_metrics.get_ascent() / Pango::SCALE;

    Glib::RefPtr&lt;Pango::Layout&gt; layout = Pango::Layout::create(get_pango_context());
    layout-&gt;set_font_description(font_desc);
    // Add one extra char width to avoid scrolling.
    layout-&gt;set_text(val + " ");
    int width = layout-&gt;get_logical_extents().get_width();

    Gtk::Border margin  = _entry.get_style_context()-&gt;get_margin();
    Gtk::Border border  = _entry.get_style_context()-&gt;get_border();
    Gtk::Border padding = _entry.get_style_context()-&gt;get_padding();
    move(_entry,
         x - margin.get_left() - border.get_left() - padding.get_left(),
         y - margin.get_top()  - border.get_top()  - padding.get_top());

    int fitWidth = width / Pango::SCALE + padding.get_left() + padding.get_right();
    _entry.set_size_request(max(fitWidth, min_width), -1);
    queue_resize();

    _entry.set_text(val);

    if(!_entry.is_visible()) {
        _entry.show();
        _entry.grab_focus();

        // We grab the input for ourselves and not the entry to still have
        // the pointer events go through the underlay.
        add_modal_grab();
    }
}

</t>
<t tx="leo.20191228122649.7">void Settings::FreezeColor(const std::string &amp;key, RgbaColor value) {
    FreezeInt(key, value.ToPackedInt());
}

RgbaColor Settings::ThawColor(const std::string &amp;key, RgbaColor defaultValue) {
    return RgbaColor::FromPackedInt(ThawInt(key, defaultValue.ToPackedInt()));
}

//-----------------------------------------------------------------------------
// File dialogs
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.70">    void stop_editing() {
        if(_entry.is_visible()) {
            remove_modal_grab();
            _entry.hide();
            _gl_widget.grab_focus();
        }
    }

    GtkGLWidget &amp;get_gl_widget() {
        return _gl_widget;
    }

protected:
</t>
<t tx="leo.20191228122649.71">bool on_key_press_event(GdkEventKey *gdk_event) override {
    if(is_editing()) {
        if(gdk_event-&gt;keyval == GDK_KEY_Escape) {
            return _gl_widget.event((GdkEvent *)gdk_event);
        } else {
            _entry.event((GdkEvent *)gdk_event);
        }
        return true;
    }

    return Gtk::Fixed::on_key_press_event(gdk_event);
}

</t>
<t tx="leo.20191228122649.72">bool on_key_release_event(GdkEventKey *gdk_event) override {
    if(is_editing()) {
        _entry.event((GdkEvent *)gdk_event);
        return true;
    }

    return Gtk::Fixed::on_key_release_event(gdk_event);
}

</t>
<t tx="leo.20191228122649.73">void on_size_allocate(Gtk::Allocation&amp; allocation) override {
    Gtk::Fixed::on_size_allocate(allocation);

    _gl_widget.size_allocate(allocation);

    int width, height, min_height, natural_height;
    _entry.get_size_request(width, height);
    _entry.get_preferred_height(min_height, natural_height);

    Gtk::Allocation entry_rect = _entry.get_allocation();
    entry_rect.set_width(width);
    entry_rect.set_height(natural_height);
    _entry.size_allocate(entry_rect);
}

</t>
<t tx="leo.20191228122649.74">void on_activate() {
    if(_receiver-&gt;onEditingDone) {
        _receiver-&gt;onEditingDone(_entry.get_text());
    }
}
</t>
<t tx="leo.20191228122649.75">class GtkWindow : public Gtk::Window {
    Platform::Window   *_receiver;
    Gtk::VBox           _vbox;
    Gtk::MenuBar       *_menu_bar = NULL;
    Gtk::HBox           _hbox;
    GtkEditorOverlay    _editor_overlay;
    Gtk::VScrollbar     _scrollbar;
    bool                _is_under_cursor = false;
    bool                _is_fullscreen = false;
    std::string         _tooltip_text;
    Gdk::Rectangle      _tooltip_area;

public:
    GtkWindow(Platform::Window *receiver) : _receiver(receiver), _editor_overlay(receiver) {
        _hbox.pack_start(_editor_overlay, /*expand=*/true, /*fill=*/true);
        _hbox.pack_end(_scrollbar, /*expand=*/false, /*fill=*/false);
        _vbox.pack_end(_hbox, /*expand=*/true, /*fill=*/true);
        add(_vbox);

        _vbox.show();
        _hbox.show();
        _editor_overlay.show();
        get_gl_widget().show();

        _scrollbar.get_adjustment()-&gt;signal_value_changed().
            connect(sigc::mem_fun(this, &amp;GtkWindow::on_scrollbar_value_changed));

        get_gl_widget().set_has_tooltip(true);
        get_gl_widget().signal_query_tooltip().
            connect(sigc::mem_fun(this, &amp;GtkWindow::on_query_tooltip));
    }

    @others
};

//-----------------------------------------------------------------------------
// Windows
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.76">bool is_full_screen() const {
    return _is_fullscreen;
}

Gtk::MenuBar *get_menu_bar() const {
    return _menu_bar;
}

</t>
<t tx="leo.20191228122649.77">void set_menu_bar(Gtk::MenuBar *menu_bar) {
    if(_menu_bar) {
        _vbox.remove(*_menu_bar);
    }
    _menu_bar = menu_bar;
    if(_menu_bar) {
        _menu_bar-&gt;show_all();
        _vbox.pack_start(*_menu_bar, /*expand=*/false, /*fill=*/false);
    }
}

GtkEditorOverlay &amp;get_editor_overlay() {
    return _editor_overlay;
}

GtkGLWidget &amp;get_gl_widget() {
    return _editor_overlay.get_gl_widget();
}

Gtk::VScrollbar &amp;get_scrollbar() {
    return _scrollbar;
}

</t>
<t tx="leo.20191228122649.78">    void set_tooltip(const std::string &amp;text, const Gdk::Rectangle &amp;rect) {
        if(_tooltip_text != text) {
            _tooltip_text = text;
            _tooltip_area = rect;
            get_gl_widget().trigger_tooltip_query();
        }
    }

protected:
</t>
<t tx="leo.20191228122649.79">bool on_query_tooltip(int x, int y, bool keyboard_tooltip,
                      const Glib::RefPtr&lt;Gtk::Tooltip&gt; &amp;tooltip) {
    tooltip-&gt;set_text(_tooltip_text);
    tooltip-&gt;set_tip_area(_tooltip_area);
    return !_tooltip_text.empty() &amp;&amp; (keyboard_tooltip || _is_under_cursor);
}

</t>
<t tx="leo.20191228122649.8">void FileDialog::AddFilter(const FileFilter &amp;filter) {
    AddFilter(Translate("file-type", filter.name.c_str()), filter.extensions);
}

</t>
<t tx="leo.20191228122649.80">bool on_enter_notify_event(GdkEventCrossing* gdk_event) override {
    _is_under_cursor = true;

    return true;
}

</t>
<t tx="leo.20191228122649.81">bool on_leave_notify_event(GdkEventCrossing* gdk_event) override {
    _is_under_cursor = false;

    return true;
}

</t>
<t tx="leo.20191228122649.82">bool on_delete_event(GdkEventAny* gdk_event) override {
    if(_receiver-&gt;onClose) {
        _receiver-&gt;onClose();
        return true;
    }

    return false;
}

</t>
<t tx="leo.20191228122649.83">bool on_window_state_event(GdkEventWindowState *gdk_event) override {
    _is_fullscreen = gdk_event-&gt;new_window_state &amp; GDK_WINDOW_STATE_FULLSCREEN;
    if(_receiver-&gt;onFullScreen) {
        _receiver-&gt;onFullScreen(_is_fullscreen);
    }

    return true;
}

</t>
<t tx="leo.20191228122649.84">void on_scrollbar_value_changed() {
    if(_receiver-&gt;onScrollbarAdjusted) {
        _receiver-&gt;onScrollbarAdjusted(_scrollbar.get_adjustment()-&gt;get_value());
    }
}
</t>
<t tx="leo.20191228122649.85">class WindowImplGtk final : public Window {
public:
    GtkWindow       gtkWindow;
    MenuBarRef      menuBar;

    WindowImplGtk(Window::Kind kind) : gtkWindow(this) {
        switch(kind) {
            case Kind::TOPLEVEL:
                break;

            case Kind::TOOL:
                gtkWindow.set_type_hint(Gdk::WINDOW_TYPE_HINT_UTILITY);
                gtkWindow.set_skip_taskbar_hint(true);
                gtkWindow.set_skip_pager_hint(true);
                break;
        }

        auto icon = LoadPng("freedesktop/solvespace-48x48.png");
        @others
};

WindowRef CreateWindow(Window::Kind kind, WindowRef parentWindow) {
    auto window = std::make_shared&lt;WindowImplGtk&gt;(kind);
    if(parentWindow) {
        window-&gt;gtkWindow.set_transient_for(
            std::static_pointer_cast&lt;WindowImplGtk&gt;(parentWindow)-&gt;gtkWindow);
    }
    return window;
}

//-----------------------------------------------------------------------------
// 3DConnexion support
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122649.86">    auto gdkIcon =
        Gdk::Pixbuf::create_from_data(&amp;icon-&gt;data[0], Gdk::COLORSPACE_RGB,
                                      icon-&gt;format == Pixmap::Format::RGBA, 8,
                                      icon-&gt;width, icon-&gt;height, icon-&gt;stride);
    gtkWindow.set_icon(gdkIcon-&gt;copy());
}

double GetPixelDensity() override {
    return gtkWindow.get_screen()-&gt;get_resolution();
}

</t>
<t tx="leo.20191228122649.87">int GetDevicePixelRatio() override {
    return gtkWindow.get_scale_factor();
}

</t>
<t tx="leo.20191228122649.88">bool IsVisible() override {
    return gtkWindow.is_visible();
}

</t>
<t tx="leo.20191228122649.89">void SetVisible(bool visible) override {
    if(visible) {
        gtkWindow.show();
    } else {
        gtkWindow.hide();
    }
}

</t>
<t tx="leo.20191228122649.9">void FileDialog::AddFilters(const std::vector&lt;FileFilter&gt; &amp;filters) {
    for(auto filter : filters) AddFilter(filter);
}

std::vector&lt;FileFilter&gt; SolveSpaceModelFileFilters = {
    { CN_("file-type", "SolveSpace models"), { "slvs" } },
};

std::vector&lt;FileFilter&gt; RasterFileFilters = {
    { CN_("file-type", "PNG image"), { "png" } },
};

std::vector&lt;FileFilter&gt; MeshFileFilters = {
    { CN_("file-type", "STL mesh"), { "stl" } },
    { CN_("file-type", "Wavefront OBJ mesh"), { "obj" } },
    { CN_("file-type", "Three.js-compatible mesh, with viewer"), { "html" } },
    { CN_("file-type", "Three.js-compatible mesh, mesh only"), { "js" } },
    { CN_("file-type", "Q3D Object file"), { "q3do" } },
    { CN_("file-type", "VRML text file"), { "wrl" } },
};

std::vector&lt;FileFilter&gt; SurfaceFileFilters = {
    { CN_("file-type", "STEP file"), { "step", "stp" } },
};

std::vector&lt;FileFilter&gt; VectorFileFilters = {
    { CN_("file-type", "PDF file"), { "pdf" } },
    { CN_("file-type", "Encapsulated PostScript"), { "eps",  "ps" } },
    { CN_("file-type", "Scalable Vector Graphics"), { "svg" } },
    { CN_("file-type", "STEP file"), { "step", "stp" } },
    { CN_("file-type", "DXF file (AutoCAD 2007)"), { "dxf" } },
    { CN_("file-type", "HPGL file"), { "plt",  "hpgl" } },
    { CN_("file-type", "G Code"), { "ngc",  "txt" } },
};

std::vector&lt;FileFilter&gt; Vector3dFileFilters = {
    { CN_("file-type", "STEP file"), { "step", "stp" } },
    { CN_("file-type", "DXF file (AutoCAD 2007)"), { "dxf" } },
};

std::vector&lt;FileFilter&gt; ImportFileFilters = {
    { CN_("file-type", "AutoCAD DXF and DWG files"), { "dxf", "dwg" } },
};

std::vector&lt;FileFilter&gt; CsvFileFilters = {
    { CN_("file-type", "Comma-separated values"), { "csv" } },
};


}
}
</t>
<t tx="leo.20191228122649.90">void Focus() override {
    gtkWindow.present();
}

</t>
<t tx="leo.20191228122649.91">bool IsFullScreen() override {
    return gtkWindow.is_full_screen();
}

</t>
<t tx="leo.20191228122649.92">void SetFullScreen(bool fullScreen) override {
    if(fullScreen) {
        gtkWindow.fullscreen();
    } else {
        gtkWindow.unfullscreen();
    }
}

</t>
<t tx="leo.20191228122649.93">void SetTitle(const std::string &amp;title) override {
    gtkWindow.set_title(PrepareTitle(title));
}

</t>
<t tx="leo.20191228122649.94">void SetMenuBar(MenuBarRef newMenuBar) override {
    if(newMenuBar) {
        Gtk::MenuBar *gtkMenuBar = &amp;((MenuBarImplGtk*)&amp;*newMenuBar)-&gt;gtkMenuBar;
        gtkWindow.set_menu_bar(gtkMenuBar);
    } else {
        gtkWindow.set_menu_bar(NULL);
    }
    menuBar = newMenuBar;
}

</t>
<t tx="leo.20191228122649.95">void GetContentSize(double *width, double *height) override {
    *width  = gtkWindow.get_gl_widget().get_allocated_width();
    *height = gtkWindow.get_gl_widget().get_allocated_height();
}

</t>
<t tx="leo.20191228122649.96">void SetMinContentSize(double width, double height) override {
    gtkWindow.get_gl_widget().set_size_request((int)width, (int)height);
}

</t>
<t tx="leo.20191228122649.97">void FreezePosition(SettingsRef settings, const std::string &amp;key) override {
    if(!gtkWindow.is_visible()) return;

    int left, top, width, height;
    gtkWindow.get_position(left, top);
    gtkWindow.get_size(width, height);
    bool isMaximized = gtkWindow.is_maximized();

    settings-&gt;FreezeInt(key + "_Left",       left);
    settings-&gt;FreezeInt(key + "_Top",        top);
    settings-&gt;FreezeInt(key + "_Width",      width);
    settings-&gt;FreezeInt(key + "_Height",     height);
    settings-&gt;FreezeBool(key + "_Maximized", isMaximized);
}

</t>
<t tx="leo.20191228122649.98">void ThawPosition(SettingsRef settings, const std::string &amp;key) override {
    int left, top, width, height;
    gtkWindow.get_position(left, top);
    gtkWindow.get_size(width, height);

    left   = settings-&gt;ThawInt(key + "_Left",   left);
    top    = settings-&gt;ThawInt(key + "_Top",    top);
    width  = settings-&gt;ThawInt(key + "_Width",  width);
    height = settings-&gt;ThawInt(key + "_Height", height);

    gtkWindow.move(left, top);
    gtkWindow.resize(width, height);

    if(settings-&gt;ThawBool(key + "_Maximized", false)) {
        gtkWindow.maximize();
    }
}

</t>
<t tx="leo.20191228122649.99">void SetCursor(Cursor cursor) override {
    Gdk::CursorType gdkCursorType;
    switch(cursor) {
        case Cursor::POINTER: gdkCursorType = Gdk::ARROW; break;
        case Cursor::HAND:    gdkCursorType = Gdk::HAND1; break;
        default: ssassert(false, "Unexpected cursor");
    }

    auto gdkWindow = gtkWindow.get_gl_widget().get_window();
    if(gdkWindow) {
        gdkWindow-&gt;set_cursor(Gdk::Cursor::create(gdkCursorType));
    }
}

</t>
<t tx="leo.20191228122650.1">typedef struct _AllocTempHeader {
    AllocTempHeader *prev;
    AllocTempHeader *next;
} AllocTempHeader;

static AllocTempHeader *Head = NULL;

</t>
<t tx="leo.20191228122650.10">void *MemAlloc(size_t n) {
    void *p = HeapAlloc(PermHeap, HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY, n);
    ssassert(p != NULL, "Cannot allocate memory");
    return p;
}
</t>
<t tx="leo.20191228122650.100">void ObjectPicker::DrawPoint(const Vector &amp;o, Canvas::hStroke hcs) {
    Stroke *stroke = strokes.FindById(hcs);
    double distance = point.DistanceTo(camera.ProjectPoint(o)) - stroke-&gt;width / 2;
    DoCompare(distance, stroke-&gt;zIndex);
}

</t>
<t tx="leo.20191228122650.101">void ObjectPicker::DrawPolygon(const SPolygon &amp;p, hFill hcf) {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo.20191228122650.102">void ObjectPicker::DrawMesh(const SMesh &amp;m, hFill hcfFront, hFill hcfBack) {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo.20191228122650.103">void ObjectPicker::DrawFaces(const SMesh &amp;m, const std::vector&lt;uint32_t&gt; &amp;faces, hFill hcf) {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo.20191228122650.104">void ObjectPicker::DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
                              const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                              const Point2d &amp;ta, const Point2d &amp;tb, Canvas::hFill hcf) {
    DrawQuad(o, o.Plus(u), o.Plus(u).Plus(v), o.Plus(v), hcf);
}

</t>
<t tx="leo.20191228122650.105">bool ObjectPicker::Pick(const std::function&lt;void()&gt; &amp;drawFn) {
    minDistance = VERY_POSITIVE;
    maxZIndex = INT_MIN;

    drawFn();
    return minDistance &lt; selRadius;
}
}
</t>
<t tx="leo.20191228122650.106">@path ./src/render/
//-----------------------------------------------------------------------------
// Backend-agnostic rendering interface, and various backends we use.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------

#ifndef SOLVESPACE_RENDER_H
#define SOLVESPACE_RENDER_H

//-----------------------------------------------------------------------------
// Interfaces common for all renderers
//-----------------------------------------------------------------------------

enum class StipplePattern : uint32_t;

// A mapping from 3d sketch coordinates to 2d screen coordinates, using
// an axonometric projection.
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122650.107">class Camera {
public:
    double      width;
    double      height;
    double      pixelRatio;
    bool        gridFit;
    Vector      offset;
    Vector      projRight;
    Vector      projUp;
    double      scale;
    double      tangent;

    bool IsPerspective() const { return tangent != 0.0; }

    Point2d ProjectPoint(Vector p) const;
    Vector ProjectPoint3(Vector p) const;
    Vector ProjectPoint4(Vector p, double *w) const;
    Vector UnProjectPoint(Point2d p) const;
    Vector UnProjectPoint3(Vector p) const;
    Vector VectorFromProjs(Vector rightUpForward) const;
    Vector AlignToPixelGrid(Vector v) const;

    SBezier ProjectBezier(SBezier b) const;

    void LoadIdentity();
    void NormalizeProjectionVectors();
};

// A description of scene lighting.
</t>
<t tx="leo.20191228122650.108">class Lighting {
public:
    RgbaColor   backgroundColor;
    double      ambientIntensity;
    double      lightIntensity[2];
    Vector      lightDirection[2];
};

class BatchCanvas;

// An interface for populating a drawing area with geometry.
</t>
<t tx="leo.20191228122650.109">class Canvas {
public:
    // Stroke and fill styles are addressed with handles to be able to quickly
    // group geometry into indexed draw calls.
    @others
struct IsHandleOracle&lt;Canvas::hFill&gt; : std::true_type {};


// An interface for view-dependent visualization.
</t>
<t tx="leo.20191228122650.11">void MemFree(void *p) {
    HeapFree(PermHeap, HEAP_NO_SERIALIZE, p);
}

</t>
<t tx="leo.20191228122650.110">class hStroke {
public:
    uint32_t v;
};

</t>
<t tx="leo.20191228122650.111">class hFill {
public:
    uint32_t v;
};

// The layer of a geometry describes how it occludes other geometry.
// Within a layer, geometry with higher z-index occludes geometry with lower z-index,
// or geometry drawn earlier if z-indexes match.
enum class Layer {
    NORMAL,     // Occluded by geometry with lower Z coordinate
    OCCLUDED,   // Only drawn over geometry with lower Z coordinate
    DEPTH_ONLY, // Like NORMAL, but only affects future occlusion, not color
    BACK,       // Always drawn below all other geometry
    FRONT,      // Always drawn above all other geometry
    LAST = FRONT
};

// The outlines are the collection of all edges that may be drawn.
// Outlines can be classified as emphasized or not; emphasized outlines indicate an abrupt
// change in the surface curvature. These are indicated by the SOutline tag.
// Outlines can also be classified as contour or not; contour outlines indicate the boundary
// of the filled mesh. Whether an outline is a part of contour or not depends on point of view.
enum class DrawOutlinesAs {
    EMPHASIZED_AND_CONTOUR      = 0, // Both emphasized and contour outlines
    EMPHASIZED_WITHOUT_CONTOUR  = 1, // Emphasized outlines except those also belonging to contour
    CONTOUR_ONLY                = 2  // Contour outlines only
};

// Stroke widths, etc, can be scale-invariant (in pixels) or scale-dependent (in millimeters).
enum class Unit {
    MM,
    PX
};

</t>
<t tx="leo.20191228122650.112">class Stroke {
public:
    hStroke         h;

    Layer           layer;
    int             zIndex;
    RgbaColor       color;
    double          width;
    Unit            unit;
    StipplePattern  stipplePattern;
    double          stippleScale;

    void Clear() { *this = {}; }
    bool Equals(const Stroke &amp;other) const;

    double WidthMm(const Camera &amp;camera) const;
    double WidthPx(const Camera &amp;camera) const;
    double StippleScaleMm(const Camera &amp;camera) const;
    double StippleScalePx(const Camera &amp;camera) const;
};

enum class FillPattern {
    SOLID, CHECKERED_A, CHECKERED_B
};

</t>
<t tx="leo.20191228122650.113">class Fill {
public:
    hFill           h;

    Layer           layer;
    int             zIndex;
    RgbaColor       color;
    FillPattern     pattern;
    std::shared_ptr&lt;const Pixmap&gt; texture;

    void Clear() { *this = {}; }
    bool Equals(const Fill &amp;other) const;
};

IdList&lt;Stroke, hStroke&gt; strokes = {};
IdList&lt;Fill,   hFill&gt;   fills   = {};
BitmapFont bitmapFont = {};

virtual void Clear();
virtual ~Canvas() = default;

hStroke GetStroke(const Stroke &amp;stroke);
hFill GetFill(const Fill &amp;fill);
BitmapFont *GetBitmapFont();

virtual const Camera &amp;GetCamera() const = 0;

virtual void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) = 0;
virtual void DrawEdges(const SEdgeList &amp;el, hStroke hcs) = 0;
virtual bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) = 0;
virtual void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) = 0;
virtual void DrawVectorText(const std::string &amp;text, double height,
                            const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                        const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
</t>
<t tx="leo.20191228122650.114">class ViewportCanvas : public Canvas {
public:
    virtual void SetCamera(const Camera &amp;camera) = 0;
    virtual void SetLighting(const Lighting &amp;lighting) = 0;

    virtual void StartFrame() = 0;
    virtual void FlushFrame() = 0;
    virtual void FinishFrame() = 0;
    virtual std::shared_ptr&lt;Pixmap&gt; ReadFrame() = 0;

    virtual void GetIdent(const char **vendor, const char **renderer, const char **version) = 0;
};

// An interface for view-independent visualization.
</t>
<t tx="leo.20191228122650.115">class BatchCanvas : public Canvas {
public:
    const Camera &amp;GetCamera() const override;

    virtual void Finalize() = 0;
    virtual void Draw() = 0;
};

// A wrapper around Canvas that simplifies drawing UI in screen coordinates.
</t>
<t tx="leo.20191228122650.116">class UiCanvas {
public:
    std::shared_ptr&lt;Canvas&gt; canvas;
    bool                    flip = false;

    void DrawLine(int x1, int y1, int x2, int y2, RgbaColor color, int width = 1,
    int Flip(int y) const { return flip ? (int)canvas-&gt;GetCamera().height - y : y; }
};

// A canvas that performs picking against drawn geometry.
</t>
<t tx="leo.20191228122650.117">class ObjectPicker : public Canvas {
public:
    Camera      camera      = {};
    // Configuration.
    Point2d     point       = {};
    double      selRadius   = 0.0;
    // Picking state.
    double      minDistance = 0.0;
    int         maxZIndex   = 0;
    uint32_t    position    = 0;

    const Camera &amp;GetCamera() const override { return camera; }

    void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) override;
    void DrawEdges(const SEdgeList &amp;el, hStroke hcs) override;
    bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) override { return false; }
    void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) override;
    void DrawVectorText(const std::string &amp;text, double height,
    void DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,

// A canvas that renders onto a 2d surface, performing z-index sorting, occlusion testing, etc,
// on the CPU.
@others
</t>
<t tx="leo.20191228122650.118">class SurfaceRenderer : public ViewportCanvas {
public:
    Camera      camera   = {};
    Lighting    lighting = {};
    // Chord tolerance, for converting beziers to pwl.
    double      chordTolerance = 0.0;
    // Render lists.
    handle_map&lt;hStroke, SEdgeList&gt;   edges;
    handle_map&lt;hStroke, SBezierList&gt; beziers;
    SMesh       mesh = {};
    // State.
    BBox        bbox = {};

    void Clear() override;

    // Canvas interface.
    const Camera &amp;GetCamera() const override { return camera; }

    // ViewportCanvas interface.
    void SetCamera(const Camera &amp;camera) override { this-&gt;camera = camera; }
    void SetLighting(const Lighting &amp;lighting) override { this-&gt;lighting = lighting; }

    void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) override;
    void DrawEdges(const SEdgeList &amp;el, hStroke hcs) override;
    bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) override;
    void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) override;
    void DrawVectorText(const std::string &amp;text, double height,
    void DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
    void OutputInPaintOrder();

    virtual bool CanOutputCurves() const = 0;
    virtual bool CanOutputTriangles() const = 0;

    virtual void OutputStart() = 0;
    virtual void OutputBezier(const SBezier &amp;b, hStroke hcs) = 0;
    virtual void OutputTriangle(const STriangle &amp;tr) = 0;
    virtual void OutputEnd() = 0;

    void OutputBezierAsNonrationalCubic(const SBezier &amp;b, hStroke hcs);
};

//-----------------------------------------------------------------------------
// 2d renderers
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.119">class CairoRenderer : public SurfaceRenderer {
public:
    cairo_t     *context  = NULL;
    // Renderer configuration.
    bool        antialias = false;
    // Renderer state.
    struct {
        hStroke     hcs;
    } current = {};

    void Clear() override;

    void StartFrame() override {}
    bool CanOutputCurves() const override { return true; }
    bool CanOutputTriangles() const override { return true; }

    void OutputStart() override;
    void OutputBezier(const SBezier &amp;b, hStroke hcs) override;
    void OutputTriangle(const STriangle &amp;tr) override;
    void OutputEnd() override;
};

</t>
<t tx="leo.20191228122650.12">void vl() {
    ssassert(HeapValidate(TempHeap, HEAP_NO_SERIALIZE, NULL), "Corrupted heap");
    ssassert(HeapValidate(PermHeap, HEAP_NO_SERIALIZE, NULL), "Corrupted heap");
}

std::vector&lt;std::string&gt; InitPlatform(int argc, char **argv) {
#if !defined(LIBRARY) &amp;&amp; defined(_MSC_VER)
    // We display our own message on abort; just call ReportFault.
    _set_abort_behavior(_CALL_REPORTFAULT, _WRITE_ABORT_MSG|_CALL_REPORTFAULT);
    int crtReportTypes[] = {_CRT_WARN, _CRT_ERROR, _CRT_ASSERT};
    for(int crtReportType : crtReportTypes) {
        _CrtSetReportMode(crtReportType, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
        _CrtSetReportFile(crtReportType, _CRTDBG_FILE_STDERR);
    }
#endif

    // Create the heap used for long-lived stuff (that gets freed piecewise).
    PermHeap = HeapCreate(HEAP_NO_SERIALIZE, 1024*1024*20, 0);
    // Create the heap that we use to store Exprs and other temp stuff.
    FreeAllTemporary();

    // Extract the command-line arguments; the ones from main() are ignored,
    // since they are in the OEM encoding.
    int argcW;
    LPWSTR *argvW = CommandLineToArgvW(GetCommandLineW(), &amp;argcW);
    std::vector&lt;std::string&gt; args;
    for(int i = 0; i &lt; argcW; i++) {
        args.push_back(Platform::Narrow(argvW[i]));
    }
    LocalFree(argvW);
    return args;
}

}
</t>
<t tx="leo.20191228122650.120">class CairoPixmapRenderer final : public CairoRenderer {
public:
    std::shared_ptr&lt;Pixmap&gt;  pixmap;

    cairo_surface_t         *surface = NULL;

    void Init();
    void Clear() override;

    std::shared_ptr&lt;Pixmap&gt; ReadFrame() override;
};

//-----------------------------------------------------------------------------
// Factories
//-----------------------------------------------------------------------------

std::shared_ptr&lt;ViewportCanvas&gt; CreateRenderer();

#endif
</t>
<t tx="leo.20191228122650.121">@path ./src/render/
//-----------------------------------------------------------------------------
// Rendering projections to 2d surfaces: z-sorting, occlusion testing, etc.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include "solvespace.h"

namespace SolveSpace {

// FIXME: The export coordinate system has a different handedness than display
// coordinate system; lighting and occlusion calculations are right-handed.
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122650.122">static Vector ProjectPoint3RH(const Camera &amp;camera, Vector p) {
    p = p.Plus(camera.offset);

    Vector r;
    r.x = p.Dot(camera.projRight);
    r.y = p.Dot(camera.projUp);
    r.z = p.Dot(camera.projRight.Cross(camera.projUp));

    double w = 1 + r.z*camera.tangent*camera.scale;
    return r.ScaledBy(camera.scale/w);
}

//-----------------------------------------------------------------------------
// Accumulation of geometry
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.123">void SurfaceRenderer::DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    edges[hcs].AddEdge(ProjectPoint3RH(camera, a),
                       ProjectPoint3RH(camera, b));
}

</t>
<t tx="leo.20191228122650.124">void SurfaceRenderer::DrawEdges(const SEdgeList &amp;el, hStroke hcs) {
    for(const SEdge &amp;e : el.l) {
        edges[hcs].AddEdge(ProjectPoint3RH(camera, e.a),
                           ProjectPoint3RH(camera, e.b));
    }
}

</t>
<t tx="leo.20191228122650.125">bool SurfaceRenderer::DrawBeziers(const SBezierList &amp;bl, hStroke hcs) {
    if(!CanOutputCurves())
        return false;

    for(const SBezier &amp;b : bl.l) {
        SBezier pb = camera.ProjectBezier(b);
        beziers[hcs].l.Add(&amp;pb);
    }
    return true;
}

</t>
<t tx="leo.20191228122650.126">void SurfaceRenderer::DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) {
    Vector projDir = camera.projRight.Cross(camera.projUp);
    for(const SOutline &amp;o : ol.l) {
        if(drawAs == DrawOutlinesAs::EMPHASIZED_AND_CONTOUR &amp;&amp;
                !(o.IsVisible(projDir) || o.tag != 0))
            continue;
        if(drawAs == DrawOutlinesAs::EMPHASIZED_WITHOUT_CONTOUR &amp;&amp;
                !(!o.IsVisible(projDir) &amp;&amp; o.tag != 0))
            continue;
        if(drawAs == DrawOutlinesAs::CONTOUR_ONLY &amp;&amp;
                !(o.IsVisible(projDir)))
            continue;

        edges[hcs].AddEdge(ProjectPoint3RH(camera, o.a),
                           ProjectPoint3RH(camera, o.b));
    }
}

</t>
<t tx="leo.20191228122650.127">void SurfaceRenderer::DrawVectorText(const std::string &amp;text, double height,
                                     const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                                     hStroke hcs) {
    @others
}

</t>
<t tx="leo.20191228122650.128">auto traceEdge = [&amp;](Vector a, Vector b) {
    edges[hcs].AddEdge(ProjectPoint3RH(camera, a),
                       ProjectPoint3RH(camera, b));
};
VectorFont::Builtin()-&gt;Trace(height, o, u, v, text, traceEdge, camera);
</t>
<t tx="leo.20191228122650.129">void SurfaceRenderer::DrawQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d,
                               hFill hcf) {
    Fill *fill = fills.FindById(hcf);
    ssassert(fill-&gt;layer == Layer::NORMAL ||
             fill-&gt;layer == Layer::DEPTH_ONLY ||
             fill-&gt;layer == Layer::FRONT ||
             fill-&gt;layer == Layer::BACK, "Unexpected mesh layer");

    Vector zOffset = {};
    if(fill-&gt;layer == Layer::BACK) {
        zOffset.z -= 1e6;
    } else if(fill-&gt;layer == Layer::FRONT) {
        zOffset.z += 1e6;
    }
    zOffset.z += camera.scale * fill-&gt;zIndex;

    STriMeta meta = {};
    if(fill-&gt;layer != Layer::DEPTH_ONLY) {
        meta.color = fill-&gt;color;
    }
    Vector ta = ProjectPoint3RH(camera, a).Plus(zOffset),
           tb = ProjectPoint3RH(camera, b).Plus(zOffset),
           tc = ProjectPoint3RH(camera, c).Plus(zOffset),
           td = ProjectPoint3RH(camera, d).Plus(zOffset);
    mesh.AddTriangle(meta, tc, tb, ta);
    mesh.AddTriangle(meta, ta, td, tc);
}

</t>
<t tx="leo.20191228122650.13"></t>
<t tx="leo.20191228122650.130">void SurfaceRenderer::DrawPoint(const Vector &amp;o, Canvas::hStroke hcs) {
    Stroke *stroke = strokes.FindById(hcs);

    Fill fill = {};
    fill.layer  = stroke-&gt;layer;
    fill.zIndex = stroke-&gt;zIndex;
    fill.color  = stroke-&gt;color;
    hFill hcf = GetFill(fill);

    Vector u = camera.projRight.ScaledBy(stroke-&gt;width/2.0/camera.scale),
           v = camera.projUp.ScaledBy(stroke-&gt;width/2.0/camera.scale);
    DrawQuad(o.Minus(u).Minus(v), o.Minus(u).Plus(v),
             o.Plus(u).Plus(v),   o.Plus(u).Minus(v), hcf);
}

</t>
<t tx="leo.20191228122650.131">void SurfaceRenderer::DrawPolygon(const SPolygon &amp;p, hFill hcf) {
    SMesh m = {};
    p.TriangulateInto(&amp;m);
    DrawMesh(m, hcf, {});
    m.Clear();
}

</t>
<t tx="leo.20191228122650.132">void SurfaceRenderer::DrawMesh(const SMesh &amp;m,
                               hFill hcfFront, hFill hcfBack) {
    Fill *fill = fills.FindById(hcfFront);
    ssassert(fill-&gt;layer == Layer::NORMAL ||
             fill-&gt;layer == Layer::DEPTH_ONLY, "Unexpected mesh layer");

    Vector l0 = (lighting.lightDirection[0]).WithMagnitude(1),
           l1 = (lighting.lightDirection[1]).WithMagnitude(1);
    for(STriangle tr : m.l) {
        tr.a = ProjectPoint3RH(camera, tr.a);
        tr.b = ProjectPoint3RH(camera, tr.b);
        tr.c = ProjectPoint3RH(camera, tr.c);

        if(CanOutputTriangles() &amp;&amp; fill-&gt;layer == Layer::NORMAL) {
            if(fill-&gt;color.IsEmpty()) {
                // Compute lighting, since we're going to draw the shaded triangles.
                Vector n = tr.Normal().WithMagnitude(1);
                double intensity = lighting.ambientIntensity +
        } else {
            // This triangle is just for occlusion testing.
            tr.meta.color = {};
        }
        mesh.AddTriangle(&amp;tr);
    }
}

</t>
<t tx="leo.20191228122650.133">void SurfaceRenderer::DrawFaces(const SMesh &amp;m, const std::vector&lt;uint32_t&gt; &amp;faces, hFill hcf) {
    Fill *fill = fills.FindById(hcf);
    ssassert(fill-&gt;layer == Layer::NORMAL ||
             fill-&gt;layer == Layer::DEPTH_ONLY, "Unexpected mesh layer");

    Vector zOffset = {};
    zOffset.z += camera.scale * fill-&gt;zIndex;

    size_t facesSize = faces.size();
    for(STriangle tr : m.l) {
        uint32_t face = tr.meta.face;
        for(size_t j = 0; j &lt; facesSize; j++) {
            if(faces[j] != face) continue;
            if(!fill-&gt;color.IsEmpty()) {
                tr.meta.color = fill-&gt;color;
            }
            mesh.AddTriangle(tr.meta,
                ProjectPoint3RH(camera, tr.a).Plus(zOffset),
                ProjectPoint3RH(camera, tr.b).Plus(zOffset),
                ProjectPoint3RH(camera, tr.c).Plus(zOffset));
            break;
        }
    }
}

</t>
<t tx="leo.20191228122650.134">void SurfaceRenderer::DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
                    const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                    const Point2d &amp;ta, const Point2d &amp;tb, hFill hcf) {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo.20191228122650.135">void SurfaceRenderer::InvalidatePixmap(std::shared_ptr&lt;const Pixmap&gt; pm) {
    ssassert(false, "Not implemented");
}

//-----------------------------------------------------------------------------
// Processing of geometry
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.136">void SurfaceRenderer::CalculateBBox() {
    bbox.minp = Vector::From(VERY_POSITIVE, VERY_POSITIVE, VERY_POSITIVE);
    bbox.maxp = Vector::From(VERY_NEGATIVE, VERY_NEGATIVE, VERY_NEGATIVE);

    for(auto &amp;it : edges) {
        SEdgeList &amp;el = it.second;
        for(SEdge &amp;e : el.l) {
            bbox.Include(e.a);
            bbox.Include(e.b);
        }
    }

    for(auto &amp;it : beziers) {
        SBezierList &amp;bl = it.second;
        for(SBezier &amp;b : bl.l) {
            for(int i = 0; i &lt;= b.deg; i++) {
                bbox.Include(b.ctrl[i]);
            }
        }
    }

    for(STriangle &amp;tr : mesh.l) {
        for(int i = 0; i &lt; 3; i++) {
            bbox.Include(tr.vertices[i]);
        }
    }
}


</t>
<t tx="leo.20191228122650.137">void SurfaceRenderer::ConvertBeziersToEdges() {
    for(auto &amp;it : beziers) {
        hStroke hcs = it.first;
        SBezierList &amp;bl = it.second;

        SEdgeList &amp;el = edges[hcs];
        for(const SBezier &amp;b : bl.l) {
            if(b.deg == 1) {
                el.AddEdge(b.ctrl[0], b.ctrl[1]);
            } else {
                List&lt;Vector&gt; lv = {};
                b.MakePwlInto(&amp;lv, chordTolerance);
                for(int i = 1; i &lt; lv.n; i++) {
                    el.AddEdge(lv[i-1], lv[i]);
                }
                lv.Clear();
            }
        }
        bl.l.Clear();
    }
    beziers.clear();
}

</t>
<t tx="leo.20191228122650.138">void SurfaceRenderer::CullOccludedStrokes() {
    // Perform occlusion testing, if necessary.
    if(mesh.l.IsEmpty())
        return;

    // We can't perform hidden line removal on exact curves.
    ConvertBeziersToEdges();

    // Remove hidden lines (on NORMAL layers), or remove visible lines (on OCCLUDED layers).
    SKdNode *root = SKdNode::From(&amp;mesh);
    root-&gt;ClearTags();

    int cnt = 1234;
    for(auto &amp;eit : edges) {
        hStroke hcs = eit.first;
        SEdgeList &amp;el = eit.second;

        Stroke *stroke = strokes.FindById(hcs);
        if(stroke-&gt;layer != Layer::NORMAL &amp;&amp;
           stroke-&gt;layer != Layer::OCCLUDED) continue;

        SEdgeList nel = {};
        for(const SEdge &amp;e : el.l) {
            SEdgeList oel = {};
            oel.AddEdge(e.a, e.b);
            root-&gt;OcclusionTestLine(e, &amp;oel, cnt);

            if(stroke-&gt;layer == Layer::OCCLUDED) {
                for(SEdge &amp;oe : oel.l) {
                    oe.tag = !oe.tag;
                }
            }
            oel.l.RemoveTagged();

            oel.MergeCollinearSegments(e.a, e.b);
            for(const SEdge &amp;oe : oel.l) {
                nel.AddEdge(oe.a, oe.b);
            }

            oel.Clear();
            cnt++;
        }

        el.l.Clear();
        el.l = nel.l;
    }
}

</t>
<t tx="leo.20191228122650.139">void SurfaceRenderer::OutputInPaintOrder() {
    // Sort our strokes in paint order.
    std::vector&lt;std::pair&lt;Layer, int&gt;&gt; paintOrder;
    paintOrder.emplace_back(Layer::NORMAL, 0); // mesh
    for(const Stroke &amp;cs : strokes) {
        paintOrder.emplace_back(cs.layer, cs.zIndex);
    }

    @others
}

</t>
<t tx="leo.20191228122650.14">@path ./src/render/
//-----------------------------------------------------------------------------
// OpenGL ES 2.0 and OpenGL 3.0 shader interface.
//
// Copyright 2016 Aleksey Egorov
//-----------------------------------------------------------------------------
#include "solvespace.h"
#include "gl3shader.h"

namespace SolveSpace {

//-----------------------------------------------------------------------------
// Floating point data structures
//-----------------------------------------------------------------------------

Vector2f Vector2f::From(float x, float y) {
    return { x, y };
}

Vector2f Vector2f::From(double x, double y) {
    return { (float)x, (float)y };
}

Vector2f Vector2f::FromInt(uint32_t x, uint32_t y) {
    return { (float)x, (float)y };
}

Vector3f Vector3f::From(float x, float y, float z) {
    return { x, y, z };
}

Vector3f Vector3f::From(const Vector &amp;v) {
    return { (float)v.x, (float)v.y, (float)v.z };
}

Vector3f Vector3f::From(const RgbaColor &amp;c) {
    return { c.redF(), c.greenF(), c.blueF() };
}

Vector4f Vector4f::From(float x, float y, float z, float w) {
    return { x, y, z, w };
}

Vector4f Vector4f::From(const Vector &amp;v, float w) {
    return { (float)v.x, (float)v.y, (float)v.z, w };
}

Vector4f Vector4f::FromInt(uint32_t x, uint32_t y, uint32_t z, uint32_t w) {
    return { (float)x, (float)y, (float)z, (float)w };
}

Vector4f Vector4f::From(const RgbaColor &amp;c) {
    return { c.redF(), c.greenF(), c.blueF(), c.alphaF() };
}

//-----------------------------------------------------------------------------
// Shader manipulation
//-----------------------------------------------------------------------------

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122650.140">const Layer stackup[] = {
    Layer::BACK, Layer::NORMAL, Layer::DEPTH_ONLY, Layer::OCCLUDED, Layer::FRONT
};
std::sort(paintOrder.begin(), paintOrder.end(),
          [&amp;](std::pair&lt;Layer, int&gt; a, std::pair&lt;Layer, int&gt; b) {
    Layer aLayer  = a.first,
          bLayer  = b.first;
</t>
<t tx="leo.20191228122650.141">    int   aZIndex = a.second,
          bZIndex = b.second;

    size_t aLayerIndex =
        std::find(std::begin(stackup), std::end(stackup), aLayer) - std::begin(stackup);
    size_t bLayerIndex =
        std::find(std::begin(stackup), std::end(stackup), bLayer) - std::begin(stackup);
    if(aLayerIndex == bLayerIndex) {
        return aZIndex &lt; bZIndex;
    } else {
        return aLayerIndex &lt; bLayerIndex;
    }
});

auto last = std::unique(paintOrder.begin(), paintOrder.end());
paintOrder.erase(last, paintOrder.end());

// Output geometry in paint order.
OutputStart();
for(auto &amp;it : paintOrder) {
    Layer layer  = it.first;
    int   zIndex = it.second;

    if(layer == Layer::NORMAL &amp;&amp; zIndex == 0) {
        SMesh mp = {};
        SBsp3 *bsp = SBsp3::FromMesh(&amp;mesh);
        if(bsp) bsp-&gt;GenerateInPaintOrder(&amp;mp);

        for(const STriangle &amp;tr : mp.l) {
            // Cull back-facing and invisible triangles.
            if(tr.Normal().z &lt; 0) continue;
            if(tr.meta.color.IsEmpty()) continue;
            OutputTriangle(tr);
        }

        mp.Clear();
    }

    for(auto eit : edges) {
        hStroke hcs = eit.first;
        const SEdgeList &amp;el = eit.second;

        Stroke *stroke = strokes.FindById(hcs);
        if(stroke-&gt;layer != layer || stroke-&gt;zIndex != zIndex) continue;

        for(const SEdge &amp;e : el.l) {
            OutputBezier(SBezier::From(e.a, e.b), hcs);
        }
    }

    for(auto &amp;bit : beziers) {
        hStroke hcs = bit.first;
        const SBezierList &amp;bl = bit.second;

        Stroke *stroke = strokes.FindById(hcs);
        if(stroke-&gt;layer != layer || stroke-&gt;zIndex != zIndex) continue;

        for(const SBezier &amp;b : bl.l) {
            OutputBezier(b, hcs);
        }
    }
}
OutputEnd();
</t>
<t tx="leo.20191228122650.142">void SurfaceRenderer::Clear() {
    Canvas::Clear();

    for(auto &amp;eit : edges) {
        SEdgeList &amp;el = eit.second;
        el.l.Clear();
    }
    edges.clear();

    for(auto &amp;bit : beziers) {
        SBezierList &amp;bl = bit.second;
        bl.l.Clear();
    }
    beziers.clear();

    mesh.Clear();
}

</t>
<t tx="leo.20191228122650.143">void SurfaceRenderer::OutputBezierAsNonrationalCubic(const SBezier &amp;b, hStroke hcs) {
    // Arbitrary choice of tolerance; make it a little finer than pwl tolerance since
    // it should be easier to achieve that with the smooth curves.
    SBezierList bl;
    b.MakeNonrationalCubicInto(&amp;bl, chordTolerance / 2);
    for(const SBezier &amp;cb : bl.l) {
        OutputBezier(cb, hcs);
    }
    bl.Clear();
}

}
</t>
<t tx="leo.20191228122650.144">@path ./src/render/
//-----------------------------------------------------------------------------
// A rendering backend that draws on a Cairo surface.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include &lt;cairo.h&gt;
#include "solvespace.h"

namespace SolveSpace {

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122650.145">void CairoRenderer::Clear() {
    SurfaceRenderer::Clear();

    if(context != NULL) cairo_destroy(context);
    context = NULL;
}

</t>
<t tx="leo.20191228122650.146">void CairoRenderer::GetIdent(const char **vendor, const char **renderer, const char **version) {
    *vendor = "Cairo";
    *renderer = "Cairo";
    *version = cairo_version_string();
}

</t>
<t tx="leo.20191228122650.147">void CairoRenderer::FlushFrame() {
    CullOccludedStrokes();
    OutputInPaintOrder();

    cairo_surface_flush(cairo_get_target(context));
}

std::shared_ptr&lt;Pixmap&gt; CairoRenderer::ReadFrame() {
    ssassert(false, "generic Cairo renderer does not support pixmap readout");
}

</t>
<t tx="leo.20191228122650.148">void CairoRenderer::OutputStart() {
    cairo_save(context);

    RgbaColor bgColor = lighting.backgroundColor;
    cairo_rectangle(context, 0.0, 0.0, (double)camera.width, (double)camera.height);
    cairo_set_source_rgba(context, bgColor.redF(), bgColor.greenF(), bgColor.blueF(),
                          bgColor.alphaF());
    cairo_fill(context);

    cairo_translate(context, camera.width / 2.0, camera.height / 2.0);

    // Avoid pixel boundaries; when not using antialiasing, we would otherwise
    // get numerically unstable output.
    cairo_translate(context, 0.1, 0.1);

    cairo_set_line_join(context, CAIRO_LINE_JOIN_ROUND);
    cairo_set_line_cap(context, CAIRO_LINE_CAP_ROUND);
}

</t>
<t tx="leo.20191228122650.149">void CairoRenderer::OutputEnd() {
    FinishPath();

    cairo_restore(context);
}

</t>
<t tx="leo.20191228122650.15">static GLuint CompileShader(const std::string &amp;res, GLenum type) {
    size_t size;
    const char *resData = (const char *)Platform::LoadResource(res, &amp;size);

    // Sigh, here we go... We want to deploy to four platforms: Linux, Windows, OS X, mobile+web.
    // These platforms are basically disjunctive in the OpenGL versions and profiles that they
    // support: mobile+web support GLES2, Windows can only be guaranteed to support GL1 without
    // vendor's drivers installed but supports D3D9+ natively, Linux supports GL3.2+ and/or
    // GLES2+ depending on whether we run on X11 or Wayland, and OS X supports either a legacy
    // profile or a GL3.2 core profile or (on 10.9+) a GL4.1 core profile.
    // The platforms barely have a common subset of features:
    //  * mobile+web and Windows (D3D9 through ANGLE) are strictly GLES2/GLSL1.0;
    //  * OS X legacy compatibility profile has GLSL1.2 only shaders, and GL3.2 core profile
    //    that has GLSL1.0 shaders compatible with GLES2 makes mandatory the use of vertex array
    //    objects, which cannot be used in GLES2 at all; similarly GL3.2 core has GL_RED but not
    //    GL_ALPHA whereas GLES2 has GL_ALPHA but not GL_RED.
    //  * GTK does not work on anything prior to GL3.0/GLES2.0; it does not permit explicitly
    //    asking for a compatibility profile, i.e. you can only ask for 3.2+; and it does not
    //    permit asking for a GLES profile prior to GTK 3.22, which will get into Ubuntu
    //    no earlier than late 2017. This is despite the fact that if only GTK defaulted
    //    to the compatibility profile, everything would have just worked as Mesa is
    //    very permissive.
    // While we're at it, let's remember that GLES2 has *only* glDepthRangef, GL3.2 has *only*
    // glDepthRange, and GL4.1+ has both glDepthRangef and glDepthRange. Also, that GLSL1.0
    // makes `precision highp float;` mandatory in fragment shaders, and GLSL1.2 removes
    // the `precision` keyword entirely, because that's clearly how minor versions work.
    // Christ, what a trash fire.

    const char *prelude;
#if defined(HAVE_GLES)
    prelude = R"(
#version 100
#define TEX_ALPHA a
precision highp float;
)";
#else
    prelude = R"(
#version 120
#define TEX_ALPHA r
)";
#endif
    std::string src(resData, size);
    src = prelude + src;

    GLuint shader = glCreateShader(type);
    ssassert(shader != 0, "glCreateShader failed");

    const GLint   glSize[]   = { (int)src.length() };
    const GLchar* glSource[] = { src.c_str() };
    glShaderSource(shader, 1, glSource, glSize);
    glCompileShader(shader);

    GLint infoLen;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;infoLen);
    if(infoLen &gt; 1) {
        std::string infoStr(infoLen, '\0');
        glGetShaderInfoLog(shader, infoLen, NULL, &amp;infoStr[0]);
        dbp(infoStr.c_str());
    }

    GLint compiled;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compiled);
    if(!compiled) {
        dbp("Failed to compile shader:\n"
            "----8&lt;----8&lt;----8&lt;----8&lt;----8&lt;----\n"
            "%s\n"
            "----8&lt;----8&lt;----8&lt;----8&lt;----8&lt;----\n",
            src.c_str());
    }
    ssassert(compiled, "Cannot compile shader");

    return shader;
}

</t>
<t tx="leo.20191228122650.150">void CairoRenderer::SelectStroke(hStroke hcs) {
    if(current.hcs == hcs) return;
    FinishPath();

    Stroke *stroke = strokes.FindById(hcs);
    current.hcs = hcs;

    RgbaColor color = stroke-&gt;color;
    std::vector&lt;double&gt; dashes = StipplePatternDashes(stroke-&gt;stipplePattern);
    for(double &amp;dash : dashes) {
        dash *= stroke-&gt;StippleScalePx(camera);
    }
    cairo_set_line_width(context, stroke-&gt;WidthPx(camera));
    cairo_set_dash(context, dashes.data(), (int)dashes.size(), 0);
    cairo_set_source_rgba(context, color.redF(), color.greenF(), color.blueF(),
                          color.alphaF());
    if(antialias) {
        cairo_set_antialias(context, CAIRO_ANTIALIAS_GRAY);
    } else {
        cairo_set_antialias(context, CAIRO_ANTIALIAS_NONE);
    }
}

</t>
<t tx="leo.20191228122650.151">void CairoRenderer::MoveTo(Vector p) {
    Point2d pos;
    cairo_get_current_point(context, &amp;pos.x, &amp;pos.y);
    if(cairo_has_current_point(context) &amp;&amp; pos.Equals(p.ProjectXy())) return;
    FinishPath();

    cairo_move_to(context, p.x, p.y);
}

</t>
<t tx="leo.20191228122650.152">void CairoRenderer::FinishPath() {
    if(!cairo_has_current_point(context)) return;

    cairo_stroke(context);
}

</t>
<t tx="leo.20191228122650.153">void CairoRenderer::OutputBezier(const SBezier &amp;b, hStroke hcs) {
    SelectStroke(hcs);

    Vector c, n = Vector::From(0, 0, 1);
    double r;
    if(b.deg == 1) {
        MoveTo(b.ctrl[0]);
        cairo_line_to(context,
            b.ctrl[1].x, b.ctrl[1].y);
    } else if(b.IsCircle(n, &amp;c, &amp;r)) {
        MoveTo(b.ctrl[0]);
        @others
}

</t>
<t tx="leo.20191228122650.154">    double theta0 = atan2(b.ctrl[0].y - c.y, b.ctrl[0].x - c.x),
           theta1 = atan2(b.ctrl[2].y - c.y, b.ctrl[2].x - c.x),
           dtheta = WRAP_SYMMETRIC(theta1 - theta0, 2*PI);
    if(dtheta &gt; 0) {
        cairo_arc(context,
            c.x, c.y, r, theta0, theta1);
    } else {
        cairo_arc_negative(context,
            c.x, c.y, r, theta0, theta1);
    }
} else if(b.deg == 3 &amp;&amp; !b.IsRational()) {
    MoveTo(b.ctrl[0]);
    cairo_curve_to(context,
        b.ctrl[1].x, b.ctrl[1].y,
        b.ctrl[2].x, b.ctrl[2].y,
        b.ctrl[3].x, b.ctrl[3].y);
} else {
    OutputBezierAsNonrationalCubic(b, hcs);
}
</t>
<t tx="leo.20191228122650.155">void CairoRenderer::OutputTriangle(const STriangle &amp;tr) {
    FinishPath();
    current.hcs = {};

    RgbaColor color = tr.meta.color;
    cairo_set_source_rgba(context, color.redF(), color.greenF(), color.blueF(),
                          color.alphaF());
    cairo_set_antialias(context, CAIRO_ANTIALIAS_NONE);
    cairo_move_to(context, tr.a.x, tr.a.y);
    cairo_line_to(context, tr.b.x, tr.b.y);
    cairo_line_to(context, tr.c.x, tr.c.y);
    cairo_fill(context);
}

</t>
<t tx="leo.20191228122650.156">void CairoPixmapRenderer::Init() {
    Clear();

    pixmap = std::make_shared&lt;Pixmap&gt;();
    pixmap-&gt;format = Pixmap::Format::BGRA;
    pixmap-&gt;width  = (size_t)camera.width;
    pixmap-&gt;height = (size_t)camera.height;
    pixmap-&gt;stride = cairo_format_stride_for_width(CAIRO_FORMAT_RGB24, (int)camera.width);
    pixmap-&gt;data   = std::vector&lt;uint8_t&gt;(pixmap-&gt;stride * pixmap-&gt;height);
    surface =
        cairo_image_surface_create_for_data(&amp;pixmap-&gt;data[0], CAIRO_FORMAT_RGB24,
                                            pixmap-&gt;width, pixmap-&gt;height,
                                            pixmap-&gt;stride);
    context = cairo_create(surface);
}

</t>
<t tx="leo.20191228122650.157">void CairoPixmapRenderer::Clear() {
    CairoRenderer::Clear();

    if(surface != NULL) cairo_surface_destroy(surface);
    surface = NULL;
}

std::shared_ptr&lt;Pixmap&gt; CairoPixmapRenderer::ReadFrame() {
    std::shared_ptr&lt;Pixmap&gt; result = pixmap-&gt;Copy();
    result-&gt;ConvertTo(Pixmap::Format::RGBA);
    return result;
}

}
</t>
<t tx="leo.20191228122650.158">@path ./src/render/
//-----------------------------------------------------------------------------
// OpenGL 1 based rendering interface.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include "solvespace.h"

#ifdef WIN32
// Include after solvespace.h to avoid identifier clashes.
#   include &lt;windows.h&gt; // required by GL headers
#endif
#ifdef __APPLE__
#   include &lt;OpenGL/gl.h&gt;
#   include &lt;OpenGL/glu.h&gt;
#else
#   include &lt;GL/gl.h&gt;
#   include &lt;GL/glu.h&gt;
#endif

namespace SolveSpace {

//-----------------------------------------------------------------------------
// Checks for buggy OpenGL renderers
//-----------------------------------------------------------------------------

// Intel GPUs with Mesa on *nix render thin lines poorly.
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122650.159">static bool HasIntelThinLineQuirk()
{
    static bool quirkChecked, quirkEnabled;
    if(!quirkChecked) {
        const char *ident = (const char*)glGetString(GL_VENDOR);
        if(ident != NULL) {
            quirkChecked = true;
            quirkEnabled = !strcmp(ident, "Intel Open Source Technology Center");
        }
    }
    return quirkEnabled;
}

// The default Windows GL renderer really does implement GL 1.1,
// and cannot handle non-power-of-2 textures, which is legal.
</t>
<t tx="leo.20191228122650.16">void Shader::Init(const std::string &amp;vertexRes, const std::string &amp;fragmentRes,
                  const std::vector&lt;std::pair&lt;GLuint, std::string&gt; &gt; &amp;locations) {
    GLuint vert = CompileShader(vertexRes, GL_VERTEX_SHADER);
    GLuint frag = CompileShader(fragmentRes, GL_FRAGMENT_SHADER);

    program = glCreateProgram();
    ssassert(program != 0, "glCreateProgram failed");

    glAttachShader(program, vert);
    glAttachShader(program, frag);
    for(const auto &amp;l : locations) {
        glBindAttribLocation(program, l.first, l.second.c_str());
    }
    glLinkProgram(program);

    GLint infoLen;
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;infoLen);
    if(infoLen &gt; 1) {
        std::string infoStr(infoLen, '\0');
        glGetProgramInfoLog(program, infoLen, NULL, &amp;infoStr[0]);
        dbp(infoStr.c_str());
    }

    GLint linked;
    glGetProgramiv(program, GL_LINK_STATUS, &amp;linked);
    ssassert(linked, "Cannot link shader");
}

</t>
<t tx="leo.20191228122650.160">static bool HasGl1V1Quirk()
{
    static bool quirkChecked, quirkEnabled;
    if(!quirkChecked) {
        const char *ident = (const char*)glGetString(GL_VERSION);
        if(ident != NULL) {
            quirkChecked = true;
            quirkEnabled = !strcmp(ident, "1.1.0");
        }
    }
    return quirkEnabled;
}

//-----------------------------------------------------------------------------
// Thin wrappers around OpenGL functions to fix bugs, adapt them to our
// data structures, etc.
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.161">static inline void ssglNormal3v(Vector n) {
    glNormal3d(n.x, n.y, n.z);
}

</t>
<t tx="leo.20191228122650.162">static inline void ssglVertex3v(Vector v) {
    glVertex3d(v.x, v.y, v.z);
}

</t>
<t tx="leo.20191228122650.163">void ssglLineWidth(double width) {
    if(HasIntelThinLineQuirk() &amp;&amp; width &lt; 1.6)
        width = 1.6;

    glLineWidth((GLfloat)width);
}

</t>
<t tx="leo.20191228122650.164">static inline void ssglColorRGBA(RgbaColor color) {
    glColor4d(color.redF(), color.greenF(), color.blueF(), color.alphaF());
}

</t>
<t tx="leo.20191228122650.165">static inline void ssglMaterialRGBA(GLenum side, RgbaColor color) {
    GLfloat mpb[] = { color.redF(), color.greenF(), color.blueF(), color.alphaF() };
    glMaterialfv(side, GL_AMBIENT_AND_DIFFUSE, mpb);
}

</t>
<t tx="leo.20191228122650.166">static void ssglDepthRange(Canvas::Layer layer, int zIndex) {
    switch(layer) {
        case Canvas::Layer::NORMAL:
        case Canvas::Layer::FRONT:
        case Canvas::Layer::BACK:
            glDepthFunc(GL_LEQUAL);
            glDepthMask(GL_TRUE);
            glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
            break;

        case Canvas::Layer::DEPTH_ONLY:
            glDepthFunc(GL_LEQUAL);
            glDepthMask(GL_TRUE);
            glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
            break;

        case Canvas::Layer::OCCLUDED:
            glDepthFunc(GL_GREATER);
            glDepthMask(GL_FALSE);
            glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
            break;
    }

    switch(layer) {
        case Canvas::Layer::FRONT:
            glDepthRange(0.0, 0.0);
            break;

        case Canvas::Layer::BACK:
            glDepthRange(1.0, 1.0);
            break;

        case Canvas::Layer::NORMAL:
        case Canvas::Layer::DEPTH_ONLY:
        case Canvas::Layer::OCCLUDED:
            // The size of this step depends on the resolution of the Z buffer; for
            // a 16-bit buffer, this should be fine.
            double offset = 1.0 / (65535 * 0.8) * zIndex;
            glDepthRange(0.1 - offset, 1.0 - offset);
            break;
    }
}

</t>
<t tx="leo.20191228122650.167">static void ssglFillPattern(Canvas::FillPattern pattern) {
    static bool Init;
    static GLubyte MaskA[(32*32)/8];
    static GLubyte MaskB[(32*32)/8];
    if(!Init) {
        int x, y;
        for(x = 0; x &lt; 32; x++) {
            for(y = 0; y &lt; 32; y++) {
                int i = y*4 + x/8, b = x % 8;
                int ym = y % 4, xm = x % 4;
                for(int k = 0; k &lt; 2; k++) {
                    if(xm &gt;= 1 &amp;&amp; xm &lt;= 2 &amp;&amp; ym &gt;= 1 &amp;&amp; ym &lt;= 2) {
                        (k == 0 ? MaskB : MaskA)[i] |= (0x80 &gt;&gt; b);
                    }
                    ym = (ym + 2) % 4; xm = (xm + 2) % 4;
                }
            }
        }
        Init = true;
    }

    switch(pattern) {
        case Canvas::FillPattern::SOLID:
            glDisable(GL_POLYGON_STIPPLE);
            break;

        case Canvas::FillPattern::CHECKERED_A:
            glEnable(GL_POLYGON_STIPPLE);
            glPolygonStipple(MaskA);
            break;

        case Canvas::FillPattern::CHECKERED_B:
            glEnable(GL_POLYGON_STIPPLE);
            glPolygonStipple(MaskB);
            break;
    }
}

//-----------------------------------------------------------------------------
// OpenGL 1 / compatibility profile based renderer
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.168">class OpenGl1Renderer final : public ViewportCanvas {
public:
    Camera      camera;
    Lighting    lighting;
    // Cached OpenGL state.
    struct {
        bool        drawing;
        GLenum      mode;
        hStroke     hcs;
        Stroke     *stroke;
        hFill       hcf;
        Fill       *fill;
        std::weak_ptr&lt;const Pixmap&gt; texture;
    } current;

    // List-initialize current to work around MSVC bug 746973.
    OpenGl1Renderer() : camera(), lighting(), current({}) {}

    const Camera &amp;GetCamera() const override { return camera; }

    void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) override;
    void DrawEdges(const SEdgeList &amp;el, hStroke hcs) override;
    bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) override { return false; }
    void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) override;
    void DrawVectorText(const std::string &amp;text, double height,
                    const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
    void DoLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs);
    void DoPoint(Vector p, double radius);
    void DoStippledLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs, double phase = 0.0);

    void UpdateProjection();
    void SetCamera(const Camera &amp;camera) override;
    void SetLighting(const Lighting &amp;lighting) override;

    void StartFrame() override;
    void FlushFrame() override;
    void FinishFrame() override;
    std::shared_ptr&lt;Pixmap&gt; ReadFrame() override;

    void GetIdent(const char **vendor, const char **renderer, const char **version) override;
};

//-----------------------------------------------------------------------------
// A simple OpenGL state tracker to group consecutive draw calls.
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.169">void OpenGl1Renderer::SelectPrimitive(GLenum mode) {
    if(current.drawing &amp;&amp; current.mode == mode) {
        return;
    } else if(current.drawing) {
        glEnd();
    }
    glBegin(mode);
    current.drawing = true;
    current.mode    = mode;
}

</t>
<t tx="leo.20191228122650.17">void Shader::Clear() {
    glDeleteProgram(program);
}

</t>
<t tx="leo.20191228122650.170">void OpenGl1Renderer::UnSelectPrimitive() {
    if(!current.drawing) return;
    glEnd();
    current.drawing = false;
}

Canvas::Stroke *OpenGl1Renderer::SelectStroke(hStroke hcs) {
    if(current.hcs == hcs) return current.stroke;

    Stroke *stroke = strokes.FindById(hcs);
    UnSelectPrimitive();
    ssglColorRGBA(stroke-&gt;color);
    ssglDepthRange(stroke-&gt;layer, stroke-&gt;zIndex);
    ssglLineWidth(stroke-&gt;WidthPx(camera));
    // Fat lines and points are quads affected by glPolygonStipple, so make sure
    // they are displayed correctly.
    ssglFillPattern(FillPattern::SOLID);
    glDisable(GL_TEXTURE_2D);

    current.hcs    = hcs;
    current.stroke = stroke;
    current.hcf    = {};
    current.fill   = NULL;
    current.texture.reset();
    return stroke;
}

Canvas::Fill *OpenGl1Renderer::SelectFill(hFill hcf) {
    if(current.hcf == hcf) return current.fill;

    Fill *fill = fills.FindById(hcf);
    UnSelectPrimitive();
    ssglColorRGBA(fill-&gt;color);
    ssglDepthRange(fill-&gt;layer, fill-&gt;zIndex);
    ssglFillPattern(fill-&gt;pattern);
    glDisable(GL_TEXTURE_2D);

    current.hcs    = {};
    current.stroke = NULL;
    current.hcf    = hcf;
    current.fill   = fill;
    current.texture.reset();
    return fill;
}

</t>
<t tx="leo.20191228122650.171">static int RoundUpToPowerOfTwo(int v)
{
    for(int i = 0; i &lt; 31; i++) {
        int vt = (1 &lt;&lt; i);
        if(vt &gt;= v) {
            return vt;
        }
    }
    return 0;
}

</t>
<t tx="leo.20191228122650.172">void OpenGl1Renderer::SelectTexture(std::shared_ptr&lt;const Pixmap&gt; pm) {
    if(current.texture.lock() == pm) return;

    glBindTexture(GL_TEXTURE_2D, 1);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,     GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,     GL_CLAMP);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

    GLenum format = 0;
    switch(pm-&gt;format) {
        case Pixmap::Format::RGBA: format = GL_RGBA;  break;
        case Pixmap::Format::RGB:  format = GL_RGB;   break;
        case Pixmap::Format::A:    format = GL_ALPHA; break;
        case Pixmap::Format::BGRA:
        case Pixmap::Format::BGR:
            ssassert(false, "Unexpected pixmap format");
    }

    if(!HasGl1V1Quirk()) {
        glTexImage2D(GL_TEXTURE_2D, 0, format, pm-&gt;width, pm-&gt;height, 0,
                     format, GL_UNSIGNED_BYTE, &amp;pm-&gt;data[0]);
    } else {
        GLsizei width = RoundUpToPowerOfTwo(pm-&gt;width);
        GLsizei height = RoundUpToPowerOfTwo(pm-&gt;height);
        glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0,
                     format, GL_UNSIGNED_BYTE, 0);
        glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, pm-&gt;width, pm-&gt;height,
                        format, GL_UNSIGNED_BYTE, &amp;pm-&gt;data[0]);
    }

    glEnable(GL_TEXTURE_2D);

    current.texture = pm;
}

//-----------------------------------------------------------------------------
// OpenGL's GL_LINES mode does not work on lines thicker than about 3 px,
// so we have to draw thicker lines using triangles.
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.173">void OpenGl1Renderer::DoFatLineEndcap(const Vector &amp;p, const Vector &amp;u, const Vector &amp;v) {
    // A table of cos and sin of (pi*i/10 + pi/2), as i goes from 0 to 10
    @others
}

</t>
<t tx="leo.20191228122650.174">static const double Circle[11][2] = {
    {  0.0000,   1.0000 },
    { -0.3090,   0.9511 },
    { -0.5878,   0.8090 },
    { -0.8090,   0.5878 },
    { -0.9511,   0.3090 },
    { -1.0000,   0.0000 },
    { -0.9511,  -0.3090 },
    { -0.8090,  -0.5878 },
    { -0.5878,  -0.8090 },
    { -0.3090,  -0.9511 },
    {  0.0000,  -1.0000 },
};

SelectPrimitive(GL_TRIANGLE_FAN);
for(auto pc : Circle) {
    double c = pc[0], s = pc[1];
    ssglVertex3v(p.Plus(u.ScaledBy(c)).Plus(v.ScaledBy(s)));
}
UnSelectPrimitive();
</t>
<t tx="leo.20191228122650.175">void OpenGl1Renderer::DoFatLine(const Vector &amp;a, const Vector &amp;b, double width) {
    // The half-width of the line we're drawing.
    double hw = width / 2;
    Vector ab  = b.Minus(a);
    Vector gn = (camera.projRight).Cross(camera.projUp);
    Vector abn = (ab.Cross(gn)).WithMagnitude(1);
    abn = abn.Minus(gn.ScaledBy(gn.Dot(abn)));
    // So now abn is normal to the projection of ab into the screen, so the
    // line will always have constant thickness as the view is rotated.

    abn = abn.WithMagnitude(hw);
    ab  = gn.Cross(abn);
    ab  = ab. WithMagnitude(hw);

    // The body of a line is a quad
    SelectPrimitive(GL_QUADS);
    ssglVertex3v(a.Plus (abn));
    ssglVertex3v(b.Plus (abn));
    ssglVertex3v(b.Minus(abn));
    ssglVertex3v(a.Minus(abn));
    // And the line has two semi-circular end caps.
    DoFatLineEndcap(a, ab,              abn);
    DoFatLineEndcap(b, ab.ScaledBy(-1), abn);
}

</t>
<t tx="leo.20191228122650.176">void OpenGl1Renderer::DoLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    if(a.Equals(b)) return;

    Stroke *stroke = SelectStroke(hcs);
    if(stroke-&gt;WidthPx(camera) &lt;= 3.0) {
        SelectPrimitive(GL_LINES);
        ssglVertex3v(a);
        ssglVertex3v(b);
    } else {
        DoFatLine(a, b, stroke-&gt;WidthPx(camera) / camera.scale);
    }
}

</t>
<t tx="leo.20191228122650.177">void OpenGl1Renderer::DoPoint(Vector p, double d) {
    if(d &lt;= 3.0) {
        Vector u = camera.projRight.WithMagnitude(d / 2.0 / camera.scale);

        SelectPrimitive(GL_LINES);
        ssglVertex3v(p.Minus(u));
        ssglVertex3v(p.Plus(u));
    } else {
        Vector u = camera.projRight.WithMagnitude(d / 2.0 / camera.scale);
        Vector v = camera.projUp.WithMagnitude(d / 2.0 / camera.scale);

        DoFatLineEndcap(p, u, v);
        DoFatLineEndcap(p, u.ScaledBy(-1.0), v);
    }
}

</t>
<t tx="leo.20191228122650.178">void OpenGl1Renderer::DoStippledLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs, double phase) {
    Stroke *stroke = SelectStroke(hcs);

    if(stroke-&gt;stipplePattern == StipplePattern::CONTINUOUS) {
        DoLine(a, b, hcs);
        return;
    }

    double scale = stroke-&gt;StippleScaleMm(camera);
    const std::vector&lt;double&gt; &amp;dashes = StipplePatternDashes(stroke-&gt;stipplePattern);
    double length = StipplePatternLength(stroke-&gt;stipplePattern) * scale;

    phase -= floor(phase / length) * length;

    double curPhase = 0.0;
    size_t curDash;
    for(curDash = 0; curDash &lt; dashes.size(); curDash++) {
        curPhase += dashes[curDash] * scale;
        if(phase &lt; curPhase) break;
    }

    Vector dir = b.Minus(a);
    double len = dir.Magnitude();
    dir = dir.WithMagnitude(1.0);

    double cur = 0.0;
    Vector curPos = a;
    double width = stroke-&gt;WidthMm(camera);

    double curDashLen = (curPhase - phase) / scale;
    while(cur &lt; len) {
        double next = std::min(len, cur + curDashLen * scale);
        Vector nextPos = curPos.Plus(dir.ScaledBy(next - cur));
        if(curDash % 2 == 0) {
            if(curDashLen &lt;= LENGTH_EPS) {
                DoPoint(curPos, width);
            } else {
                DoLine(curPos, nextPos, hcs);
            }
        }
        cur = next;
        curPos = nextPos;
        curDash++;
        curDashLen = dashes[curDash % dashes.size()];
    }
}

//-----------------------------------------------------------------------------
// A canvas implemented using OpenGL 3 immediate mode.
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.179">void OpenGl1Renderer::DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    DoStippledLine(a, b, hcs);
}

</t>
<t tx="leo.20191228122650.18">void Shader::SetUniformMatrix(const char *name, const double *md) {
    Enable();
    float mf[16];
    for(int i = 0; i &lt; 16; i++) mf[i] = (float)md[i];
    glUniformMatrix4fv(glGetUniformLocation(program, name), 1, false, mf);
}

</t>
<t tx="leo.20191228122650.180">void OpenGl1Renderer::DrawEdges(const SEdgeList &amp;el, hStroke hcs) {
    double phase = 0.0;
    for(const SEdge *e = el.l.First(); e; e = el.l.NextAfter(e)) {
        DoStippledLine(e-&gt;a, e-&gt;b, hcs, phase);
        phase += e-&gt;a.Minus(e-&gt;b).Magnitude();
    }
}

</t>
<t tx="leo.20191228122650.181">void OpenGl1Renderer::DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) {
    Vector projDir = camera.projRight.Cross(camera.projUp);
    double phase = 0.0;
    switch(drawAs) {
        case DrawOutlinesAs::EMPHASIZED_AND_CONTOUR:
            for(const SOutline &amp;o : ol.l) {
                if(o.IsVisible(projDir) || o.tag != 0) {
                    DoStippledLine(o.a, o.b, hcs, phase);
                }
                phase += o.a.Minus(o.b).Magnitude();
            }
            break;

        case DrawOutlinesAs::EMPHASIZED_WITHOUT_CONTOUR:
            for(const SOutline &amp;o : ol.l) {
                if(!o.IsVisible(projDir) &amp;&amp; o.tag != 0) {
                    DoStippledLine(o.a, o.b, hcs, phase);
                }
                phase += o.a.Minus(o.b).Magnitude();
            }
            break;

        case DrawOutlinesAs::CONTOUR_ONLY:
            for(const SOutline &amp;o : ol.l) {
                if(o.IsVisible(projDir)) {
                    DoStippledLine(o.a, o.b, hcs, phase);
                }
                phase += o.a.Minus(o.b).Magnitude();
            }
            break;
    }
}

</t>
<t tx="leo.20191228122650.182">void OpenGl1Renderer::DrawVectorText(const std::string &amp;text, double height,
                                     const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                                     hStroke hcs) {
    auto traceEdge = [&amp;](Vector a, Vector b) { DoStippledLine(a, b, hcs); };
    VectorFont::Builtin()-&gt;Trace(height, o, u, v, text, traceEdge, camera);
}

</t>
<t tx="leo.20191228122650.183">void OpenGl1Renderer::DrawQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d,
                               hFill hcf) {
    SelectFill(hcf);
    SelectPrimitive(GL_QUADS);
    ssglVertex3v(a);
    ssglVertex3v(b);
    ssglVertex3v(c);
    ssglVertex3v(d);
}

</t>
<t tx="leo.20191228122650.184">void OpenGl1Renderer::DrawPoint(const Vector &amp;o, Canvas::hStroke hcs) {
    Stroke *stroke = SelectStroke(hcs);

    Canvas::Fill fill = {};
    fill.layer  = stroke-&gt;layer;
    fill.zIndex = stroke-&gt;zIndex;
    fill.color  = stroke-&gt;color;
    hFill hcf = GetFill(fill);

    Vector r = camera.projRight.ScaledBy(stroke-&gt;width/2.0/camera.scale);
    Vector u = camera.projUp.ScaledBy(stroke-&gt;width/2.0/camera.scale);
    Vector a = o.Plus (r).Plus (u),
           b = o.Plus (r).Minus(u),
           c = o.Minus(r).Minus(u),
           d = o.Minus(r).Plus (u);
    DrawQuad(a, b, c, d, hcf);
}

#ifdef WIN32
#define SSGL_CALLBACK CALLBACK
#else
#define SSGL_CALLBACK
#endif
typedef void(SSGL_CALLBACK *GLUCallback)();

</t>
<t tx="leo.20191228122650.185">static void SSGL_CALLBACK Vertex(Vector *p) {
    ssglVertex3v(*p);
}
</t>
<t tx="leo.20191228122650.186">static void SSGL_CALLBACK Combine(double coords[3], void *vertexData[4],
                                  float weight[4], void **outData) {
    Vector *n = (Vector *)AllocTemporary(sizeof(Vector));
    n-&gt;x = coords[0];
    n-&gt;y = coords[1];
    n-&gt;z = coords[2];

    *outData = n;
}
</t>
<t tx="leo.20191228122650.187">void OpenGl1Renderer::DrawPolygon(const SPolygon &amp;p, hFill hcf) {
    UnSelectPrimitive();
    SelectFill(hcf);

    GLUtesselator *gt = gluNewTess();
    gluTessCallback(gt, GLU_TESS_BEGIN,   (GLUCallback) glBegin);
    gluTessCallback(gt, GLU_TESS_VERTEX,  (GLUCallback) Vertex);
    gluTessCallback(gt, GLU_TESS_END,     (GLUCallback) glEnd);
    gluTessCallback(gt, GLU_TESS_COMBINE, (GLUCallback) Combine);

    gluTessProperty(gt, GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_ODD);

    ssglNormal3v(p.normal);
    gluTessNormal(gt, p.normal.x, p.normal.y, p.normal.z);

    gluTessBeginPolygon(gt, NULL);
    for(const SContour &amp;sc : p.l) {
        gluTessBeginContour(gt);
        for(const SPoint &amp;sp : sc.l) {
            double ap[3] = { sp.p.x, sp.p.y, sp.p.z };
            gluTessVertex(gt, ap, (GLvoid *) &amp;sp.p);
        }
        gluTessEndContour(gt);
    }
    gluTessEndPolygon(gt);

    gluDeleteTess(gt);
}

</t>
<t tx="leo.20191228122650.188">void OpenGl1Renderer::DrawMesh(const SMesh &amp;m, hFill hcfFront, hFill hcfBack) {
    UnSelectPrimitive();

    RgbaColor frontColor = {},
              backColor  = {};

    Fill *frontFill = SelectFill(hcfFront);
    frontColor = frontFill-&gt;color;

    ssglMaterialRGBA(GL_FRONT, frontFill-&gt;color);
    if(hcfBack.v != 0) {
        Fill *backFill = fills.FindById(hcfBack);
        backColor = backFill-&gt;color;
        ssassert(frontFill-&gt;layer  == backFill-&gt;layer &amp;&amp;
                 frontFill-&gt;zIndex == backFill-&gt;zIndex,
                 "frontFill and backFill should belong to the same depth range");
        ssassert(frontFill-&gt;pattern == backFill-&gt;pattern,
                 "frontFill and backFill should have the same pattern");
        glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 1);
        ssglMaterialRGBA(GL_BACK, backFill-&gt;color);
    } else {
        glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 0);
    }

    RgbaColor triangleColor = {};
    glEnable(GL_LIGHTING);
    glBegin(GL_TRIANGLES);
    for(const STriangle &amp;tr : m.l) {
        if(frontColor.IsEmpty() || backColor.IsEmpty()) {
            if(triangleColor.IsEmpty() || !triangleColor.Equals(tr.meta.color)) {
                triangleColor = tr.meta.color;
                if(frontColor.IsEmpty()) {
                    ssglMaterialRGBA(GL_FRONT, triangleColor);
                }
                if(backColor.IsEmpty()) {
                    ssglMaterialRGBA(GL_BACK, triangleColor);
                }
            }
        }

        if(tr.an.EqualsExactly(Vector::From(0, 0, 0))) {
            // Compute the normal from the vertices
            ssglNormal3v(tr.Normal());
            ssglVertex3v(tr.a);
            ssglVertex3v(tr.b);
            ssglVertex3v(tr.c);
        } else {
            // Use the exact normals that are specified
            ssglNormal3v(tr.an);
            ssglVertex3v(tr.a);
            ssglNormal3v(tr.bn);
            ssglVertex3v(tr.b);
            ssglNormal3v(tr.cn);
            ssglVertex3v(tr.c);
        }
    }
    glEnd();
    glDisable(GL_LIGHTING);
}

</t>
<t tx="leo.20191228122650.189">void OpenGl1Renderer::DrawFaces(const SMesh &amp;m, const std::vector&lt;uint32_t&gt; &amp;faces, hFill hcf) {
    SelectFill(hcf);
    SelectPrimitive(GL_TRIANGLES);
    size_t facesSize = faces.size();
    for(const STriangle &amp;tr : m.l) {
        uint32_t face = tr.meta.face;
        for(size_t j = 0; j &lt; facesSize; j++) {
            if(faces[j] != face) continue;
            ssglVertex3v(tr.a);
            ssglVertex3v(tr.b);
            ssglVertex3v(tr.c);
            break;
        }
    }
}

</t>
<t tx="leo.20191228122650.19">void Shader::SetUniformVector(const char *name, const Vector &amp;v) {
    Enable();
    glUniform3f(glGetUniformLocation(program, name), (float)v.x, (float)v.y, (float)v.z);
}

</t>
<t tx="leo.20191228122650.190">void OpenGl1Renderer::DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
                                 const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                                 const Point2d &amp;ta, const Point2d &amp;tb, hFill hcf) {
    @others
}

</t>
<t tx="leo.20191228122650.191">double xfactor = 1.0,
       yfactor = 1.0;
if(HasGl1V1Quirk()) {
    xfactor = (double)pm-&gt;width / RoundUpToPowerOfTwo(pm-&gt;width);
    yfactor = (double)pm-&gt;height / RoundUpToPowerOfTwo(pm-&gt;height);
}

UnSelectPrimitive();
SelectFill(hcf);
SelectTexture(pm);
SelectPrimitive(GL_QUADS);
glTexCoord2d(ta.x * xfactor, ta.y * yfactor);
ssglVertex3v(o);
glTexCoord2d(ta.x * xfactor, tb.y * yfactor);
ssglVertex3v(o.Plus(v));
glTexCoord2d(tb.x * xfactor, tb.y * yfactor);
ssglVertex3v(o.Plus(u).Plus(v));
glTexCoord2d(tb.x * xfactor, ta.y * yfactor);
ssglVertex3v(o.Plus(u));
</t>
<t tx="leo.20191228122650.192">void OpenGl1Renderer::InvalidatePixmap(std::shared_ptr&lt;const Pixmap&gt; pm) {
    if(current.texture.lock() == pm) {
        current.texture.reset();
    }
}

</t>
<t tx="leo.20191228122650.193">void OpenGl1Renderer::UpdateProjection() {
    UnSelectPrimitive();

    glViewport(0, 0,
               (GLsizei)(camera.width  * camera.pixelRatio),
               (GLsizei)(camera.height * camera.pixelRatio));

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glScaled(camera.scale * 2.0 / camera.width,
             camera.scale * 2.0 / camera.height,
             camera.scale * 1.0 / 30000);

    double mat[16];
    // Last thing before display is to apply the perspective
    double clp = camera.tangent * camera.scale;
    MakeMatrix(mat, 1,              0,              0,              0,
                    0,              1,              0,              0,
                    0,              0,              1,              0,
                    0,              0,              clp,            1);
    glMultMatrixd(mat);

    // Before that, we apply the rotation
    Vector projRight = camera.projRight,
           projUp    = camera.projUp,
           n         = camera.projUp.Cross(camera.projRight);
    MakeMatrix(mat, projRight.x,    projRight.y,    projRight.z,    0,
                    projUp.x,       projUp.y,       projUp.z,       0,
                    n.x,            n.y,            n.z,            0,
                    0,              0,              0,              1);
    glMultMatrixd(mat);

    // And before that, the translation
    Vector offset = camera.offset;
    MakeMatrix(mat, 1,              0,              0,              offset.x,
                    0,              1,              0,              offset.y,
                    0,              0,              1,              offset.z,
                    0,              0,              0,              1);
    glMultMatrixd(mat);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glClearDepth(1.0);
    glClear(GL_DEPTH_BUFFER_BIT);
}

</t>
<t tx="leo.20191228122650.194">void OpenGl1Renderer::StartFrame() {
    glEnable(GL_NORMALIZE);

    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_BLEND);

    glEnable(GL_LINE_SMOOTH);
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
    // don't enable GL_POLYGON_SMOOTH; that looks ugly on some graphics cards,
    // drawn with leaks in the mesh

    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    if(EXACT(lighting.lightIntensity[0] != 0.0)) {
        glEnable(GL_LIGHT0);
        GLfloat f = (GLfloat)lighting.lightIntensity[0];
        GLfloat li0[] = { f, f, f, 1.0f };
        glLightfv(GL_LIGHT0, GL_DIFFUSE, li0);
        glLightfv(GL_LIGHT0, GL_SPECULAR, li0);

        Vector ld = camera.VectorFromProjs(lighting.lightDirection[0]);
        GLfloat ld0[4] = { (GLfloat)ld.x, (GLfloat)ld.y, (GLfloat)ld.z, 0 };
        glLightfv(GL_LIGHT0, GL_POSITION, ld0);
    }

    if(EXACT(lighting.lightIntensity[1] != 0.0)) {
        glEnable(GL_LIGHT1);
        GLfloat f = (GLfloat)lighting.lightIntensity[1];
        GLfloat li0[] = { f, f, f, 1.0f };
        glLightfv(GL_LIGHT1, GL_DIFFUSE, li0);
        glLightfv(GL_LIGHT1, GL_SPECULAR, li0);

        Vector ld = camera.VectorFromProjs(lighting.lightDirection[1]);
        GLfloat ld0[4] = { (GLfloat)ld.x, (GLfloat)ld.y, (GLfloat)ld.z, 0 };
        glLightfv(GL_LIGHT1, GL_POSITION, ld0);
    }

    if(EXACT(lighting.ambientIntensity != 0.0)) {
        GLfloat ambient[4] = { (float)lighting.ambientIntensity,
                               (float)lighting.ambientIntensity,
                               (float)lighting.ambientIntensity, 1 };
        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambient);
    }

    glClearColor(lighting.backgroundColor.redF(),  lighting.backgroundColor.greenF(),
                 lighting.backgroundColor.blueF(), lighting.backgroundColor.alphaF());
    glClear(GL_COLOR_BUFFER_BIT);

    glClearDepth(1.0);
    glClear(GL_DEPTH_BUFFER_BIT);
}

</t>
<t tx="leo.20191228122650.195">void OpenGl1Renderer::FlushFrame() {
    UnSelectPrimitive();

    glFlush();
}

</t>
<t tx="leo.20191228122650.196">void OpenGl1Renderer::FinishFrame() {
    glFinish();

    GLenum error = glGetError();
    if(error != GL_NO_ERROR) {
        dbp("glGetError() == 0x%X %s", error, gluErrorString(error));
    }
}

std::shared_ptr&lt;Pixmap&gt; OpenGl1Renderer::ReadFrame() {
    int width  = (int)(camera.width  * camera.pixelRatio);
    int height = (int)(camera.height * camera.pixelRatio);
    std::shared_ptr&lt;Pixmap&gt; pixmap =
        Pixmap::Create(Pixmap::Format::RGB, (size_t)width, (size_t)height);
    glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, &amp;pixmap-&gt;data[0]);
    ssassert(glGetError() == GL_NO_ERROR, "Unexpected glReadPixels error");
    return pixmap;
}

</t>
<t tx="leo.20191228122650.197">void OpenGl1Renderer::GetIdent(const char **vendor, const char **renderer, const char **version) {
    *vendor   = (const char *)glGetString(GL_VENDOR);
    *renderer = (const char *)glGetString(GL_RENDERER);
    *version  = (const char *)glGetString(GL_VERSION);
}

</t>
<t tx="leo.20191228122650.198">void OpenGl1Renderer::SetCamera(const Camera &amp;c) {
    camera = c;
    UpdateProjection();
}

</t>
<t tx="leo.20191228122650.199">void OpenGl1Renderer::SetLighting(const Lighting &amp;l) {
    lighting = l;
}

std::shared_ptr&lt;ViewportCanvas&gt; CreateRenderer() {
    return std::shared_ptr&lt;ViewportCanvas&gt;(new OpenGl1Renderer());
}

}
</t>
<t tx="leo.20191228122650.2">void *AllocTemporary(size_t n)
{
    AllocTempHeader *h =
        (AllocTempHeader *)malloc(n + sizeof(AllocTempHeader));
    h-&gt;prev = NULL;
    h-&gt;next = Head;
    if(Head) Head-&gt;prev = h;
    Head = h;
    memset(&amp;h[1], 0, n);
    return (void *)&amp;h[1];
}

</t>
<t tx="leo.20191228122650.20">void Shader::SetUniformVector(const char *name, const Vector4f &amp;v) {
    Enable();
    glUniform4f(glGetUniformLocation(program, name), v.x, v.y, v.z, v.w);
}

</t>
<t tx="leo.20191228122650.200">@path ./src/render/
//-----------------------------------------------------------------------------
// OpenGL ES 2.0 and OpenGL 3.0 based rendering interface.
//
// Copyright 2016 Aleksey Egorov
//-----------------------------------------------------------------------------
#include "solvespace.h"
#include "gl3shader.h"

namespace SolveSpace {

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122650.201">class TextureCache {
public:
    std::map&lt;std::weak_ptr&lt;const Pixmap&gt;, GLuint,
             std::owner_less&lt;std::weak_ptr&lt;const Pixmap&gt;&gt;&gt; items;

    @others
};

// A canvas that uses the core OpenGL 3 profile, for desktop systems.
</t>
<t tx="leo.20191228122650.202">bool Lookup(std::shared_ptr&lt;const Pixmap&gt; ptr, GLuint *result) {
    auto it = items.find(ptr);
    if(it == items.end()) {
        GLuint id;
        glGenTextures(1, &amp;id);
        items[ptr] = id;
        *result = id;
        return false;
    }

    *result = it-&gt;second;
    return true;
}

</t>
<t tx="leo.20191228122650.203">void CleanupUnused() {
    for(auto it = items.begin(); it != items.end();) {
        if(it-&gt;first.expired()) {
            glDeleteTextures(1, &amp;it-&gt;second);
            it = items.erase(it);
            continue;
        }
        it++;
    }
}
</t>
<t tx="leo.20191228122650.204">class OpenGl3Renderer final : public ViewportCanvas {
public:
    struct SEdgeListItem {
        hStroke         h;
        SEdgeList       lines;

        void Clear() { lines.Clear(); }
    };

    struct SMeshListItem {
        hFill           h;
        SIndexedMesh    mesh;

        void Clear() { mesh.Clear(); }
    };

    struct SPointListItem {
        hStroke         h;
        SIndexedMesh    points;

        void Clear() { points.Clear(); }
    };

    IdList&lt;SEdgeListItem,  hStroke&gt; lines;
    IdList&lt;SMeshListItem,  hFill&gt;   meshes;
    IdList&lt;SPointListItem, hStroke&gt; points;

    TextureCache            pixmapCache;
    std::shared_ptr&lt;Pixmap&gt; masks[3];

    bool                initialized;
    StippleAtlas        atlas;
    MeshRenderer        meshRenderer;
    IndexedMeshRenderer imeshRenderer;
    EdgeRenderer        edgeRenderer;
    OutlineRenderer     outlineRenderer;

    Camera   camera;
    Lighting lighting;
    // Cached OpenGL state.
    struct {
        hStroke     hcs;
        Stroke     *stroke;
        hFill       hcf;
        Fill       *fill;
        std::weak_ptr&lt;const Pixmap&gt; texture;
    } current;
    const char *vendor   = "&lt;uninitialized&gt;";
    const char *renderer = "&lt;uninitialized&gt;";
    const char *version  = "&lt;uninitialized&gt;";

    // List-initialize current to work around MSVC bug 746973.
    OpenGl3Renderer() :
        lines(), meshes(), points(), pixmapCache(), masks(),
        initialized(), atlas(), meshRenderer(), imeshRenderer(),
        edgeRenderer(), outlineRenderer(), camera(), lighting(),
        current({}) {}

    void Init();

    const Camera &amp;GetCamera() const override { return camera; }

    void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) override;
    void DrawEdges(const SEdgeList &amp;el, hStroke hcs) override;
    bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) override { return false; }
    void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs mode) override;
    void DrawVectorText(const std::string &amp;text, double height,
                    const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
    void DoFatLine(const Vector &amp;a, const Vector &amp;b, double width);
    void DoLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs);
    void DoPoint(Vector p, hStroke hs);
    void DoStippledLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs);

    void UpdateProjection();
    void SetCamera(const Camera &amp;c) override;
    void SetLighting(const Lighting &amp;l) override;

    void StartFrame() override;
    void FlushFrame() override;
    void FinishFrame() override;
    void Clear() override;
    std::shared_ptr&lt;Pixmap&gt; ReadFrame() override;

    void GetIdent(const char **vendor, const char **renderer, const char **version) override;
};

//-----------------------------------------------------------------------------
// Thin wrappers around OpenGL functions to fix bugs, adapt them to our
// data structures, etc.
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.205">static void ssglDepthRange(Canvas::Layer layer, int zIndex) {
    switch(layer) {
        case Canvas::Layer::NORMAL:
        case Canvas::Layer::FRONT:
        case Canvas::Layer::BACK:
            glDepthFunc(GL_LEQUAL);
            glDepthMask(GL_TRUE);
            glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
            break;

        case Canvas::Layer::DEPTH_ONLY:
            glDepthFunc(GL_LEQUAL);
            glDepthMask(GL_TRUE);
            glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
            break;

        case Canvas::Layer::OCCLUDED:
            glDepthFunc(GL_GREATER);
            glDepthMask(GL_FALSE);
            glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
            break;
    }

    switch(layer) {
        case Canvas::Layer::FRONT:
            glDepthRangef(0.0f, 0.0f);
            break;

        case Canvas::Layer::BACK:
            glDepthRangef(1.0f, 1.0f);
            break;

        case Canvas::Layer::NORMAL:
        case Canvas::Layer::DEPTH_ONLY:
        case Canvas::Layer::OCCLUDED:
            // The size of this step depends on the resolution of the Z buffer; for
            // a 16-bit buffer, this should be fine.
            double offset = 1.0 / (65535 * 0.8) * zIndex;
            glDepthRangef((float)(0.1 - offset), (float)(1.0 - offset));
            break;
    }
}

//-----------------------------------------------------------------------------
// A simple OpenGL state tracker to group consecutive draw calls.
//-----------------------------------------------------------------------------

Canvas::Stroke *OpenGl3Renderer::SelectStroke(hStroke hcs) {
    if(current.hcs == hcs) return current.stroke;

    Stroke *stroke = strokes.FindById(hcs);
    ssglDepthRange(stroke-&gt;layer, stroke-&gt;zIndex);

    current.hcs    = hcs;
    current.stroke = stroke;
    current.hcf    = {};
    current.fill   = NULL;
    current.texture.reset();
    return stroke;
}

</t>
<t tx="leo.20191228122650.206">void OpenGl3Renderer::SelectMask(FillPattern pattern) {
    if(!masks[0]) {
        masks[0] = Pixmap::Create(Pixmap::Format::A, 32, 32);
        masks[1] = Pixmap::Create(Pixmap::Format::A, 32, 32);
        masks[2] = Pixmap::Create(Pixmap::Format::A, 32, 32);

        for(int x = 0; x &lt; 32; x++) {
            for(int y = 0; y &lt; 32; y++) {
                masks[0]-&gt;data[y * 32 + x] = ((x / 2) % 2 == 0 &amp;&amp; (y / 2) % 2 == 0) ? 0xFF : 0x00;
                masks[1]-&gt;data[y * 32 + x] = ((x / 2) % 2 == 1 &amp;&amp; (y / 2) % 2 == 1) ? 0xFF : 0x00;
                masks[2]-&gt;data[y * 32 + x] = 0xFF;
            }
        }
    }

    switch(pattern) {
        case Canvas::FillPattern::SOLID:
            SelectTexture(masks[2]);
            break;

        case Canvas::FillPattern::CHECKERED_A:
            SelectTexture(masks[0]);
            break;

        case Canvas::FillPattern::CHECKERED_B:
            SelectTexture(masks[1]);
            break;

        default: ssassert(false, "Unexpected fill pattern");
    }
}

Canvas::Fill *OpenGl3Renderer::SelectFill(hFill hcf) {
    if(current.hcf == hcf) return current.fill;

    Fill *fill = fills.FindById(hcf);
    ssglDepthRange(fill-&gt;layer, fill-&gt;zIndex);

    current.hcs    = {};
    current.stroke = NULL;
    current.hcf    = hcf;
    current.fill   = fill;
    if(fill-&gt;pattern != FillPattern::SOLID) {
        SelectMask(fill-&gt;pattern);
    } else if(fill-&gt;texture) {
        SelectTexture(fill-&gt;texture);
    } else {
        SelectMask(FillPattern::SOLID);
    }
    return fill;
}

</t>
<t tx="leo.20191228122650.207">static bool IsPowerOfTwo(size_t n) {
    return (n &amp; (n - 1)) == 0;
}

</t>
<t tx="leo.20191228122650.208">void OpenGl3Renderer::InvalidatePixmap(std::shared_ptr&lt;const Pixmap&gt; pm) {
    GLuint id;
    pixmapCache.Lookup(pm, &amp;id);
    glBindTexture(GL_TEXTURE_2D, id);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    if(IsPowerOfTwo(pm-&gt;width) &amp;&amp; IsPowerOfTwo(pm-&gt;height)) {
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    } else {
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    }

    GLenum format = 0;
    switch(pm-&gt;format) {
        case Pixmap::Format::RGBA: format = GL_RGBA;  break;
        case Pixmap::Format::RGB:  format = GL_RGB;   break;
#if defined(HAVE_GLES)
        case Pixmap::Format::A:    format = GL_ALPHA; break;
#else
        case Pixmap::Format::A:    format = GL_RED;   break;
#endif
        case Pixmap::Format::BGRA:
        case Pixmap::Format::BGR:
            ssassert(false, "Unexpected pixmap format");
    }
    glTexImage2D(GL_TEXTURE_2D, 0, format, pm-&gt;width, pm-&gt;height, 0,
                 format, GL_UNSIGNED_BYTE, &amp;pm-&gt;data[0]);
}

</t>
<t tx="leo.20191228122650.209">void OpenGl3Renderer::SelectTexture(std::shared_ptr&lt;const Pixmap&gt; pm) {
    if(current.texture.lock() == pm) return;

    GLuint id;
    if(!pixmapCache.Lookup(pm, &amp;id)) {
        InvalidatePixmap(pm);
    }

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, id);
    current.texture = pm;
}

</t>
<t tx="leo.20191228122650.21">void Shader::SetUniformColor(const char *name, RgbaColor c) {
    Enable();
    glUniform4f(glGetUniformLocation(program, name), c.redF(), c.greenF(), c.blueF(), c.alphaF());
}

</t>
<t tx="leo.20191228122650.210">void OpenGl3Renderer::DoLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    SEdgeListItem *eli = lines.FindByIdNoOops(hcs);
    if(eli == NULL) {
        SEdgeListItem item = {};
        item.h = hcs;
        lines.Add(&amp;item);
        eli = lines.FindByIdNoOops(hcs);
    }

    eli-&gt;lines.AddEdge(a, b);
}

</t>
<t tx="leo.20191228122650.211">void OpenGl3Renderer::DoPoint(Vector p, hStroke hs) {
    SPointListItem *pli = points.FindByIdNoOops(hs);
    if(pli == NULL) {
        SPointListItem item = {};
        item.h = hs;
        points.Add(&amp;item);
        pli = points.FindByIdNoOops(hs);
    }

    pli-&gt;points.AddPoint(p);
}

</t>
<t tx="leo.20191228122650.212">void OpenGl3Renderer::DoStippledLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    Stroke *stroke = strokes.FindById(hcs);
    if(stroke-&gt;stipplePattern != StipplePattern::FREEHAND &amp;&amp;
       stroke-&gt;stipplePattern != StipplePattern::ZIGZAG)
    {
        DoLine(a, b, hcs);
        return;
    }

    const char *patternSeq = NULL;
    Stroke s = *stroke;
    s.stipplePattern = StipplePattern::CONTINUOUS;
    hcs = GetStroke(s);
    switch(stroke-&gt;stipplePattern) {
        case StipplePattern::CONTINUOUS:    DoLine(a, b, hcs);  return;
        case StipplePattern::SHORT_DASH:    patternSeq = "-  "; break;
        case StipplePattern::DASH:          patternSeq = "- ";  break;
        case StipplePattern::LONG_DASH:     patternSeq = "_ ";  break;
        case StipplePattern::DASH_DOT:      patternSeq = "-.";  break;
        case StipplePattern::DASH_DOT_DOT:  patternSeq = "-.."; break;
        case StipplePattern::DOT:           patternSeq = ".";   break;
        case StipplePattern::FREEHAND:      patternSeq = "~";   break;
        case StipplePattern::ZIGZAG:        patternSeq = "~__"; break;
    }

    Vector dir = b.Minus(a);
    double len = dir.Magnitude();
    dir = dir.WithMagnitude(1.0);

    const char *si = patternSeq;
    double end = len;
    double ss = stroke-&gt;stippleScale / 2.0;
    do {
        double start = end;
        switch(*si) {
            case ' ':
                end -= 1.0 * ss;
                break;

            case '-':
                start = max(start - 0.5 * ss, 0.0);
                end = max(start - 2.0 * ss, 0.0);
                if(start == end) break;
                DoLine(a.Plus(dir.ScaledBy(start)), a.Plus(dir.ScaledBy(end)), hcs);
                end = max(end - 0.5 * ss, 0.0);
                break;

            case '_':
                end = max(end - 4.0 * ss, 0.0);
                DoLine(a.Plus(dir.ScaledBy(start)), a.Plus(dir.ScaledBy(end)), hcs);
                break;

            case '.':
                end = max(end - 0.5 * ss, 0.0);
                if(end == 0.0) break;
                DoPoint(a.Plus(dir.ScaledBy(end)), hcs);
                end = max(end - 0.5 * ss, 0.0);
                break;

            case '~': {
                Vector ab  = b.Minus(a);
                Vector gn = (camera.projRight).Cross(camera.projUp);
                Vector abn = (ab.Cross(gn)).WithMagnitude(1);
                abn = abn.Minus(gn.ScaledBy(gn.Dot(abn)));
                double pws = 2.0 * stroke-&gt;width / camera.scale;

                end = max(end - 0.5 * ss, 0.0);
                Vector aa = a.Plus(dir.ScaledBy(start));
                Vector bb = a.Plus(dir.ScaledBy(end))
                             .Plus(abn.ScaledBy(pws * (start - end) / (0.5 * ss)));
                DoLine(aa, bb, hcs);
                if(end == 0.0) break;

                start = end;
                end = max(end - 1.0 * ss, 0.0);
                aa = a.Plus(dir.ScaledBy(end))
                      .Plus(abn.ScaledBy(pws))
                      .Minus(abn.ScaledBy(2.0 * pws * (start - end) / ss));
                DoLine(bb, aa, hcs);
                if(end == 0.0) break;

                start = end;
                end = max(end - 0.5 * ss, 0.0);
                bb = a.Plus(dir.ScaledBy(end))
                      .Minus(abn.ScaledBy(pws))
                      .Plus(abn.ScaledBy(pws * (start - end) / (0.5 * ss)));
                DoLine(aa, bb, hcs);
                break;
            }

            default: ssassert(false, "Unexpected stipple pattern element");
        }
        if(*(++si) == 0) si = patternSeq;
    } while(end &gt; 0.0);
}

//-----------------------------------------------------------------------------
// A canvas implemented using OpenGL 3 vertex buffer objects.
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.213">void OpenGl3Renderer::Init() {
    atlas.Init();
    edgeRenderer.Init(&amp;atlas);
    outlineRenderer.Init(&amp;atlas);
    meshRenderer.Init();
    imeshRenderer.Init();

    vendor   = (const char *)glGetString(GL_VENDOR);
    renderer = (const char *)glGetString(GL_RENDERER);
    version  = (const char *)glGetString(GL_VERSION);

#if !defined(HAVE_GLES) &amp;&amp; !defined(__APPLE__)
    GLuint array;
    glGenVertexArrays(1, &amp;array);
    glBindVertexArray(array);
#endif
    UpdateProjection();
}

</t>
<t tx="leo.20191228122650.214">void OpenGl3Renderer::DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    DoStippledLine(a, b, hcs);
}

</t>
<t tx="leo.20191228122650.215">void OpenGl3Renderer::DrawEdges(const SEdgeList &amp;el, hStroke hcs) {
    for(const SEdge &amp;e : el.l) {
        DoStippledLine(e.a, e.b, hcs);
    }
}

</t>
<t tx="leo.20191228122650.216">void OpenGl3Renderer::DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs mode) {
    if(ol.l.IsEmpty())
        return;

    Stroke *stroke = SelectStroke(hcs);
    ssassert(stroke-&gt;stipplePattern != StipplePattern::ZIGZAG &amp;&amp;
             stroke-&gt;stipplePattern != StipplePattern::FREEHAND,
             "ZIGZAG and FREEHAND not supported for outlines");

    outlineRenderer.SetStroke(*stroke, 1.0 / camera.scale);
    outlineRenderer.Draw(ol, mode);
}

</t>
<t tx="leo.20191228122650.217">void OpenGl3Renderer::DrawVectorText(const std::string &amp;text, double height,
                                     const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                                     hStroke hcs) {
    SEdgeListItem *eli = lines.FindByIdNoOops(hcs);
    if(eli == NULL) {
        SEdgeListItem item = {};
        item.h = hcs;
        lines.Add(&amp;item);
        eli = lines.FindByIdNoOops(hcs);
    }
    SEdgeList &amp;lines = eli-&gt;lines;
    auto traceEdge = [&amp;](Vector a, Vector b) { lines.AddEdge(a, b); };
    VectorFont::Builtin()-&gt;Trace(height, o, u, v, text, traceEdge, camera);
}

</t>
<t tx="leo.20191228122650.218">void OpenGl3Renderer::DrawQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d,
                               hFill hcf) {
    SMeshListItem *li = meshes.FindByIdNoOops(hcf);
    if(li == NULL) {
        SMeshListItem item = {};
        item.h = hcf;
        meshes.Add(&amp;item);
        li = meshes.FindByIdNoOops(hcf);
    }
    li-&gt;mesh.AddQuad(a, b, c, d);
}

</t>
<t tx="leo.20191228122650.219">void OpenGl3Renderer::DrawPoint(const Vector &amp;o, hStroke hs) {
    DoPoint(o, hs);
}

</t>
<t tx="leo.20191228122650.22">void Shader::SetUniformFloat(const char *name, float v) {
    Enable();
    glUniform1f(glGetUniformLocation(program, name), v);
}

</t>
<t tx="leo.20191228122650.220">void OpenGl3Renderer::DrawPolygon(const SPolygon &amp;p, hFill hcf) {
    Fill *fill = SelectFill(hcf);

    SMesh m = {};
    p.TriangulateInto(&amp;m);
    meshRenderer.UseFilled(*fill);
    meshRenderer.Draw(m);
    m.Clear();
}

</t>
<t tx="leo.20191228122650.221">void OpenGl3Renderer::DrawMesh(const SMesh &amp;m, hFill hcfFront, hFill hcfBack) {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo.20191228122650.222">void OpenGl3Renderer::DrawFaces(const SMesh &amp;m, const std::vector&lt;uint32_t&gt; &amp;faces, hFill hcf) {
    if(faces.empty()) return;

    Fill *fill = SelectFill(hcf);

    SMesh facesMesh = {};
    for(uint32_t f : faces) {
        for(const STriangle &amp;t : m.l) {
            if(f != t.meta.face) continue;
            facesMesh.l.Add(&amp;t);
        }
    }

    meshRenderer.UseFilled(*fill);
    meshRenderer.Draw(facesMesh);
    facesMesh.Clear();
}

</t>
<t tx="leo.20191228122650.223">void OpenGl3Renderer::DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
                                 const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                                 const Point2d &amp;ta, const Point2d &amp;tb, hFill hcf) {
    Fill fill = *fills.FindById(hcf);
    fill.texture = pm;
    hcf = GetFill(fill);

    SMeshListItem *mli = meshes.FindByIdNoOops(hcf);
    if(mli == NULL) {
        SMeshListItem item = {};
        item.h = hcf;
        meshes.Add(&amp;item);
        mli = meshes.FindByIdNoOops(hcf);
    }

    mli-&gt;mesh.AddPixmap(o, u, v, ta, tb);
}

</t>
<t tx="leo.20191228122650.224">void OpenGl3Renderer::UpdateProjection() {
    glViewport(0, 0,
               (int)(camera.width  * camera.pixelRatio),
               (int)(camera.height * camera.pixelRatio));

    double mat1[16];
    double mat2[16];

    double sx = camera.scale * 2.0 / camera.width;
    double sy = camera.scale * 2.0 / camera.height;
    double sz = camera.scale * 1.0 / 30000;

    MakeMatrix(mat1,
       sx,   0,   0,   0,
        0,  sy,   0,   0,
        0,   0,  sz,   0,
        0,   0,   0,   1
    );

    // Last thing before display is to apply the perspective
    double clp = camera.tangent * camera.scale;
    MakeMatrix(mat2,
        1,   0,   0,   0,
        0,   1,   0,   0,
        0,   0,   1,   0,
        0,   0,   clp, 1
    );

    double projection[16];
    MultMatrix(mat1, mat2, projection);

    // Before that, we apply the rotation
    Vector u = camera.projRight,
           v = camera.projUp,
           n = camera.projUp.Cross(camera.projRight);
    MakeMatrix(mat1,
        u.x, u.y, u.z,   0,
        v.x, v.y, v.z,   0,
        n.x, n.y, n.z,   0,
          0,   0,   0,   1
    );

    // And before that, the translation
    Vector o = camera.offset;
    MakeMatrix(mat2,
        1, 0, 0, o.x,
        0, 1, 0, o.y,
        0, 0, 1, o.z,
        0, 0, 0,   1
    );

    double modelview[16];
    MultMatrix(mat1, mat2, modelview);

    imeshRenderer.SetProjection(projection);
    imeshRenderer.SetModelview(modelview);
    meshRenderer.SetProjection(projection);
    meshRenderer.SetModelview(modelview);
    edgeRenderer.SetProjection(projection);
    edgeRenderer.SetModelview(modelview);
    outlineRenderer.SetProjection(projection);
    outlineRenderer.SetModelview(modelview);

    glClearDepthf(1.0f);
    glClear(GL_DEPTH_BUFFER_BIT);
}

</t>
<t tx="leo.20191228122650.225">void OpenGl3Renderer::StartFrame() {
    if(!initialized) {
        Init();
        initialized = true;
    }

    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_BLEND);

    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    RgbaColor backgroundColor = lighting.backgroundColor;
    glClearColor(backgroundColor.redF(),  backgroundColor.greenF(),
                 backgroundColor.blueF(), backgroundColor.alphaF());
    glClearDepthf(1.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glFrontFace(GL_CW);
}

</t>
<t tx="leo.20191228122650.226">void OpenGl3Renderer::FlushFrame() {
    for(SMeshListItem &amp;li : meshes) {
        Fill *fill = SelectFill(li.h);

        imeshRenderer.UseFilled(*fill);
        imeshRenderer.Draw(li.mesh);
        li.mesh.Clear();
    }
    meshes.Clear();

    for(SEdgeListItem &amp;eli : lines) {
        Stroke *stroke = SelectStroke(eli.h);

        edgeRenderer.SetStroke(*stroke, 1.0 / camera.scale);
        edgeRenderer.Draw(eli.lines);
        eli.lines.Clear();
    }
    lines.Clear();

    for(SPointListItem &amp;li : points) {
        Stroke *stroke = SelectStroke(li.h);

        imeshRenderer.UsePoint(*stroke, 1.0 / camera.scale);
        imeshRenderer.Draw(li.points);
        li.points.Clear();
    }
    points.Clear();

    glFlush();
}

</t>
<t tx="leo.20191228122650.227">void OpenGl3Renderer::FinishFrame() {
    glFinish();

    GLenum error = glGetError();
    if(error != GL_NO_ERROR) {
        dbp("glGetError() == 0x%X", error);
    }
}

</t>
<t tx="leo.20191228122650.228">void OpenGl3Renderer::Clear() {
    ViewportCanvas::Clear();
    pixmapCache.CleanupUnused();
}

std::shared_ptr&lt;Pixmap&gt; OpenGl3Renderer::ReadFrame() {
    int width  = camera.width  * camera.pixelRatio;
    int height = camera.height * camera.pixelRatio;
    std::shared_ptr&lt;Pixmap&gt; pixmap =
        Pixmap::Create(Pixmap::Format::RGBA, (size_t)width, (size_t)height);
    glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, &amp;pixmap-&gt;data[0]);
    ssassert(glGetError() == GL_NO_ERROR, "Unexpected glReadPixels error");
    return pixmap;
}

</t>
<t tx="leo.20191228122650.229">void OpenGl3Renderer::GetIdent(const char **vendor, const char **renderer, const char **version) {
    *vendor   = this-&gt;vendor;
    *renderer = this-&gt;renderer;
    *version  = this-&gt;version;
}

</t>
<t tx="leo.20191228122650.23">void Shader::SetUniformInt(const char *name, GLint v) {
    Enable();
    glUniform1i(glGetUniformLocation(program, name), v);
}

</t>
<t tx="leo.20191228122650.230">void OpenGl3Renderer::SetCamera(const Camera &amp;c) {
    camera = c;
    if(initialized) {
        UpdateProjection();
    }
}

</t>
<t tx="leo.20191228122650.231">void OpenGl3Renderer::SetLighting(const Lighting &amp;l) {
    lighting = l;
}

//-----------------------------------------------------------------------------
// A batch canvas implemented using OpenGL 3 vertex buffer objects.
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.232">class DrawCall {
public:
    virtual Canvas::Layer GetLayer() const = 0;
    virtual int GetZIndex() const = 0;

    virtual void Draw(OpenGl3Renderer *renderer) = 0;
    virtual void Remove(OpenGl3Renderer *renderer) = 0;
};

</t>
<t tx="leo.20191228122650.233">class EdgeDrawCall final : public DrawCall {
public:
    // Key
    Canvas::Stroke              stroke;
    // Data
    EdgeRenderer::Handle        handle;

    Canvas::Layer GetLayer() const override { return stroke.layer; }
    int GetZIndex() const override { return stroke.zIndex; }

    @others
};

</t>
<t tx="leo.20191228122650.234">static std::shared_ptr&lt;DrawCall&gt; Create(OpenGl3Renderer *renderer, const SEdgeList &amp;el,
                                        Canvas::Stroke *stroke) {
    EdgeDrawCall *dc = new EdgeDrawCall();
    dc-&gt;stroke = *stroke;
    dc-&gt;handle = renderer-&gt;edgeRenderer.Add(el);
    return std::shared_ptr&lt;DrawCall&gt;(dc);
}

</t>
<t tx="leo.20191228122650.235">void Draw(OpenGl3Renderer *renderer) override {
    ssglDepthRange(stroke.layer, stroke.zIndex);
    renderer-&gt;edgeRenderer.SetStroke(stroke, 1.0 / renderer-&gt;camera.scale);
    renderer-&gt;edgeRenderer.Draw(handle);
}

</t>
<t tx="leo.20191228122650.236">void Remove(OpenGl3Renderer *renderer) override {
    renderer-&gt;edgeRenderer.Remove(handle);
}
</t>
<t tx="leo.20191228122650.237">class OutlineDrawCall final : public DrawCall {
public:
    // Key
    Canvas::Stroke              stroke;
    // Data
    OutlineRenderer::Handle     handle;
    Canvas::DrawOutlinesAs      drawAs;

    Canvas::Layer GetLayer() const override { return stroke.layer; }
    int GetZIndex() const override { return stroke.zIndex; }

    @others
};

</t>
<t tx="leo.20191228122650.238">static std::shared_ptr&lt;DrawCall&gt; Create(OpenGl3Renderer *renderer, const SOutlineList &amp;ol,
                                        Canvas::Stroke *stroke,
                                        Canvas::DrawOutlinesAs drawAs) {
    OutlineDrawCall *dc = new OutlineDrawCall();
    dc-&gt;stroke = *stroke;
    dc-&gt;handle = renderer-&gt;outlineRenderer.Add(ol);
    dc-&gt;drawAs = drawAs;
    return std::shared_ptr&lt;DrawCall&gt;(dc);
}

</t>
<t tx="leo.20191228122650.239">void Draw(OpenGl3Renderer *renderer) override {
    ssglDepthRange(stroke.layer, stroke.zIndex);
    renderer-&gt;outlineRenderer.SetStroke(stroke, 1.0 / renderer-&gt;camera.scale);
    renderer-&gt;outlineRenderer.Draw(handle, drawAs);
}

</t>
<t tx="leo.20191228122650.24">void Shader::SetUniformTextureUnit(const char *name, GLint index) {
    Enable();
    glUniform1i(glGetUniformLocation(program, name), index);
}

</t>
<t tx="leo.20191228122650.240">void Remove(OpenGl3Renderer *renderer) override {
    renderer-&gt;outlineRenderer.Remove(handle);
}
</t>
<t tx="leo.20191228122650.241">class PointDrawCall final : public DrawCall {
public:
    // Key
    Canvas::Stroke               stroke;
    // Data
    IndexedMeshRenderer::Handle  handle;

    Canvas::Layer GetLayer() const override { return stroke.layer; }
    int GetZIndex() const override { return stroke.zIndex; }

    @others
};

</t>
<t tx="leo.20191228122650.242">static std::shared_ptr&lt;DrawCall&gt; Create(OpenGl3Renderer *renderer, const SIndexedMesh &amp;mesh,
                                        Canvas::Stroke *stroke) {
    PointDrawCall *dc = new PointDrawCall();
    dc-&gt;stroke = *stroke;
    dc-&gt;handle = renderer-&gt;imeshRenderer.Add(mesh);
    return std::shared_ptr&lt;DrawCall&gt;(dc);
}

</t>
<t tx="leo.20191228122650.243">void Draw(OpenGl3Renderer *renderer) override {
    ssglDepthRange(stroke.layer, stroke.zIndex);
    renderer-&gt;imeshRenderer.UsePoint(stroke, 1.0 / renderer-&gt;camera.scale);
    renderer-&gt;imeshRenderer.Draw(handle);
}

</t>
<t tx="leo.20191228122650.244">void Remove(OpenGl3Renderer *renderer) override {
    renderer-&gt;imeshRenderer.Remove(handle);
}
</t>
<t tx="leo.20191228122650.245">class PixmapDrawCall final : public DrawCall {
public:
    // Key
    Canvas::Fill                 fill;
    // Data
    IndexedMeshRenderer::Handle  handle;

    Canvas::Layer GetLayer() const override { return fill.layer; }
    int GetZIndex() const override { return fill.zIndex; }

    @others
};

</t>
<t tx="leo.20191228122650.246">static std::shared_ptr&lt;DrawCall&gt; Create(OpenGl3Renderer *renderer, const SIndexedMesh &amp;mesh,
                                        Canvas::Fill *fill) {
    PixmapDrawCall *dc = new PixmapDrawCall();
    dc-&gt;fill   = *fill;
    dc-&gt;handle = renderer-&gt;imeshRenderer.Add(mesh);
    return std::shared_ptr&lt;DrawCall&gt;(dc);
}

</t>
<t tx="leo.20191228122650.247">void Draw(OpenGl3Renderer *renderer) override {
    ssglDepthRange(fill.layer, fill.zIndex);
    if(fill.pattern != Canvas::FillPattern::SOLID) {
        renderer-&gt;SelectMask(fill.pattern);
    } else if(fill.texture) {
        renderer-&gt;SelectTexture(fill.texture);
    } else {
        renderer-&gt;SelectMask(Canvas::FillPattern::SOLID);
    }
    renderer-&gt;imeshRenderer.UseFilled(fill);
    renderer-&gt;imeshRenderer.Draw(handle);
}

</t>
<t tx="leo.20191228122650.248">void Remove(OpenGl3Renderer *renderer) override {
    renderer-&gt;imeshRenderer.Remove(handle);
}
</t>
<t tx="leo.20191228122650.249">class MeshDrawCall final : public DrawCall {
public:
    // Key
    Canvas::Fill            fillFront;
    // Data
    MeshRenderer::Handle    handle;
    Canvas::Fill            fillBack;
    bool                    hasFillBack;
    bool                    isShaded;

    Canvas::Layer GetLayer() const override { return fillFront.layer; }
    int GetZIndex() const override { return fillFront.zIndex; }

    @others
};

struct CompareDrawCall {
</t>
<t tx="leo.20191228122650.25">void Shader::Enable() const {
    glUseProgram(program);
}

</t>
<t tx="leo.20191228122650.250">static std::shared_ptr&lt;DrawCall&gt; Create(OpenGl3Renderer *renderer, const SMesh &amp;m,
                                        Canvas::Fill *fillFront, Canvas::Fill *fillBack = NULL,
                                        bool isShaded = false) {
    MeshDrawCall *dc = new MeshDrawCall();
    dc-&gt;fillFront       = *fillFront;
    dc-&gt;handle          = renderer-&gt;meshRenderer.Add(m);
    dc-&gt;fillBack        = *fillBack;
    dc-&gt;isShaded        = isShaded;
    dc-&gt;hasFillBack     = (fillBack != NULL);
    return std::shared_ptr&lt;DrawCall&gt;(dc);
}

</t>
<t tx="leo.20191228122650.251">void DrawFace(OpenGl3Renderer *renderer, GLenum cullFace, const Canvas::Fill &amp;fill) {
    glCullFace(cullFace);
    ssglDepthRange(fill.layer, fill.zIndex);
    if(fill.pattern != Canvas::FillPattern::SOLID) {
        renderer-&gt;SelectMask(fill.pattern);
    } else if(fill.texture) {
        renderer-&gt;SelectTexture(fill.texture);
    } else {
        renderer-&gt;SelectMask(Canvas::FillPattern::SOLID);
    }
    if(isShaded) {
        renderer-&gt;meshRenderer.UseShaded(renderer-&gt;lighting);
    } else {
        renderer-&gt;meshRenderer.UseFilled(fill);
    }
    renderer-&gt;meshRenderer.Draw(handle, /*useColors=*/fill.color.IsEmpty(), fill.color);
}

</t>
<t tx="leo.20191228122650.26">void Shader::Disable() const {
    glUseProgram(0);
}

//-----------------------------------------------------------------------------
// Mesh rendering
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.27">void MeshRenderer::Init() {
    lightShader.Init(
        "shaders/mesh.vert", "shaders/mesh.frag",
        {
            { ATTRIB_POS, "pos" },
            { ATTRIB_NOR, "nor" },
            { ATTRIB_COL, "col" },
        }
    );

    fillShader.Init(
        "shaders/mesh_fill.vert", "shaders/mesh_fill.frag",
        {
            { ATTRIB_POS, "pos" },
        }
    );
    fillShader.SetUniformTextureUnit("texture_", 0);

    selectedShader = &amp;lightShader;
}

</t>
<t tx="leo.20191228122650.28">void MeshRenderer::Clear() {
    lightShader.Clear();
    fillShader.Clear();
}

MeshRenderer::Handle MeshRenderer::Add(const SMesh &amp;m, bool dynamic) {
    Handle handle;
    glGenBuffers(1, &amp;handle.vertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);

    MeshVertex *vertices = new MeshVertex[m.l.n * 3];
    for(int i = 0; i &lt; m.l.n; i++) {
        const STriangle &amp;t = m.l[i];
        vertices[i * 3 + 0].pos = Vector3f::From(t.a);
        vertices[i * 3 + 1].pos = Vector3f::From(t.b);
        vertices[i * 3 + 2].pos = Vector3f::From(t.c);

        if(t.an.EqualsExactly(Vector::From(0, 0, 0))) {
            Vector3f normal = Vector3f::From(t.Normal());
            vertices[i * 3 + 0].nor = normal;
            vertices[i * 3 + 1].nor = normal;
            vertices[i * 3 + 2].nor = normal;
        } else {
            vertices[i * 3 + 0].nor = Vector3f::From(t.an);
            vertices[i * 3 + 1].nor = Vector3f::From(t.bn);
            vertices[i * 3 + 2].nor = Vector3f::From(t.cn);
        }

        for(int j = 0; j &lt; 3; j++) {
            vertices[i * 3 + j].col = Vector4f::From(t.meta.color);
        }

    }
    glBufferData(GL_ARRAY_BUFFER, m.l.n * 3 * sizeof(MeshVertex),
                 vertices, dynamic ? GL_DYNAMIC_DRAW : GL_STATIC_DRAW);
    handle.size = m.l.n * 3;
    delete []vertices;

    return handle;
}

</t>
<t tx="leo.20191228122650.29">void MeshRenderer::Remove(const MeshRenderer::Handle &amp;handle) {
    glDeleteBuffers(1, &amp;handle.vertexBuffer);
}

</t>
<t tx="leo.20191228122650.3">void FreeAllTemporary() {
    AllocTempHeader *h = Head;
    while(h) {
        AllocTempHeader *f = h;
        h = h-&gt;next;
        free(f);
    }
    Head = NULL;
}

</t>
<t tx="leo.20191228122650.30">void MeshRenderer::Draw(const MeshRenderer::Handle &amp;handle,
                        bool useColors, RgbaColor overrideColor) {
    if(handle.size == 0) return;

    selectedShader-&gt;Enable();

    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);

    glEnableVertexAttribArray(ATTRIB_POS);
    glVertexAttribPointer(ATTRIB_POS, 3, GL_FLOAT, GL_FALSE, sizeof(MeshVertex),
                          (void *)offsetof(MeshVertex, pos));

    if(selectedShader == &amp;lightShader) {
        glEnableVertexAttribArray(ATTRIB_NOR);
        glVertexAttribPointer(ATTRIB_NOR, 3, GL_FLOAT, GL_FALSE, sizeof(MeshVertex),
                              (void *)offsetof(MeshVertex, nor));
        if(useColors) {
            glEnableVertexAttribArray(ATTRIB_COL);
            glVertexAttribPointer(ATTRIB_COL, 4, GL_FLOAT, GL_FALSE, sizeof(MeshVertex),
                                  (void *)offsetof(MeshVertex, col));
        } else {
            glVertexAttrib4f(ATTRIB_COL, overrideColor.redF(), overrideColor.greenF(), overrideColor.blueF(), overrideColor.alphaF());
        }
    }

    glDrawArrays(GL_TRIANGLES, 0, handle.size);

    glDisableVertexAttribArray(ATTRIB_POS);
    if(selectedShader == &amp;lightShader) {
        glDisableVertexAttribArray(ATTRIB_NOR);
        if(useColors) glDisableVertexAttribArray(ATTRIB_COL);
    }

    glBindBuffer(GL_ARRAY_BUFFER, 0);

    selectedShader-&gt;Disable();
}

</t>
<t tx="leo.20191228122650.31">void MeshRenderer::Draw(const SMesh &amp;mesh, bool useColors, RgbaColor overrideColor) {
    Handle handle = Add(mesh, /*dynamic=*/true);
    Draw(handle, useColors, overrideColor);
    Remove(handle);
}

</t>
<t tx="leo.20191228122650.32">void MeshRenderer::SetModelview(double *matrix) {
    lightShader.SetUniformMatrix("modelview", matrix);
    fillShader.SetUniformMatrix("modelview", matrix);
}

</t>
<t tx="leo.20191228122650.33">void MeshRenderer::SetProjection(double *matrix) {
    lightShader.SetUniformMatrix("projection", matrix);
    fillShader.SetUniformMatrix("projection", matrix);
}

</t>
<t tx="leo.20191228122650.34">void MeshRenderer::UseShaded(const Lighting &amp;lighting) {
    Vector dir0 = lighting.lightDirection[0];
    Vector dir1 = lighting.lightDirection[1];
    dir0.z = -dir0.z;
    dir1.z = -dir1.z;

    lightShader.SetUniformVector("lightDir0", dir0);
    lightShader.SetUniformFloat("lightInt0", (float)lighting.lightIntensity[0]);
    lightShader.SetUniformVector("lightDir1", dir1);
    lightShader.SetUniformFloat("lightInt1", (float)lighting.lightIntensity[1]);
    lightShader.SetUniformFloat("ambient", (float)lighting.ambientIntensity);
    selectedShader = &amp;lightShader;
}

</t>
<t tx="leo.20191228122650.35">void MeshRenderer::UseFilled(const Canvas::Fill &amp;fill) {
    fillShader.SetUniformColor("color", fill.color);
    selectedShader = &amp;fillShader;
}

//-----------------------------------------------------------------------------
// Arrangement of stipple patterns into textures
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.36">static double Frac(double x) {
    return x - floor(x);
}

</t>
<t tx="leo.20191228122650.37">static RgbaColor EncodeLengthAsFloat(double v) {
    v = max(0.0, min(1.0, v));
    double er = v;
    double eg = Frac(255.0 * v);
    double eb = Frac(65025.0 * v);
    double ea = Frac(160581375.0 * v);

    double r = er - eg / 255.0;
    double g = eg - eb / 255.0;
    double b = eb - ea / 255.0;
    return RgbaColor::From((int)floor( r * 255.0 + 0.5),
                           (int)floor( g * 255.0 + 0.5),
                           (int)floor( b * 255.0 + 0.5),
                           (int)floor(ea * 255.0 + 0.5));
}

GLuint Generate(const std::vector&lt;double&gt; &amp;pattern) {
    double patternLen = 0.0;
    for(double s : pattern) {
        patternLen += s;
    }

    GLuint texture;
    glGenTextures(1, &amp;texture);
    glBindTexture(GL_TEXTURE_2D, texture);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);

    GLint size;
    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;size);
    size /= 2;

    RgbaColor *textureData = new RgbaColor[size];
    int mipCount = (int)log2(size) + 1;
    for(int mip = 0; mip &lt; mipCount; mip++) {
        int dashI = 0;
        double dashT = 0.0;
        for(int i = 0; i &lt; size; i++) {
            if(pattern.empty()) {
                textureData[i] = EncodeLengthAsFloat(0.0);
                continue;
            }

            double t = (double)i / (double)(size - 1);
            while(t - LENGTH_EPS &gt; dashT + pattern[dashI] / patternLen) {
                dashT += pattern[dashI] / patternLen;
                dashI++;
            }
            double dashW = pattern[dashI] / patternLen;
            if(dashI % 2 == 0) {
                textureData[i] = EncodeLengthAsFloat(0.0);
            } else {
                double value;
                if(t - dashT &lt; pattern[dashI] / patternLen / 2.0) {
                    value = t - dashT;
                } else {
                    value = dashT + dashW - t;
                }
                value = value * patternLen;
                textureData[i] = EncodeLengthAsFloat(value);
            }
        }
        glTexImage2D(GL_TEXTURE_2D, mip, GL_RGBA, size, 1, 0, GL_RGBA, GL_UNSIGNED_BYTE,
                     textureData);
        size /= 2;
    }
    delete []textureData;

    return texture;
}

</t>
<t tx="leo.20191228122650.38">void StippleAtlas::Init() {
    for(uint32_t i = 0; i &lt;= (uint32_t)StipplePattern::LAST; i++) {
        patterns.push_back(Generate(StipplePatternDashes((StipplePattern)i)));
    }
}

</t>
<t tx="leo.20191228122650.39">void StippleAtlas::Clear() {
    for(GLuint p : patterns) {
        glDeleteTextures(1, &amp;p);
    }
}

GLint StippleAtlas::GetTexture(StipplePattern pattern) const {
    return patterns[(uint32_t)pattern];
}

double StippleAtlas::GetLength(StipplePattern pattern) const {
    if(pattern == StipplePattern::CONTINUOUS) {
        return 1.0;
    }
    return StipplePatternLength(pattern);
}

//-----------------------------------------------------------------------------
// Edge rendering
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.4">void *MemAlloc(size_t n) {
    void *p = malloc(n);
    ssassert(p != NULL, "Cannot allocate memory");
    return p;
}

</t>
<t tx="leo.20191228122650.40">void EdgeRenderer::Init(const StippleAtlas *a) {
    atlas = a;
    shader.Init(
        "shaders/edge.vert", "shaders/edge.frag",
        {
            { ATTRIB_POS, "pos" },
            { ATTRIB_LOC, "loc" },
            { ATTRIB_TAN, "tgt" }
        }
    );
}

</t>
<t tx="leo.20191228122650.41">void EdgeRenderer::Clear() {
    shader.Clear();
}

EdgeRenderer::Handle EdgeRenderer::Add(const SEdgeList &amp;edges, bool dynamic) {
    Handle handle;
    glGenBuffers(1, &amp;handle.vertexBuffer);
    glGenBuffers(1, &amp;handle.indexBuffer);

    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle.indexBuffer);

    EdgeVertex *vertices = new EdgeVertex[edges.l.n * 8];
    uint32_t *indices = new uint32_t[edges.l.n * 6 * 3];
    double phase = 0.0;
    uint32_t curVertex = 0;
    uint32_t curIndex = 0;
    for(int i = 0; i &lt; edges.l.n; i++) {
        const SEdge &amp;curr = edges.l[i];
        const SEdge &amp;next = edges.l[(i + 1) % edges.l.n];

        // 3d positions
        Vector3f a = Vector3f::From(curr.a);
        Vector3f b = Vector3f::From(curr.b);

        // tangent
        Vector3f tan = Vector3f::From(curr.b.Minus(curr.a));

        // length
        double len = curr.b.Minus(curr.a).Magnitude();

        // make line start cap
        for(int j = 0; j &lt; 2; j++) {
            vertices[curVertex + j].pos = a;
            vertices[curVertex + j].tan = tan;
        }
        vertices[curVertex + 0].loc = Vector3f::From(-1.0f, -1.0f, float(phase));
        vertices[curVertex + 1].loc = Vector3f::From(-1.0f, +1.0f, float(phase));

        indices[curIndex++] = curVertex + 0;
        indices[curIndex++] = curVertex + 1;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 1;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 3;

        curVertex += 2;

        // make line body
        vertices[curVertex +  0].pos = a;
        vertices[curVertex +  1].pos = a;
        vertices[curVertex +  2].pos = b;
        vertices[curVertex +  3].pos = b;

        for(int j = 0; j &lt; 4; j++) {
            vertices[curVertex + j].tan = tan;
        }

        vertices[curVertex +  0].loc = Vector3f::From( 0.0f, -1.0f, float(phase));
        vertices[curVertex +  1].loc = Vector3f::From( 0.0f, +1.0f, float(phase));
        vertices[curVertex +  2].loc = Vector3f::From( 0.0f, +1.0f, float(phase + len));
        vertices[curVertex +  3].loc = Vector3f::From( 0.0f, -1.0f, float(phase + len));

        indices[curIndex++] = curVertex + 0;
        indices[curIndex++] = curVertex + 1;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 0;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 3;

        curVertex += 4;

        // make line end cap
        for(int j = 0; j &lt; 2; j++) {
            vertices[curVertex + j].pos = b;
            vertices[curVertex + j].tan = tan;
        }

        vertices[curVertex + 0].loc = Vector3f::From(+1.0, +1.0, float(phase + len));
        vertices[curVertex + 1].loc = Vector3f::From(+1.0, -1.0, float(phase + len));

        indices[curIndex++] = curVertex - 2;
        indices[curIndex++] = curVertex - 1;
        indices[curIndex++] = curVertex;
        indices[curIndex++] = curVertex - 1;
        indices[curIndex++] = curVertex;
        indices[curIndex++] = curVertex + 1;

        curVertex += 2;

        // phase stitching
        if(curr.a.EqualsExactly(next.a) ||
           curr.a.EqualsExactly(next.b) ||
           curr.b.EqualsExactly(next.a) ||
           curr.b.EqualsExactly(next.b))
        {
            phase += len;
        } else {
            phase = 0.0;
        }
    }
    handle.size = curIndex;
    GLenum mode = dynamic ? GL_DYNAMIC_DRAW : GL_STATIC_DRAW;
    glBufferData(GL_ARRAY_BUFFER, curVertex * sizeof(EdgeVertex), vertices, mode);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, curIndex * sizeof(uint32_t), indices, mode);
    delete []vertices;
    delete []indices;

    return handle;
}

</t>
<t tx="leo.20191228122650.42">void EdgeRenderer::Remove(const EdgeRenderer::Handle &amp;handle) {
    glDeleteBuffers(1, &amp;handle.vertexBuffer);
    glDeleteBuffers(1, &amp;handle.indexBuffer);
}

</t>
<t tx="leo.20191228122650.43">void EdgeRenderer::Draw(const EdgeRenderer::Handle &amp;handle) {
    if(handle.size == 0) return;

    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, atlas-&gt;GetTexture(pattern));
    shader.SetUniformTextureUnit("pattern", 1);
    shader.SetUniformFloat("patternLen", (float)atlas-&gt;GetLength(pattern));

    shader.Enable();

    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle.indexBuffer);

    glEnableVertexAttribArray(ATTRIB_POS);
    glEnableVertexAttribArray(ATTRIB_LOC);
    glEnableVertexAttribArray(ATTRIB_TAN);

    glVertexAttribPointer(ATTRIB_POS, 3, GL_FLOAT, GL_FALSE, sizeof(EdgeVertex), (void *)offsetof(EdgeVertex, pos));
    glVertexAttribPointer(ATTRIB_LOC, 3, GL_FLOAT, GL_FALSE, sizeof(EdgeVertex), (void *)offsetof(EdgeVertex, loc));
    glVertexAttribPointer(ATTRIB_TAN, 3, GL_FLOAT, GL_FALSE, sizeof(EdgeVertex), (void *)offsetof(EdgeVertex, tan));
    glDrawElements(GL_TRIANGLES, handle.size, GL_UNSIGNED_INT, NULL);

    glDisableVertexAttribArray(ATTRIB_POS);
    glDisableVertexAttribArray(ATTRIB_LOC);
    glDisableVertexAttribArray(ATTRIB_TAN);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

    shader.Disable();
}

</t>
<t tx="leo.20191228122650.44">void EdgeRenderer::Draw(const SEdgeList &amp;edges) {
    Handle handle = Add(edges, /*dynamic=*/true);
    Draw(handle);
    Remove(handle);
}

</t>
<t tx="leo.20191228122650.45">void EdgeRenderer::SetModelview(const double *matrix) {
    shader.SetUniformMatrix("modelview", matrix);
}

</t>
<t tx="leo.20191228122650.46">void EdgeRenderer::SetProjection(const double *matrix) {
    shader.SetUniformMatrix("projection", matrix);
}

</t>
<t tx="leo.20191228122650.47">void EdgeRenderer::SetStroke(const Canvas::Stroke &amp;stroke, double pixel) {
    double unitScale = stroke.unit == Canvas::Unit::PX ? pixel : 1.0;
    shader.SetUniformFloat("width", float(stroke.width * unitScale / 2.0));
    shader.SetUniformColor("color", stroke.color);
    shader.SetUniformFloat("patternScale", float(stroke.stippleScale * unitScale * 2.0));
    shader.SetUniformFloat("pixel", (float)pixel);
    pattern = stroke.stipplePattern;
}

//-----------------------------------------------------------------------------
// Outline rendering
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.48">void OutlineRenderer::Init(const StippleAtlas *a) {
    atlas = a;
    shader.Init(
        "shaders/outline.vert", "shaders/edge.frag",
        {
            { ATTRIB_POS, "pos" },
            { ATTRIB_LOC, "loc" },
            { ATTRIB_TAN, "tgt" },
            { ATTRIB_NOL, "nol" },
            { ATTRIB_NOR, "nor" }
        }
    );
}

</t>
<t tx="leo.20191228122650.49">void OutlineRenderer::Clear() {
    shader.Clear();
}

OutlineRenderer::Handle OutlineRenderer::Add(const SOutlineList &amp;outlines, bool dynamic) {
    Handle handle;
    glGenBuffers(1, &amp;handle.vertexBuffer);
    glGenBuffers(1, &amp;handle.indexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle.indexBuffer);

    OutlineVertex *vertices = new OutlineVertex[outlines.l.n * 8];
    uint32_t *indices = new uint32_t[outlines.l.n * 6 * 3];
    double phase = 0.0;
    uint32_t curVertex = 0;
    uint32_t curIndex = 0;

    for(int i = 0; i &lt; outlines.l.n; i++) {
        const SOutline &amp;curr = outlines.l[i];
        const SOutline &amp;next = outlines.l[(i + 1) % outlines.l.n];

        // 3d positions
        Vector3f a = Vector3f::From(curr.a);
        Vector3f b = Vector3f::From(curr.b);
        Vector3f nl = Vector3f::From(curr.nl);
        Vector3f nr = Vector3f::From(curr.nr);

        // tangent
        Vector3f tan = Vector3f::From(curr.b.Minus(curr.a));

        // length
        double len = curr.b.Minus(curr.a).Magnitude();
        float tag = (float)curr.tag;

        // make line start cap
        for(int j = 0; j &lt; 2; j++) {
            vertices[curVertex + j].pos = a;
            vertices[curVertex + j].nol = nl;
            vertices[curVertex + j].nor = nr;
            vertices[curVertex + j].tan = tan;
        }

        vertices[curVertex + 0].loc = Vector4f::From(-1.0f, -1.0f, float(phase), (float)tag);
        vertices[curVertex + 1].loc = Vector4f::From(-1.0f, +1.0f, float(phase), (float)tag);

        indices[curIndex++] = curVertex;
        indices[curIndex++] = curVertex + 1;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 1;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 3;

        curVertex += 2;

        // make line body
        vertices[curVertex +  0].pos = a;
        vertices[curVertex +  1].pos = a;
        vertices[curVertex +  2].pos = b;
        vertices[curVertex +  3].pos = b;

        for(int j = 0; j &lt; 4; j++) {
            vertices[curVertex + j].nol = nl;
            vertices[curVertex + j].nor = nr;
            vertices[curVertex + j].tan = tan;
        }

        vertices[curVertex +  0].loc = Vector4f::From( 0.0f, -1.0f, float(phase), (float)tag);
        vertices[curVertex +  1].loc = Vector4f::From( 0.0f, +1.0f, float(phase), (float)tag);
        vertices[curVertex +  2].loc = Vector4f::From( 0.0f, +1.0f,
                                                      float(phase + len), (float)tag);
        vertices[curVertex +  3].loc = Vector4f::From( 0.0f, -1.0f,
                                                      float(phase + len), (float)tag);

        indices[curIndex++] = curVertex + 0;
        indices[curIndex++] = curVertex + 1;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 0;
        indices[curIndex++] = curVertex + 2;
        indices[curIndex++] = curVertex + 3;

        curVertex += 4;

        // make line end cap
        for(int j = 0; j &lt; 2; j++) {
            vertices[curVertex + j].pos = b;
            vertices[curVertex + j].nol = nl;
            vertices[curVertex + j].nor = nr;
            vertices[curVertex + j].tan = tan;
        }

        vertices[curVertex + 0].loc = Vector4f::From(+1.0f, +1.0f, float(phase + len), (float)tag);
        vertices[curVertex + 1].loc = Vector4f::From(+1.0f, -1.0f, float(phase + len), (float)tag);

        indices[curIndex++] = curVertex - 2;
        indices[curIndex++] = curVertex - 1;
        indices[curIndex++] = curVertex;
        indices[curIndex++] = curVertex - 1;
        indices[curIndex++] = curVertex;
        indices[curIndex++] = curVertex + 1;

        curVertex += 2;

        // phase stitching
        if(curr.a.EqualsExactly(next.a) ||
           curr.a.EqualsExactly(next.b) ||
           curr.b.EqualsExactly(next.a) ||
           curr.b.EqualsExactly(next.b))
        {
            phase += len;
        } else {
            phase = 0.0;
        }
    }
    handle.size = curIndex;
    GLenum mode = dynamic ? GL_DYNAMIC_DRAW : GL_STATIC_DRAW;
    glBufferData(GL_ARRAY_BUFFER, curVertex * sizeof(OutlineVertex), vertices, mode);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, curIndex * sizeof(uint32_t), indices, mode);

    delete []vertices;
    delete []indices;
    return handle;
}

</t>
<t tx="leo.20191228122650.5">void MemFree(void *p) {
    free(p);
}

std::vector&lt;std::string&gt; InitPlatform(int argc, char **argv) {
    std::vector&lt;std::string&gt; args;
    args.reserve(argc);
    for(int i = 0; i &lt; argc; i++) {
        args.emplace_back(argv[i]);
    }
    return args;
}

};
</t>
<t tx="leo.20191228122650.50">void OutlineRenderer::Remove(const OutlineRenderer::Handle &amp;handle) {
    glDeleteBuffers(1, &amp;handle.vertexBuffer);
    glDeleteBuffers(1, &amp;handle.indexBuffer);
}

</t>
<t tx="leo.20191228122650.51">void OutlineRenderer::Draw(const OutlineRenderer::Handle &amp;handle, Canvas::DrawOutlinesAs mode) {
    if(handle.size == 0) return;

    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, atlas-&gt;GetTexture(pattern));
    shader.SetUniformTextureUnit("pattern", 1);
    shader.SetUniformFloat("patternLen", (float)atlas-&gt;GetLength(pattern));
    shader.SetUniformInt("mode", (GLint)mode);

    shader.Enable();

    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle.indexBuffer);

    glEnableVertexAttribArray(ATTRIB_POS);
    glEnableVertexAttribArray(ATTRIB_LOC);
    glEnableVertexAttribArray(ATTRIB_TAN);
    glEnableVertexAttribArray(ATTRIB_NOL);
    glEnableVertexAttribArray(ATTRIB_NOR);

    glVertexAttribPointer(ATTRIB_POS, 3, GL_FLOAT, GL_FALSE, sizeof(OutlineVertex),
                          (void *)offsetof(OutlineVertex, pos));
    glVertexAttribPointer(ATTRIB_LOC, 4, GL_FLOAT, GL_FALSE, sizeof(OutlineVertex),
                          (void *)offsetof(OutlineVertex, loc));
    glVertexAttribPointer(ATTRIB_TAN, 3, GL_FLOAT, GL_FALSE, sizeof(OutlineVertex),
                          (void *)offsetof(OutlineVertex, tan));
    glVertexAttribPointer(ATTRIB_NOL, 3, GL_FLOAT, GL_FALSE, sizeof(OutlineVertex),
                          (void *)offsetof(OutlineVertex, nol));
    glVertexAttribPointer(ATTRIB_NOR, 3, GL_FLOAT, GL_FALSE, sizeof(OutlineVertex),
                          (void *)offsetof(OutlineVertex, nor));
    glDrawElements(GL_TRIANGLES, handle.size, GL_UNSIGNED_INT, NULL);

    glDisableVertexAttribArray(ATTRIB_POS);
    glDisableVertexAttribArray(ATTRIB_LOC);
    glDisableVertexAttribArray(ATTRIB_TAN);
    glDisableVertexAttribArray(ATTRIB_NOL);
    glDisableVertexAttribArray(ATTRIB_NOR);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
    shader.Disable();
}

</t>
<t tx="leo.20191228122650.52">void OutlineRenderer::Draw(const SOutlineList &amp;outlines, Canvas::DrawOutlinesAs drawAs) {
    Handle handle = Add(outlines, /*dynamic=*/true);
    Draw(handle, drawAs);
    Remove(handle);
}

</t>
<t tx="leo.20191228122650.53">void OutlineRenderer::SetModelview(const double *matrix) {
    shader.SetUniformMatrix("modelview", matrix);
}

</t>
<t tx="leo.20191228122650.54">void OutlineRenderer::SetProjection(const double *matrix) {
    shader.SetUniformMatrix("projection", matrix);
}

</t>
<t tx="leo.20191228122650.55">void OutlineRenderer::SetStroke(const Canvas::Stroke &amp;stroke, double pixel) {
    double unitScale = (stroke.unit == Canvas::Unit::PX) ? pixel : 1.0;
    shader.SetUniformFloat("width", (float)(stroke.width * unitScale / 2.0));
    shader.SetUniformColor("color", stroke.color);
    shader.SetUniformFloat("patternScale", (float)(stroke.stippleScale * unitScale * 2.0));
    shader.SetUniformFloat("pixel", (float)pixel);
    pattern = stroke.stipplePattern;
}

//-----------------------------------------------------------------------------
// Indexed mesh storage
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.56">void SIndexedMesh::AddPoint(const Vector &amp;p) {
    uint32_t vstart = vertices.size();
    vertices.resize(vertices.size() + 4);

    vertices[vstart + 0].pos = Vector3f::From(p);
    vertices[vstart + 0].tex = Vector2f::From(-1.0f, -1.0f);
    vertices[vstart + 1].pos = Vector3f::From(p);
    vertices[vstart + 1].tex = Vector2f::From(+1.0f, -1.0f);
    vertices[vstart + 2].pos = Vector3f::From(p);
    vertices[vstart + 2].tex = Vector2f::From(+1.0f, +1.0f);
    vertices[vstart + 3].pos = Vector3f::From(p);
    vertices[vstart + 3].tex = Vector2f::From(-1.0f, +1.0f);

    size_t istart = indices.size();
    indices.resize(indices.size() + 6);

    indices[istart + 0] = vstart + 0;
    indices[istart + 1] = vstart + 1;
    indices[istart + 2] = vstart + 2;
    indices[istart + 3] = vstart + 0;
    indices[istart + 4] = vstart + 2;
    indices[istart + 5] = vstart + 3;
}

</t>
<t tx="leo.20191228122650.57">void SIndexedMesh::AddQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d) {
    uint32_t vstart = vertices.size();
    vertices.resize(vertices.size() + 4);

    vertices[vstart + 0].pos = Vector3f::From(a);
    vertices[vstart + 1].pos = Vector3f::From(b);
    vertices[vstart + 2].pos = Vector3f::From(c);
    vertices[vstart + 3].pos = Vector3f::From(d);

    size_t istart = indices.size();
    indices.resize(indices.size() + 6);

    indices[istart + 0] = vstart + 0;
    indices[istart + 1] = vstart + 1;
    indices[istart + 2] = vstart + 2;
    indices[istart + 3] = vstart + 0;
    indices[istart + 4] = vstart + 2;
    indices[istart + 5] = vstart + 3;
}

</t>
<t tx="leo.20191228122650.58">void SIndexedMesh::AddPixmap(const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                             const Point2d &amp;ta, const Point2d &amp;tb) {
    uint32_t vstart = vertices.size();
    vertices.resize(vertices.size() + 4);

    vertices[vstart + 0].pos = Vector3f::From(o);
    vertices[vstart + 0].tex = Vector2f::From(ta.x, ta.y);

    vertices[vstart + 1].pos = Vector3f::From(o.Plus(v));
    vertices[vstart + 1].tex = Vector2f::From(ta.x, tb.y);

    vertices[vstart + 2].pos = Vector3f::From(o.Plus(u).Plus(v));
    vertices[vstart + 2].tex = Vector2f::From(tb.x, tb.y);

    vertices[vstart + 3].pos = Vector3f::From(o.Plus(u));
    vertices[vstart + 3].tex = Vector2f::From(tb.x, ta.y);

    size_t istart = indices.size();
    indices.resize(indices.size() + 6);

    indices[istart + 0] = vstart + 0;
    indices[istart + 1] = vstart + 1;
    indices[istart + 2] = vstart + 2;
    indices[istart + 3] = vstart + 0;
    indices[istart + 4] = vstart + 2;
    indices[istart + 5] = vstart + 3;
}

</t>
<t tx="leo.20191228122650.59">void SIndexedMesh::Clear() {
    vertices.clear();
    indices.clear();
}

//-----------------------------------------------------------------------------
// Indexed mesh rendering
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.6">@path ./src/platform/
//-----------------------------------------------------------------------------
// Utility functions that depend on Win32. Notably, our memory allocation;
// we use two separate allocators, one for long-lived stuff and one for
// stuff that gets freed after every regeneration of the model, to save us
// the trouble of freeing the latter explicitly.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

// Include after solvespace.h to avoid identifier clashes.
#include &lt;windows.h&gt;
#include &lt;shellapi.h&gt;

namespace SolveSpace {
static HANDLE PermHeap, TempHeap;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122650.60">void IndexedMeshRenderer::Init() {
    colShader.Init(
        "shaders/imesh.vert", "shaders/imesh.frag",
        {
            { ATTRIB_POS, "pos" }
        }
    );
    texShader.Init(
        "shaders/imesh_tex.vert", "shaders/imesh_tex.frag",
        {
            { ATTRIB_POS, "pos" },
            { ATTRIB_TEX, "tex" }
        }
    );
    texaShader.Init(
        "shaders/imesh_tex.vert", "shaders/imesh_texa.frag",
        {
            { ATTRIB_POS, "pos" },
            { ATTRIB_TEX, "tex" }
        }
    );
    pointShader.Init(
        "shaders/imesh_point.vert", "shaders/imesh_point.frag",
        {
            { ATTRIB_POS, "pos" },
            { ATTRIB_TEX, "loc" }
        }
    );

    texShader.SetUniformTextureUnit("texture_", 0);
    texaShader.SetUniformTextureUnit("texture_", 0);
    selectedShader = &amp;colShader;
}

</t>
<t tx="leo.20191228122650.61">void IndexedMeshRenderer::Clear() {
    texShader.Clear();
    texaShader.Clear();
    colShader.Clear();
    pointShader.Clear();
}

IndexedMeshRenderer::Handle IndexedMeshRenderer::Add(const SIndexedMesh &amp;m, bool dynamic) {
    Handle handle;
    glGenBuffers(1, &amp;handle.vertexBuffer);
    glGenBuffers(1, &amp;handle.indexBuffer);

    GLenum mode = dynamic ? GL_DYNAMIC_DRAW : GL_STATIC_DRAW;
    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);
    glBufferData(GL_ARRAY_BUFFER, m.vertices.size() * sizeof(SIndexedMesh::Vertex),
                 m.vertices.data(), mode);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle.indexBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, m.indices.size() * sizeof(uint32_t),
                 m.indices.data(), mode);
    handle.size = m.indices.size();
    return handle;
}

</t>
<t tx="leo.20191228122650.62">void IndexedMeshRenderer::Remove(const IndexedMeshRenderer::Handle &amp;handle) {
    glDeleteBuffers(1, &amp;handle.vertexBuffer);
    glDeleteBuffers(1, &amp;handle.indexBuffer);
}

</t>
<t tx="leo.20191228122650.63">void IndexedMeshRenderer::Draw(const IndexedMeshRenderer::Handle &amp;handle) {
    if(handle.size == 0) return;

    selectedShader-&gt;Enable();

    glBindBuffer(GL_ARRAY_BUFFER, handle.vertexBuffer);
    glEnableVertexAttribArray(ATTRIB_POS);
    glVertexAttribPointer(ATTRIB_POS, 3, GL_FLOAT, GL_FALSE, sizeof(SIndexedMesh::Vertex),
                          (void *)offsetof(SIndexedMesh::Vertex, pos));
    if(NeedsTexture()) {
        glEnableVertexAttribArray(ATTRIB_TEX);
        glVertexAttribPointer(ATTRIB_TEX, 2, GL_FLOAT, GL_FALSE, sizeof(SIndexedMesh::Vertex),
                              (void *)offsetof(SIndexedMesh::Vertex, tex));
    }

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, handle.indexBuffer);
    glDrawElements(GL_TRIANGLES, handle.size, GL_UNSIGNED_INT, NULL);

    glDisableVertexAttribArray(ATTRIB_POS);
    if(NeedsTexture()) glDisableVertexAttribArray(ATTRIB_TEX);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

    selectedShader-&gt;Disable();
}

</t>
<t tx="leo.20191228122650.64">void IndexedMeshRenderer::Draw(const SIndexedMesh &amp;mesh) {
    Handle handle = Add(mesh, /*dynamic=*/true) ;
    Draw(handle);
    Remove(handle);
}

</t>
<t tx="leo.20191228122650.65">bool IndexedMeshRenderer::NeedsTexture() const {
    return selectedShader == &amp;texShader ||
        selectedShader == &amp;texaShader ||
        selectedShader == &amp;pointShader;
}

</t>
<t tx="leo.20191228122650.66">void IndexedMeshRenderer::SetModelview(const double *matrix) {
    colShader.SetUniformMatrix("modelview", matrix);
    texShader.SetUniformMatrix("modelview", matrix);
    texaShader.SetUniformMatrix("modelview", matrix);
    pointShader.SetUniformMatrix("modelview", matrix);
}

</t>
<t tx="leo.20191228122650.67">void IndexedMeshRenderer::SetProjection(const double *matrix) {
    colShader.SetUniformMatrix("projection", matrix);
    texShader.SetUniformMatrix("projection", matrix);
    texaShader.SetUniformMatrix("projection", matrix);
    pointShader.SetUniformMatrix("projection", matrix);
}

</t>
<t tx="leo.20191228122650.68">void IndexedMeshRenderer::UseFilled(const Canvas::Fill &amp;fill) {
    if(fill.texture) {
        selectedShader = (fill.texture-&gt;format == Pixmap::Format::A) ? &amp;texaShader : &amp;texShader;
    } else {
        selectedShader = &amp;colShader;
    }
    selectedShader-&gt;SetUniformColor("color", fill.color);
}

</t>
<t tx="leo.20191228122650.69">void IndexedMeshRenderer::UsePoint(const Canvas::Stroke &amp;stroke, double pixel) {
    pointShader.SetUniformColor("color", stroke.color);
    pointShader.SetUniformFloat("width", (float)(stroke.width * pixel / 2.0));
    pointShader.SetUniformFloat("pixel", (float)pixel);
    selectedShader = &amp;pointShader;
}

}
</t>
<t tx="leo.20191228122650.7">void dbp(const char *str, ...)
{
    va_list f;
    static char buf[1024*50];
    va_start(f, str);
    _vsnprintf(buf, sizeof(buf), str, f);
    va_end(f);

    // The native version of OutputDebugString, unlike most others,
    // is OutputDebugStringA.
    OutputDebugStringA(buf);
    OutputDebugStringA("\n");

#ifndef NDEBUG
    // Duplicate to stderr in debug builds, but not in release; this is slow.
    fputs(buf, stderr);
    fputc('\n', stderr);
#endif
}

//-----------------------------------------------------------------------------
// A separate heap, on which we allocate expressions. Maybe a bit faster,
// since no fragmentation issues whatsoever, and it also makes it possible
// to be sloppy with our memory management, and just free everything at once
// at the end.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122650.70">@path ./src/render/
//-----------------------------------------------------------------------------
// OpenGL ES 2.0 and OpenGL 3.0 shader interface.
//
// Copyright 2016 Aleksey Egorov
//-----------------------------------------------------------------------------
#ifndef SOLVESPACE_GL3SHADER_H
#define SOLVESPACE_GL3SHADER_H

#if defined(WIN32)
#   define GL_APICALL /*static linkage*/
#   define GL_GLEXT_PROTOTYPES
#   include &lt;GLES2/gl2.h&gt;
#   include &lt;GLES2/gl2ext.h&gt;
#   define HAVE_GLES
#elif defined(__APPLE__)
#   include &lt;OpenGL/gl.h&gt;
#else
#   define GL_GLEXT_PROTOTYPES
#   include &lt;GL/gl.h&gt;
#   include &lt;GL/glext.h&gt;
#endif

#if !defined(HAVE_GLES)
// glDepthRange is in GL1+ but not GLES2, glDepthRangef is in GL4.1+ and GLES2.
// Consistency!
#   define glClearDepthf glClearDepth
#   define glDepthRangef glDepthRange
#endif

namespace SolveSpace {

//-----------------------------------------------------------------------------
// Floating-point data structures; the layout of these must match shaders
//-----------------------------------------------------------------------------

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122650.71">class Vector2f {
public:
    float x, y;

    static Vector2f From(float x, float y);
    static Vector2f From(double x, double y);
    static Vector2f FromInt(uint32_t x, uint32_t y);
};

</t>
<t tx="leo.20191228122650.72">class Vector3f {
public:
    float x, y, z;

    static Vector3f From(float x, float y, float z);
    static Vector3f From(const Vector &amp;v);
    static Vector3f From(const RgbaColor &amp;c);
};

</t>
<t tx="leo.20191228122650.73">class Vector4f {
public:
    float x, y, z, w;

    static Vector4f From(float x, float y, float z, float w);
    static Vector4f From(const Vector &amp;v, float w);
    static Vector4f FromInt(uint32_t x, uint32_t y, uint32_t z, uint32_t w);
    static Vector4f From(const RgbaColor &amp;c);
};

//-----------------------------------------------------------------------------
// Wrappers for our shaders
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.74">class Shader {
public:
    GLuint program = 0;

    void Init(const std::string &amp;vertexRes,
    void SetUniformTextureUnit(const char *name, GLint index);
    void Enable() const;
    void Disable() const;
};

</t>
<t tx="leo.20191228122650.75">class MeshRenderer {
public:
    const GLint ATTRIB_POS = 0;
    const GLint ATTRIB_NOR = 1;
    const GLint ATTRIB_COL = 2;

    struct MeshVertex {
        Vector3f    pos;
        Vector3f    nor;
        Vector4f    col;
    };

    struct Handle {
        GLuint      vertexBuffer;
        GLsizei     size;
    };

    Shader  lightShader;
    Shader  fillShader;
    Shader *selectedShader = NULL;

    void Init();
    void Clear();

    Handle Add(const SMesh &amp;m, bool dynamic = false);
    void Remove(const Handle &amp;handle);
    void Draw(const Handle &amp;handle, bool useColors = true, RgbaColor overrideColor = {});
    void Draw(const SMesh &amp;mesh, bool useColors = true, RgbaColor overrideColor = {});

    void SetModelview(double *matrix);
    void SetProjection(double *matrix);

    void UseShaded(const Lighting &amp;lighting);
    void UseFilled(const Canvas::Fill &amp;fill);
};

</t>
<t tx="leo.20191228122650.76">class StippleAtlas {
public:
    std::vector&lt;GLint&gt; patterns;

    void Init();
    void Clear();

    GLint GetTexture(StipplePattern pattern) const;
    double GetLength(StipplePattern pattern) const;
};

</t>
<t tx="leo.20191228122650.77">class EdgeRenderer {
public:
    const GLint ATTRIB_POS = 0;
    const GLint ATTRIB_LOC = 1;
    const GLint ATTRIB_TAN = 2;

    struct EdgeVertex {
        Vector3f    pos;
        Vector3f    loc;
        Vector3f    tan;
    };

    struct Handle {
        GLuint      vertexBuffer;
        GLuint      indexBuffer;
        GLsizei     size;
    };

    Shader              shader;

    const StippleAtlas *atlas   = NULL;
    StipplePattern      pattern = StipplePattern::CONTINUOUS;

    void Init(const StippleAtlas *atlas);
    void Clear();

    Handle Add(const SEdgeList &amp;edges, bool dynamic = false);
    void Remove(const Handle &amp;handle);
    void Draw(const Handle &amp;handle);
    void Draw(const SEdgeList &amp;edges);

    void SetModelview(const double *matrix);
    void SetProjection(const double *matrix);
    void SetStroke(const Canvas::Stroke &amp;stroke, double pixel);
};

</t>
<t tx="leo.20191228122650.78">class OutlineRenderer {
public:
    const GLint ATTRIB_POS = 0;
    const GLint ATTRIB_LOC = 1;
    const GLint ATTRIB_TAN = 2;
    const GLint ATTRIB_NOL = 3;
    const GLint ATTRIB_NOR = 4;

    struct OutlineVertex {
        Vector3f    pos;
        Vector4f    loc;
        Vector3f    tan;
        Vector3f    nol;
        Vector3f    nor;
    };

    struct Handle {
        GLuint      vertexBuffer;
        GLuint      indexBuffer;
        GLsizei     size;
    };

    Shader              shader;

    const StippleAtlas *atlas   = NULL;
    StipplePattern      pattern = StipplePattern::CONTINUOUS;

    void Init(const StippleAtlas *atlas);
    void Clear();

    Handle Add(const SOutlineList &amp;outlines, bool dynamic = false);
    void Remove(const Handle &amp;handle);
    void Draw(const Handle &amp;handle, Canvas::DrawOutlinesAs mode);
    void Draw(const SOutlineList &amp;outlines, Canvas::DrawOutlinesAs mode);

    void SetModelview(const double *matrix);
    void SetProjection(const double *matrix);
    void SetStroke(const Canvas::Stroke &amp;stroke, double pixel);
};

</t>
<t tx="leo.20191228122650.79">class SIndexedMesh {
public:
    struct Vertex {
        Vector3f    pos;
        Vector2f    tex;
    };

    std::vector&lt;Vertex&gt;   vertices;
    std::vector&lt;uint32_t&gt; indices;

    void AddPoint(const Vector &amp;p);
    void AddQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d);
    @others
};

}

#endif
</t>
<t tx="leo.20191228122650.8">void *AllocTemporary(size_t n)
{
    void *v = HeapAlloc(TempHeap, HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY, n);
    ssassert(v != NULL, "Cannot allocate memory");
    return v;
}
</t>
<t tx="leo.20191228122650.80">    void AddPixmap(const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                   const Point2d &amp;ta, const Point2d &amp;tb);

    void Clear();
};

class IndexedMeshRenderer {
public:
    const GLint ATTRIB_POS = 0;
    const GLint ATTRIB_TEX = 1;

    struct Handle {
        GLuint      vertexBuffer;
        GLuint      indexBuffer;
        GLsizei     size;
    };

    Shader  texShader;
    Shader  texaShader;
    Shader  colShader;
    Shader  pointShader;

    Shader *selectedShader = NULL;

    void Init();
    void Clear();

    Handle Add(const SIndexedMesh &amp;m, bool dynamic = false);
    void Remove(const Handle &amp;handle);
    void Draw(const Handle &amp;handle);
    void Draw(const SIndexedMesh &amp;mesh);

    void SetModelview(const double *matrix);
    void SetProjection(const double *matrix);

    bool NeedsTexture() const;

    void UseFilled(const Canvas::Fill &amp;fill);
    void UsePoint(const Canvas::Stroke &amp;stroke, double pixel);
</t>
<t tx="leo.20191228122650.81">@path ./src/render/
//-----------------------------------------------------------------------------
// Backend-agnostic rendering interface, and various backends we use.
//
// Copyright 2016 whitequark
//-----------------------------------------------------------------------------
#include "solvespace.h"

namespace SolveSpace {

//-----------------------------------------------------------------------------
// Camera transformations.
//-----------------------------------------------------------------------------

Point2d Camera::ProjectPoint(Vector p) const {
    Vector p3 = ProjectPoint3(p);
    Point2d p2 = { p3.x, p3.y };
    return p2;
}

Vector Camera::ProjectPoint3(Vector p) const {
    double w;
    Vector r = ProjectPoint4(p, &amp;w);
    return r.ScaledBy(scale/w);
}

Vector Camera::ProjectPoint4(Vector p, double *w) const {
    p = p.Plus(offset);

    Vector r;
    r.x = p.Dot(projRight);
    r.y = p.Dot(projUp);
    r.z = p.Dot(projUp.Cross(projRight));

    *w = 1 + r.z*tangent*scale;
    return r;
}

Vector Camera::UnProjectPoint(Point2d p) const {
    Vector orig = offset.ScaledBy(-1);

    // Note that we're ignoring the effects of perspective. Since our returned
    // point has the same component normal to the screen as the offset, it
    // will have z = 0 after the rotation is applied, thus w = 1. So this is
    // correct.
    orig = orig.Plus(projRight.ScaledBy(p.x / scale)).Plus(
                     projUp.   ScaledBy(p.y / scale));
    return orig;
}

Vector Camera::UnProjectPoint3(Vector p) const {
    p.z = p.z / (scale - p.z * tangent * scale);
    double w = 1 + p.z * tangent * scale;
    p.x *= w / scale;
    p.y *= w / scale;

    Vector orig = offset.ScaledBy(-1);
    orig = orig.Plus(projRight.ScaledBy(p.x)).Plus(
                     projUp.   ScaledBy(p.y).Plus(
                     projUp.Cross(projRight). ScaledBy(p.z)));
    return orig;
}

Vector Camera::VectorFromProjs(Vector rightUpForward) const {
    Vector n = projRight.Cross(projUp);

    Vector r = (projRight.ScaledBy(rightUpForward.x));
    r =  r.Plus(projUp.ScaledBy(rightUpForward.y));
    r =  r.Plus(n.ScaledBy(rightUpForward.z));
    return r;
}

Vector Camera::AlignToPixelGrid(Vector v) const {
    if(!gridFit) return v;

    v = ProjectPoint3(v);
    v.x = floor(v.x) + 0.5;
    v.y = floor(v.y) + 0.5;
    return UnProjectPoint3(v);
}

SBezier Camera::ProjectBezier(SBezier b) const {
    Quaternion q = Quaternion::From(projRight, projUp);
    q = q.Inverse();
    // we want Q*(p - o) = Q*p - Q*o
    b = b.TransformedBy(q.Rotate(offset).ScaledBy(scale), q, scale);
    for(int i = 0; i &lt;= b.deg; i++) {
        Vector4 ct = Vector4::From(b.weight[i], b.ctrl[i]);
        // so the desired curve, before perspective, is
        //    (x/w, y/w, z/w)
        // and after perspective is
        //    ((x/w)/(1 - (z/w)*tangent, ...
        //  = (x/(w - z*tangent), ...
        // so we want to let w' = w - z*tangent
        ct.w = ct.w - ct.z*tangent;

        b.ctrl[i] = ct.PerspectiveProject();
        b.weight[i] = ct.w;
    }
    return b;
}

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122650.82">void Camera::LoadIdentity() {
    offset    = { 0.0, 0.0, 0.0 };
    projRight = { 1.0, 0.0, 0.0 };
    projUp    = { 0.0, 1.0, 0.0 };
    scale     = 1.0;
    tangent   = 0.0;
}

</t>
<t tx="leo.20191228122650.83">void Camera::NormalizeProjectionVectors() {
    if(projRight.Magnitude() &lt; LENGTH_EPS) {
        projRight = Vector::From(1, 0, 0);
    }

    Vector norm = projRight.Cross(projUp);
    // If projRight and projUp somehow ended up parallel, then pick an
    // arbitrary projUp normal to projRight.
    if(norm.Magnitude() &lt; LENGTH_EPS) {
        norm = projRight.Normal(0);
    }
    projUp = norm.Cross(projRight);

    projUp = projUp.WithMagnitude(1);
    projRight = projRight.WithMagnitude(1);
}

//-----------------------------------------------------------------------------
// Stroke and fill caching.
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.84">bool Canvas::Stroke::Equals(const Stroke &amp;other) const {
    return (layer  == other.layer &amp;&amp;
            zIndex == other.zIndex &amp;&amp;
            color.Equals(other.color) &amp;&amp;
            width == other.width &amp;&amp;
            unit == other.unit &amp;&amp;
            stipplePattern == other.stipplePattern &amp;&amp;
            stippleScale == other.stippleScale);
}

double Canvas::Stroke::WidthMm(const Camera &amp;camera) const {
    switch(unit) {
        case Canvas::Unit::MM:
            return width;
        case Canvas::Unit::PX:
            return width / camera.scale;
        default:
            ssassert(false, "Unexpected unit");
    }
}

double Canvas::Stroke::WidthPx(const Camera &amp;camera) const {
    switch(unit) {
        case Canvas::Unit::MM:
            return width * camera.scale;
        case Canvas::Unit::PX:
            return width;
        default:
            ssassert(false, "Unexpected unit");
    }
}

double Canvas::Stroke::StippleScaleMm(const Camera &amp;camera) const {
    switch(unit) {
        case Canvas::Unit::MM:
            return stippleScale;
        case Canvas::Unit::PX:
            return stippleScale / camera.scale;
        default:
            ssassert(false, "Unexpected unit");
    }
}

double Canvas::Stroke::StippleScalePx(const Camera &amp;camera) const {
    switch(unit) {
        case Canvas::Unit::MM:
            return stippleScale * camera.scale;
        case Canvas::Unit::PX:
            return stippleScale;
        default:
            ssassert(false, "Unexpected unit");
    }
}

</t>
<t tx="leo.20191228122650.85">bool Canvas::Fill::Equals(const Fill &amp;other) const {
    return (layer  == other.layer &amp;&amp;
            zIndex == other.zIndex &amp;&amp;
            color.Equals(other.color) &amp;&amp;
            pattern == other.pattern &amp;&amp;
            texture == other.texture);
}

</t>
<t tx="leo.20191228122650.86">void Canvas::Clear() {
    strokes.Clear();
    fills.Clear();
}

Canvas::hStroke Canvas::GetStroke(const Stroke &amp;stroke) {
    for(const Stroke &amp;s : strokes) {
        if(s.Equals(stroke)) return s.h;
    }
    Stroke strokeCopy = stroke;
    return strokes.AddAndAssignId(&amp;strokeCopy);
}

Canvas::hFill Canvas::GetFill(const Fill &amp;fill) {
    for(const Fill &amp;f : fills) {
        if(f.Equals(fill)) return f.h;
    }
    Fill fillCopy = fill;
    return fills.AddAndAssignId(&amp;fillCopy);
}

BitmapFont *Canvas::GetBitmapFont() {
    if(bitmapFont.IsEmpty()) {
        bitmapFont = BitmapFont::Create();
    }
    return &amp;bitmapFont;
}

std::shared_ptr&lt;BatchCanvas&gt; Canvas::CreateBatch() {
    return std::shared_ptr&lt;BatchCanvas&gt;();
}

//-----------------------------------------------------------------------------
// An interface for view-independent visualization
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.87">const Camera &amp;BatchCanvas::GetCamera() const {
    ssassert(false, "Geometry drawn on BatchCanvas must be independent from camera");
}

//-----------------------------------------------------------------------------
// A wrapper around Canvas that simplifies drawing UI in screen coordinates
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.88">void UiCanvas::DrawLine(int x1, int y1, int x2, int y2, RgbaColor color, int width, int zIndex) {
    Vector va = { (double)x1 + 0.5, (double)Flip(y1) + 0.5, 0.0 },
           vb = { (double)x2 + 0.5, (double)Flip(y2) + 0.5, 0.0 };

    Canvas::Stroke stroke = {};
    stroke.layer  = Canvas::Layer::NORMAL;
    stroke.zIndex = zIndex;
    stroke.width  = (double)width;
    stroke.color  = color;
    stroke.unit   = Canvas::Unit::PX;
    Canvas::hStroke hcs = canvas-&gt;GetStroke(stroke);

    canvas-&gt;DrawLine(va, vb, hcs);
}

</t>
<t tx="leo.20191228122650.89">void UiCanvas::DrawRect(int l, int r, int t, int b, RgbaColor fillColor, RgbaColor outlineColor,
                        int zIndex) {
    Vector va = { (double)l + 0.5, (double)Flip(b) + 0.5, 0.0 },
           vb = { (double)l + 0.5, (double)Flip(t) + 0.5, 0.0 },
           vc = { (double)r + 0.5, (double)Flip(t) + 0.5, 0.0 },
           vd = { (double)r + 0.5, (double)Flip(b) + 0.5, 0.0 };

    if(!fillColor.IsEmpty()) {
        Canvas::Fill fill = {};
        fill.layer  = Canvas::Layer::NORMAL;
        fill.zIndex = zIndex;
        fill.color  = fillColor;
        Canvas::hFill hcf = canvas-&gt;GetFill(fill);

        canvas-&gt;DrawQuad(va, vb, vc, vd, hcf);
    }

    if(!outlineColor.IsEmpty()) {
        Canvas::Stroke stroke = {};
        stroke.layer  = Canvas::Layer::NORMAL;
        stroke.zIndex = zIndex;
        stroke.width  = 1.0;
        stroke.color  = outlineColor;
        stroke.unit   = Canvas::Unit::PX;
        Canvas::hStroke hcs = canvas-&gt;GetStroke(stroke);

        canvas-&gt;DrawLine(va, vb, hcs);
        canvas-&gt;DrawLine(vb, vc, hcs);
        canvas-&gt;DrawLine(vc, vd, hcs);
        canvas-&gt;DrawLine(vd, va, hcs);
    }
}

</t>
<t tx="leo.20191228122650.9">void FreeAllTemporary()
{
    if(TempHeap) HeapDestroy(TempHeap);
    TempHeap = HeapCreate(HEAP_NO_SERIALIZE, 1024*1024*20, 0);
    // This is a good place to validate, because it gets called fairly
    // often.
    vl();
}

</t>
<t tx="leo.20191228122650.90">void UiCanvas::DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm, int x, int y, int zIndex) {
    Canvas::Fill fill = {};
    fill.layer  = Canvas::Layer::NORMAL;
    fill.zIndex = zIndex;
    fill.color  = { 255, 255, 255, 255 };
    Canvas::hFill hcf = canvas-&gt;GetFill(fill);

    canvas-&gt;DrawPixmap(pm,
                       { (double)x, (double)(flip ? Flip(y) - pm-&gt;height : y), 0.0 },
                       { (double)pm-&gt;width,  0.0, 0.0 },
                       { 0.0, (double)pm-&gt;height, 0.0 },
                       { 0.0, 1.0 },
                       { 1.0, 0.0 },
                       hcf);
}

</t>
<t tx="leo.20191228122650.91">void UiCanvas::DrawBitmapChar(char32_t codepoint, int x, int y, RgbaColor color, int zIndex) {
    BitmapFont *font = canvas-&gt;GetBitmapFont();

    Canvas::Fill fill = {};
    fill.layer  = Canvas::Layer::NORMAL;
    fill.zIndex = zIndex;
    fill.color  = color;
    Canvas::hFill hcf = canvas-&gt;GetFill(fill);

    if(codepoint &gt;= 0xe000 &amp;&amp; codepoint &lt;= 0xefff) {
        // Special character, like a checkbox or a radio button
        x -= 3;
    }

    double s0, t0, s1, t1;
    size_t w, h;
    font-&gt;LocateGlyph(codepoint, &amp;s0, &amp;t0, &amp;s1, &amp;t1, &amp;w, &amp;h);
    if(font-&gt;textureUpdated) {
        // LocateGlyph modified the texture, reload it.
        canvas-&gt;InvalidatePixmap(font-&gt;texture);
        font-&gt;textureUpdated = false;
    }

    canvas-&gt;DrawPixmap(font-&gt;texture,
                       { (double)x, (double)Flip(y), 0.0 },
                       { (double)w,  0.0, 0.0 },
                       { 0.0, (double) h, 0.0 },
                       { s0, t1 },
                       { s1, t0 },
                       hcf);
}

</t>
<t tx="leo.20191228122650.92">void UiCanvas::DrawBitmapText(const std::string &amp;str, int x, int y, RgbaColor color, int zIndex) {
    BitmapFont *font = canvas-&gt;GetBitmapFont();

    for(char32_t codepoint : ReadUTF8(str)) {
        DrawBitmapChar(codepoint, x, y, color, zIndex);
        x += (int)font-&gt;GetWidth(codepoint) * 8;
    }
}

//-----------------------------------------------------------------------------
// A canvas that performs picking against drawn geometry.
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122650.93">void ObjectPicker::DoCompare(double distance, int zIndex, int comparePosition) {
    if(distance &gt; selRadius) return;
    if((zIndex == maxZIndex &amp;&amp; distance &lt; minDistance) || (zIndex &gt; maxZIndex)) {
        minDistance = distance;
        maxZIndex   = zIndex;
        position    = comparePosition;
    }
}

</t>
<t tx="leo.20191228122650.94">void ObjectPicker::DoQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d,
                          int zIndex, int comparePosition) {
    Point2d corners[4] = {
        camera.ProjectPoint(a),
        camera.ProjectPoint(b),
        camera.ProjectPoint(c),
        camera.ProjectPoint(d)
    };
    @others
}

</t>
<t tx="leo.20191228122650.95">double minNegative = VERY_NEGATIVE,
       maxPositive = VERY_POSITIVE;
for(int i = 0; i &lt; 4; i++) {
    Point2d ap = corners[i],
            bp = corners[(i + 1) % 4];
    double distance = point.DistanceToLineSigned(ap, bp.Minus(ap), /*asSegment=*/true);
    if(distance &lt; 0) minNegative = std::max(minNegative, distance);
    if(distance &gt; 0) maxPositive = std::min(maxPositive, distance);
}

bool insideQuad = (minNegative == VERY_NEGATIVE || maxPositive == VERY_POSITIVE);
if(insideQuad) {
    DoCompare(0.0, zIndex, comparePosition);
} else {
    double distance = std::min(fabs(minNegative), fabs(maxPositive));
    DoCompare(distance, zIndex, comparePosition);
}
</t>
<t tx="leo.20191228122650.96">void ObjectPicker::DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) {
    Stroke *stroke = strokes.FindById(hcs);
    Point2d ap = camera.ProjectPoint(a);
    Point2d bp = camera.ProjectPoint(b);
    double distance = point.DistanceToLine(ap, bp.Minus(ap), /*asSegment=*/true);
    DoCompare(distance - stroke-&gt;width / 2.0, stroke-&gt;zIndex);
}

</t>
<t tx="leo.20191228122650.97">void ObjectPicker::DrawEdges(const SEdgeList &amp;el, hStroke hcs) {
    Stroke *stroke = strokes.FindById(hcs);
    for(const SEdge &amp;e : el.l) {
        Point2d ap = camera.ProjectPoint(e.a);
        Point2d bp = camera.ProjectPoint(e.b);
        double distance = point.DistanceToLine(ap, bp.Minus(ap), /*asSegment=*/true);
        DoCompare(distance - stroke-&gt;width / 2.0, stroke-&gt;zIndex, e.auxB);
    }
}

</t>
<t tx="leo.20191228122650.98">void ObjectPicker::DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo.20191228122650.99">void ObjectPicker::DrawVectorText(const std::string &amp;text, double height,
                                  const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                                  hStroke hcs) {
    Stroke *stroke = strokes.FindById(hcs);
    double w = VectorFont::Builtin()-&gt; GetWidth(height, text),
    Fill *fill = fills.FindById(hcf);
    DoQuad(a, b, c, d, fill-&gt;zIndex);
}

</t>
<t tx="leo.20191228122651.1">void Draw(OpenGl3Renderer *renderer) override {
    glEnable(GL_CULL_FACE);
    if(hasFillBack)
        DrawFace(renderer, GL_BACK, fillBack);
    DrawFace(renderer, GL_FRONT, fillFront);
    glDisable(GL_CULL_FACE);
}

</t>
<t tx="leo.20191228122651.10">void DrawEdges(const SEdgeList &amp;el, hStroke hcs) override {
    EdgeBuffer *eb = edgeBuffer.FindByIdNoOops(hcs);
    if(!eb) {
        EdgeBuffer neb = {};
        neb.h = hcs;
        edgeBuffer.Add(&amp;neb);
        eb = edgeBuffer.FindById(hcs);
    }

    for(const SEdge &amp;e : el.l) {
        eb-&gt;edges.AddEdge(e.a, e.b);
    }
}

</t>
<t tx="leo.20191228122651.100">            double mag =
                ((ctrl[ia][ja].Minus(ctrl[ib][jb]))).Cross(
                 (ctrl[ia][ja].Minus(ctrl[i ][j ]))).Magnitude();
            if(mag &gt; best) {
                best = mag;
                ic = i;
                jc = j;
            }
        }
    }

    Vector n = ((ctrl[ia][ja].Minus(ctrl[ib][jb]))).Cross(
                (ctrl[ia][ja].Minus(ctrl[ic][jc])));
    n = n.WithMagnitude(1);
    double d = (ctrl[ia][ja]).Dot(n);

    // Finally, calculate the deviation from each point to the plane.
    double farthest = VERY_NEGATIVE;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            double dist = fabs(n.Dot(ctrl[i][j]) - d);
            if(dist &gt; farthest) {
                farthest = dist;
            }
        }
    }
    return farthest;
}

</t>
<t tx="leo.20191228122651.101">void SSurface::WeightControlPoints() {
    int i, j;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            ctrl[i][j] = (ctrl[i][j]).ScaledBy(weight[i][j]);
        }
    }
}
</t>
<t tx="leo.20191228122651.102">void SSurface::UnWeightControlPoints() {
    int i, j;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            ctrl[i][j] = (ctrl[i][j]).ScaledBy(1.0/weight[i][j]);
        }
    }
}
</t>
<t tx="leo.20191228122651.103">void SSurface::CopyRowOrCol(bool row, int this_ij, SSurface *src, int src_ij) {
    if(row) {
        int j;
        for(j = 0; j &lt;= degn; j++) {
            ctrl  [this_ij][j] = src-&gt;ctrl  [src_ij][j];
            weight[this_ij][j] = src-&gt;weight[src_ij][j];
        }
    } else {
        int i;
        for(i = 0; i &lt;= degm; i++) {
            ctrl  [i][this_ij] = src-&gt;ctrl  [i][src_ij];
            weight[i][this_ij] = src-&gt;weight[i][src_ij];
        }
    }
}
</t>
<t tx="leo.20191228122651.104">void SSurface::BlendRowOrCol(bool row, int this_ij, SSurface *a, int a_ij,
                                                    SSurface *b, int b_ij)
{
    if(row) {
        int j;
        for(j = 0; j &lt;= degn; j++) {
            Vector c = (a-&gt;ctrl  [a_ij][j]).Plus(b-&gt;ctrl  [b_ij][j]);
            double w = (a-&gt;weight[a_ij][j]   +   b-&gt;weight[b_ij][j]);
            ctrl  [this_ij][j] = c.ScaledBy(0.5);
            weight[this_ij][j] = w / 2;
        }
    } else {
        int i;
        for(i = 0; i &lt;= degm; i++) {
            Vector c = (a-&gt;ctrl  [i][a_ij]).Plus(b-&gt;ctrl  [i][b_ij]);
            double w = (a-&gt;weight[i][a_ij]   +   b-&gt;weight[i][b_ij]);
            ctrl  [i][this_ij] = c.ScaledBy(0.5);
            weight[i][this_ij] = w / 2;
        }
    }
}
</t>
<t tx="leo.20191228122651.105">void SSurface::SplitInHalf(bool byU, SSurface *sa, SSurface *sb) {
    sa-&gt;degm = sb-&gt;degm = degm;
    sa-&gt;degn = sb-&gt;degn = degn;

    // by de Casteljau's algorithm in a projective space; so we must work
    // on points (w*x, w*y, w*z, w)
    WeightControlPoints();

    switch(byU ? degm : degn) {
        case 1:
            sa-&gt;CopyRowOrCol (byU, 0, this, 0);
            sb-&gt;CopyRowOrCol (byU, 1, this, 1);

            sa-&gt;BlendRowOrCol(byU, 1, this, 0, this, 1);
            sb-&gt;BlendRowOrCol(byU, 0, this, 0, this, 1);
            break;

        case 2:
            sa-&gt;CopyRowOrCol (byU, 0, this, 0);
            sb-&gt;CopyRowOrCol (byU, 2, this, 2);

            sa-&gt;BlendRowOrCol(byU, 1, this, 0, this, 1);
            sb-&gt;BlendRowOrCol(byU, 1, this, 1, this, 2);

            sa-&gt;BlendRowOrCol(byU, 2, sa,   1, sb,   1);
            sb-&gt;BlendRowOrCol(byU, 0, sa,   1, sb,   1);
            break;

        case 3: {
            SSurface st;
            st.degm = degm; st.degn = degn;

            sa-&gt;CopyRowOrCol (byU, 0, this, 0);
            sb-&gt;CopyRowOrCol (byU, 3, this, 3);

            sa-&gt;BlendRowOrCol(byU, 1, this, 0, this, 1);
            sb-&gt;BlendRowOrCol(byU, 2, this, 2, this, 3);
            st. BlendRowOrCol(byU, 0, this, 1, this, 2); // scratch var

            sa-&gt;BlendRowOrCol(byU, 2, sa,   1, &amp;st,  0);
            sb-&gt;BlendRowOrCol(byU, 1, sb,   2, &amp;st,  0);

            sa-&gt;BlendRowOrCol(byU, 3, sa,   2, sb,   1);
            sb-&gt;BlendRowOrCol(byU, 0, sa,   2, sb,   1);
            break;
        }

        default: ssassert(false, "Unexpected degree of spline");
    }

    sa-&gt;UnWeightControlPoints();
    sb-&gt;UnWeightControlPoints();
    UnWeightControlPoints();
}

//-----------------------------------------------------------------------------
// Find all points where the indicated finite (if segment) or infinite (if not
// segment) line intersects our surface. Report them in uv space in the list.
// We first do a bounding box check; if the line doesn't intersect, then we're
// done. If it does, then we check how small our surface is. If it's big,
// then we subdivide into quarters and recurse. If it's small, then we refine
// by Newton's method and record the point.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.106">void SSurface::AllPointsIntersectingUntrimmed(Vector a, Vector b,
                                              int *cnt, int *level,
                                              List&lt;Inter&gt; *l, bool asSegment,
                                              SSurface *sorig)
{
    // Test if the line intersects our axis-aligned bounding box; if no, then
    // no possibility of an intersection
    if(LineEntirelyOutsideBbox(a, b, asSegment)) return;

    if(*cnt &gt; 2000) {
        dbp("!!! too many subdivisions (level=%d)!", *level);
        dbp("degm = %d degn = %d", degm, degn);
        return;
    }
    (*cnt)++;

    // If we might intersect, and the surface is small, then switch to Newton
    // iterations.
    if(DepartureFromCoplanar() &lt; 0.2*SS.ChordTolMm()) {
        Vector p = (ctrl[0   ][0   ]).Plus(
                    ctrl[0   ][degn]).Plus(
                    ctrl[degm][0   ]).Plus(
                    ctrl[degm][degn]).ScaledBy(0.25);
        Inter inter;
        sorig-&gt;ClosestPointTo(p, &amp;(inter.p.x), &amp;(inter.p.y), /*mustConverge=*/false);
        if(sorig-&gt;PointIntersectingLine(a, b, &amp;(inter.p.x), &amp;(inter.p.y))) {
            Vector p = sorig-&gt;PointAt(inter.p.x, inter.p.y);
            // Debug check, verify that the point lies in both surfaces
            // (which it ought to, since the surfaces should be coincident)
            double u, v;
            ClosestPointTo(p, &amp;u, &amp;v);
            l-&gt;Add(&amp;inter);
        } else {
            // Might not converge if line is almost tangent to surface...
        }
        return;
    }

    // But the surface is big, so split it, alternating by u and v
    SSurface surf0, surf1;
    SplitInHalf((*level &amp; 1) == 0, &amp;surf0, &amp;surf1);

    int nextLevel = (*level) + 1;
    (*level) = nextLevel;
    surf0.AllPointsIntersectingUntrimmed(a, b, cnt, level, l, asSegment, sorig);
    (*level) = nextLevel;
    surf1.AllPointsIntersectingUntrimmed(a, b, cnt, level, l, asSegment, sorig);
}

//-----------------------------------------------------------------------------
// Find all points where a line through a and b intersects our surface, and
// add them to the list. If seg is true then report only intersections that
// lie within the finite line segment (not including the endpoints); otherwise
// we work along the infinite line. And we report either just intersections
// inside the trim curve, or any intersection with u, v in [0, 1]. And we
// either disregard or report tangent points.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.107">void SSurface::AllPointsIntersecting(Vector a, Vector b,
                                     List&lt;SInter&gt; *l,
                                     bool asSegment, bool trimmed, bool inclTangent)
{
    if(LineEntirelyOutsideBbox(a, b, asSegment)) return;

    Vector ba = b.Minus(a);
    double bam = ba.Magnitude();

    List&lt;Inter&gt; inters = {};

    // All the intersections between the line and the surface; either special
    // cases that we can quickly solve in closed form, or general numerical.
    Vector center, axis, start, finish;
    double radius;
    if(degm == 1 &amp;&amp; degn == 1) {
        // Against a plane, easy.
        Vector n = NormalAt(0, 0).WithMagnitude(1);
        double d = n.Dot(PointAt(0, 0));
        // Trim to line segment now if requested, don't generate points that
        // would just get discarded later.
        if(!asSegment ||
           (n.Dot(a) &gt; d + LENGTH_EPS &amp;&amp; n.Dot(b) &lt; d - LENGTH_EPS) ||
           (n.Dot(b) &gt; d + LENGTH_EPS &amp;&amp; n.Dot(a) &lt; d - LENGTH_EPS))
        {
            Vector p = Vector::AtIntersectionOfPlaneAndLine(n, d, a, b, NULL);
            Inter inter;
            ClosestPointTo(p, &amp;(inter.p.x), &amp;(inter.p.y));
            inters.Add(&amp;inter);
        }
    } else if(IsCylinder(&amp;axis, &amp;center, &amp;radius, &amp;start, &amp;finish)) {
        // This one can be solved in closed form too.
        Vector ab = b.Minus(a);
        if(axis.Cross(ab).Magnitude() &lt; LENGTH_EPS) {
            // edge is parallel to axis of cylinder, no intersection points
            return;
        }
        // A coordinate system centered at the center of the circle, with
        // the edge under test horizontal
        Vector u, v, n = axis.WithMagnitude(1);
        u = (ab.Minus(n.ScaledBy(ab.Dot(n)))).WithMagnitude(1);
        v = n.Cross(u);
        Point2d ap = (a.Minus(center)).DotInToCsys(u, v, n).ProjectXy(),
                bp = (b.Minus(center)).DotInToCsys(u, v, n).ProjectXy(),
                sp = (start. Minus(center)).DotInToCsys(u, v, n).ProjectXy(),
                fp = (finish.Minus(center)).DotInToCsys(u, v, n).ProjectXy();

        double thetas = atan2(sp.y, sp.x), thetaf = atan2(fp.y, fp.x);

        Point2d ip[2];
        int ip_n = 0;
        if(fabs(fabs(ap.y) - radius) &lt; LENGTH_EPS) {
            // tangent
            if(inclTangent) {
                ip[0] = Point2d::From(0, ap.y);
                ip_n = 1;
            }
        } else if(fabs(ap.y) &lt; radius) {
            // two intersections
            double xint = sqrt(radius*radius - ap.y*ap.y);
            ip[0] = Point2d::From(-xint, ap.y);
            ip[1] = Point2d::From( xint, ap.y);
            ip_n = 2;
        }
        int i;
        for(i = 0; i &lt; ip_n; i++) {
            double t = (ip[i].Minus(ap)).DivProjected(bp.Minus(ap));
            // This is a point on the circle; but is it on the arc?
            Point2d pp = ap.Plus((bp.Minus(ap)).ScaledBy(t));
            double theta = atan2(pp.y, pp.x);
            @others
}

</t>
<t tx="leo.20191228122651.108">        double dp = WRAP_SYMMETRIC(theta  - thetas, 2*PI),
               df = WRAP_SYMMETRIC(thetaf - thetas, 2*PI);
        double tol = LENGTH_EPS/radius;

        if((df &gt; 0 &amp;&amp; ((dp &lt; -tol) || (dp &gt; df + tol))) ||
           (df &lt; 0 &amp;&amp; ((dp &gt;  tol) || (dp &lt; df - tol))))
        {
            continue;
        }

        Vector p = a.Plus((b.Minus(a)).ScaledBy(t));

        Inter inter;
        ClosestPointTo(p, &amp;(inter.p.x), &amp;(inter.p.y));
        inters.Add(&amp;inter);
    }
} else {
    // General numerical solution by subdivision, fallback
    int cnt = 0, level = 0;
    AllPointsIntersectingUntrimmed(a, b, &amp;cnt, &amp;level, &amp;inters, asSegment, this);
}

// Remove duplicate intersection points
inters.ClearTags();
int i, j;
for(i = 0; i &lt; inters.n; i++) {
    for(j = i + 1; j &lt; inters.n; j++) {
        if(inters[i].p.Equals(inters[j].p)) {
            inters[j].tag = 1;
        }
    }
}
inters.RemoveTagged();

for(i = 0; i &lt; inters.n; i++) {
    Point2d puv = inters[i].p;

    // Make sure the point lies within the finite line segment
    Vector pxyz = PointAt(puv.x, puv.y);
    double t = (pxyz.Minus(a)).DivProjected(ba);
    if(asSegment &amp;&amp; (t &gt; 1 - LENGTH_EPS/bam || t &lt; LENGTH_EPS/bam)) {
        continue;
    }

    // And that it lies inside our trim region
    Point2d dummy = { 0, 0 };
    SBspUv::Class c = (bsp) ? bsp-&gt;ClassifyPoint(puv, dummy, this) : SBspUv::Class::OUTSIDE;
    if(trimmed &amp;&amp; c == SBspUv::Class::OUTSIDE) {
        continue;
    }

    // It does, so generate the intersection
    SInter si;
    si.p = pxyz;
    si.surfNormal = NormalAt(puv.x, puv.y);
    si.pinter = puv;
    si.srf = this;
    si.onEdge = (c != SBspUv::Class::INSIDE);
    l-&gt;Add(&amp;si);
}

inters.Clear();
</t>
<t tx="leo.20191228122651.109">void SShell::AllPointsIntersecting(Vector a, Vector b,
                                   List&lt;SInter&gt; *il,
                                   bool asSegment, bool trimmed, bool inclTangent)
{
    SSurface *ss;
    for(ss = surface.First(); ss; ss = surface.NextAfter(ss)) {
        ss-&gt;AllPointsIntersecting(a, b, il,
            asSegment, trimmed, inclTangent);
    }
}



SShell::Class SShell::ClassifyRegion(Vector edge_n, Vector inter_surf_n,
                           Vector edge_surf_n) const
{
    double dot = inter_surf_n.DirectionCosineWith(edge_n);
    if(fabs(dot) &lt; DOTP_TOL) {
        // The edge's surface and the edge-on-face surface
        // are coincident. Test the edge's surface normal
        // to see if it's with same or opposite normals.
        if(inter_surf_n.Dot(edge_surf_n) &gt; 0) {
            return Class::COINC_SAME;
        } else {
            return Class::COINC_OPP;
        }
    } else if(dot &gt; 0) {
        return Class::OUTSIDE;
    } else {
        return Class::INSIDE;
    }
}

//-----------------------------------------------------------------------------
// Does the given point lie on our shell? There are many cases; inside and
// outside are obvious, but then there's all the edge-on-edge and edge-on-face
// possibilities.
//
// To calculate, we intersect a ray through p with our shell, and classify
// using the closest intersection point. If the ray hits a surface on edge,
// then just reattempt in a different random direction.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.11">bool DrawBeziers(const SBezierList &amp;bl, hStroke hcs) override {
    return false;
}

</t>
<t tx="leo.20191228122651.110">bool SShell::ClassifyEdge(Class *indir, Class *outdir,
                          Vector ea, Vector eb,
                          Vector p,
                          Vector edge_n_in, Vector edge_n_out, Vector surf_n)
{
    List&lt;SInter&gt; l = {};

    srand(0);

    // First, check for edge-on-edge
    int edge_inters = 0;
    Vector inter_surf_n[2], inter_edge_n[2];
    SSurface *srf;
    for(srf = surface.First(); srf; srf = surface.NextAfter(srf)) {
        if(srf-&gt;LineEntirelyOutsideBbox(ea, eb, /*asSegment=*/true)) continue;

        SEdgeList *sel = &amp;(srf-&gt;edges);
        SEdge *se;
        for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
            if((ea.Equals(se-&gt;a) &amp;&amp; eb.Equals(se-&gt;b)) ||
               (eb.Equals(se-&gt;a) &amp;&amp; ea.Equals(se-&gt;b)) ||
                p.OnLineSegment(se-&gt;a, se-&gt;b))
            {
                if(edge_inters &lt; 2) {
                    // Edge-on-edge case
                    Point2d pm;
                    srf-&gt;ClosestPointTo(p,  &amp;pm, /*mustConverge=*/false);
                    // A vector normal to the surface, at the intersection point
                    inter_surf_n[edge_inters] = srf-&gt;NormalAt(pm);
                    // A vector normal to the intersecting edge (but within the
                    // intersecting surface) at the intersection point, pointing
                    // out.
                    @others
}

</t>
<t tx="leo.20191228122651.111">                inter_edge_n[edge_inters] =
                  (inter_surf_n[edge_inters]).Cross((se-&gt;b).Minus((se-&gt;a)));
            }

            edge_inters++;
        }
    }
}

if(edge_inters == 2) {
    //! @todo make this use the appropriate curved normals
    double dotp[2];
    for(int i = 0; i &lt; 2; i++) {
        dotp[i] = edge_n_out.DirectionCosineWith(inter_surf_n[i]);
    }

    if(fabs(dotp[1]) &lt; DOTP_TOL) {
        swap(dotp[0],         dotp[1]);
        swap(inter_surf_n[0], inter_surf_n[1]);
        swap(inter_edge_n[0], inter_edge_n[1]);
    }

    Class coinc = (surf_n.Dot(inter_surf_n[0])) &gt; 0 ? Class::COINC_SAME : Class::COINC_OPP;

    if(fabs(dotp[0]) &lt; DOTP_TOL &amp;&amp; fabs(dotp[1]) &lt; DOTP_TOL) {
        // This is actually an edge on face case, just that the face
        // is split into two pieces joining at our edge.
        *indir  = coinc;
        *outdir = coinc;
    } else if(fabs(dotp[0]) &lt; DOTP_TOL &amp;&amp; dotp[1] &gt; DOTP_TOL) {
        if(edge_n_out.Dot(inter_edge_n[0]) &gt; 0) {
            *indir  = coinc;
            *outdir = Class::OUTSIDE;
        } else {
            *indir  = Class::INSIDE;
            *outdir = coinc;
        }
    } else if(fabs(dotp[0]) &lt; DOTP_TOL &amp;&amp; dotp[1] &lt; -DOTP_TOL) {
        if(edge_n_out.Dot(inter_edge_n[0]) &gt; 0) {
            *indir  = coinc;
            *outdir = Class::INSIDE;
        } else {
            *indir  = Class::OUTSIDE;
            *outdir = coinc;
        }
    } else if(dotp[0] &gt; DOTP_TOL &amp;&amp; dotp[1] &gt; DOTP_TOL) {
        *indir  = Class::INSIDE;
        *outdir = Class::OUTSIDE;
    } else if(dotp[0] &lt; -DOTP_TOL &amp;&amp; dotp[1] &lt; -DOTP_TOL) {
        *indir  = Class::OUTSIDE;
        *outdir = Class::INSIDE;
    } else {
        // Edge is tangent to the shell at shell's edge, so can't be
        // a boundary of the surface.
        return false;
    }
    return true;
}

if(edge_inters != 0) dbp("bad, edge_inters=%d", edge_inters);

// Next, check for edge-on-surface. The ray-casting for edge-inside-shell
// would catch this too, but test separately, for speed (since many edges
// are on surface) and for numerical stability, so we don't pick up
// the additional error from the line intersection.

for(srf = surface.First(); srf; srf = surface.NextAfter(srf)) {
    if(srf-&gt;LineEntirelyOutsideBbox(ea, eb, /*asSegment=*/true)) continue;

    Point2d puv;
    srf-&gt;ClosestPointTo(p, &amp;(puv.x), &amp;(puv.y), /*mustConverge=*/false);
    Vector pp = srf-&gt;PointAt(puv);

    if((pp.Minus(p)).Magnitude() &gt; LENGTH_EPS) continue;
    Point2d dummy = { 0, 0 };
    SBspUv::Class c = (srf-&gt;bsp) ? srf-&gt;bsp-&gt;ClassifyPoint(puv, dummy, srf) : SBspUv::Class::OUTSIDE;
    if(c == SBspUv::Class::OUTSIDE) continue;

    // Edge-on-face (unless edge-on-edge above superceded)
    Point2d pin, pout;
    srf-&gt;ClosestPointTo(p.Plus(edge_n_in),  &amp;pin,  /*mustConverge=*/false);
    srf-&gt;ClosestPointTo(p.Plus(edge_n_out), &amp;pout, /*mustConverge=*/false);

    Vector surf_n_in  = srf-&gt;NormalAt(pin),
           surf_n_out = srf-&gt;NormalAt(pout);

    *indir  = ClassifyRegion(edge_n_in,  surf_n_in,  surf_n);
    *outdir = ClassifyRegion(edge_n_out, surf_n_out, surf_n);
    return true;
}

// Edge is not on face or on edge; so it's either inside or outside
// the shell, and we'll determine which by raycasting.
int cnt = 0;
for(;;) {
    // Cast a ray in a random direction (two-sided so that we test if
    // the point lies on a surface, but use only one side for in/out
    // testing)
    Vector ray = Vector::From(Random(1), Random(1), Random(1));

    AllPointsIntersecting(
        p.Minus(ray), p.Plus(ray), &amp;l,
            /*asSegment=*/false, /*trimmed=*/true, /*inclTangent=*/false);

    // no intersections means it's outside
    *indir  = Class::OUTSIDE;
    *outdir = Class::OUTSIDE;
    double dmin = VERY_POSITIVE;
    bool onEdge = false;
    edge_inters = 0;

    SInter *si;
    for(si = l.First(); si; si = l.NextAfter(si)) {
        double t = ((si-&gt;p).Minus(p)).DivProjected(ray);
        if(t*ray.Magnitude() &lt; -LENGTH_EPS) {
            // wrong side, doesn't count
            continue;
        }

        double d = ((si-&gt;p).Minus(p)).Magnitude();

        // We actually should never hit this case; it should have been
        // handled above.
        if(d &lt; LENGTH_EPS &amp;&amp; si-&gt;onEdge) {
            edge_inters++;
        }

        if(d &lt; dmin) {
            dmin = d;
            // Edge does not lie on surface; either strictly inside
            // or strictly outside
            if((si-&gt;surfNormal).Dot(ray) &gt; 0) {
                *indir  = Class::INSIDE;
                *outdir = Class::INSIDE;
            } else {
                *indir  = Class::OUTSIDE;
                *outdir = Class::OUTSIDE;
            }
            onEdge = si-&gt;onEdge;
        }
    }
    l.Clear();

    // If the point being tested lies exactly on an edge of the shell,
    // then our ray always lies on edge, and that's okay. Otherwise
    // try again in a different random direction.
    if(!onEdge) break;
    if(cnt++ &gt; 5) {
        dbp("can't find a ray that doesn't hit on edge!");
        dbp("on edge = %d, edge_inters = %d", onEdge, edge_inters);
        SS.nakedEdges.AddEdge(ea, eb);
        break;
    }
}

return true;
</t>
<t tx="leo.20191228122651.112">@path ./src/srf/
//-----------------------------------------------------------------------------
// Anything involving surfaces and sets of surfaces (i.e., shells); except
// for the real math, which is in ratpoly.cpp.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "../solvespace.h"

SSurface SSurface::FromExtrusionOf(SBezier *sb, Vector t0, Vector t1) {
    SSurface ret = {};

    ret.degm = sb-&gt;deg;
    ret.degn = 1;

    int i;
    for(i = 0; i &lt;= ret.degm; i++) {
        ret.ctrl[i][0] = (sb-&gt;ctrl[i]).Plus(t0);
        ret.weight[i][0] = sb-&gt;weight[i];

        ret.ctrl[i][1] = (sb-&gt;ctrl[i]).Plus(t1);
        ret.weight[i][1] = sb-&gt;weight[i];
    }

    return ret;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122651.113">bool SSurface::IsExtrusion(SBezier *of, Vector *alongp) const {
    int i;

    if(degn != 1) return false;

    Vector along = (ctrl[0][1]).Minus(ctrl[0][0]);
    for(i = 0; i &lt;= degm; i++) {
        if((fabs(weight[i][1] - weight[i][0]) &lt; LENGTH_EPS) &amp;&amp;
           ((ctrl[i][1]).Minus(ctrl[i][0])).Equals(along))
        {
            continue;
        }
        return false;
    }

    // yes, we are a surface of extrusion; copy the original curve and return
    if(of) {
        for(i = 0; i &lt;= degm; i++) {
            of-&gt;weight[i] = weight[i][0];
            of-&gt;ctrl[i] = ctrl[i][0];
        }
        of-&gt;deg = degm;
        *alongp = along;
    }
    return true;
}

</t>
<t tx="leo.20191228122651.114">bool SSurface::IsCylinder(Vector *axis, Vector *center, double *r,
                            Vector *start, Vector *finish) const
{
    SBezier sb;
    if(!IsExtrusion(&amp;sb, axis)) return false;
    if(!sb.IsCircle(*axis, center, r)) return false;

    *start = sb.ctrl[0];
    *finish = sb.ctrl[2];
    return true;
}

// Create a surface patch by revolving and possibly translating a curve.
// Works for sections up to but not including 180 degrees.
SSurface SSurface::FromRevolutionOf(SBezier *sb, Vector pt, Vector axis, double thetas,
</t>
<t tx="leo.20191228122651.115">                                    double thetaf, double dists,
                                    double distf) { // s is start, f is finish
    SSurface ret = {};
    ret.degm = sb-&gt;deg;
    ret.degn = 2;

    double dtheta = fabs(WRAP_SYMMETRIC(thetaf - thetas, 2*PI));
    double w      = cos(dtheta / 2);

    // Revolve the curve about the z axis
    int i;
    for(i = 0; i &lt;= ret.degm; i++) {
        Vector p = sb-&gt;ctrl[i];

        Vector ps = p.RotatedAbout(pt, axis, thetas),
               pf = p.RotatedAbout(pt, axis, thetaf);

        // The middle control point should be at the intersection of the tangents at ps and pf.
        // This is equivalent but works for 0 &lt;= angle &lt; 180 degrees.
        Vector mid = ps.Plus(pf).ScaledBy(0.5);
        Vector c   = ps.ClosestPointOnLine(pt, axis);
        Vector ct  = mid.Minus(c).ScaledBy(1 / (w * w)).Plus(c);

        // not sure this is needed
        if(ps.Equals(pf)) {
            ps = c;
            ct = c;
            pf = c;
        }
        // moving along the axis can create hilical surfaces (or straight extrusion if
        // thetas==thetaf)
        ret.ctrl[i][0] = ps.Plus(axis.ScaledBy(dists));
        ret.ctrl[i][1] = ct.Plus(axis.ScaledBy((dists + distf) / 2));
        ret.ctrl[i][2] = pf.Plus(axis.ScaledBy(distf));

        ret.weight[i][0] = sb-&gt;weight[i];
        ret.weight[i][1] = sb-&gt;weight[i] * w;
        ret.weight[i][2] = sb-&gt;weight[i];
    }

    return ret;
}

SSurface SSurface::FromPlane(Vector pt, Vector u, Vector v) {
    SSurface ret = {};

    ret.degm = 1;
    ret.degn = 1;

    ret.weight[0][0] = ret.weight[0][1] = 1;
    ret.weight[1][0] = ret.weight[1][1] = 1;

    ret.ctrl[0][0] = pt;
    ret.ctrl[0][1] = pt.Plus(u);
    ret.ctrl[1][0] = pt.Plus(v);
    ret.ctrl[1][1] = pt.Plus(v).Plus(u);

    return ret;
}

SSurface SSurface::FromTransformationOf(SSurface *a, Vector t, Quaternion q, double scale,
</t>
<t tx="leo.20191228122651.116">                                        bool includingTrims)
{
    bool needRotate    = !EXACT(q.vx == 0.0 &amp;&amp; q.vy == 0.0 &amp;&amp; q.vz == 0.0 &amp;&amp; q.w == 1.0);
    bool needTranslate = !EXACT(t.x  == 0.0 &amp;&amp; t.y  == 0.0 &amp;&amp; t.z  == 0.0);
    bool needScale     = !EXACT(scale == 1.0);

    SSurface ret = {};
    ret.h = a-&gt;h;
    ret.color = a-&gt;color;
    ret.face = a-&gt;face;

    ret.degm = a-&gt;degm;
    ret.degn = a-&gt;degn;
    int i, j;
    for(i = 0; i &lt;= 3; i++) {
        for(j = 0; j &lt;= 3; j++) {
            Vector ctrl = a-&gt;ctrl[i][j];
            if(needScale) {
                ctrl = ctrl.ScaledBy(scale);
            }
            if(needRotate) {
                ctrl = q.Rotate(ctrl);
            }
            if(needTranslate) {
                ctrl = ctrl.Plus(t);
            }
            ret.ctrl[i][j] = ctrl;
            ret.weight[i][j] = a-&gt;weight[i][j];
        }
    }

    if(includingTrims) {
        STrimBy *stb;
        ret.trim.ReserveMore(a-&gt;trim.n);
        for(stb = a-&gt;trim.First(); stb; stb = a-&gt;trim.NextAfter(stb)) {
            STrimBy n = *stb;
            if(needScale) {
                n.start  = n.start.ScaledBy(scale);
                n.finish = n.finish.ScaledBy(scale);
            }
            if(needRotate) {
                n.start  = q.Rotate(n.start);
                n.finish = q.Rotate(n.finish);
            }
            if(needTranslate) {
                n.start  = n.start.Plus(t);
                n.finish = n.finish.Plus(t);
            }
            ret.trim.Add(&amp;n);
        }
    }

    if(scale &lt; 0) {
        // If we mirror every surface of a shell, then it will end up inside
        // out. So fix that here.
        ret.Reverse();
    }

    return ret;
}

</t>
<t tx="leo.20191228122651.117">void SSurface::GetAxisAlignedBounding(Vector *ptMax, Vector *ptMin) const {
    *ptMax = Vector::From(VERY_NEGATIVE, VERY_NEGATIVE, VERY_NEGATIVE);
    *ptMin = Vector::From(VERY_POSITIVE, VERY_POSITIVE, VERY_POSITIVE);

    int i, j;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            (ctrl[i][j]).MakeMaxMin(ptMax, ptMin);
        }
    }
}

</t>
<t tx="leo.20191228122651.118">bool SSurface::LineEntirelyOutsideBbox(Vector a, Vector b, bool asSegment) const {
    Vector amax, amin;
    GetAxisAlignedBounding(&amp;amax, &amp;amin);
    if(!Vector::BoundingBoxIntersectsLine(amax, amin, a, b, asSegment)) {
        // The line segment could fail to intersect the bbox, but lie entirely
        // within it and intersect the surface.
        if(a.OutsideAndNotOn(amax, amin) &amp;&amp; b.OutsideAndNotOn(amax, amin)) {
            return true;
        }
    }
    return false;
}

//-----------------------------------------------------------------------------
// Generate the piecewise linear approximation of the trim stb, which applies
// to the curve sc.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.119">void SSurface::MakeTrimEdgesInto(SEdgeList *sel, MakeAs flags,
                                 SCurve *sc, STrimBy *stb)
{
    Vector prev = Vector::From(0, 0, 0);
    bool inCurve = false, empty = true;
    double u = 0, v = 0;

    int i, first, last, increment;
    if(stb-&gt;backwards) {
        first = sc-&gt;pts.n - 1;
        last = 0;
        increment = -1;
    } else {
        first = 0;
        last = sc-&gt;pts.n - 1;
        increment = 1;
    }
    for(i = first; i != (last + increment); i += increment) {
        Vector tpt, *pt = &amp;(sc-&gt;pts[i].p);

        if(flags == MakeAs::UV) {
            ClosestPointTo(*pt, &amp;u, &amp;v);
            tpt = Vector::From(u, v, 0);
        } else {
            tpt = *pt;
        }

        if(inCurve) {
            sel-&gt;AddEdge(prev, tpt, sc-&gt;h.v, stb-&gt;backwards);
            empty = false;
        }

        prev = tpt;     // either uv or xyz, depending on flags

        if(pt-&gt;Equals(stb-&gt;start)) inCurve = true;
        if(pt-&gt;Equals(stb-&gt;finish)) inCurve = false;
    }
    if(inCurve) dbp("trim was unterminated");
    if(empty)   dbp("trim was empty");
}

//-----------------------------------------------------------------------------
// Generate all of our trim curves, in piecewise linear form. We can do
// so in either uv or xyz coordinates. And if requested, then we can use
// the split curves from useCurvesFrom instead of the curves in our own
// shell.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.12">void DrawOutlines(const SOutlineList &amp;ol, hStroke hcs, DrawOutlinesAs drawAs) override {
    drawCalls.emplace(OutlineDrawCall::Create(renderer, ol, strokes.FindById(hcs), drawAs));
}

</t>
<t tx="leo.20191228122651.120">void SSurface::MakeEdgesInto(SShell *shell, SEdgeList *sel, MakeAs flags,
                             SShell *useCurvesFrom)
{
    STrimBy *stb;
    for(stb = trim.First(); stb; stb = trim.NextAfter(stb)) {
        SCurve *sc = shell-&gt;curve.FindById(stb-&gt;curve);

        // We have the option to use the curves from another shell; this
        // is relevant when generating the coincident edges while doing the
        // Booleans, since the curves from the output shell will be split
        // against any intersecting surfaces (and the originals aren't).
        if(useCurvesFrom) {
            sc = useCurvesFrom-&gt;curve.FindById(sc-&gt;newH);
        }

        MakeTrimEdgesInto(sel, flags, sc, stb);
    }
}

//-----------------------------------------------------------------------------
// Compute the exact tangent to the intersection curve between two surfaces,
// by taking the cross product of the surface normals. We choose the direction
// of this tangent so that its dot product with dir is positive.
//-----------------------------------------------------------------------------
Vector SSurface::ExactSurfaceTangentAt(Vector p, SSurface *srfA, SSurface *srfB, Vector dir)
{
    Point2d puva, puvb;
    srfA-&gt;ClosestPointTo(p, &amp;puva);
    srfB-&gt;ClosestPointTo(p, &amp;puvb);
    Vector ts = (srfA-&gt;NormalAt(puva)).Cross(
                (srfB-&gt;NormalAt(puvb)));
    ts = ts.WithMagnitude(1);
    if(ts.Dot(dir) &lt; 0) {
        ts = ts.ScaledBy(-1);
    }
    return ts;
}

//-----------------------------------------------------------------------------
// Report our trim curves. If a trim curve is exact and sbl is not null, then
// add its exact form to sbl. Otherwise, add its piecewise linearization to
// sel.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.121">void SSurface::MakeSectionEdgesInto(SShell *shell, SEdgeList *sel, SBezierList *sbl)
{
    STrimBy *stb;
    for(stb = trim.First(); stb; stb = trim.NextAfter(stb)) {
        SCurve *sc = shell-&gt;curve.FindById(stb-&gt;curve);
        SBezier *sb = &amp;(sc-&gt;exact);

        if(sbl &amp;&amp; sc-&gt;isExact &amp;&amp; (sb-&gt;deg != 1 || !sel)) {
            double ts, tf;
            if(stb-&gt;backwards) {
                sb-&gt;ClosestPointTo(stb-&gt;start,  &amp;tf);
                sb-&gt;ClosestPointTo(stb-&gt;finish, &amp;ts);
            } else {
                sb-&gt;ClosestPointTo(stb-&gt;start,  &amp;ts);
                sb-&gt;ClosestPointTo(stb-&gt;finish, &amp;tf);
            }
            SBezier junk_bef, keep_aft;
            sb-&gt;SplitAt(ts, &amp;junk_bef, &amp;keep_aft);
            // In the kept piece, the range that used to go from ts to 1
            // now goes from 0 to 1; so rescale tf appropriately.
            tf = (tf - ts)/(1 - ts);

            SBezier keep_bef, junk_aft;
            keep_aft.SplitAt(tf, &amp;keep_bef, &amp;junk_aft);

            sbl-&gt;l.Add(&amp;keep_bef);
        } else if(sbl &amp;&amp; !sel &amp;&amp; !sc-&gt;isExact) {
            // We must approximate this trim curve, as piecewise cubic sections.
            SSurface *srfA = shell-&gt;surface.FindById(sc-&gt;surfA);
            SSurface *srfB = shell-&gt;surface.FindById(sc-&gt;surfB);

            Vector s = stb-&gt;backwards ? stb-&gt;finish : stb-&gt;start,
                   f = stb-&gt;backwards ? stb-&gt;start : stb-&gt;finish;

            int sp, fp;
            for(sp = 0; sp &lt; sc-&gt;pts.n; sp++) {
                if(s.Equals(sc-&gt;pts[sp].p)) break;
            }
            if(sp &gt;= sc-&gt;pts.n) return;
            for(fp = sp; fp &lt; sc-&gt;pts.n; fp++) {
                if(f.Equals(sc-&gt;pts[fp].p)) break;
            }
            if(fp &gt;= sc-&gt;pts.n) return;
            // So now the curve we want goes from elem[sp] to elem[fp]

            while(sp &lt; fp) {
                // Initially, we'll try approximating the entire trim curve
                // as a single Bezier segment
                int fpt = fp;

                for(;;) {
                    // So construct a cubic Bezier with the correct endpoints
                    // and tangents for the current span.
                    Vector st = sc-&gt;pts[sp].p,
                           ft = sc-&gt;pts[fpt].p,
                           sf = ft.Minus(st);
                    double m = sf.Magnitude() / 3;

                    Vector stan = ExactSurfaceTangentAt(st, srfA, srfB, sf),
                           ftan = ExactSurfaceTangentAt(ft, srfA, srfB, sf);

                    SBezier sb = SBezier::From(st,
                                               st.Plus (stan.WithMagnitude(m)),
                                               ft.Minus(ftan.WithMagnitude(m)),
                                               ft);

                    // And test how much this curve deviates from the
                    // intermediate points (if any).
                    int i;
                    bool tooFar = false;
                    for(i = sp + 1; i &lt;= (fpt - 1); i++) {
                        Vector p = sc-&gt;pts[i].p;
                        double t;
                        sb.ClosestPointTo(p, &amp;t, /*mustConverge=*/false);
                        Vector pp = sb.PointAt(t);
                        if((pp.Minus(p)).Magnitude() &gt; SS.ChordTolMm()/2) {
                            tooFar = true;
                            break;
                        }
                    }

                    if(tooFar) {
                        // Deviates by too much, so try a shorter span
                        fpt--;
                        continue;
                    } else {
                        // Okay, so use this piece and break.
                        sbl-&gt;l.Add(&amp;sb);
                        break;
                    }
                }

                // And continue interpolating, starting wherever the curve
                // we just generated finishes.
                sp = fpt;
            }
        } else {
            if(sel) MakeTrimEdgesInto(sel, MakeAs::XYZ, sc, stb);
        }
    }
}

</t>
<t tx="leo.20191228122651.122">void SSurface::TriangulateInto(SShell *shell, SMesh *sm) {
    SEdgeList el = {};

    MakeEdgesInto(shell, &amp;el, MakeAs::UV);

    SPolygon poly = {};
    if(el.AssemblePolygon(&amp;poly, NULL, /*keepDir=*/true)) {
        int i, start = sm-&gt;l.n;
        if(degm == 1 &amp;&amp; degn == 1) {
            // A surface with curvature along one direction only; so
            // choose the triangulation with chords that lie as much
            // as possible within the surface. And since the trim curves
            // have been pwl'd to within the desired chord tol, that will
            // produce a surface good to within roughly that tol.
            //
            // If this is just a plane (degree (1, 1)) then the triangulation
            // code will notice that, and not bother checking chord tols.
            poly.UvTriangulateInto(sm, this);
        } else {
            // A surface with compound curvature. So we must overlay a
            // two-dimensional grid, and triangulate around that.
            poly.UvGridTriangulateInto(sm, this);
        }

        STriMeta meta = { face, color };
        for(i = start; i &lt; sm-&gt;l.n; i++) {
            STriangle *st = &amp;(sm-&gt;l[i]);
            st-&gt;meta = meta;
            st-&gt;an = NormalAt(st-&gt;a.x, st-&gt;a.y);
            st-&gt;bn = NormalAt(st-&gt;b.x, st-&gt;b.y);
            st-&gt;cn = NormalAt(st-&gt;c.x, st-&gt;c.y);
            st-&gt;a = PointAt(st-&gt;a.x, st-&gt;a.y);
            st-&gt;b = PointAt(st-&gt;b.x, st-&gt;b.y);
            st-&gt;c = PointAt(st-&gt;c.x, st-&gt;c.y);
            // Works out that my chosen contour direction is inconsistent with
            // the triangle direction, sigh.
            st-&gt;FlipNormal();
        }
    } else {
        dbp("failed to assemble polygon to trim nurbs surface in uv space");
    }

    el.Clear();
    poly.Clear();
}

//-----------------------------------------------------------------------------
// Reverse the parametrisation of one of our dimensions, which flips the
// normal. We therefore must reverse all our trim curves too. The uv
// coordinates change, but trim curves are stored as xyz so nothing happens
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.123">void SSurface::Reverse() {
    int i, j;
    for(i = 0; i &lt; (degm+1)/2; i++) {
        for(j = 0; j &lt;= degn; j++) {
            swap(ctrl[i][j], ctrl[degm-i][j]);
            swap(weight[i][j], weight[degm-i][j]);
        }
    }

    STrimBy *stb;
    for(stb = trim.First(); stb; stb = trim.NextAfter(stb)) {
        stb-&gt;backwards = !stb-&gt;backwards;
        swap(stb-&gt;start, stb-&gt;finish);
    }
}

</t>
<t tx="leo.20191228122651.124">void SSurface::ScaleSelfBy(double s) {
    int i, j;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            ctrl[i][j] = ctrl[i][j].ScaledBy(s);
        }
    }
}

</t>
<t tx="leo.20191228122651.125">void SSurface::Clear() {
    trim.Clear();
}

</t>
<t tx="leo.20191228122651.126">typedef struct {
    hSCurve     hc;
    hSSurface   hs;
} TrimLine;

</t>
<t tx="leo.20191228122651.127">void SShell::MakeFromExtrusionOf(SBezierLoopSet *sbls, Vector t0, Vector t1, RgbaColor color)
{
    // Make the extrusion direction consistent with respect to the normal
    // of the sketch we're extruding.
    if((t0.Minus(t1)).Dot(sbls-&gt;normal) &lt; 0) {
        swap(t0, t1);
    }

    // Define a coordinate system to contain the original sketch, and get
    // a bounding box in that csys
    Vector n = sbls-&gt;normal.ScaledBy(-1);
    Vector u = n.Normal(0), v = n.Normal(1);
    Vector orig = sbls-&gt;point;
    double umax = 1e-10, umin = 1e10;
    sbls-&gt;GetBoundingProjd(u, orig, &amp;umin, &amp;umax);
    double vmax = 1e-10, vmin = 1e10;
    sbls-&gt;GetBoundingProjd(v, orig, &amp;vmin, &amp;vmax);
    // and now fix things up so that all u and v lie between 0 and 1
    orig = orig.Plus(u.ScaledBy(umin));
    orig = orig.Plus(v.ScaledBy(vmin));
    u = u.ScaledBy(umax - umin);
    v = v.ScaledBy(vmax - vmin);

    // So we can now generate the top and bottom surfaces of the extrusion,
    // planes within a translated (and maybe mirrored) version of that csys.
    SSurface s0, s1;
    s0 = SSurface::FromPlane(orig.Plus(t0), u, v);
    s0.color = color;
    s1 = SSurface::FromPlane(orig.Plus(t1).Plus(u), u.ScaledBy(-1), v);
    s1.color = color;
    hSSurface hs0 = surface.AddAndAssignId(&amp;s0),
              hs1 = surface.AddAndAssignId(&amp;s1);

    // Now go through the input curves. For each one, generate its surface
    // of extrusion, its two translated trim curves, and one trim line. We
    // go through by loops so that we can assign the lines correctly.
    SBezierLoop *sbl;
    for(sbl = sbls-&gt;l.First(); sbl; sbl = sbls-&gt;l.NextAfter(sbl)) {
        SBezier *sb;
        List&lt;TrimLine&gt; trimLines = {};

        for(sb = sbl-&gt;l.First(); sb; sb = sbl-&gt;l.NextAfter(sb)) {
            // Generate the surface of extrusion of this curve, and add
            // it to the list
            SSurface ss = SSurface::FromExtrusionOf(sb, t0, t1);
            ss.color = color;
            hSSurface hsext = surface.AddAndAssignId(&amp;ss);

            // Translate the curve by t0 and t1 to produce two trim curves
            SCurve sc = {};
            sc.isExact = true;
            sc.exact = sb-&gt;TransformedBy(t0, Quaternion::IDENTITY, 1.0);
            (sc.exact).MakePwlInto(&amp;(sc.pts));
            sc.surfA = hs0;
            sc.surfB = hsext;
            hSCurve hc0 = curve.AddAndAssignId(&amp;sc);

            sc = {};
            sc.isExact = true;
            sc.exact = sb-&gt;TransformedBy(t1, Quaternion::IDENTITY, 1.0);
            (sc.exact).MakePwlInto(&amp;(sc.pts));
            sc.surfA = hs1;
            sc.surfB = hsext;
            hSCurve hc1 = curve.AddAndAssignId(&amp;sc);

            STrimBy stb0, stb1;
            // The translated curves trim the flat top and bottom surfaces.
            stb0 = STrimBy::EntireCurve(this, hc0, /*backwards=*/false);
            stb1 = STrimBy::EntireCurve(this, hc1, /*backwards=*/true);
            (surface.FindById(hs0))-&gt;trim.Add(&amp;stb0);
            (surface.FindById(hs1))-&gt;trim.Add(&amp;stb1);

            // The translated curves also trim the surface of extrusion.
            stb0 = STrimBy::EntireCurve(this, hc0, /*backwards=*/true);
            stb1 = STrimBy::EntireCurve(this, hc1, /*backwards=*/false);
            (surface.FindById(hsext))-&gt;trim.Add(&amp;stb0);
            (surface.FindById(hsext))-&gt;trim.Add(&amp;stb1);

            // And form the trim line
            Vector pt = sb-&gt;Finish();
            sc = {};
            sc.isExact = true;
            sc.exact = SBezier::From(pt.Plus(t0), pt.Plus(t1));
            (sc.exact).MakePwlInto(&amp;(sc.pts));
            hSCurve hl = curve.AddAndAssignId(&amp;sc);
            // save this for later
            TrimLine tl;
            tl.hc = hl;
            tl.hs = hsext;
            trimLines.Add(&amp;tl);
        }

        int i;
        for(i = 0; i &lt; trimLines.n; i++) {
            TrimLine *tl = &amp;(trimLines[i]);
            SSurface *ss = surface.FindById(tl-&gt;hs);

            TrimLine *tlp = &amp;(trimLines[WRAP(i-1, trimLines.n)]);

            STrimBy stb;
            stb = STrimBy::EntireCurve(this, tl-&gt;hc, /*backwards=*/true);
            ss-&gt;trim.Add(&amp;stb);
            stb = STrimBy::EntireCurve(this, tlp-&gt;hc, /*backwards=*/false);
            ss-&gt;trim.Add(&amp;stb);

            (curve.FindById(tl-&gt;hc))-&gt;surfA = ss-&gt;h;
            (curve.FindById(tlp-&gt;hc))-&gt;surfB = ss-&gt;h;
        }
        trimLines.Clear();
    }
}

</t>
<t tx="leo.20191228122651.128">bool SShell::CheckNormalAxisRelationship(SBezierLoopSet *sbls, Vector pt, Vector axis, double da, double dx)
// Check that the direction of revolution/extrusion ends up parallel to the normal of
// the sketch, on the side of the axis where the sketch is.
{
    SBezierLoop *sbl;
    Vector pto;
    double md = VERY_NEGATIVE;
    for(sbl = sbls-&gt;l.First(); sbl; sbl = sbls-&gt;l.NextAfter(sbl)) {
        SBezier *sb;
        for(sb = sbl-&gt;l.First(); sb; sb = sbl-&gt;l.NextAfter(sb)) {
            // Choose the point farthest from the axis; we'll get garbage
            // if we choose a point that lies on the axis, for example.
            // (And our surface will be self-intersecting if the sketch
            // spans the axis, so don't worry about that.)
            for(int i = 0; i &lt;= sb-&gt;deg; i++) {
                Vector p = sb-&gt;ctrl[i];
                double d = p.DistanceToLine(pt, axis);
                if(d &gt; md) {
                    md  = d;
                    pto = p;
                }
            }
        }
    }
    Vector ptc = pto.ClosestPointOnLine(pt, axis),
           up = axis.Cross(pto.Minus(ptc)).ScaledBy(da),
           vp = up.Plus(axis.ScaledBy(dx));
   
    return (vp.Dot(sbls-&gt;normal) &gt; 0);
}

// sketch must not contain the axis of revolution as a non-construction line for helix
</t>
<t tx="leo.20191228122651.129">void SShell::MakeFromHelicalRevolutionOf(SBezierLoopSet *sbls, Vector pt, Vector axis,
                                         RgbaColor color, Group *group, double angles,
                                         double anglef, double dists, double distf) {
    int i0 = surface.n; // number of pre-existing surfaces
    SBezierLoop *sbl;
    // for testing - hard code the axial distance, and number of sections.
    // distance will need to be parameters in the future.
    double dist  = distf - dists;
    int sections = (int)(fabs(anglef - angles) / (PI / 2) + 1);
    double wedge = (anglef - angles) / sections;

    if(CheckNormalAxisRelationship(sbls, pt, axis, anglef-angles, distf-dists)) {
        swap(angles, anglef);
        swap(dists, distf);
        dist  = -dist;
        wedge = -wedge;
    }

    // Define a coordinate system to contain the original sketch, and get
    // a bounding box in that csys
    Vector n = sbls-&gt;normal.ScaledBy(-1);
    Vector u = n.Normal(0), v = n.Normal(1);
    Vector orig = sbls-&gt;point;
    double umax = 1e-10, umin = 1e10;
    sbls-&gt;GetBoundingProjd(u, orig, &amp;umin, &amp;umax);
    double vmax = 1e-10, vmin = 1e10;
    sbls-&gt;GetBoundingProjd(v, orig, &amp;vmin, &amp;vmax);
    // and now fix things up so that all u and v lie between 0 and 1
    orig = orig.Plus(u.ScaledBy(umin));
    orig = orig.Plus(v.ScaledBy(vmin));
    u    = u.ScaledBy(umax - umin);
    v    = v.ScaledBy(vmax - vmin);

    // So we can now generate the end caps of the extrusion within
    // a translated and rotated (and maybe mirrored) version of that csys.
    SSurface s0, s1;
    s0       = SSurface::FromPlane(orig.RotatedAbout(pt, axis, angles).Plus(axis.ScaledBy(dists)),
                             u.RotatedAbout(axis, angles), v.RotatedAbout(axis, angles));
    s0.color = color;
    s1       = SSurface::FromPlane(
        orig.Plus(u).RotatedAbout(pt, axis, anglef).Plus(axis.ScaledBy(distf)),
        u.ScaledBy(-1).RotatedAbout(axis, anglef), v.RotatedAbout(axis, anglef));
    s1.color      = color;
    hSSurface hs0 = surface.AddAndAssignId(&amp;s0), hs1 = surface.AddAndAssignId(&amp;s1);

    // Now we actually build and trim the swept surfaces. One loop at a time.
    for(sbl = sbls-&gt;l.First(); sbl; sbl = sbls-&gt;l.NextAfter(sbl)) {
        int i, j;
        SBezier *sb;
        List&lt;std::vector&lt;hSSurface&gt;&gt; hsl = {};

        // This is where all the NURBS are created and Remapped to the generating curve
        for(sb = sbl-&gt;l.First(); sb; sb = sbl-&gt;l.NextAfter(sb)) {
            std::vector&lt;hSSurface&gt; revs(sections);
            for(j = 0; j &lt; sections; j++) {
                if((dist == 0) &amp;&amp; sb-&gt;deg == 1 &amp;&amp;
                   (sb-&gt;ctrl[0]).DistanceToLine(pt, axis) &lt; LENGTH_EPS &amp;&amp;
                   (sb-&gt;ctrl[1]).DistanceToLine(pt, axis) &lt; LENGTH_EPS) {
                    // This is a line on the axis of revolution; it does
                    // not contribute a surface.
                    revs[j].v = 0;
                } else {
                    SSurface ss = SSurface::FromRevolutionOf(
                        sb, pt, axis, angles + (wedge)*j, angles + (wedge) * (j + 1),
                        dists + j * dist / sections, dists + (j + 1) * dist / sections);
                    ss.color = color;
                    if(sb-&gt;entity != 0) {
                        hEntity he;
                        he.v          = sb-&gt;entity;
                        hEntity hface = group-&gt;Remap(he, Group::REMAP_LINE_TO_FACE);
                        if(SK.entity.FindByIdNoOops(hface) != NULL) {
                            ss.face = hface.v;
                        }
                    }
                    revs[j] = surface.AddAndAssignId(&amp;ss);
                }
            }
            hsl.Add(&amp;revs);
        }
        // Still the same loop. Need to create trim curves
        for(i = 0; i &lt; sbl-&gt;l.n; i++) {
            std::vector&lt;hSSurface&gt; revs = hsl[i], revsp = hsl[WRAP(i - 1, sbl-&gt;l.n)];

            sb = &amp;(sbl-&gt;l[i]);

            // we generate one more curve than we did surfaces
            for(j = 0; j &lt;= sections; j++) {
                SCurve sc;
                Quaternion qs = Quaternion::From(axis, angles + wedge * j);
                // we want Q*(x - p) + p = Q*x + (p - Q*p)
                Vector ts =
                    pt.Minus(qs.Rotate(pt)).Plus(axis.ScaledBy(dists + j * dist / sections));

                // If this input curve generated a surface, then trim that
                // surface with the rotated version of the input curve.
                if(revs[0].v) { // not d[j] because crash on j==sections
                    sc         = {};
                    sc.isExact = true;
                    sc.exact   = sb-&gt;TransformedBy(ts, qs, 1.0);
                    (sc.exact).MakePwlInto(&amp;(sc.pts));

                    // the surfaces already exist so trim with this curve
                    if(j &lt; sections) {
                        sc.surfA = revs[j];
                    } else {
                        sc.surfA = hs1; // end cap
                    }

                    if(j &gt; 0) {
                        sc.surfB = revs[j - 1];
                    } else {
                        sc.surfB = hs0; // staring cap
                    }
                    hSCurve hcb = curve.AddAndAssignId(&amp;sc);

                    STrimBy stb;
                    stb = STrimBy::EntireCurve(this, hcb, /*backwards=*/true);
                    (surface.FindById(sc.surfA))-&gt;trim.Add(&amp;stb);
                    stb = STrimBy::EntireCurve(this, hcb, /*backwards=*/false);
                    (surface.FindById(sc.surfB))-&gt;trim.Add(&amp;stb);
                } else if(j == 0) { // curve was on the rotation axis and is shared by the end caps.
                    sc         = {};
                    sc.isExact = true;
                    sc.exact   = sb-&gt;TransformedBy(ts, qs, 1.0);
                    (sc.exact).MakePwlInto(&amp;(sc.pts));
                    sc.surfA    = hs1; // end cap
                    sc.surfB    = hs0; // staring cap
                    hSCurve hcb = curve.AddAndAssignId(&amp;sc);

                    STrimBy stb;
                    stb = STrimBy::EntireCurve(this, hcb, /*backwards=*/true);
                    (surface.FindById(sc.surfA))-&gt;trim.Add(&amp;stb);
                    stb = STrimBy::EntireCurve(this, hcb, /*backwards=*/false);
                    (surface.FindById(sc.surfB))-&gt;trim.Add(&amp;stb);
                }

                // And if this input curve and the one after it both generated
                // surfaces, then trim both of those by the appropriate
                // curve based on the control points.
                if((j &lt; sections) &amp;&amp; revs[j].v &amp;&amp; revsp[j].v) {
                    SSurface *ss = surface.FindById(revs[j]);

                    sc         = {};
                    sc.isExact = true;
                    sc.exact   = SBezier::From(ss-&gt;ctrl[0][0], ss-&gt;ctrl[0][1], ss-&gt;ctrl[0][2]);
                    sc.exact.weight[1] = ss-&gt;weight[0][1];
                    (sc.exact).MakePwlInto(&amp;(sc.pts));
                    sc.surfA = revs[j];
                    sc.surfB = revsp[j];

                    hSCurve hcc = curve.AddAndAssignId(&amp;sc);

                    STrimBy stb;
                    stb = STrimBy::EntireCurve(this, hcc, /*backwards=*/false);
                    (surface.FindById(sc.surfA))-&gt;trim.Add(&amp;stb);
                    stb = STrimBy::EntireCurve(this, hcc, /*backwards=*/true);
                    (surface.FindById(sc.surfB))-&gt;trim.Add(&amp;stb);
                }
            }
        }

        hsl.Clear();
    }

    if(dist == 0) {
        MakeFirstOrderRevolvedSurfaces(pt, axis, i0);
    }
}

</t>
<t tx="leo.20191228122651.13">void DrawVectorText(const std::string &amp;text, double height,
                    const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                    hStroke hcs) override {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo.20191228122651.130">void SShell::MakeFromRevolutionOf(SBezierLoopSet *sbls, Vector pt, Vector axis, RgbaColor color,
                                  Group *group) {
    int i0 = surface.n; // number of pre-existing surfaces
    SBezierLoop *sbl;

    if(CheckNormalAxisRelationship(sbls, pt, axis, 1.0, 0.0)) {
        axis = axis.ScaledBy(-1);
    }

    // Now we actually build and trim the surfaces.
    for(sbl = sbls-&gt;l.First(); sbl; sbl = sbls-&gt;l.NextAfter(sbl)) {
        int i, j;
        SBezier *sb;
        List&lt;std::vector&lt;hSSurface&gt;&gt; hsl = {};

        for(sb = sbl-&gt;l.First(); sb; sb = sbl-&gt;l.NextAfter(sb)) {
            std::vector&lt;hSSurface&gt; revs(4);
            for(j = 0; j &lt; 4; j++) {
                if(sb-&gt;deg == 1 &amp;&amp;
                    (sb-&gt;ctrl[0]).DistanceToLine(pt, axis) &lt; LENGTH_EPS &amp;&amp;
                    (sb-&gt;ctrl[1]).DistanceToLine(pt, axis) &lt; LENGTH_EPS)
                {
                    // This is a line on the axis of revolution; it does
                    // not contribute a surface.
                    revs[j].v = 0;
                } else {
                    SSurface ss = SSurface::FromRevolutionOf(sb, pt, axis, (PI / 2) * j,
                                                             (PI / 2) * (j + 1), 0.0, 0.0);
                    ss.color = color;
                    if(sb-&gt;entity != 0) {
                        hEntity he;
                        he.v = sb-&gt;entity;
                        hEntity hface = group-&gt;Remap(he, Group::REMAP_LINE_TO_FACE);
                        if(SK.entity.FindByIdNoOops(hface) != NULL) {
                            ss.face = hface.v;
                        }
                    }
                    revs[j] = surface.AddAndAssignId(&amp;ss);
                }
            }
            hsl.Add(&amp;revs);
        }

        for(i = 0; i &lt; sbl-&gt;l.n; i++) {
            std::vector&lt;hSSurface&gt; revs  = hsl[i],
                     revsp = hsl[WRAP(i-1, sbl-&gt;l.n)];

            sb   = &amp;(sbl-&gt;l[i]);

            for(j = 0; j &lt; 4; j++) {
                SCurve sc;
                Quaternion qs = Quaternion::From(axis, (PI/2)*j);
                // we want Q*(x - p) + p = Q*x + (p - Q*p)
                Vector ts = pt.Minus(qs.Rotate(pt));

                // If this input curve generate a surface, then trim that
                // surface with the rotated version of the input curve.
                if(revs[j].v) {
                    sc = {};
                    sc.isExact = true;
                    sc.exact = sb-&gt;TransformedBy(ts, qs, 1.0);
                    (sc.exact).MakePwlInto(&amp;(sc.pts));
                    sc.surfA = revs[j];
                    sc.surfB = revs[WRAP(j-1, 4)];

                    hSCurve hcb = curve.AddAndAssignId(&amp;sc);

                    STrimBy stb;
                    stb = STrimBy::EntireCurve(this, hcb, /*backwards=*/true);
                    (surface.FindById(sc.surfA))-&gt;trim.Add(&amp;stb);
                    stb = STrimBy::EntireCurve(this, hcb, /*backwards=*/false);
                    (surface.FindById(sc.surfB))-&gt;trim.Add(&amp;stb);
                }

                // And if this input curve and the one after it both generated
                // surfaces, then trim both of those by the appropriate
                // circle.
                if(revs[j].v &amp;&amp; revsp[j].v) {
                    SSurface *ss = surface.FindById(revs[j]);

                    sc = {};
                    sc.isExact = true;
                    sc.exact = SBezier::From(ss-&gt;ctrl[0][0],
                                             ss-&gt;ctrl[0][1],
                                             ss-&gt;ctrl[0][2]);
                    sc.exact.weight[1] = ss-&gt;weight[0][1];
                    (sc.exact).MakePwlInto(&amp;(sc.pts));
                    sc.surfA = revs[j];
                    sc.surfB = revsp[j];

                    hSCurve hcc = curve.AddAndAssignId(&amp;sc);

                    STrimBy stb;
                    stb = STrimBy::EntireCurve(this, hcc, /*backwards=*/false);
                    (surface.FindById(sc.surfA))-&gt;trim.Add(&amp;stb);
                    stb = STrimBy::EntireCurve(this, hcc, /*backwards=*/true);
                    (surface.FindById(sc.surfB))-&gt;trim.Add(&amp;stb);
                }
            }
        }

        hsl.Clear();
    }

    MakeFirstOrderRevolvedSurfaces(pt, axis, i0);
}

</t>
<t tx="leo.20191228122651.131">void SShell::MakeFirstOrderRevolvedSurfaces(Vector pt, Vector axis, int i0) {
    int i;

    for(i = i0; i &lt; surface.n; i++) {
        SSurface *srf = &amp;(surface[i]);

        // Revolution of a line; this is potentially a plane, which we can
        // rewrite to have degree (1, 1).
        if(srf-&gt;degm == 1 &amp;&amp; srf-&gt;degn == 2) {
            // close start, far start, far finish
            Vector cs, fs, ff;
            double d0, d1;
            d0 = (srf-&gt;ctrl[0][0]).DistanceToLine(pt, axis);
            d1 = (srf-&gt;ctrl[1][0]).DistanceToLine(pt, axis);

            if(d0 &gt; d1) {
                cs = srf-&gt;ctrl[1][0];
                fs = srf-&gt;ctrl[0][0];
                ff = srf-&gt;ctrl[0][2];
            } else {
                cs = srf-&gt;ctrl[0][0];
                fs = srf-&gt;ctrl[1][0];
                ff = srf-&gt;ctrl[1][2];
            }

            // origin close, origin far
            Vector oc = cs.ClosestPointOnLine(pt, axis),
                   of = fs.ClosestPointOnLine(pt, axis);

            if(oc.Equals(of)) {
                // This is a plane, not a (non-degenerate) cone.
                Vector oldn = srf-&gt;NormalAt(0.5, 0.5);

                Vector u = fs.Minus(of), v;

                v = (axis.Cross(u)).WithMagnitude(1);

                double vm = (ff.Minus(of)).Dot(v);
                v = v.ScaledBy(vm);

                srf-&gt;degm = 1;
                srf-&gt;degn = 1;
                srf-&gt;ctrl[0][0] = of;
                srf-&gt;ctrl[0][1] = of.Plus(u);
                srf-&gt;ctrl[1][0] = of.Plus(v);
                srf-&gt;ctrl[1][1] = of.Plus(u).Plus(v);
                srf-&gt;weight[0][0] = 1;
                srf-&gt;weight[0][1] = 1;
                srf-&gt;weight[1][0] = 1;
                srf-&gt;weight[1][1] = 1;

                if(oldn.Dot(srf-&gt;NormalAt(0.5, 0.5)) &lt; 0) {
                    swap(srf-&gt;ctrl[0][0], srf-&gt;ctrl[1][0]);
                    swap(srf-&gt;ctrl[0][1], srf-&gt;ctrl[1][1]);
                }
                continue;
            }

            if(fabs(d0 - d1) &lt; LENGTH_EPS) {
                // This is a cylinder; so transpose it so that we'll recognize
                // it as a surface of extrusion.
                SSurface sn = *srf;

                // Transposing u and v flips the normal, so reverse u to
                // flip it again and put it back where we started.
                sn.degm = 2;
                sn.degn = 1;
                int dm, dn;
                for(dm = 0; dm &lt;= 1; dm++) {
                    for(dn = 0; dn &lt;= 2; dn++) {
                        sn.ctrl  [dn][dm] = srf-&gt;ctrl  [1-dm][dn];
                        sn.weight[dn][dm] = srf-&gt;weight[1-dm][dn];
                    }
                }

                *srf = sn;
                continue;
            }
        }
    }
}

</t>
<t tx="leo.20191228122651.132">void SShell::MakeFromCopyOf(SShell *a) {
    ssassert(this != a, "Can't make from copy of self");
    MakeFromTransformationOf(a,
        Vector::From(0, 0, 0), Quaternion::IDENTITY, 1.0);
}

</t>
<t tx="leo.20191228122651.133">void SShell::MakeFromTransformationOf(SShell *a,
                                      Vector t, Quaternion q, double scale)
{
    booleanFailed = false;
    surface.ReserveMore(a-&gt;surface.n);
    SSurface *s;
    for(s = a-&gt;surface.First(); s; s = a-&gt;surface.NextAfter(s)) {
        SSurface n;
        n = SSurface::FromTransformationOf(s, t, q, scale, /*includingTrims=*/true);
        surface.Add(&amp;n); // keeping the old ID
    }

    curve.ReserveMore(a-&gt;curve.n);
    SCurve *c;
    for(c = a-&gt;curve.First(); c; c = a-&gt;curve.NextAfter(c)) {
        SCurve n;
        n = SCurve::FromTransformationOf(c, t, q, scale);
        curve.Add(&amp;n); // keeping the old ID
    }
}

</t>
<t tx="leo.20191228122651.134">void SShell::MakeEdgesInto(SEdgeList *sel) {
    SSurface *s;
    for(s = surface.First(); s; s = surface.NextAfter(s)) {
        s-&gt;MakeEdgesInto(this, sel, SSurface::MakeAs::XYZ);
    }
}

</t>
<t tx="leo.20191228122651.135">void SShell::MakeSectionEdgesInto(Vector n, double d, SEdgeList *sel, SBezierList *sbl)
{
    SSurface *s;
    for(s = surface.First(); s; s = surface.NextAfter(s)) {
        if(s-&gt;CoincidentWithPlane(n, d)) {
            s-&gt;MakeSectionEdgesInto(this, sel, sbl);
        }
    }
}

</t>
<t tx="leo.20191228122651.136">void SShell::TriangulateInto(SMesh *sm) {
    SSurface *s;
    for(s = surface.First(); s; s = surface.NextAfter(s)) {
        s-&gt;TriangulateInto(this, sm);
    }
}

</t>
<t tx="leo.20191228122651.137">bool SShell::IsEmpty() const {
    return surface.IsEmpty();
}

</t>
<t tx="leo.20191228122651.138">void SShell::Clear() {
    SSurface *s;
    for(s = surface.First(); s; s = surface.NextAfter(s)) {
        s-&gt;Clear();
    }
    surface.Clear();

    SCurve *c;
    for(c = curve.First(); c; c = curve.NextAfter(c)) {
        c-&gt;Clear();
    }
    curve.Clear();
}
</t>
<t tx="leo.20191228122651.139">@path ./src/srf/
//-----------------------------------------------------------------------------
// Functions relating to rational polynomial surfaces, which are trimmed by
// curves (either rational polynomial curves, or piecewise linear
// approximations to curves of intersection that can't be represented
// exactly in ratpoly form), and assembled into watertight shells.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------

#ifndef SOLVESPACE_SURFACE_H
#define SOLVESPACE_SURFACE_H

// Utility functions, Bernstein polynomials of order 1-3 and their derivatives.
double Bernstein(int k, int deg, double t);
double BernsteinDerivative(int k, int deg, double t);

class SBezierList;
class SSurface;
class SCurvePt;

// Utility data structure, a two-dimensional BSP to accelerate polygon
// operations.
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122651.14">void DrawQuad(const Vector &amp;a, const Vector &amp;b, const Vector &amp;c, const Vector &amp;d,
              hFill hcf) override {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo.20191228122651.140">class SBspUv {
public:
    Point2d  a, b;

    SBspUv  *pos;
    SBspUv  *neg;

    SBspUv  *more;

    enum class Class : uint32_t {
        INSIDE            = 100,
        OUTSIDE           = 200,
        EDGE_PARALLEL     = 300,
        EDGE_ANTIPARALLEL = 400,
        EDGE_OTHER        = 500
    };

    static SBspUv *Alloc();
    static SBspUv *From(SEdgeList *el, SSurface *srf);

    void ScalePoints(Point2d *pt, Point2d *a, Point2d *b, SSurface *srf) const;
    double ScaledSignedDistanceToLine(Point2d pt, Point2d a, Point2d b,

// Now the data structures to represent a shell of trimmed rational polynomial
// surfaces.

class SShell;

</t>
<t tx="leo.20191228122651.141">class hSSurface {
public:
    uint32_t v;
};

template&lt;&gt;
struct IsHandleOracle&lt;hSSurface&gt; : std::true_type {};

</t>
<t tx="leo.20191228122651.142">class hSCurve {
public:
    uint32_t v;
};

template&lt;&gt;
struct IsHandleOracle&lt;hSCurve&gt; : std::true_type {};

// Stuff for rational polynomial curves, of degree one to three. These are
// our inputs, and are also calculated for certain exact surface-surface
// intersections.
</t>
<t tx="leo.20191228122651.143">class SBezier {
public:
    int             tag;
    int             auxA, auxB;

    int             deg;
    Vector          ctrl[4];
    double          weight[4];
    uint32_t        entity;

    Vector PointAt(double t) const;
    Vector TangentAt(double t) const;
    void ClosestPointTo(Vector p, double *t, bool mustConverge=true) const;
    void SplitAt(double t, SBezier *bef, SBezier *aft) const;
    bool PointOnThisAndCurve(const SBezier *sbb, Vector *p) const;

    Vector Start() const;
    Vector Finish() const;
    bool Equals(SBezier *b) const;
    void MakePwlInto(SEdgeList *sel, double chordTol=0) const;
    void MakePwlInto(List&lt;SCurvePt&gt; *l, double chordTol=0) const;
    void MakePwlInto(SContour *sc, double chordTol=0) const;
    void MakePwlInto(List&lt;Vector&gt; *l, double chordTol=0) const;
    void MakePwlWorker(List&lt;Vector&gt; *l, double ta, double tb, double chordTol) const;
    void MakePwlInitialWorker(List&lt;Vector&gt; *l, double ta, double tb, double chordTol) const;
    void MakeNonrationalCubicInto(SBezierList *bl, double tolerance, int depth = 0) const;

    void AllIntersectionsWith(const SBezier *sbb, SPointList *spl) const;
    void GetBoundingProjd(Vector u, Vector orig, double *umin, double *umax) const;
    void Reverse();

    bool IsInPlane(Vector n, double d) const;
    bool IsCircle(Vector axis, Vector *center, double *r) const;
    bool IsRational() const;

    SBezier TransformedBy(Vector t, Quaternion q, double scale) const;
    SBezier InPerspective(Vector u, Vector v, Vector n,
                          Vector origin, double cameraTan) const;
    void ScaleSelfBy(double s);

    static SBezier From(Vector p0, Vector p1, Vector p2, Vector p3);
    static SBezier From(Vector p0, Vector p1, Vector p2);
    static SBezier From(Vector p0, Vector p1);
    static SBezier From(Vector4 p0, Vector4 p1, Vector4 p2, Vector4 p3);
    static SBezier From(Vector4 p0, Vector4 p1, Vector4 p2);
    static SBezier From(Vector4 p0, Vector4 p1);
};

</t>
<t tx="leo.20191228122651.144">class SBezierList {
public:
    List&lt;SBezier&gt;   l;

    void Clear();
    void ScaleSelfBy(double s);
    void CullIdenticalBeziers(bool both=true);
    void AllIntersectionsWith(SBezierList *sblb, SPointList *spl) const;
    @others
</t>
<t tx="leo.20191228122651.145">    bool GetPlaneContainingBeziers(Vector *p, Vector *u, Vector *v,
                                        Vector *notCoplanarAt) const;
};

class SBezierLoop {
public:
    int             tag;
    List&lt;SBezier&gt;   l;

    inline void Clear() { l.Clear(); }
    bool IsClosed() const;
    void Reverse();
    void MakePwlInto(SContour *sc, double chordTol=0) const;
    void GetBoundingProjd(Vector u, Vector orig, double *umin, double *umax) const;

</t>
<t tx="leo.20191228122651.146">    static SBezierLoop FromCurves(SBezierList *spcl,
                                  bool *allClosed, SEdge *errorAt);
};

class SBezierLoopSet {
public:
    List&lt;SBezierLoop&gt; l;
    Vector normal;
    Vector point;
    double area;

    static SBezierLoopSet From(SBezierList *spcl, SPolygon *poly,
</t>
<t tx="leo.20191228122651.147">class SBezierLoopSetSet {
public:
    List&lt;SBezierLoopSet&gt;    l;

    void FindOuterFacesFrom(SBezierList *sbl, SPolygon *spxyz, SSurface *srfuv,
public:
    int         tag;
    Vector      p;
    bool        vertex;
};

</t>
<t tx="leo.20191228122651.148">class SCurve {
public:
    hSCurve         h;

    // In a Boolean, C = A op B. The curves in A and B get copied into C, and
    // therefore must get new hSCurves assigned. For the curves in A and B,
    // we use newH to record their new handle in C.
    hSCurve         newH;
    enum class Source : uint32_t {
        A             = 100,
        B             = 200,
        INTERSECTION  = 300
    };
    Source          source;

    bool            isExact;
    SBezier         exact;

    List&lt;SCurvePt&gt;  pts;

    hSSurface       surfA;
    hSSurface       surfB;

    static SCurve FromTransformationOf(SCurve *a, Vector t,
// A segment of a curve by which a surface is trimmed: indicates which curve,
// by its handle, and the starting and ending points of our segment of it.
// The vector out points out of the surface; it, the surface outer normal,
// and a tangent to the beginning of the curve are all orthogonal.
@others
</t>
<t tx="leo.20191228122651.149">class STrimBy {
public:
    hSCurve     curve;
    bool        backwards;
    // If a trim runs backwards, then start and finish still correspond to
    // the actual start and finish, but they appear in reverse order in
    // the referenced curve.
    Vector      start;
    Vector      finish;

    static STrimBy EntireCurve(SShell *shell, hSCurve hsc, bool backwards);
};

// An intersection point between a line and a surface
</t>
<t tx="leo.20191228122651.15">void DrawPoint(const Vector &amp;o, hStroke hcs) override {
    PointBuffer *pb = pointBuffer.FindByIdNoOops(hcs);
    if(!pb) {
        PointBuffer npb = {};
        npb.h = hcs;
        pointBuffer.Add(&amp;npb);
        pb = pointBuffer.FindById(hcs);
    }

    pb-&gt;points.AddPoint(o);
}

</t>
<t tx="leo.20191228122651.150">class SInter {
public:
    int         tag;
    Vector      p;
    SSurface    *srf;
    Point2d     pinter;
    Vector      surfNormal;     // of the intersecting surface, at pinter
    bool        onEdge;         // pinter is on edge of trim poly
};

// A rational polynomial surface in Bezier form.
</t>
<t tx="leo.20191228122651.151">class SSurface {
public:

    enum class CombineAs : uint32_t {
        UNION      = 10,
        DIFFERENCE = 11,
        INTERSECT  = 12
    };

    int             tag;
    hSSurface       h;

    // Same as newH for the curves; record what a surface gets renamed to
    // when I copy things over.
    hSSurface       newH;

    RgbaColor       color;
    uint32_t        face;

    int             degm, degn;
    Vector          ctrl[4][4];
    double          weight[4][4];

    List&lt;STrimBy&gt;   trim;

    // For testing whether a point (u, v) on the surface lies inside the trim
    SBspUv          *bsp;
    SEdgeList       edges;

    // For caching our initial (u, v) when doing Newton iterations to project
    // a point into our surface.
    Point2d         cached;

    static SSurface FromExtrusionOf(SBezier *spc, Vector t0, Vector t1);
    static SSurface FromRevolutionOf(SBezier *sb, Vector pt, Vector axis, double thetas,
                                  uint32_t auxA,
                                  SShell *shell, SShell *sha, SShell *shb);
    void FindChainAvoiding(SEdgeList *src, SEdgeList *dest, SPointList *avoid);
    SSurface MakeCopyTrimAgainst(SShell *parent, SShell *a, SShell *b,
                                    SShell *into, SSurface::CombineAs type);
    void TrimFromEdgeList(SEdgeList *el, bool asUv);
    @others
};

</t>
<t tx="leo.20191228122651.152">void IntersectAgainst(SSurface *b, SShell *agnstA, SShell *agnstB,
                      SShell *into);
void AddExactIntersectionCurve(SBezier *sb, SSurface *srfB,
                      SShell *agnstA, SShell *agnstB, SShell *into);

typedef struct {
    int     tag;
    Point2d p;
} Inter;
void WeightControlPoints();
void UnWeightControlPoints();
void CopyRowOrCol(bool row, int this_ij, SSurface *src, int src_ij);
void BlendRowOrCol(bool row, int this_ij, SSurface *a, int a_ij,

void ClosestPointTo(Vector p, Point2d *puv, bool mustConverge=true);
void ClosestPointTo(Vector p, double *u, double *v, bool mustConverge=true);
bool ClosestPointNewton(Vector p, double *u, double *v, bool mustConverge=true) const;

bool PointIntersectingLine(Vector p0, Vector p1, double *u, double *v) const;
Vector ClosestPointOnThisAndSurface(SSurface *srf2, Vector p);
void PointOnSurfaces(SSurface *s1, SSurface *s2, double *u, double *v);
Vector PointAt(double u, double v) const;
Vector PointAt(Point2d puv) const;
void TangentsAt(double u, double v, Vector *tu, Vector *tv) const;
Vector NormalAt(Point2d puv) const;
Vector NormalAt(double u, double v) const;
bool LineEntirelyOutsideBbox(Vector a, Vector b, bool asSegment) const;
void GetAxisAlignedBounding(Vector *ptMax, Vector *ptMin) const;
bool CoincidentWithPlane(Vector n, double d) const;
bool CoincidentWith(SSurface *ss, bool sameNormal) const;
bool IsExtrusion(SBezier *of, Vector *along) const;
</t>
<t tx="leo.20191228122651.153">bool IsCylinder(Vector *axis, Vector *center, double *r,
                    Vector *start, Vector *finish) const;

void TriangulateInto(SShell *shell, SMesh *sm);

// these are intended as bitmasks, even though there's just one now
enum class MakeAs : uint32_t {
   UV  = 0x01,
   XYZ = 0x00
};
void MakeTrimEdgesInto(SEdgeList *sel, MakeAs flags, SCurve *sc, STrimBy *stb);
void MakeEdgesInto(SShell *shell, SEdgeList *sel, MakeAs flags,

void Reverse();
void Clear();
</t>
<t tx="leo.20191228122651.154">class SShell {
public:
    IdList&lt;SCurve,hSCurve&gt;      curve;
    IdList&lt;SSurface,hSSurface&gt;  surface;

    bool                        booleanFailed;

    void MakeFromExtrusionOf(SBezierLoopSet *sbls, Vector t0, Vector t1,
    void CopyCurvesSplitAgainst(bool opA, SShell *agnst, SShell *into);
    void CopySurfacesTrimAgainst(SShell *sha, SShell *shb, SShell *into, SSurface::CombineAs type);
    void MakeIntersectionCurvesAgainst(SShell *against, SShell *into);
    void MakeClassifyingBsps(SShell *useCurvesFrom);
    void AllPointsIntersecting(Vector a, Vector b, List&lt;SInter&gt; *il,
        INSIDE     = 100,
        OUTSIDE    = 200,
        COINC_SAME = 300,
        COINC_OPP  = 400
    };
    static const double DOTP_TOL;
    Class ClassifyRegion(Vector edge_n, Vector inter_surf_n,
                       Vector edge_surf_n) const;

    bool ClassifyEdge(Class *indir, Class *outdir,
    void TriangulateInto(SMesh *sm);
    void MakeEdgesInto(SEdgeList *sel);
    void MakeSectionEdgesInto(Vector n, double d, SEdgeList *sel, SBezierList *sbl);
    bool IsEmpty() const;
    void RemapFaces(Group *g, int remap);
    void Clear();
};

#endif

</t>
<t tx="leo.20191228122651.16">void DrawPolygon(const SPolygon &amp;p, hFill hcf) override {
    SMesh m = {};
    p.TriangulateInto(&amp;m);
    drawCalls.emplace(MeshDrawCall::Create(renderer, m, fills.FindById(hcf),
                                           fills.FindById(hcf)));
    m.Clear();
}

</t>
<t tx="leo.20191228122651.17">void DrawMesh(const SMesh &amp;m, hFill hcfFront, hFill hcfBack = {}) override {
    drawCalls.emplace(MeshDrawCall::Create(renderer, m, fills.FindById(hcfFront),
                                           fills.FindByIdNoOops(hcfBack),
                                           /*isShaded=*/true));
}

</t>
<t tx="leo.20191228122651.18">void DrawFaces(const SMesh &amp;m, const std::vector&lt;uint32_t&gt; &amp;faces, hFill hcf) override {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo.20191228122651.19">void DrawPixmap(std::shared_ptr&lt;const Pixmap&gt; pm,
                const Vector &amp;o, const Vector &amp;u, const Vector &amp;v,
                const Point2d &amp;ta, const Point2d &amp;tb, hFill hcf) override {
    Fill fill = *fills.FindById(hcf);
    fill.texture = pm;
    hcf = GetFill(fill);

    SIndexedMesh mesh = {};
    mesh.AddPixmap(o, u, v, ta, tb);
    drawCalls.emplace(PixmapDrawCall::Create(renderer, mesh, fills.FindByIdNoOops(hcf)));
    mesh.Clear();
}

</t>
<t tx="leo.20191228122651.2">void Remove(OpenGl3Renderer *renderer) override {
    renderer-&gt;meshRenderer.Remove(handle);
}
</t>
<t tx="leo.20191228122651.20">void InvalidatePixmap(std::shared_ptr&lt;const Pixmap&gt; pm) override {
    ssassert(false, "Not implemented");
}

</t>
<t tx="leo.20191228122651.21">void Finalize() override {
    for(const EdgeBuffer &amp;eb : edgeBuffer) {
        drawCalls.emplace(EdgeDrawCall::Create(renderer, eb.edges, strokes.FindById(eb.h)));
    }
    edgeBuffer.Clear();

    for(const PointBuffer &amp;pb : pointBuffer) {
        drawCalls.emplace(PointDrawCall::Create(renderer, pb.points, strokes.FindById(pb.h)));
    }
    pointBuffer.Clear();
}

</t>
<t tx="leo.20191228122651.22">void Draw() override {
    renderer-&gt;current = {};

    for(std::shared_ptr&lt;DrawCall&gt; dc : drawCalls) {
        dc-&gt;Draw(renderer);
    }
}

</t>
<t tx="leo.20191228122651.23">void Clear() override {
    for(std::shared_ptr&lt;DrawCall&gt; dc : drawCalls) {
        dc-&gt;Remove(renderer);
    }
    drawCalls.clear();
}
</t>
<t tx="leo.20191228122651.24"></t>
<t tx="leo.20191228122651.25">@path ./src/srf/
//-----------------------------------------------------------------------------
// Top-level functions to compute the Boolean union or difference between
// two shells of rational polynomial surfaces.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

static int I;

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122651.26">void SShell::MakeFromUnionOf(SShell *a, SShell *b) {
    MakeFromBoolean(a, b, SSurface::CombineAs::UNION);
}

</t>
<t tx="leo.20191228122651.27">void SShell::MakeFromDifferenceOf(SShell *a, SShell *b) {
    MakeFromBoolean(a, b, SSurface::CombineAs::DIFFERENCE);
}

//-----------------------------------------------------------------------------
// Take our original pwl curve. Wherever an edge intersects a surface within
// either agnstA or agnstB, split the piecewise linear element. Then refine
// the intersection so that it lies on all three relevant surfaces: the
// intersecting surface, srfA, and srfB. (So the pwl curve should lie at
// the intersection of srfA and srfB.) Return a new pwl curve with everything
// split.
//-----------------------------------------------------------------------------
SCurve SCurve::MakeCopySplitAgainst(SShell *agnstA, SShell *agnstB,
                                    SSurface *srfA, SSurface *srfB) const
{
    SCurve ret;
    ret = *this;
    ret.pts = {};

    const SCurvePt *p = pts.First();
    ssassert(p != NULL, "Cannot split an empty curve");
    SCurvePt prev = *p;
    ret.pts.Add(p);
    p = pts.NextAfter(p);

    for(; p; p = pts.NextAfter(p)) {
        List&lt;SInter&gt; il = {};

        // Find all the intersections with the two passed shells
        if(agnstA)
            agnstA-&gt;AllPointsIntersecting(prev.p, p-&gt;p, &amp;il,
                /*asSegment=*/true, /*trimmed=*/false, /*inclTangent=*/true);
        if(agnstB)
            agnstB-&gt;AllPointsIntersecting(prev.p, p-&gt;p, &amp;il,
                /*asSegment=*/true, /*trimmed=*/false, /*inclTangent=*/true);

        if(!il.IsEmpty()) {
            // The intersections were generated by intersecting the pwl
            // edge against a surface; so they must be refined to lie
            // exactly on the original curve.
            il.ClearTags();
            SInter *pi;
            for(pi = il.First(); pi; pi = il.NextAfter(pi)) {
                if(pi-&gt;srf == srfA || pi-&gt;srf == srfB) {
                    // The edge certainly intersects the surfaces that it
                    // trims (at its endpoints), but those ones don't count.
                    // They are culled later, but no sense calculating them
                    // and they will cause numerical problems (since two
                    // of the three surfaces they're refined to lie on will
                    // be identical, so the matrix will be singular).
                    pi-&gt;tag = 1;
                    continue;
                }

                Point2d puv;
                (pi-&gt;srf)-&gt;ClosestPointTo(pi-&gt;p, &amp;puv, /*mustConverge=*/false);

                // Split the edge if the intersection lies within the surface's
                // trim curves, or within the chord tol of the trim curve; want
                // some slop if points are close to edge and pwl is too coarse,
                // and it doesn't hurt to split unnecessarily.
                Point2d dummy = { 0, 0 };
                SBspUv::Class c = (pi-&gt;srf-&gt;bsp) ? pi-&gt;srf-&gt;bsp-&gt;ClassifyPoint(puv, dummy, pi-&gt;srf) : SBspUv::Class::OUTSIDE;
                if(c == SBspUv::Class::OUTSIDE) {
                    double d = VERY_POSITIVE;
                    if(pi-&gt;srf-&gt;bsp) d = pi-&gt;srf-&gt;bsp-&gt;MinimumDistanceToEdge(puv, pi-&gt;srf);
                    if(d &gt; SS.ChordTolMm()) {
                        pi-&gt;tag = 1;
                        continue;
                    }
                }

                // We're keeping the intersection, so actually refine it.
                (pi-&gt;srf)-&gt;PointOnSurfaces(srfA, srfB, &amp;(puv.x), &amp;(puv.y));
                pi-&gt;p = (pi-&gt;srf)-&gt;PointAt(puv);
            }
            il.RemoveTagged();

            // And now sort them in order along the line. Note that we must
            // do that after refining, in case the refining would make two
            // points switch places.
            const Vector lineStart     = prev.p;
            const Vector lineDirection = (p-&gt;p).Minus(prev.p);
            std::sort(il.begin(), il.end(), [&amp;](const SInter &amp;a, const SInter &amp;b) {
                double ta = (a.p.Minus(lineStart)).DivProjected(lineDirection);
                double tb = (b.p.Minus(lineStart)).DivProjected(lineDirection);

                return (ta &lt; tb);
            });

            // And now uses the intersections to generate our split pwl edge(s)
            Vector prev = Vector::From(VERY_POSITIVE, 0, 0);
            for(pi = il.First(); pi; pi = il.NextAfter(pi)) {
                // On-edge intersection will generate same split point for
                // both surfaces, so don't create zero-length edge.
                if(!prev.Equals(pi-&gt;p)) {
                    SCurvePt scpt;
                    scpt.tag    = 0;
                    scpt.p      = pi-&gt;p;
                    scpt.vertex = true;
                    ret.pts.Add(&amp;scpt);
                }
                prev = pi-&gt;p;
            }
        }

        il.Clear();
        ret.pts.Add(p);
        prev = *p;
    }
    return ret;
}

</t>
<t tx="leo.20191228122651.28">void SShell::CopyCurvesSplitAgainst(bool opA, SShell *agnst, SShell *into) {
    SCurve *sc;
    for(sc = curve.First(); sc; sc = curve.NextAfter(sc)) {
        SCurve scn = sc-&gt;MakeCopySplitAgainst(agnst, NULL,
                                surface.FindById(sc-&gt;surfA),
                                surface.FindById(sc-&gt;surfB));
        scn.source = opA ? SCurve::Source::A : SCurve::Source::B;

        hSCurve hsc = into-&gt;curve.AddAndAssignId(&amp;scn);
        // And note the new ID so that we can rewrite the trims appropriately
        sc-&gt;newH = hsc;
    }
}

</t>
<t tx="leo.20191228122651.29">void SSurface::TrimFromEdgeList(SEdgeList *el, bool asUv) {
    el-&gt;l.ClearTags();

    STrimBy stb = {};
    for(;;) {
        // Find an edge, any edge; we'll start from there.
        SEdge *se;
        for(se = el-&gt;l.First(); se; se = el-&gt;l.NextAfter(se)) {
            if(se-&gt;tag) continue;
            break;
        }
        if(!se) break;
        se-&gt;tag = 1;
        stb.start = se-&gt;a;
        stb.finish = se-&gt;b;
        stb.curve.v = se-&gt;auxA;
        stb.backwards = se-&gt;auxB ? true : false;

        // Find adjoining edges from the same curve; those should be
        // merged into a single trim.
        bool merged;
        do {
            merged = false;
            for(se = el-&gt;l.First(); se; se = el-&gt;l.NextAfter(se)) {
                if(se-&gt;tag)                         continue;
                if(se-&gt;auxA != (int)stb.curve.v)    continue;
                if(( se-&gt;auxB &amp;&amp; !stb.backwards) ||
                   (!se-&gt;auxB &amp;&amp;  stb.backwards))   continue;

                if((se-&gt;a).Equals(stb.finish)) {
                    stb.finish = se-&gt;b;
                    se-&gt;tag = 1;
                    merged = true;
                } else if((se-&gt;b).Equals(stb.start)) {
                    stb.start = se-&gt;a;
                    se-&gt;tag = 1;
                    merged = true;
                }
            }
        } while(merged);

        if(asUv) {
            stb.start  = PointAt(stb.start.x,  stb.start.y);
            stb.finish = PointAt(stb.finish.x, stb.finish.y);
        }

        // And add the merged trim, with xyz (not uv like the polygon) pts
        trim.Add(&amp;stb);
    }
}

</t>
<t tx="leo.20191228122651.3">    bool operator()(const std::shared_ptr&lt;DrawCall&gt; &amp;a, const std::shared_ptr&lt;DrawCall&gt; &amp;b) const {
        @others
    }
};

</t>
<t tx="leo.20191228122651.30">static bool KeepRegion(SSurface::CombineAs type, bool opA, SShell::Class shell, SShell::Class orig)
{
    @others
}
</t>
<t tx="leo.20191228122651.31">bool inShell = (shell == SShell::Class::INSIDE),
     outSide = (shell == SShell::Class::OUTSIDE),
     inSame  = (shell == SShell::Class::COINC_SAME),
     inOrig  = (orig == SShell::Class::INSIDE);

if(!inOrig) return false;
switch(type) {
    case SSurface::CombineAs::UNION:
        if(opA) {
            return outSide;
        } else {
            return outSide || inSame;
        }

    case SSurface::CombineAs::DIFFERENCE:
        if(opA) {
            return outSide;
        } else {
            return inShell || inSame;
        }

    default: ssassert(false, "Unexpected combine type");
}
</t>
<t tx="leo.20191228122651.32">static bool KeepEdge(SSurface::CombineAs type, bool opA,
                     SShell::Class indir_shell, SShell::Class outdir_shell,
                     SShell::Class indir_orig, SShell::Class outdir_orig)
{
    bool keepIn  = KeepRegion(type, opA, indir_shell,  indir_orig),
    switch(bspclass) {
        case SBspUv::Class::INSIDE:
            *indir  = SShell::Class::INSIDE;
            *outdir = SShell::Class::INSIDE;
            break;

        case SBspUv::Class::OUTSIDE:
            *indir  = SShell::Class::OUTSIDE;
            *outdir = SShell::Class::OUTSIDE;
            break;

        case SBspUv::Class::EDGE_PARALLEL:
            *indir  = SShell::Class::INSIDE;
            *outdir = SShell::Class::OUTSIDE;
            break;

        case SBspUv::Class::EDGE_ANTIPARALLEL:
            *indir  = SShell::Class::OUTSIDE;
            *outdir = SShell::Class::INSIDE;
            break;

        default:
            dbp("TagByClassifiedEdge: fail!");
            *indir  = SShell::Class::OUTSIDE;
            *outdir = SShell::Class::OUTSIDE;
            break;
    }
}

</t>
<t tx="leo.20191228122651.33">static void DEBUGEDGELIST(SEdgeList *sel, SSurface *surf) {
    dbp("print %d edges", sel-&gt;l.n);
    SEdge *se;
    for(se = sel-&gt;l.First(); se; se = sel-&gt;l.NextAfter(se)) {
        Vector mid = (se-&gt;a).Plus(se-&gt;b).ScaledBy(0.5);
        Vector arrow = (se-&gt;b).Minus(se-&gt;a);
        swap(arrow.x, arrow.y);
        arrow.x *= -1;
        arrow = arrow.WithMagnitude(0.01);
        arrow = arrow.Plus(mid);

        SS.nakedEdges.AddEdge(surf-&gt;PointAt(se-&gt;a.x, se-&gt;a.y),
                              surf-&gt;PointAt(se-&gt;b.x, se-&gt;b.y));
        SS.nakedEdges.AddEdge(surf-&gt;PointAt(mid.x, mid.y),
                              surf-&gt;PointAt(arrow.x, arrow.y));
    }
}

//-----------------------------------------------------------------------------
// We are given src, with at least one edge, and avoid, a list of points to
// avoid. We return a chain of edges (that share endpoints), such that no
// point within the avoid list ever occurs in the middle of a chain. And we
// delete the edges in that chain from our source list.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.34">void SSurface::FindChainAvoiding(SEdgeList *src, SEdgeList *dest,
                                 SPointList *avoid)
{
    ssassert(!src-&gt;l.IsEmpty(), "Need at least one edge");
    // Start with an arbitrary edge.
    dest-&gt;l.Add(src-&gt;l.First());
    src-&gt;l.ClearTags();
    src-&gt;l.First()-&gt;tag = 1;

    bool added;
    do {
        added = false;
        // The start and finish of the current edge chain
        Vector s = dest-&gt;l.First()-&gt;a,
               f = dest-&gt;l.Last()-&gt;b;

        // We can attach a new edge at the start or finish, as long as that
        // start or finish point isn't in the list of points to avoid.
        @others
}

</t>
<t tx="leo.20191228122651.35">    bool startOkay  = !avoid-&gt;ContainsPoint(s),
         finishOkay = !avoid-&gt;ContainsPoint(f);

    // Now look for an unused edge that joins at the start or finish of
    // our chain (if permitted by the avoid list).
    SEdge *se;
    for(se = src-&gt;l.First(); se; se = src-&gt;l.NextAfter(se)) {
        if(se-&gt;tag) continue;
        if(startOkay &amp;&amp; s.Equals(se-&gt;b)) {
            dest-&gt;l.AddToBeginning(se);
            s = se-&gt;a;
            se-&gt;tag = 1;
            startOkay = !avoid-&gt;ContainsPoint(s);
        } else if(finishOkay &amp;&amp; f.Equals(se-&gt;a)) {
            dest-&gt;l.Add(se);
            f = se-&gt;b;
            se-&gt;tag = 1;
            finishOkay = !avoid-&gt;ContainsPoint(f);
        } else {
            continue;
        }

        added = true;
    }
} while(added);

src-&gt;l.RemoveTagged();
</t>
<t tx="leo.20191228122651.36">void SSurface::EdgeNormalsWithinSurface(Point2d auv, Point2d buv,
                                        Vector *pt,
                                        Vector *enin, Vector *enout,
                                        Vector *surfn,
                                        uint32_t auxA,
                                        SShell *shell, SShell *sha, SShell *shb)
{
    // the midpoint of the edge
    Point2d muv  = (auv.Plus(buv)).ScaledBy(0.5);

    *pt    = PointAt(muv);

    // If this edge just approximates a curve, then refine our midpoint so
    // so that it actually lies on that curve too. Otherwise stuff like
    // point-on-face tests will fail, since the point won't actually lie
    // on the other face.
    hSCurve hc = { auxA };
    SCurve *sc = shell-&gt;curve.FindById(hc);
    if(sc-&gt;isExact &amp;&amp; sc-&gt;exact.deg != 1) {
        double t;
        sc-&gt;exact.ClosestPointTo(*pt, &amp;t, /*mustConverge=*/false);
        *pt = sc-&gt;exact.PointAt(t);
        ClosestPointTo(*pt, &amp;muv);
    } else if(!sc-&gt;isExact) {
        SSurface *trimmedA = sc-&gt;GetSurfaceA(sha, shb),
                       *trimmedB = sc-&gt;GetSurfaceB(sha, shb);
        *pt = trimmedA-&gt;ClosestPointOnThisAndSurface(trimmedB, *pt);
        ClosestPointTo(*pt, &amp;muv);
    }

    *surfn = NormalAt(muv.x, muv.y);

    // Compute the edge's inner normal in xyz space.
    Vector ab    = (PointAt(auv)).Minus(PointAt(buv)),
           enxyz = (ab.Cross(*surfn)).WithMagnitude(SS.ChordTolMm());
    // And based on that, compute the edge's inner normal in uv space. This
    // vector is perpendicular to the edge in xyz, but not necessarily in uv.
    Vector tu, tv;
    TangentsAt(muv.x, muv.y, &amp;tu, &amp;tv);
    Point2d enuv;
    enuv.x = enxyz.Dot(tu) / tu.MagSquared();
    enuv.y = enxyz.Dot(tv) / tv.MagSquared();

    // Compute the inner and outer normals of this edge (within the srf),
    // in xyz space. These are not necessarily antiparallel, if the
    // surface is curved.
    Vector pin   = PointAt(muv.Minus(enuv)),
           pout  = PointAt(muv.Plus(enuv));
    *enin  = pin.Minus(*pt),
    *enout = pout.Minus(*pt);
}

//-----------------------------------------------------------------------------
// Trim this surface against the specified shell, in the way that's appropriate
// for the specified Boolean operation type (and which operand we are). We
// also need a pointer to the shell that contains our own surface, since that
// contains our original trim curves.
//-----------------------------------------------------------------------------
SSurface SSurface::MakeCopyTrimAgainst(SShell *parent,
                                       SShell *sha, SShell *shb,
                                       SShell *into,
                                       SSurface::CombineAs type)
{
    bool opA = (parent == sha);
    SShell *agnst = opA ? shb : sha;

    SSurface ret;
    // The returned surface is identical, just the trim curves change
    ret = *this;
    ret.trim = {};

    // First, build a list of the existing trim curves; update them to use
    // the split curves.
    STrimBy *stb;
    for(stb = trim.First(); stb; stb = trim.NextAfter(stb)) {
        STrimBy stn = *stb;
        stn.curve = (parent-&gt;curve.FindById(stn.curve))-&gt;newH;
        ret.trim.Add(&amp;stn);
    }

    if(type == SSurface::CombineAs::DIFFERENCE &amp;&amp; !opA) {
        // The second operand of a Boolean difference gets turned inside out
        ret.Reverse();
    }

    // Build up our original trim polygon; remember the coordinates could
    // be changed if we just flipped the surface normal, and we are using
    // the split curves (not the original curves).
    SEdgeList orig = {};
    ret.MakeEdgesInto(into, &amp;orig, MakeAs::UV);
    ret.trim.Clear();
    // which means that we can't necessarily use the old BSP...
    SBspUv *origBsp = SBspUv::From(&amp;orig, &amp;ret);

    // And now intersect the other shell against us
    SEdgeList inter = {};

    SSurface *ss;
    for(ss = agnst-&gt;surface.First(); ss; ss = agnst-&gt;surface.NextAfter(ss)) {
        SCurve *sc;
        for(sc = into-&gt;curve.First(); sc; sc = into-&gt;curve.NextAfter(sc)) {
            if(sc-&gt;source != SCurve::Source::INTERSECTION) continue;
            if(opA) {
                if(sc-&gt;surfA != h || sc-&gt;surfB != ss-&gt;h) continue;
            } else {
                if(sc-&gt;surfB != h || sc-&gt;surfA != ss-&gt;h) continue;
            }

            int i;
            for(i = 1; i &lt; sc-&gt;pts.n; i++) {
                Vector a = sc-&gt;pts[i-1].p,
                       b = sc-&gt;pts[i].p;

                Point2d auv, buv;
                ss-&gt;ClosestPointTo(a, &amp;(auv.x), &amp;(auv.y));
                ss-&gt;ClosestPointTo(b, &amp;(buv.x), &amp;(buv.y));

                SBspUv::Class c = (ss-&gt;bsp) ? ss-&gt;bsp-&gt;ClassifyEdge(auv, buv, ss) : SBspUv::Class::OUTSIDE;
                if(c != SBspUv::Class::OUTSIDE) {
                    Vector ta = Vector::From(0, 0, 0);
                    Vector tb = Vector::From(0, 0, 0);
                    ret.ClosestPointTo(a, &amp;(ta.x), &amp;(ta.y));
                    ret.ClosestPointTo(b, &amp;(tb.x), &amp;(tb.y));

                    Vector tn = ret.NormalAt(ta.x, ta.y);
                    Vector sn = ss-&gt;NormalAt(auv.x, auv.y);

                    // We are subtracting the portion of our surface that
                    // lies in the shell, so the in-plane edge normal should
                    // point opposite to the surface normal.
                    bool bkwds = true;
                    if((tn.Cross(b.Minus(a))).Dot(sn) &lt; 0) bkwds = !bkwds;
                    if(type == SSurface::CombineAs::DIFFERENCE &amp;&amp; !opA) bkwds = !bkwds;
                    if(bkwds) {
                        inter.AddEdge(tb, ta, sc-&gt;h.v, 1);
                    } else {
                        inter.AddEdge(ta, tb, sc-&gt;h.v, 0);
                    }
                }
            }
        }
    }

    // Record all the points where more than two edges join, which I will call
    // the choosing points. If two edges join at a non-choosing point, then
    // they must either both be kept or both be discarded (since that would
    // otherwise create an open contour).
    SPointList choosing = {};
    SEdge *se;
    for(se = orig.l.First(); se; se = orig.l.NextAfter(se)) {
        choosing.IncrementTagFor(se-&gt;a);
        choosing.IncrementTagFor(se-&gt;b);
    }
    for(se = inter.l.First(); se; se = inter.l.NextAfter(se)) {
        choosing.IncrementTagFor(se-&gt;a);
        choosing.IncrementTagFor(se-&gt;b);
    }
    SPoint *sp;
    for(sp = choosing.l.First(); sp; sp = choosing.l.NextAfter(sp)) {
        if(sp-&gt;tag == 2) {
            sp-&gt;tag = 1;
        } else {
            sp-&gt;tag = 0;
        }
    }
    choosing.l.RemoveTagged();

    // The list of edges to trim our new surface, a combination of edges from
    // our original and intersecting edge lists.
    SEdgeList final = {};

    while(!orig.l.IsEmpty()) {
        SEdgeList chain = {};
        FindChainAvoiding(&amp;orig, &amp;chain, &amp;choosing);

        // Arbitrarily choose an edge within the chain to classify; they
        // should all be the same, though.
        se = &amp;(chain.l[chain.l.n/2]);

        Point2d auv  = (se-&gt;a).ProjectXy(),
                buv  = (se-&gt;b).ProjectXy();

        Vector pt, enin, enout, surfn;
        ret.EdgeNormalsWithinSurface(auv, buv, &amp;pt, &amp;enin, &amp;enout, &amp;surfn,
                                        se-&gt;auxA, into, sha, shb);

        SShell::Class indir_shell, outdir_shell, indir_orig, outdir_orig;

        indir_orig  = SShell::Class::INSIDE;
        outdir_orig = SShell::Class::OUTSIDE;

        agnst-&gt;ClassifyEdge(&amp;indir_shell, &amp;outdir_shell,
                            ret.PointAt(auv), ret.PointAt(buv), pt,
                            enin, enout, surfn);

        if(KeepEdge(type, opA, indir_shell, outdir_shell,
                               indir_orig,  outdir_orig))
        {
            for(se = chain.l.First(); se; se = chain.l.NextAfter(se)) {
                final.AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA, se-&gt;auxB);
            }
        }
        chain.Clear();
    }

    while(!inter.l.IsEmpty()) {
        SEdgeList chain = {};
        FindChainAvoiding(&amp;inter, &amp;chain, &amp;choosing);

        // Any edge in the chain, same as above.
        se = &amp;(chain.l[chain.l.n/2]);

        Point2d auv = (se-&gt;a).ProjectXy(),
                buv = (se-&gt;b).ProjectXy();

        Vector pt, enin, enout, surfn;
        ret.EdgeNormalsWithinSurface(auv, buv, &amp;pt, &amp;enin, &amp;enout, &amp;surfn,
                                        se-&gt;auxA, into, sha, shb);

        SShell::Class indir_shell, outdir_shell, indir_orig, outdir_orig;

        SBspUv::Class c_this = (origBsp) ? origBsp-&gt;ClassifyEdge(auv, buv, &amp;ret) : SBspUv::Class::OUTSIDE;
        TagByClassifiedEdge(c_this, &amp;indir_orig, &amp;outdir_orig);

        agnst-&gt;ClassifyEdge(&amp;indir_shell, &amp;outdir_shell,
                            ret.PointAt(auv), ret.PointAt(buv), pt,
                            enin, enout, surfn);

        if(KeepEdge(type, opA, indir_shell, outdir_shell,
                               indir_orig,  outdir_orig))
        {
            for(se = chain.l.First(); se; se = chain.l.NextAfter(se)) {
                final.AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA, se-&gt;auxB);
            }
        }
        chain.Clear();
    }

    // Cull extraneous edges; duplicates or anti-parallel pairs. In particular,
    // we can get duplicate edges if our surface intersects the other shell
    // at an edge, so that both surfaces intersect coincident (and both
    // generate an intersection edge).
    final.CullExtraneousEdges();

    // Use our reassembled edges to trim the new surface.
    ret.TrimFromEdgeList(&amp;final, /*asUv=*/true);

    SPolygon poly = {};
    final.l.ClearTags();
    if(!final.AssemblePolygon(&amp;poly, NULL, /*keepDir=*/true)) {
        into-&gt;booleanFailed = true;
        dbp("failed: I=%d, avoid=%d", I, choosing.l.n);
        DEBUGEDGELIST(&amp;final, &amp;ret);
    }
    poly.Clear();

    choosing.Clear();
    final.Clear();
    inter.Clear();
    orig.Clear();
    return ret;
}

</t>
<t tx="leo.20191228122651.37">void SShell::CopySurfacesTrimAgainst(SShell *sha, SShell *shb, SShell *into, SSurface::CombineAs type) {
    SSurface *ss;
    for(ss = surface.First(); ss; ss = surface.NextAfter(ss)) {
        SSurface ssn;
        ssn = ss-&gt;MakeCopyTrimAgainst(this, sha, shb, into, type);
        ss-&gt;newH = into-&gt;surface.AddAndAssignId(&amp;ssn);
        I++;
    }
}

</t>
<t tx="leo.20191228122651.38">void SShell::MakeIntersectionCurvesAgainst(SShell *agnst, SShell *into) {
    SSurface *sa;
    for(sa = surface.First(); sa; sa = surface.NextAfter(sa)) {
        SSurface *sb;
        for(sb = agnst-&gt;surface.First(); sb; sb = agnst-&gt;surface.NextAfter(sb)){
            // Intersect every surface from our shell against every surface
            // from agnst; this will add zero or more curves to the curve
            // list for into.
            sa-&gt;IntersectAgainst(sb, this, agnst, into);
        }
    }
}

</t>
<t tx="leo.20191228122651.39">void SShell::CleanupAfterBoolean() {
    SSurface *ss;
    for(ss = surface.First(); ss; ss = surface.NextAfter(ss)) {
        ss-&gt;edges.Clear();
    }
}

//-----------------------------------------------------------------------------
// All curves contain handles to the two surfaces that they trim. After a
// Boolean or assembly, we must rewrite those handles to refer to the curves
// by their new IDs.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.4">const Canvas::Layer stackup[] = {
    Canvas::Layer::BACK,
    Canvas::Layer::DEPTH_ONLY,
    Canvas::Layer::NORMAL,
    Canvas::Layer::OCCLUDED,
    Canvas::Layer::FRONT
};

</t>
<t tx="leo.20191228122651.40">void SShell::RewriteSurfaceHandlesForCurves(SShell *a, SShell *b) {
    SCurve *sc;
    for(sc = curve.First(); sc; sc = curve.NextAfter(sc)) {
        sc-&gt;surfA = sc-&gt;GetSurfaceA(a, b)-&gt;newH,
        sc-&gt;surfB = sc-&gt;GetSurfaceB(a, b)-&gt;newH;
    }
}

//-----------------------------------------------------------------------------
// Copy all the surfaces and curves from two different shells into a single
// shell. The only difficulty is to rewrite all of their handles; we don't
// look for any surface intersections, so if two objects interfere then the
// result is just self-intersecting. This is used for assembly, since it's
// much faster than merging as union.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.41">void SShell::MakeFromAssemblyOf(SShell *a, SShell *b) {
    booleanFailed = false;

    Vector t = Vector::From(0, 0, 0);
    Quaternion q = Quaternion::IDENTITY;
    int i = 0;
    SShell *ab;

    // First, copy over all the curves. Note which shell (a or b) each curve
    // came from, but assign it a new ID.
    curve.ReserveMore(a-&gt;curve.n + b-&gt;curve.n);
    SCurve *c, cn;
    for(i = 0; i &lt; 2; i++) {
        ab = (i == 0) ? a : b;
        for(c = ab-&gt;curve.First(); c; c = ab-&gt;curve.NextAfter(c)) {
            cn = SCurve::FromTransformationOf(c, t, q, 1.0);
            cn.source = (i == 0) ? SCurve::Source::A : SCurve::Source::B;
            // surfA and surfB are wrong now, and we can't fix them until
            // we've assigned IDs to the surfaces. So we'll get that later.
            c-&gt;newH = curve.AddAndAssignId(&amp;cn);
        }
    }

    // Likewise copy over all the surfaces.
    surface.ReserveMore(a-&gt;surface.n + b-&gt;surface.n);
    SSurface *s, sn;
    for(i = 0; i &lt; 2; i++) {
        ab = (i == 0) ? a : b;
        for(s = ab-&gt;surface.First(); s; s = ab-&gt;surface.NextAfter(s)) {
            sn = SSurface::FromTransformationOf(s, t, q, 1.0, /*includingTrims=*/true);
            // All the trim curve IDs get rewritten; we know the new handles
            // to the curves since we recorded them in the previous step.
            STrimBy *stb;
            for(stb = sn.trim.First(); stb; stb = sn.trim.NextAfter(stb)) {
                stb-&gt;curve = ab-&gt;curve.FindById(stb-&gt;curve)-&gt;newH;
            }
            s-&gt;newH = surface.AddAndAssignId(&amp;sn);
        }
    }

    // Finally, rewrite the surfaces associated with each curve to use the
    // new handles.
    RewriteSurfaceHandlesForCurves(a, b);
}

</t>
<t tx="leo.20191228122651.42">void SShell::MakeFromBoolean(SShell *a, SShell *b, SSurface::CombineAs type) {
    booleanFailed = false;

    a-&gt;MakeClassifyingBsps(NULL);
    b-&gt;MakeClassifyingBsps(NULL);

    // Copy over all the original curves, splitting them so that a
    // piecwise linear segment never crosses a surface from the other
    // shell.
    a-&gt;CopyCurvesSplitAgainst(/*opA=*/true,  b, this);
    b-&gt;CopyCurvesSplitAgainst(/*opA=*/false, a, this);

    // Generate the intersection curves for each surface in A against all
    // the surfaces in B (which is all of the intersection curves).
    a-&gt;MakeIntersectionCurvesAgainst(b, this);

    SCurve *sc;
    for(sc = curve.First(); sc; sc = curve.NextAfter(sc)) {
        SSurface *srfA = sc-&gt;GetSurfaceA(a, b),
                       *srfB = sc-&gt;GetSurfaceB(a, b);

        sc-&gt;RemoveShortSegments(srfA, srfB);
    }

    // And clean up the piecewise linear things we made as a calculation aid
    a-&gt;CleanupAfterBoolean();
    b-&gt;CleanupAfterBoolean();
    // Remake the classifying BSPs with the split (and short-segment-removed)
    // curves
    a-&gt;MakeClassifyingBsps(this);
    b-&gt;MakeClassifyingBsps(this);

    if(b-&gt;surface.IsEmpty() || a-&gt;surface.IsEmpty()) {
        I = 1000000;
    } else {
        I = 0;
    }
    // Then trim and copy the surfaces
    a-&gt;CopySurfacesTrimAgainst(a, b, this, type);
    b-&gt;CopySurfacesTrimAgainst(a, b, this, type);

    // Now that we've copied the surfaces, we know their new hSurfaces, so
    // rewrite the curves to refer to the surfaces by their handles in the
    // result.
    RewriteSurfaceHandlesForCurves(a, b);

    // And clean up the piecewise linear things we made as a calculation aid
    a-&gt;CleanupAfterBoolean();
    b-&gt;CleanupAfterBoolean();
}

//-----------------------------------------------------------------------------
// All of the BSP routines that we use to perform and accelerate polygon ops.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.43">void SShell::MakeClassifyingBsps(SShell *useCurvesFrom) {
    SSurface *ss;
    for(ss = surface.First(); ss; ss = surface.NextAfter(ss)) {
        ss-&gt;MakeClassifyingBsp(this, useCurvesFrom);
    }
}

</t>
<t tx="leo.20191228122651.44">void SSurface::MakeClassifyingBsp(SShell *shell, SShell *useCurvesFrom) {
    SEdgeList el = {};

    MakeEdgesInto(shell, &amp;el, MakeAs::UV, useCurvesFrom);
    bsp = SBspUv::From(&amp;el, this);
    el.Clear();

    edges = {};
    MakeEdgesInto(shell, &amp;edges, MakeAs::XYZ, useCurvesFrom);
}

SBspUv *SBspUv::Alloc() {
    return (SBspUv *)AllocTemporary(sizeof(SBspUv));
}

SBspUv *SBspUv::From(SEdgeList *el, SSurface *srf) {
    SEdgeList work = {};

    SEdge *se;
    for(se = el-&gt;l.First(); se; se = el-&gt;l.NextAfter(se)) {
        work.AddEdge(se-&gt;a, se-&gt;b, se-&gt;auxA, se-&gt;auxB);
    }
    std::sort(work.l.begin(), work.l.end(), [](SEdge const &amp;a, SEdge const &amp;b) {
        double la = (a.a).Minus(a.b).Magnitude(), lb = (b.a).Minus(b.b).Magnitude();
        // Sort in descending order, longest first. This improves numerical
        // stability for the normals.
        return la &gt; lb;
    });
    SBspUv *bsp = NULL;
    for(se = work.l.First(); se; se = work.l.NextAfter(se)) {
        bsp = InsertOrCreateEdge(bsp, (se-&gt;a).ProjectXy(), (se-&gt;b).ProjectXy(), srf);
    }

    work.Clear();
    return bsp;
}

//-----------------------------------------------------------------------------
// The points in this BSP are in uv space, but we want to apply our tolerances
// consistently in xyz (i.e., we want to say a point is on-edge if its xyz
// distance to that edge is less than LENGTH_EPS, irrespective of its distance
// in uv). So we linearize the surface about the point we're considering and
// then do the test. That preserves point-on-line relationships, and the only
// time we care about exact correctness is when we're very close to the line,
// which is when the linearization is accurate.
//-----------------------------------------------------------------------------

</t>
<t tx="leo.20191228122651.45">void SBspUv::ScalePoints(Point2d *pt, Point2d *a, Point2d *b, SSurface *srf) const {
    Vector tu, tv;
    srf-&gt;TangentsAt(pt-&gt;x, pt-&gt;y, &amp;tu, &amp;tv);
    double mu = tu.Magnitude(), mv = tv.Magnitude();

    pt-&gt;x *= mu; pt-&gt;y *= mv;
    a -&gt;x *= mu; a -&gt;y *= mv;
    b -&gt;x *= mu; b -&gt;y *= mv;
}

double SBspUv::ScaledSignedDistanceToLine(Point2d pt, Point2d a, Point2d b,
                                          SSurface *srf) const
{
    ScalePoints(&amp;pt, &amp;a, &amp;b, srf);

    Point2d n = ((b.Minus(a)).Normal()).WithMagnitude(1);
    double d = a.Dot(n);

    return pt.Dot(n) - d;
}

double SBspUv::ScaledDistanceToLine(Point2d pt, Point2d a, Point2d b, bool asSegment,
                                    SSurface *srf) const
{
    ScalePoints(&amp;pt, &amp;a, &amp;b, srf);

    return pt.DistanceToLine(a, b, asSegment);
}

SBspUv *SBspUv::InsertOrCreateEdge(SBspUv *where, Point2d ea, Point2d eb, SSurface *srf) {
    if(where == NULL) {
        SBspUv *ret = Alloc();
        ret-&gt;a = ea;
        ret-&gt;b = eb;
        return ret;
    }
    where-&gt;InsertEdge(ea, eb, srf);
    return where;
}

</t>
<t tx="leo.20191228122651.46">void SBspUv::InsertEdge(Point2d ea, Point2d eb, SSurface *srf) {
    @others
}

SBspUv::Class SBspUv::ClassifyPoint(Point2d p, Point2d eb, SSurface *srf) const {
    double dp = ScaledSignedDistanceToLine(p, a, b, srf);

    if(fabs(dp) &lt; LENGTH_EPS) {
        const SBspUv *f = this;
        while(f) {
            Point2d ba = (f-&gt;b).Minus(f-&gt;a);
            if(ScaledDistanceToLine(p, f-&gt;a, ba, /*asSegment=*/true, srf) &lt; LENGTH_EPS) {
                if(ScaledDistanceToLine(eb, f-&gt;a, ba, /*asSegment=*/false, srf) &lt; LENGTH_EPS){
                    if(ba.Dot(eb.Minus(p)) &gt; 0) {
                        return Class::EDGE_PARALLEL;
                    } else {
                        return Class::EDGE_ANTIPARALLEL;
                    }
                } else {
                    return Class::EDGE_OTHER;
                }
            }
            f = f-&gt;more;
        }
        // Pick arbitrarily which side to send it down, doesn't matter
        Class c1 =  neg ? neg-&gt;ClassifyPoint(p, eb, srf) : Class::OUTSIDE;
        Class c2 =  pos ? pos-&gt;ClassifyPoint(p, eb, srf) : Class::INSIDE;
        if(c1 != c2) {
            dbp("MISMATCH: %d %d %08x %08x", c1, c2, neg, pos);
        }
        return c1;
    } else if(dp &gt; 0) {
        return pos ? pos-&gt;ClassifyPoint(p, eb, srf) : Class::INSIDE;
    } else {
        return neg ? neg-&gt;ClassifyPoint(p, eb, srf) : Class::OUTSIDE;
    }
}

SBspUv::Class SBspUv::ClassifyEdge(Point2d ea, Point2d eb, SSurface *srf) const {
    SBspUv::Class ret = ClassifyPoint((ea.Plus(eb)).ScaledBy(0.5), eb, srf);
    if(ret == Class::EDGE_OTHER) {
        // Perhaps the edge is tangent at its midpoint (and we screwed up
        // somewhere earlier and failed to split it); try a different
        // point on the edge.
        ret = ClassifyPoint(ea.Plus((eb.Minus(ea)).ScaledBy(0.294)), eb, srf);
    }
    return ret;
}

double SBspUv::MinimumDistanceToEdge(Point2d p, SSurface *srf) const {

    double dn = (neg) ? neg-&gt;MinimumDistanceToEdge(p, srf) : VERY_POSITIVE;
    double dp = (pos) ? pos-&gt;MinimumDistanceToEdge(p, srf) : VERY_POSITIVE;

    Point2d as = a, bs = b;
    ScalePoints(&amp;p, &amp;as, &amp;bs, srf);
    double d = p.DistanceToLine(as, bs.Minus(as), /*asSegment=*/true);

    return min(d, min(dn, dp));
}

</t>
<t tx="leo.20191228122651.47">double dea = ScaledSignedDistanceToLine(ea, a, b, srf),
       deb = ScaledSignedDistanceToLine(eb, a, b, srf);

if(fabs(dea) &lt; LENGTH_EPS &amp;&amp; fabs(deb) &lt; LENGTH_EPS) {
    // Line segment is coincident with this one, store in same node
    SBspUv *m = Alloc();
    m-&gt;a = ea;
    m-&gt;b = eb;
    m-&gt;more = more;
    more = m;
} else if(fabs(dea) &lt; LENGTH_EPS) {
    // Point A lies on this lie, but point B does not
    if(deb &gt; 0) {
        pos = InsertOrCreateEdge(pos, ea, eb, srf);
    } else {
        neg = InsertOrCreateEdge(neg, ea, eb, srf);
    }
} else if(fabs(deb) &lt; LENGTH_EPS) {
    // Point B lies on this lie, but point A does not
    if(dea &gt; 0) {
        pos = InsertOrCreateEdge(pos, ea, eb, srf);
    } else {
        neg = InsertOrCreateEdge(neg, ea, eb, srf);
    }
} else if(dea &gt; 0 &amp;&amp; deb &gt; 0) {
    pos = InsertOrCreateEdge(pos, ea, eb, srf);
} else if(dea &lt; 0 &amp;&amp; deb &lt; 0) {
    neg = InsertOrCreateEdge(neg, ea, eb, srf);
} else {
    // New edge crosses this one; we need to split.
    Point2d n = ((b.Minus(a)).Normal()).WithMagnitude(1);
    double d = a.Dot(n);
    double t = (d - n.Dot(ea)) / (n.Dot(eb.Minus(ea)));
    Point2d pi = ea.Plus((eb.Minus(ea)).ScaledBy(t));
    if(dea &gt; 0) {
        pos = InsertOrCreateEdge(pos, ea, pi, srf);
        neg = InsertOrCreateEdge(neg, pi, eb, srf);
    } else {
        neg = InsertOrCreateEdge(neg, ea, pi, srf);
        pos = InsertOrCreateEdge(pos, pi, eb, srf);
    }
}
return;
</t>
<t tx="leo.20191228122651.48">@path ./src/srf/
//-----------------------------------------------------------------------------
// Anything involving curves and sets of curves (except for the real math,
// which is in ratpoly.cpp).
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "../solvespace.h"

SBezier SBezier::From(Vector4 p0, Vector4 p1) {
    SBezier ret = {};
    ret.deg = 1;
    ret.weight[0] = p0.w;
    ret.ctrl  [0] = p0.PerspectiveProject();
    ret.weight[1] = p1.w;
    ret.ctrl  [1] = p1.PerspectiveProject();
    return ret;
}

SBezier SBezier::From(Vector4 p0, Vector4 p1, Vector4 p2) {
    SBezier ret = {};
    ret.deg = 2;
    ret.weight[0] = p0.w;
    ret.ctrl  [0] = p0.PerspectiveProject();
    ret.weight[1] = p1.w;
    ret.ctrl  [1] = p1.PerspectiveProject();
    ret.weight[2] = p2.w;
    ret.ctrl  [2] = p2.PerspectiveProject();
    return ret;
}

SBezier SBezier::From(Vector4 p0, Vector4 p1, Vector4 p2, Vector4 p3) {
    SBezier ret = {};
    ret.deg = 3;
    ret.weight[0] = p0.w;
    ret.ctrl  [0] = p0.PerspectiveProject();
    ret.weight[1] = p1.w;
    ret.ctrl  [1] = p1.PerspectiveProject();
    ret.weight[2] = p2.w;
    ret.ctrl  [2] = p2.PerspectiveProject();
    ret.weight[3] = p3.w;
    ret.ctrl  [3] = p3.PerspectiveProject();
    return ret;
}

SBezier SBezier::From(Vector p0, Vector p1) {
    return SBezier::From(p0.Project4d(),
                         p1.Project4d());
}

SBezier SBezier::From(Vector p0, Vector p1, Vector p2) {
    return SBezier::From(p0.Project4d(),
                         p1.Project4d(),
                         p2.Project4d());
}

SBezier SBezier::From(Vector p0, Vector p1, Vector p2, Vector p3) {
    return SBezier::From(p0.Project4d(),
                         p1.Project4d(),
                         p2.Project4d(),
                         p3.Project4d());
}

Vector SBezier::Start() const {
    return ctrl[0];
}

Vector SBezier::Finish() const {
    return ctrl[deg];
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122651.49">void SBezier::Reverse() {
    int i;
    for(i = 0; i &lt; (deg+1)/2; i++) {
        swap(ctrl[i], ctrl[deg-i]);
        swap(weight[i], weight[deg-i]);
    }
}

</t>
<t tx="leo.20191228122651.5">int aLayerIndex =
    std::find(std::begin(stackup), std::end(stackup), a-&gt;GetLayer()) - std::begin(stackup);
int bLayerIndex =
    std::find(std::begin(stackup), std::end(stackup), b-&gt;GetLayer()) - std::begin(stackup);
if(aLayerIndex == bLayerIndex) {
    return a-&gt;GetZIndex() &lt; b-&gt;GetZIndex();
} else {
    return aLayerIndex &lt; bLayerIndex;
}
</t>
<t tx="leo.20191228122651.50">void SBezier::ScaleSelfBy(double s) {
    int i;
    for(i = 0; i &lt;= deg; i++) {
        ctrl[i] = ctrl[i].ScaledBy(s);
    }
}

</t>
<t tx="leo.20191228122651.51">void SBezier::GetBoundingProjd(Vector u, Vector orig,
                               double *umin, double *umax) const
{
    int i;
    for(i = 0; i &lt;= deg; i++) {
        double ut = ((ctrl[i]).Minus(orig)).Dot(u);
        if(ut &lt; *umin) *umin = ut;
        if(ut &gt; *umax) *umax = ut;
    }
}

SBezier SBezier::TransformedBy(Vector t, Quaternion q, double scale) const {
    SBezier ret = *this;
    int i;
    for(i = 0; i &lt;= deg; i++) {
        ret.ctrl[i] = (ret.ctrl[i]).ScaledBy(scale);
        ret.ctrl[i] = (q.Rotate(ret.ctrl[i])).Plus(t);
    }
    return ret;
}

//-----------------------------------------------------------------------------
// Does this curve lie entirely within the specified plane? It does if all
// the control points lie in that plane.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.52">bool SBezier::IsInPlane(Vector n, double d) const {
    int i;
    for(i = 0; i &lt;= deg; i++) {
        if(fabs((ctrl[i]).Dot(n) - d) &gt; LENGTH_EPS) {
            return false;
        }
    }
    return true;
}

//-----------------------------------------------------------------------------
// Is this Bezier exactly the arc of a circle, projected along the specified
// axis? If yes, return that circle's center and radius.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.53">bool SBezier::IsCircle(Vector axis, Vector *center, double *r) const {
    if(deg != 2) return false;

    if(ctrl[1].DistanceToLine(ctrl[0], ctrl[2].Minus(ctrl[0])) &lt; LENGTH_EPS) {
        // This is almost a line segment. So it's a circle with very large
        // radius, which is likely to make code that tries to handle circles
        // blow up. So return false.
        return false;
    }

    Vector t0 = (ctrl[0]).Minus(ctrl[1]),
           t2 = (ctrl[2]).Minus(ctrl[1]),
           r0 = axis.Cross(t0),
           r2 = axis.Cross(t2);

    *center = Vector::AtIntersectionOfLines(ctrl[0], (ctrl[0]).Plus(r0),
                                            ctrl[2], (ctrl[2]).Plus(r2),
                                            NULL, NULL, NULL);

    @others
}

</t>
<t tx="leo.20191228122651.54">double rd0 = center-&gt;Minus(ctrl[0]).Magnitude(),
       rd2 = center-&gt;Minus(ctrl[2]).Magnitude();
if(fabs(rd0 - rd2) &gt; LENGTH_EPS) {
    return false;
}
*r = rd0;

Vector u = r0.WithMagnitude(1),
       v = (axis.Cross(u)).WithMagnitude(1);
Point2d c2  = center-&gt;Project2d(u, v),
        pa2 = (ctrl[0]).Project2d(u, v).Minus(c2),
        pb2 = (ctrl[2]).Project2d(u, v).Minus(c2);

</t>
<t tx="leo.20191228122651.55">double thetaa = atan2(pa2.y, pa2.x), // in fact always zero due to csys
       thetab = atan2(pb2.y, pb2.x),
       dtheta = WRAP_NOT_0(thetab - thetaa, 2*PI);
if(dtheta &gt; PI) {
    // Not possible with a second order Bezier arc; so we must have
    // the points backwards.
    dtheta = 2*PI - dtheta;
}

if(fabs(weight[1] - cos(dtheta/2)) &gt; LENGTH_EPS) {
    return false;
}

return true;
</t>
<t tx="leo.20191228122651.56">bool SBezier::IsRational() const {
    int i;
    for(i = 0; i &lt;= deg; i++) {
        if(fabs(weight[i] - 1) &gt; LENGTH_EPS) return true;
    }
    return false;
}

//-----------------------------------------------------------------------------
// Apply a perspective transformation to a rational Bezier curve, calculating
// the new weights as required.
//-----------------------------------------------------------------------------
SBezier SBezier::InPerspective(Vector u, Vector v, Vector n,
                               Vector origin, double cameraTan) const
{
    Quaternion q = Quaternion::From(u, v);
    q = q.Inverse();
    // we want Q*(p - o) = Q*p - Q*o
    SBezier ret = this-&gt;TransformedBy(q.Rotate(origin).ScaledBy(-1), q, 1.0);
    int i;
    for(i = 0; i &lt;= deg; i++) {
        Vector4 ct = Vector4::From(ret.weight[i], ret.ctrl[i]);
        // so the desired curve, before perspective, is
        //    (x/w, y/w, z/w)
        // and after perspective is
        //    ((x/w)/(1 - (z/w)*cameraTan, ...
        //  = (x/(w - z*cameraTan), ...
        // so we want to let w' = w - z*cameraTan
        ct.w = ct.w - ct.z*cameraTan;

        ret.ctrl[i] = ct.PerspectiveProject();
        ret.weight[i] = ct.w;
    }
    return ret;
}

</t>
<t tx="leo.20191228122651.57">bool SBezier::Equals(SBezier *b) const {
    // We just test of identical degree and control points, even though two
    // curves could still be coincident (even sharing endpoints).
    if(deg != b-&gt;deg) return false;
    int i;
    for(i = 0; i &lt;= deg; i++) {
        if(!(ctrl[i]).Equals(b-&gt;ctrl[i])) return false;
        if(fabs(weight[i] - b-&gt;weight[i]) &gt; LENGTH_EPS) return false;
    }
    return true;
}

</t>
<t tx="leo.20191228122651.58">void SBezierList::Clear() {
    l.Clear();
}

</t>
<t tx="leo.20191228122651.59">void SBezierList::ScaleSelfBy(double s) {
    SBezier *sb;
    for(sb = l.First(); sb; sb = l.NextAfter(sb)) {
        sb-&gt;ScaleSelfBy(s);
    }
}

//-----------------------------------------------------------------------------
// If our list contains multiple identical Beziers (in either forward or
// reverse order), then cull them. If both is true, both beziers are removed.
// Otherwise only one of them is removed.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.6">class OpenGl3RendererBatch final : public BatchCanvas {
public:
    struct EdgeBuffer {
        hStroke         h;
        SEdgeList       edges;

        @others
};

//-----------------------------------------------------------------------------
// Factory functions.
//-----------------------------------------------------------------------------

std::shared_ptr&lt;BatchCanvas&gt; OpenGl3Renderer::CreateBatch() {
    OpenGl3RendererBatch *batch = new OpenGl3RendererBatch();
    batch-&gt;renderer = this;
    return std::shared_ptr&lt;BatchCanvas&gt;(batch);
}

std::shared_ptr&lt;ViewportCanvas&gt; CreateRenderer() {
    return std::shared_ptr&lt;ViewportCanvas&gt;(new OpenGl3Renderer());
}

}
</t>
<t tx="leo.20191228122651.60">void SBezierList::CullIdenticalBeziers(bool both) {
    int i, j;

    l.ClearTags();
    for(i = 0; i &lt; l.n; i++) {
        SBezier *bi = &amp;(l[i]), bir;
        bir = *bi;
        bir.Reverse();

        for(j = i + 1; j &lt; l.n; j++) {
            SBezier *bj = &amp;(l[j]);
            if(bj-&gt;Equals(bi) ||
               bj-&gt;Equals(&amp;bir))
            {
                if (both) bi-&gt;tag = 1;
                bj-&gt;tag = 1;
            }
        }
    }
    l.RemoveTagged();
}

//-----------------------------------------------------------------------------
// Find all the points where a list of Bezier curves intersects another list
// of Bezier curves. We do this by intersecting their piecewise linearizations,
// and then refining any intersections that we find to lie exactly on the
// curves. So this will screw up on tangencies and stuff, but otherwise should
// be fine.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.61">void SBezierList::AllIntersectionsWith(SBezierList *sblb, SPointList *spl) const {
    for(const SBezier *sba = l.First(); sba; sba = l.NextAfter(sba)) {
        for(const SBezier *sbb = sblb-&gt;l.First(); sbb; sbb = sblb-&gt;l.NextAfter(sbb)) {
            sbb-&gt;AllIntersectionsWith(sba, spl);
        }
    }
}
</t>
<t tx="leo.20191228122651.62">void SBezier::AllIntersectionsWith(const SBezier *sbb, SPointList *spl) const {
    SPointList splRaw = {};
    SEdgeList sea, seb;
    sea = {};
    seb = {};
    this-&gt;MakePwlInto(&amp;sea);
    sbb -&gt;MakePwlInto(&amp;seb);
    SEdge *se;
    for(se = sea.l.First(); se; se = sea.l.NextAfter(se)) {
        // This isn't quite correct, since AnyEdgeCrossings doesn't count
        // the case where two pairs of line segments intersect at their
        // vertices. So this isn't robust, although that case isn't very
        // likely.
        seb.AnyEdgeCrossings(se-&gt;a, se-&gt;b, NULL, &amp;splRaw);
    }
    SPoint *sp;
    for(sp = splRaw.l.First(); sp; sp = splRaw.l.NextAfter(sp)) {
        Vector p = sp-&gt;p;
        if(PointOnThisAndCurve(sbb, &amp;p)) {
            if(!spl-&gt;ContainsPoint(p)) spl-&gt;Add(p);
        }
    }
    sea.Clear();
    seb.Clear();
    splRaw.Clear();
}

//-----------------------------------------------------------------------------
// Find a plane that contains all of the curves in this list. If the curves
// are all colinear (or coincident, or empty), then that plane is not exactly
// determined but we choose the additional degree(s) of freedom arbitrarily.
// Returns true if all the curves are coplanar, otherwise false.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.63">bool SBezierList::GetPlaneContainingBeziers(Vector *p, Vector *u, Vector *v,
                        Vector *notCoplanarAt) const
{
    Vector pt, ptFar, ptOffLine, dp, n;
    double farMax, offLineMax;
    int i;

    // Get any point on any Bezier; or an arbitrary point if list is empty.
    if(!l.IsEmpty()) {
        pt = l[0].Start();
    } else {
        pt = Vector::From(0, 0, 0);
    }
    ptFar = ptOffLine = pt;

    // Get the point farthest from our arbitrary point.
    farMax = VERY_NEGATIVE;
    for(const SBezier *sb = l.First(); sb; sb = l.NextAfter(sb)) {
        for(i = 0; i &lt;= sb-&gt;deg; i++) {
            double m = (pt.Minus(sb-&gt;ctrl[i])).Magnitude();
            if(m &gt; farMax) {
                ptFar = sb-&gt;ctrl[i];
                farMax = m;
            }
        }
    }
    if(ptFar.Equals(pt)) {
        // The points are all coincident. So neither basis vector matters.
        *p = pt;
        *u = Vector::From(1, 0, 0);
        *v = Vector::From(0, 1, 0);
        return true;
    }

    // Get the point farthest from the line between pt and ptFar
    dp = ptFar.Minus(pt);
    offLineMax = VERY_NEGATIVE;
    for(const SBezier *sb = l.First(); sb; sb = l.NextAfter(sb)) {
        for(i = 0; i &lt;= sb-&gt;deg; i++) {
            double m = (sb-&gt;ctrl[i]).DistanceToLine(pt, dp);
            if(m &gt; offLineMax) {
                ptOffLine = sb-&gt;ctrl[i];
                offLineMax = m;
            }
        }
    }

    *p = pt;
    if(offLineMax &lt; LENGTH_EPS) {
        // The points are all colinear; so choose the second basis vector
        // arbitrarily.
        *u = (ptFar.Minus(pt)).WithMagnitude(1);
        *v = (u-&gt;Normal(0)).WithMagnitude(1);
    } else {
        // The points actually define a plane.
        n = (ptFar.Minus(pt)).Cross(ptOffLine.Minus(pt));
        *u = (n.Normal(0)).WithMagnitude(1);
        *v = (n.Normal(1)).WithMagnitude(1);
    }

    // So we have a plane; but check whether all of the points lie in that
    // plane.
    n = u-&gt;Cross(*v);
    n = n.WithMagnitude(1);
    double d = p-&gt;Dot(n);
    for(const SBezier *sb = l.First(); sb; sb = l.NextAfter(sb)) {
        for(i = 0; i &lt;= sb-&gt;deg; i++) {
            if(fabs(n.Dot(sb-&gt;ctrl[i]) - d) &gt; LENGTH_EPS) {
                if(notCoplanarAt) *notCoplanarAt = sb-&gt;ctrl[i];
                return false;
            }
        }
    }
    return true;
}

//-----------------------------------------------------------------------------
// Assemble curves in sbl into a single loop. The curves may appear in any
// direction (start to finish, or finish to start), and will be reversed if
// necessary. The curves in the returned loop are removed from sbl, even if
// the loop cannot be closed.
//-----------------------------------------------------------------------------
SBezierLoop SBezierLoop::FromCurves(SBezierList *sbl,
                                    bool *allClosed, SEdge *errorAt)
{
    SBezierLoop loop = {};

    if(sbl-&gt;l.n &lt; 1) return loop;
    sbl-&gt;l.ClearTags();

    SBezier *first = &amp;(sbl-&gt;l[0]);
    first-&gt;tag = 1;
    loop.l.Add(first);
    Vector start = first-&gt;Start();
    Vector hanging = first-&gt;Finish();
    int auxA = first-&gt;auxA;

    sbl-&gt;l.RemoveTagged();

    while(!sbl-&gt;l.IsEmpty() &amp;&amp; !hanging.Equals(start)) {
        int i;
        bool foundNext = false;
        for(i = 0; i &lt; sbl-&gt;l.n; i++) {
            SBezier *test = &amp;(sbl-&gt;l[i]);

            if((test-&gt;Finish()).Equals(hanging) &amp;&amp; test-&gt;auxA == auxA) {
                test-&gt;Reverse();
                // and let the next test catch it
            }
            if((test-&gt;Start()).Equals(hanging) &amp;&amp; test-&gt;auxA == auxA) {
                test-&gt;tag = 1;
                loop.l.Add(test);
                hanging = test-&gt;Finish();
                sbl-&gt;l.RemoveTagged();
                foundNext = true;
                break;
            }
        }
        if(!foundNext) {
            // The loop completed without finding the hanging edge, so
            // it's an open loop
            errorAt-&gt;a = hanging;
            errorAt-&gt;b = start;
            *allClosed = false;
            return loop;
        }
    }
    if(hanging.Equals(start)) {
        *allClosed = true;
    } else {
        // We ran out of edges without forming a closed loop.
        errorAt-&gt;a = hanging;
        errorAt-&gt;b = start;
        *allClosed = false;
    }

    return loop;
}

</t>
<t tx="leo.20191228122651.64">void SBezierLoop::Reverse() {
    l.Reverse();
    SBezier *sb;
    for(sb = l.First(); sb; sb = l.NextAfter(sb)) {
        // If we didn't reverse each curve, then the next curve in list would
        // share your start, not your finish.
        sb-&gt;Reverse();
    }
}

</t>
<t tx="leo.20191228122651.65">void SBezierLoop::GetBoundingProjd(Vector u, Vector orig,
                                   double *umin, double *umax) const
{
    for(const SBezier *sb = l.First(); sb; sb = l.NextAfter(sb)) {
        sb-&gt;GetBoundingProjd(u, orig, umin, umax);
    }
}

</t>
<t tx="leo.20191228122651.66">void SBezierLoop::MakePwlInto(SContour *sc, double chordTol) const {
    for(const SBezier *sb = l.First(); sb; sb = l.NextAfter(sb)) {
        sb-&gt;MakePwlInto(sc, chordTol);
        // Avoid double points at join between Beziers; except that
        // first and last points should be identical.
        if(l.NextAfter(sb) != NULL) {
            sc-&gt;l.RemoveLast(1);
        }
    }
    // Ensure that it's exactly closed, not just within a numerical tolerance.
    if((sc-&gt;l.Last()-&gt;p).Equals(sc-&gt;l.First()-&gt;p)) {
        *sc-&gt;l.Last() = *sc-&gt;l.First();
    }
}

</t>
<t tx="leo.20191228122651.67">bool SBezierLoop::IsClosed() const {
    if(l.IsEmpty()) return false;
    Vector s = l.First()-&gt;Start(),
           f = l.Last()-&gt;Finish();
    return s.Equals(f);
}


//-----------------------------------------------------------------------------
// Assemble the curves in sbl into multiple loops, and piecewise linearize the
// curves into poly. If we can't close a contour, then we add it to
// openContours (if that isn't NULL) and keep going; so this works even if the
// input contains a mix of open and closed curves.
//-----------------------------------------------------------------------------
SBezierLoopSet SBezierLoopSet::From(SBezierList *sbl, SPolygon *poly,
</t>
<t tx="leo.20191228122651.68">                                    double chordTol,
                                    bool *allClosed, SEdge *errorAt,
                                    SBezierLoopSet *openContours)
{
    SBezierLoopSet ret = {};

    *allClosed = true;
    while(!sbl-&gt;l.IsEmpty()) {
        bool thisClosed;
        SBezierLoop loop;
        loop = SBezierLoop::FromCurves(sbl, &amp;thisClosed, errorAt);
        if(!thisClosed) {
            // Record open loops in a separate list, if requested.
            *allClosed = false;
            if(openContours) {
                openContours-&gt;l.Add(&amp;loop);
            } else {
                loop.Clear();
            }
        } else {
            ret.l.Add(&amp;loop);
            poly-&gt;AddEmptyContour();
            loop.MakePwlInto(poly-&gt;l.Last(), chordTol);
        }
    }

    poly-&gt;normal = poly-&gt;ComputeNormal();
    ret.normal = poly-&gt;normal;
    if(poly-&gt;l.n &gt; 0) {
        ret.point = poly-&gt;AnyPoint();
    } else {
        ret.point = Vector::From(0, 0, 0);
    }

    return ret;
}

</t>
<t tx="leo.20191228122651.69">void SBezierLoopSet::GetBoundingProjd(Vector u, Vector orig,
                                      double *umin, double *umax) const
{
    for(const SBezierLoop *sbl = l.First(); sbl; sbl = l.NextAfter(sbl)) {
        sbl-&gt;GetBoundingProjd(u, orig, umin, umax);
    }
}

double SBezierLoopSet::SignedArea() {
    if(EXACT(area == 0.0)) {
        SPolygon sp = {};
        MakePwlInto(&amp;sp);
        sp.normal = sp.ComputeNormal();
        area = sp.SignedArea();
        sp.Clear();
    }
    return area;
}

//-----------------------------------------------------------------------------
// Convert all the Beziers into piecewise linear form, and assemble that into
// a polygon, one contour per loop.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.7">    void Clear() {
        edges.Clear();
    }
};

struct PointBuffer {
    hStroke         h;
    SIndexedMesh    points;

</t>
<t tx="leo.20191228122651.70">void SBezierLoopSet::MakePwlInto(SPolygon *sp) const {
    for(const SBezierLoop *sbl = l.First(); sbl; sbl = l.NextAfter(sbl)) {
        sp-&gt;AddEmptyContour();
        sbl-&gt;MakePwlInto(sp-&gt;l.Last());
    }
}

</t>
<t tx="leo.20191228122651.71">void SBezierLoopSet::Clear() {
    int i;
    for(i = 0; i &lt; l.n; i++) {
        (l[i]).Clear();
    }
    l.Clear();
}

//-----------------------------------------------------------------------------
// An export helper function. We start with a list of Bezier curves, and
// assemble them into loops. We find the outer loops, and find the outer loops'
// inner loops, and group them accordingly.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.72">void SBezierLoopSetSet::FindOuterFacesFrom(SBezierList *sbl, SPolygon *spxyz,
                                   SSurface *srfuv,
                                   double chordTol,
                                   bool *allClosed, SEdge *notClosedAt,
                                   bool *allCoplanar, Vector *notCoplanarAt,
                                   SBezierLoopSet *openContours)
{
    SSurface srfPlane;
    if(!srfuv) {
        Vector p, u, v;
        *allCoplanar =
            sbl-&gt;GetPlaneContainingBeziers(&amp;p, &amp;u, &amp;v, notCoplanarAt);
        if(!*allCoplanar) {
            // Don't even try to assemble them into loops if they're not
            // all coplanar.
            if(openContours) {
                SBezier *sb;
                for(sb = sbl-&gt;l.First(); sb; sb = sbl-&gt;l.NextAfter(sb)) {
                    SBezierLoop sbl={};
                    sbl.l.Add(sb);
                    openContours-&gt;l.Add(&amp;sbl);
                }
            }
            return;
        }
        // All the curves lie in a plane through p with basis vectors u and v.
        srfPlane = SSurface::FromPlane(p, u, v);
        srfuv = &amp;srfPlane;
    }

    int i, j;
    // Assemble the Bezier trim curves into closed loops; we also get the
    // piecewise linearization of the curves (in the SPolygon spxyz), as a
    // calculation aid for the loop direction.
    SBezierLoopSet sbls = SBezierLoopSet::From(sbl, spxyz, chordTol,
                                               allClosed, notClosedAt,
                                               openContours);
    if(sbls.l.n != spxyz-&gt;l.n) return;

    // Convert the xyz piecewise linear to uv piecewise linear.
    SPolygon spuv = {};
    SContour *sc;
    for(sc = spxyz-&gt;l.First(); sc; sc = spxyz-&gt;l.NextAfter(sc)) {
        spuv.AddEmptyContour();
        SPoint *pt;
        for(pt = sc-&gt;l.First(); pt; pt = sc-&gt;l.NextAfter(pt)) {
            double u, v;
            srfuv-&gt;ClosestPointTo(pt-&gt;p, &amp;u, &amp;v);
            spuv.l.Last()-&gt;AddPoint(Vector::From(u, v, 0));
        }
    }
    spuv.normal = Vector::From(0, 0, 1); // must be, since it's in xy plane now

    static const int OUTER_LOOP = 10;
    static const int INNER_LOOP = 20;
    static const int USED_LOOP  = 30;
    // Fix the contour directions; we do this properly, in uv space, so it
    // works for curved surfaces too (important for STEP export).
    spuv.FixContourDirections();
    for(i = 0; i &lt; spuv.l.n; i++) {
        SContour    *contour = &amp;(spuv.l[i]);
        SBezierLoop *bl = &amp;(sbls.l[i]);
        if(contour-&gt;tag) {
            // This contour got reversed in the polygon to make the directions
            // consistent, so the same must be necessary for the Bezier loop.
            bl-&gt;Reverse();
        }
        if(contour-&gt;IsClockwiseProjdToNormal(spuv.normal)) {
            bl-&gt;tag = INNER_LOOP;
        } else {
            bl-&gt;tag = OUTER_LOOP;
        }
    }

    bool loopsRemaining = true;
    while(loopsRemaining) {
        loopsRemaining = false;
        for(i = 0; i &lt; sbls.l.n; i++) {
            SBezierLoop *loop = &amp;(sbls.l[i]);
            if(loop-&gt;tag != OUTER_LOOP) continue;

            // Check if this contour contains any outer loops; if it does, then
            // we should do those "inner outer loops" first; otherwise we
            // will steal their holes, since their holes also lie inside this
            // contour.
            for(j = 0; j &lt; sbls.l.n; j++) {
                SBezierLoop *outer = &amp;(sbls.l[j]);
                if(i == j) continue;
                if(outer-&gt;tag != OUTER_LOOP) continue;

                Vector p = spuv.l[j].AnyEdgeMidpoint();
                if(spuv.l[i].ContainsPointProjdToNormal(spuv.normal, p)) {
                    break;
                }
            }
            if(j &lt; sbls.l.n) {
                // It does, can't do this one yet.
                continue;
            }

            SBezierLoopSet outerAndInners = {};
            loopsRemaining = true;
            loop-&gt;tag = USED_LOOP;
            outerAndInners.l.Add(loop);
            int auxA = 0;
            if(loop-&gt;l.n &gt; 0) auxA = loop-&gt;l[0].auxA;

            for(j = 0; j &lt; sbls.l.n; j++) {
                SBezierLoop *inner = &amp;(sbls.l[j]);
                if(inner-&gt;tag != INNER_LOOP) continue;
                if(inner-&gt;l.n &lt; 1) continue;
                if(inner-&gt;l[0].auxA != auxA) continue;

                Vector p = spuv.l[j].AnyEdgeMidpoint();
                if(spuv.l[i].ContainsPointProjdToNormal(spuv.normal, p)) {
                    outerAndInners.l.Add(inner);
                    inner-&gt;tag = USED_LOOP;
                }
            }

            outerAndInners.point  = srfuv-&gt;PointAt(0, 0);
            outerAndInners.normal = srfuv-&gt;NormalAt(0, 0);
            l.Add(&amp;outerAndInners);
        }
    }

    // If we have poorly-formed loops--for example, overlapping zero-area
    // stuff--then we can end up with leftovers. We use this function to
    // group stuff into closed paths for export when possible, so it's bad
    // to screw up on that stuff. So just add them onto the open curve list.
    // Very ugly, but better than losing curves.
    for(i = 0; i &lt; sbls.l.n; i++) {
        SBezierLoop *loop = &amp;(sbls.l[i]);
        if(loop-&gt;tag == USED_LOOP) continue;

        if(openContours) {
            openContours-&gt;l.Add(loop);
        } else {
            loop-&gt;Clear();
        }
        // but don't free the used loops, since we shallow-copied them to
        // ourself
    }

    sbls.l.Clear(); // not sbls.Clear(), since that would deep-clear
    spuv.Clear();
}

</t>
<t tx="leo.20191228122651.73">void SBezierLoopSetSet::AddOpenPath(SBezier *sb) {
    SBezierLoop sbl = {};
    sbl.l.Add(sb);

    SBezierLoopSet sbls = {};
    sbls.l.Add(&amp;sbl);

    l.Add(&amp;sbls);
}

</t>
<t tx="leo.20191228122651.74">void SBezierLoopSetSet::Clear() {
    SBezierLoopSet *sbls;
    for(sbls = l.First(); sbls; sbls = l.NextAfter(sbls)) {
        sbls-&gt;Clear();
    }
    l.Clear();
}

SCurve SCurve::FromTransformationOf(SCurve *a, Vector t,
                                    Quaternion q, double scale)
{
    bool needRotate    = !EXACT(q.vx == 0.0 &amp;&amp; q.vy == 0.0 &amp;&amp; q.vz == 0.0 &amp;&amp; q.w == 1.0);
    bool needTranslate = !EXACT(t.x  == 0.0 &amp;&amp; t.y  == 0.0 &amp;&amp; t.z  == 0.0);
    bool needScale     = !EXACT(scale == 1.0);

    SCurve ret = {};
    ret.h = a-&gt;h;
    ret.isExact = a-&gt;isExact;
    ret.exact = (a-&gt;exact).TransformedBy(t, q, scale);
    ret.surfA = a-&gt;surfA;
    ret.surfB = a-&gt;surfB;

    SCurvePt *p;
    ret.pts.ReserveMore(a-&gt;pts.n);
    for(p = a-&gt;pts.First(); p; p = a-&gt;pts.NextAfter(p)) {
        SCurvePt pp = *p;
        if(needScale) {
            pp.p = (pp.p).ScaledBy(scale);
        }
        if(needRotate) {
            pp.p = q.Rotate(pp.p);
        }
        if(needTranslate) {
            pp.p = pp.p.Plus(t);
        }
        ret.pts.Add(&amp;pp);
    }
    return ret;
}

</t>
<t tx="leo.20191228122651.75">void SCurve::Clear() {
    pts.Clear();
}

SSurface *SCurve::GetSurfaceA(SShell *a, SShell *b) const {
    if(source == Source::A) {
        return a-&gt;surface.FindById(surfA);
    } else if(source == Source::B) {
        return b-&gt;surface.FindById(surfA);
    } else if(source == Source::INTERSECTION) {
        return a-&gt;surface.FindById(surfA);
    } else ssassert(false, "Unexpected curve source");
}

SSurface *SCurve::GetSurfaceB(SShell *a, SShell *b) const {
    if(source == Source::A) {
        return a-&gt;surface.FindById(surfB);
    } else if(source == Source::B) {
        return b-&gt;surface.FindById(surfB);
    } else if(source == Source::INTERSECTION) {
        return b-&gt;surface.FindById(surfB);
    } else ssassert(false, "Unexpected curve source");
}

//-----------------------------------------------------------------------------
// When we split line segments wherever they intersect a surface, we introduce
// extra pwl points. This may create very short edges that could be removed
// without violating the chord tolerance. Those are ugly, and also break
// stuff in the Booleans. So remove them.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122651.76">void SCurve::RemoveShortSegments(SSurface *srfA, SSurface *srfB) {
    // Three, not two; curves are pwl'd to at least two edges (three points)
    // even if not necessary, to avoid square holes.
    if(pts.n &lt;= 3) return;
    pts.ClearTags();

    Vector prev = pts[0].p;
    int i, a;
    for(i = 1; i &lt; pts.n - 1; i++) {
        SCurvePt *sct = &amp;(pts[i]),
                 *scn = &amp;(pts[i+1]);
        if(sct-&gt;vertex) {
            prev = sct-&gt;p;
            continue;
        }
        bool mustKeep = false;

        // We must check against both surfaces; the piecewise linear edge
        // may have a different chord tolerance in the two surfaces. (For
        // example, a circle in the surface of a cylinder is just a straight
        // line, so it always has perfect chord tol, but that circle in
        // a plane is a circle so it doesn't).
        for(a = 0; a &lt; 2; a++) {
            SSurface *srf = (a == 0) ? srfA : srfB;
            Vector puv, nuv;
            srf-&gt;ClosestPointTo(prev,   &amp;(puv.x), &amp;(puv.y));
            srf-&gt;ClosestPointTo(scn-&gt;p, &amp;(nuv.x), &amp;(nuv.y));

            if(srf-&gt;ChordToleranceForEdge(nuv, puv) &gt; SS.ChordTolMm()) {
                mustKeep = true;
            }
        }

        if(mustKeep) {
            prev = sct-&gt;p;
        } else {
            sct-&gt;tag = 1;
            // and prev is unchanged, since there's no longer any point
            // in between
        }
    }

    pts.RemoveTagged();
}

STrimBy STrimBy::EntireCurve(SShell *shell, hSCurve hsc, bool backwards) {
    STrimBy stb = {};
    stb.curve = hsc;
    SCurve *sc = shell-&gt;curve.FindById(hsc);

    if(backwards) {
        stb.finish = sc-&gt;pts[0].p;
        stb.start = sc-&gt;pts.Last()-&gt;p;
        stb.backwards = true;
    } else {
        stb.start = sc-&gt;pts[0].p;
        stb.finish = sc-&gt;pts.Last()-&gt;p;
        stb.backwards = false;
    }

    return stb;
}

</t>
<t tx="leo.20191228122651.77">@path ./src/srf/
//-----------------------------------------------------------------------------
// Routines to merge multiple coincident surfaces (each with their own trim
// curves) into a single surface, with all of the trim curves.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "../solvespace.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122651.78">void SShell::MergeCoincidentSurfaces() {
    surface.ClearTags();

    int i, j;
    SSurface *si, *sj;

    for(i = 0; i &lt; surface.n; i++) {
        si = &amp;(surface[i]);
        if(si-&gt;tag) continue;
        // Let someone else clean up the empty surfaces; we can certainly merge
        // them, but we don't know how to calculate a reasonable bounding box.
        if(si-&gt;trim.IsEmpty())
            continue;
        // And for now we handle only coincident planes, so no sense wasting
        // time on other surfaces.
        if(si-&gt;degm != 1 || si-&gt;degn != 1) continue;

        SEdgeList sel = {};
        si-&gt;MakeEdgesInto(this, &amp;sel, SSurface::MakeAs::XYZ);

        bool mergedThisTime, merged = false;
        do {
            mergedThisTime = false;

            for(j = i + 1; j &lt; surface.n; j++) {
                sj = &amp;(surface[j]);
                if(sj-&gt;tag) continue;
                if(!sj-&gt;CoincidentWith(si, /*sameNormal=*/true)) continue;
                if(!sj-&gt;color.Equals(si-&gt;color)) continue;
                // But we do merge surfaces with different face entities, since
                // otherwise we'd hardly ever merge anything.

                // This surface is coincident. But let's not merge coincident
                // surfaces if they contain disjoint contours; that just makes
                // the bounding box tests less effective, and possibly things
                // less robust.
                SEdgeList tel = {};
                sj-&gt;MakeEdgesInto(this, &amp;tel, SSurface::MakeAs::XYZ);
                if(!sel.ContainsEdgeFrom(&amp;tel)) {
                    tel.Clear();
                    continue;
                }
                tel.Clear();

                sj-&gt;tag = 1;
                merged = true;
                mergedThisTime = true;
                sj-&gt;MakeEdgesInto(this, &amp;sel, SSurface::MakeAs::XYZ);
                sj-&gt;trim.Clear();

                // All the references to this surface get replaced with the
                // new srf
                SCurve *sc;
                for(sc = curve.First(); sc; sc = curve.NextAfter(sc)) {
                    if(sc-&gt;surfA == sj-&gt;h) sc-&gt;surfA = si-&gt;h;
                    if(sc-&gt;surfB == sj-&gt;h) sc-&gt;surfB = si-&gt;h;
                }
            }

            // If this iteration merged a contour onto ours, then we have to
            // go through the surfaces again; that might have made a new
            // surface touch us.
        } while(mergedThisTime);

        if(merged) {
            sel.CullExtraneousEdges();
            si-&gt;trim.Clear();
            si-&gt;TrimFromEdgeList(&amp;sel, /*asUv=*/false);

            // And we must choose control points such that all the trims lie
            // with u and v in [0, 1], so that the bbox tests work.
            Vector u, v, n;
            si-&gt;TangentsAt(0.5, 0.5, &amp;u, &amp;v);
            u = u.WithMagnitude(1);
            v = v.WithMagnitude(1);
            n = si-&gt;NormalAt(0.5, 0.5).WithMagnitude(1);
            v = (n.Cross(u)).WithMagnitude(1);

            @others
}

</t>
<t tx="leo.20191228122651.79">        double umax = VERY_NEGATIVE, umin = VERY_POSITIVE,
               vmax = VERY_NEGATIVE, vmin = VERY_POSITIVE;
        SEdge *se;
        for(se = sel.l.First(); se; se = sel.l.NextAfter(se)) {
            double ut = (se-&gt;a).Dot(u), vt = (se-&gt;a).Dot(v);
            umax = max(umax, ut);
            vmax = max(vmax, vt);
            umin = min(umin, ut);
            vmin = min(vmin, vt);
        }

        // An interesting problem here; the real curve could extend
        // slightly beyond the bounding box of the piecewise linear
        // bits. Not a problem for us, but some apps won't import STEP
        // in that case. So give a bit of extra room; in theory just
        // a chord tolerance, but more can't hurt.
        double muv = max((umax - umin), (vmax - vmin));
        double tol = muv/50 + 3*SS.ChordTolMm();
        umax += tol;
        vmax += tol;
        umin -= tol;
        vmin -= tol;

        // We move in the +v direction as v goes from 0 to 1, and in the
        // +u direction as u goes from 0 to 1. So our normal ends up
        // pointed the same direction.
        double nt = (si-&gt;ctrl[0][0]).Dot(n);
        si-&gt;ctrl[0][0] =
            Vector::From(umin, vmin, nt).ScaleOutOfCsys(u, v, n);
        si-&gt;ctrl[0][1] =
            Vector::From(umin, vmax, nt).ScaleOutOfCsys(u, v, n);
        si-&gt;ctrl[1][1] =
            Vector::From(umax, vmax, nt).ScaleOutOfCsys(u, v, n);
        si-&gt;ctrl[1][0] =
            Vector::From(umax, vmin, nt).ScaleOutOfCsys(u, v, n);
    }
    sel.Clear();
}

surface.RemoveTagged();
</t>
<t tx="leo.20191228122651.8">    void Clear() {
        points.Clear();
    }
};

OpenGl3Renderer *renderer;

IdList&lt;EdgeBuffer,  hStroke&gt; edgeBuffer;
IdList&lt;PointBuffer, hStroke&gt; pointBuffer;

std::multiset&lt;std::shared_ptr&lt;DrawCall&gt;, CompareDrawCall&gt; drawCalls;

OpenGl3RendererBatch() : renderer(), edgeBuffer(), pointBuffer() {}

</t>
<t tx="leo.20191228122651.80">@path ./src/srf/
//-----------------------------------------------------------------------------
// Math on rational polynomial surfaces and curves, typically in Bezier
// form. Evaluate, root-find (by Newton's methods), evaluate derivatives,
// and so on.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "../solvespace.h"

// Converge it to better than LENGTH_EPS; we want two points, each
// independently projected into uv and back, to end up equal with the
// LENGTH_EPS. Best case that requires LENGTH_EPS/2, but more is better
// and convergence should be fast by now.
#define RATPOLY_EPS (LENGTH_EPS/(1e2))

double SolveSpace::Bernstein(int k, int deg, double t)
{
    if(k &gt; deg || k &lt; 0) return 0;

    switch(deg) {
        case 0:
            return 1;

        case 1:
            if(k == 0) {
                return (1 - t);
            } else if(k == 1) {
                return t;
            }
            break;

        case 2:
            if(k == 0) {
                return (1 - t)*(1 - t);
            } else if(k == 1) {
                return 2*(1 - t)*t;
            } else if(k == 2) {
                return t*t;
            }
            break;

        case 3:
            if(k == 0) {
                return (1 - t)*(1 - t)*(1 - t);
            } else if(k == 1) {
                return 3*(1 - t)*(1 - t)*t;
            } else if(k == 2) {
                return 3*(1 - t)*t*t;
            } else if(k == 3) {
                return t*t*t;
            }
            break;
    }
    ssassert(false, "Unexpected degree of spline");
}

double SolveSpace::BernsteinDerivative(int k, int deg, double t)
{
    switch(deg) {
        case 0:
            return 0;

        case 1:
            if(k == 0) {
                return -1;
            } else if(k == 1) {
                return 1;
            }
            break;

        case 2:
            if(k == 0) {
                return -2 + 2*t;
            } else if(k == 1) {
                return 2 - 4*t;
            } else if(k == 2) {
                return 2*t;
            }
            break;

        case 3:
            if(k == 0) {
                return -3 + 6*t - 3*t*t;
            } else if(k == 1) {
                return 3 - 12*t + 9*t*t;
            } else if(k == 2) {
                return 6*t - 9*t*t;
            } else if(k == 3) {
                return 3*t*t;
            }
            break;
    }
    ssassert(false, "Unexpected degree of spline");
}

Vector SBezier::PointAt(double t) const {
    Vector pt = Vector::From(0, 0, 0);
    double d = 0;

    int i;
    for(i = 0; i &lt;= deg; i++) {
        double B = Bernstein(i, deg, t);
        pt = pt.Plus(ctrl[i].ScaledBy(B*weight[i]));
        d += weight[i]*B;
    }
    pt = pt.ScaledBy(1.0/d);
    return pt;
}

Vector SBezier::TangentAt(double t) const {
    Vector pt = Vector::From(0, 0, 0), pt_p = Vector::From(0, 0, 0);
    double d = 0, d_p = 0;

    int i;
    for(i = 0; i &lt;= deg; i++) {
        double B  = Bernstein(i, deg, t),
    Vector ret;
    ret = (pt_p.ScaledBy(d)).Minus(pt.ScaledBy(d_p));
    ret = ret.ScaledBy(1.0/(d*d));
    return ret;
}

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122651.81">void SBezier::ClosestPointTo(Vector p, double *t, bool mustConverge) const {
    int i;
    double minDist = VERY_POSITIVE;
    *t = 0;
    double res = (deg &lt;= 2) ? 7.0 : 20.0;
    for(i = 0; i &lt; (int)res; i++) {
        double tryt = (i/res);

        Vector tryp = PointAt(tryt);
        double d = (tryp.Minus(p)).Magnitude();
        if(d &lt; minDist) {
            *t = tryt;
            minDist = d;
        }
    }

    Vector p0;
    for(i = 0; i &lt; (mustConverge ? 15 : 5); i++) {
        p0 = PointAt(*t);
        if(p0.Equals(p, RATPOLY_EPS)) {
            return;
        }

        Vector dp = TangentAt(*t);
        Vector pc = p.ClosestPointOnLine(p0, dp);
        *t += (pc.Minus(p0)).DivProjected(dp);
    }
    if(mustConverge) {
        dbp("didn't converge (closest point on bezier curve)");
    }
}

</t>
<t tx="leo.20191228122651.82">bool SBezier::PointOnThisAndCurve(const SBezier *sbb, Vector *p) const {
    double ta, tb;
    this-&gt;ClosestPointTo(*p, &amp;ta, /*mustConverge=*/false);
    sbb -&gt;ClosestPointTo(*p, &amp;tb, /*mustConverge=*/false);

    int i;
    for(i = 0; i &lt; 20; i++) {
        Vector pa = this-&gt;PointAt(ta),
               pb = sbb -&gt;PointAt(tb),
               da = this-&gt;TangentAt(ta),
               db = sbb -&gt;TangentAt(tb);

        if(pa.Equals(pb, RATPOLY_EPS)) {
            *p = pa;
            return true;
        }

        double tta, ttb;
        Vector::ClosestPointBetweenLines(pa, da, pb, db, &amp;tta, &amp;ttb);
        ta += tta;
        tb += ttb;
    }
    return false;
}

</t>
<t tx="leo.20191228122651.83">void SBezier::SplitAt(double t, SBezier *bef, SBezier *aft) const {
    Vector4 ct[4];
    int i;
    for(i = 0; i &lt;= deg; i++) {
        ct[i] = Vector4::From(weight[i], ctrl[i]);
    }

    switch(deg) {
        case 1: {
            Vector4 cts = Vector4::Blend(ct[0], ct[1], t);
            *bef = SBezier::From(ct[0], cts);
            *aft = SBezier::From(cts, ct[1]);
            break;
        }
        case 2: {
            Vector4 ct01 = Vector4::Blend(ct[0], ct[1], t),
                    ct12 = Vector4::Blend(ct[1], ct[2], t),
                    cts  = Vector4::Blend(ct01,  ct12,  t);

            *bef = SBezier::From(ct[0], ct01, cts);
            *aft = SBezier::From(cts, ct12, ct[2]);
            break;
        }
        case 3: {
            Vector4 ct01    = Vector4::Blend(ct[0], ct[1], t),
                    ct12    = Vector4::Blend(ct[1], ct[2], t),
                    ct23    = Vector4::Blend(ct[2], ct[3], t),
                    ct01_12 = Vector4::Blend(ct01,  ct12,  t),
                    ct12_23 = Vector4::Blend(ct12,  ct23,  t),
                    cts     = Vector4::Blend(ct01_12, ct12_23, t);

            *bef = SBezier::From(ct[0], ct01, ct01_12, cts);
            *aft = SBezier::From(cts, ct12_23, ct23, ct[3]);
            break;
        }
        default: ssassert(false, "Unexpected degree of spline");
    }
}

</t>
<t tx="leo.20191228122651.84">void SBezier::MakePwlInto(SEdgeList *sel, double chordTol) const {
    List&lt;Vector&gt; lv = {};
    MakePwlInto(&amp;lv, chordTol);
    int i;
    for(i = 1; i &lt; lv.n; i++) {
        sel-&gt;AddEdge(lv[i-1], lv[i]);
    }
    lv.Clear();
}
</t>
<t tx="leo.20191228122651.85">void SBezier::MakePwlInto(List&lt;SCurvePt&gt; *l, double chordTol) const {
    List&lt;Vector&gt; lv = {};
    MakePwlInto(&amp;lv, chordTol);
    int i;
    for(i = 0; i &lt; lv.n; i++) {
        SCurvePt scpt;
        scpt.tag    = 0;
        scpt.p      = lv[i];
        scpt.vertex = (i == 0) || (i == (lv.n - 1));
        l-&gt;Add(&amp;scpt);
    }
    lv.Clear();
}
</t>
<t tx="leo.20191228122651.86">void SBezier::MakePwlInto(SContour *sc, double chordTol) const {
    List&lt;Vector&gt; lv = {};
    MakePwlInto(&amp;lv, chordTol);
    int i;
    for(i = 0; i &lt; lv.n; i++) {
        sc-&gt;AddPoint(lv[i]);
    }
    lv.Clear();
}
</t>
<t tx="leo.20191228122651.87">void SBezier::MakePwlInto(List&lt;Vector&gt; *l, double chordTol) const {
    if(EXACT(chordTol == 0)) {
        // Use the default chord tolerance.
        chordTol = SS.ChordTolMm();
    }
    l-&gt;Add(&amp;(ctrl[0]));
    if(deg == 1) {
        l-&gt;Add(&amp;(ctrl[1]));
    } else {
        // Never do fewer than one intermediate point; people seem to get
        // unhappy when their circles turn into squares, but maybe less
        // unhappy with octagons.
        MakePwlInitialWorker(l, 0.0, 0.5, chordTol);
        MakePwlInitialWorker(l, 0.5, 1.0, chordTol);
    }
}
</t>
<t tx="leo.20191228122651.88">void SBezier::MakePwlWorker(List&lt;Vector&gt; *l, double ta, double tb, double chordTol) const
{
    Vector pa = PointAt(ta);
    Vector pb = PointAt(tb);

    Vector pm = PointAt((ta + tb) / 2.0);
    double d = pm.DistanceToLine(pa, pb.Minus(pa));

    double step = 1.0/SS.GetMaxSegments();
    if((tb - ta) &lt; step || d &lt; chordTol) {
        // A previous call has already added the beginning of our interval.
        l-&gt;Add(&amp;pb);
    } else {
        double tm = (ta + tb) / 2;
        MakePwlWorker(l, ta, tm, chordTol);
        MakePwlWorker(l, tm, tb, chordTol);
    }
}
</t>
<t tx="leo.20191228122651.89">void SBezier::MakePwlInitialWorker(List&lt;Vector&gt; *l, double ta, double tb, double chordTol) const
{
    Vector pa = PointAt(ta);
    Vector pb = PointAt(tb);

    double tm1 = ta + (tb - ta) * 0.25;
    double tm2 = ta + (tb - ta) * 0.5;
    double tm3 = ta + (tb - ta) * 0.75;

    Vector pm1 = PointAt(tm1);
    Vector pm2 = PointAt(tm2);
    Vector pm3 = PointAt(tm3);
    Vector dir = pb.Minus(pa);

    @others
}

</t>
<t tx="leo.20191228122651.9">void DrawLine(const Vector &amp;a, const Vector &amp;b, hStroke hcs) override {
    EdgeBuffer *eb = edgeBuffer.FindByIdNoOops(hcs);
    if(!eb) {
        EdgeBuffer neb = {};
        neb.h = hcs;
        edgeBuffer.Add(&amp;neb);
        eb = edgeBuffer.FindById(hcs);
    }

    eb-&gt;edges.AddEdge(a, b);
}

</t>
<t tx="leo.20191228122651.90">double d = max({
               pm1.DistanceToLine(pa, dir),
               pm2.DistanceToLine(pa, dir),
               pm3.DistanceToLine(pa, dir)
            });

double step = 1.0/SS.GetMaxSegments();
if((tb - ta) &lt; step || d &lt; chordTol) {
    // A previous call has already added the beginning of our interval.
    l-&gt;Add(&amp;pb);
} else {
    double tm = (ta + tb) / 2;
    MakePwlWorker(l, ta, tm, chordTol);
    MakePwlWorker(l, tm, tb, chordTol);
}
</t>
<t tx="leo.20191228122651.91">void SBezier::MakeNonrationalCubicInto(SBezierList *bl, double tolerance, int depth) const {
    Vector t0 = TangentAt(0), t1 = TangentAt(1);
    // The curve is correct, and the first derivatives are correct, at the
    // endpoints.
    SBezier bnr = SBezier::From(
                        Start(),
                        Start().Plus(t0.ScaledBy(1.0/3)),
                        Finish().Minus(t1.ScaledBy(1.0/3)),
                        Finish());

    bool closeEnough = true;
    int i;
    for(i = 1; i &lt;= 3; i++) {
        double t = i/4.0;
        Vector p0 = PointAt(t),
               pn = bnr.PointAt(t);
        double d = (p0.Minus(pn)).Magnitude();
        if(d &gt; tolerance) {
            closeEnough = false;
        }
    }

    if(closeEnough || depth &gt; 3) {
        bl-&gt;l.Add(this);
    } else {
        SBezier bef, aft;
        SplitAt(0.5, &amp;bef, &amp;aft);
        bef.MakeNonrationalCubicInto(bl, tolerance, depth+1);
        aft.MakeNonrationalCubicInto(bl, tolerance, depth+1);
    }
}

Vector SSurface::PointAt(Point2d puv) const {
    return PointAt(puv.x, puv.y);
}
Vector SSurface::PointAt(double u, double v) const {
    Vector num = Vector::From(0, 0, 0);
    double den = 0;

    int i, j;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            double Bi = Bernstein(i, degm, u),
</t>
<t tx="leo.20191228122651.92">void SSurface::TangentsAt(double u, double v, Vector *tu, Vector *tv) const {
    Vector num   = Vector::From(0, 0, 0),
           num_u = Vector::From(0, 0, 0),
           num_v = Vector::From(0, 0, 0);
    @others
}

Vector SSurface::NormalAt(Point2d puv) const {
    return NormalAt(puv.x, puv.y);
}

Vector SSurface::NormalAt(double u, double v) const {
    Vector tu, tv;
    TangentsAt(u, v, &amp;tu, &amp;tv);
    return tu.Cross(tv);
}

</t>
<t tx="leo.20191228122651.93">double den   = 0,
       den_u = 0,
       den_v = 0;

int i, j;
for(i = 0; i &lt;= degm; i++) {
    for(j = 0; j &lt;= degn; j++) {
        double Bi  = Bernstein(i, degm, u),
        num_v = num_v.Plus(ctrl[i][j].ScaledBy(Bi*Bjp*weight[i][j]));
        den_v += weight[i][j]*Bi*Bjp;
    }
}
// quotient rule; f(t) = n(t)/d(t), so f' = (n'*d - n*d')/(d^2)
*tu = ((num_u.ScaledBy(den)).Minus(num.ScaledBy(den_u)));
*tu = tu-&gt;ScaledBy(1.0/(den*den));

*tv = ((num_v.ScaledBy(den)).Minus(num.ScaledBy(den_v)));
*tv = tv-&gt;ScaledBy(1.0/(den*den));
</t>
<t tx="leo.20191228122651.94">void SSurface::ClosestPointTo(Vector p, Point2d *puv, bool mustConverge) {
    ClosestPointTo(p, &amp;(puv-&gt;x), &amp;(puv-&gt;y), mustConverge);
}

</t>
<t tx="leo.20191228122651.95">void SSurface::ClosestPointTo(Vector p, double *u, double *v, bool mustConverge) {
    // A few special cases first; when control points are coincident the
    // derivative goes to zero at the control points, and would result in
    // nonconvergence. We avoid that here, and also guarantee a consistent
    // (u, v) (of the infinitely many possible in one parameter).
    if(p.Equals(ctrl[0]   [0]   )) { *u = 0; *v = 0; return; }
    if(p.Equals(ctrl[degm][0]   )) { *u = 1; *v = 0; return; }
    if(p.Equals(ctrl[degm][degn])) { *u = 1; *v = 1; return; }
    if(p.Equals(ctrl[0]   [degn])) { *u = 0; *v = 1; return; }

    // And planes are trivial, so don't waste time iterating over those.
    if(degm == 1 &amp;&amp; degn == 1) {
        Vector orig =  ctrl[0][0],
               bu   = (ctrl[1][0]).Minus(orig),
               bv   = (ctrl[0][1]).Minus(orig);
        if((ctrl[1][1]).Equals(orig.Plus(bu).Plus(bv))) {
            Vector dp = p.Minus(orig);
            *u = dp.Dot(bu) / bu.MagSquared();
            *v = dp.Dot(bv) / bv.MagSquared();
            return;
        }
    }

    // Try whatever the previous guess was. This is likely to do something
    // good if we're working our way along a curve or something else where
    // we project successive points that are close to each other; something
    // like a 20% speedup empirically.
    if(mustConverge) {
        double ut = cached.x, vt = cached.y;
        if(ClosestPointNewton(p, &amp;ut, &amp;vt, mustConverge)) {
            cached.x = *u = ut;
            cached.y = *v = vt;
            return;
        }
    }

    // Search for a reasonable initial guess
    int i, j;
    double minDist = VERY_POSITIVE;
    int res = (max(degm, degn) == 2) ? 7 : 20;
    for(i = 0; i &lt; res; i++) {
        for(j = 0; j &lt; res; j++) {
            double tryu = (i + 0.5)/res, tryv = (j + 0.5)/res;

            Vector tryp = PointAt(tryu, tryv);
            double d = (tryp.Minus(p)).Magnitude();
            if(d &lt; minDist) {
                *u = tryu;
                *v = tryv;
                minDist = d;
            }
        }
    }

    if(ClosestPointNewton(p, u, v, mustConverge)) {
        cached.x = *u;
        cached.y = *v;
        return;
    }

    // If we failed to converge, then at least don't return NaN.
    if(isnan(*u) || isnan(*v)) {
        *u = *v = 0;
    }
}

</t>
<t tx="leo.20191228122651.96">bool SSurface::ClosestPointNewton(Vector p, double *u, double *v, bool mustConverge) const
{
    // Initial guess is in u, v; refine by Newton iteration.
    Vector p0 = Vector::From(0, 0, 0);
    for(int i = 0; i &lt; (mustConverge ? 25 : 5); i++) {
        p0 = PointAt(*u, *v);
        if(mustConverge) {
            if(p0.Equals(p, RATPOLY_EPS)) {
                return true;
            }
        }

        Vector tu, tv;
        TangentsAt(*u, *v, &amp;tu, &amp;tv);

        // Project the point into a plane through p0, with basis tu, tv; a
        // second-order thing would converge faster but needs second
        // derivatives.
        Vector dp = p.Minus(p0);
        double du = dp.Dot(tu), dv = dp.Dot(tv);
        *u += du / (tu.MagSquared());
        *v += dv / (tv.MagSquared());
    }

    if(mustConverge) {
        dbp("didn't converge");
        dbp("have %.3f %.3f %.3f", CO(p0));
        dbp("want %.3f %.3f %.3f", CO(p));
        dbp("distance = %g", (p.Minus(p0)).Magnitude());
    }
    return false;
}

</t>
<t tx="leo.20191228122651.97">bool SSurface::PointIntersectingLine(Vector p0, Vector p1, double *u, double *v) const
{
    int i;
    for(i = 0; i &lt; 15; i++) {
        Vector pi, p, tu, tv;
        p = PointAt(*u, *v);
        TangentsAt(*u, *v, &amp;tu, &amp;tv);

        Vector n = (tu.Cross(tv)).WithMagnitude(1);
        double d = p.Dot(n);

        bool parallel;
        pi = Vector::AtIntersectionOfPlaneAndLine(n, d, p0, p1, &amp;parallel);
        if(parallel) break;

        // Check for convergence
        if(pi.Equals(p, RATPOLY_EPS)) return true;

        // Adjust our guess and iterate
        Vector dp = pi.Minus(p);
        double du = dp.Dot(tu), dv = dp.Dot(tv);
        *u += du / (tu.MagSquared());
        *v += dv / (tv.MagSquared());
    }
//    dbp("didn't converge (surface intersecting line)");
    return false;
}

Vector SSurface::ClosestPointOnThisAndSurface(SSurface *srf2, Vector p) {
    // This is untested.
    int i, j;
    Point2d puv[2];
    SSurface *srf[2] = { this, srf2 };

    for(j = 0; j &lt; 2; j++) {
        (srf[j])-&gt;ClosestPointTo(p, &amp;(puv[j]), /*mustConverge=*/false);
    }

    for(i = 0; i &lt; 10; i++) {
        Vector tu[2], tv[2], cp[2], n[2];
        double d[2];

        for(j = 0; j &lt; 2; j++) {
            (srf[j])-&gt;TangentsAt(puv[j].x, puv[j].y, &amp;(tu[j]), &amp;(tv[j]));

            cp[j] = (srf[j])-&gt;PointAt(puv[j]);

            n[j] = ((tu[j]).Cross(tv[j])).WithMagnitude(1);
            d[j] = (n[j]).Dot(cp[j]);
        }

        if((cp[0]).Equals(cp[1], RATPOLY_EPS)) break;

        Vector p0 = Vector::AtIntersectionOfPlanes(n[0], d[0], n[1], d[1]),
               dp = (n[0]).Cross(n[1]);

        Vector pc = p.ClosestPointOnLine(p0, dp);

        // Adjust our guess and iterate
        for(j = 0; j &lt; 2; j++) {
            Vector dc = pc.Minus(cp[j]);
            double du = dc.Dot(tu[j]), dv = dc.Dot(tv[j]);
            puv[j].x += du / ((tu[j]).MagSquared());
            puv[j].y += dv / ((tv[j]).MagSquared());
        }
    }
    if(i &gt;= 10) {
        dbp("this and srf, didn't converge, d=%g",
            (puv[0].Minus(puv[1])).Magnitude());
    }

    // If this converged, then the two points are actually equal.
    return ((srf[0])-&gt;PointAt(puv[0])).Plus(
           ((srf[1])-&gt;PointAt(puv[1]))).ScaledBy(0.5);
}

</t>
<t tx="leo.20191228122651.98">void SSurface::PointOnSurfaces(SSurface *s1, SSurface *s2, double *up, double *vp)
{
    double u[3] = { *up, 0, 0 }, v[3] = { *vp, 0, 0 };
    SSurface *srf[3] = { this, s1, s2 };

    // Get initial guesses for (u, v) in the other surfaces
    Vector p = PointAt(*u, *v);
    (srf[1])-&gt;ClosestPointTo(p, &amp;(u[1]), &amp;(v[1]), /*mustConverge=*/false);
    (srf[2])-&gt;ClosestPointTo(p, &amp;(u[2]), &amp;(v[2]), /*mustConverge=*/false);

    int i, j;
    for(i = 0; i &lt; 20; i++) {
        // Approximate each surface by a plane
        Vector p[3], tu[3], tv[3], n[3];
        double d[3];
        for(j = 0; j &lt; 3; j++) {
            p[j] = (srf[j])-&gt;PointAt(u[j], v[j]);
            (srf[j])-&gt;TangentsAt(u[j], v[j], &amp;(tu[j]), &amp;(tv[j]));
            n[j] = ((tu[j]).Cross(tv[j])).WithMagnitude(1);
            d[j] = (n[j]).Dot(p[j]);
        }

        // If a = b and b = c, then does a = c? No, it doesn't.
        if((p[0]).Equals(p[1], RATPOLY_EPS) &amp;&amp;
           (p[1]).Equals(p[2], RATPOLY_EPS) &amp;&amp;
           (p[2]).Equals(p[0], RATPOLY_EPS))
        {
            *up = u[0];
            *vp = v[0];
            return;
        }

        bool parallel;
        Vector pi = Vector::AtIntersectionOfPlanes(n[0], d[0],
                                                   n[1], d[1],
                                                   n[2], d[2], &amp;parallel);
        if(parallel) break;

        for(j = 0; j &lt; 3; j++) {
            Vector dp = pi.Minus(p[j]);
            double du = dp.Dot(tu[j]), dv = dp.Dot(tv[j]);
            u[j] += du / (tu[j]).MagSquared();
            v[j] += dv / (tv[j]).MagSquared();
        }
    }
    dbp("didn't converge (three surfaces intersecting)");
}

</t>
<t tx="leo.20191228122651.99">@path ./src/srf/
//-----------------------------------------------------------------------------
// Routines for ray-casting: intersecting a line segment or an infinite line
// with a surface or shell. Ray-casting against a shell is used for point-in-
// shell testing, and the intersection of edge line segments against surfaces
// is used to get rough surface-curve intersections, which are later refined
// numerically.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

// Dot product tolerance for perpendicular; this is on the direction cosine,
// so it's about 0.001 degrees.
const double SShell::DOTP_TOL = 1e-5;

extern int FLAG;


double SSurface::DepartureFromCoplanar() const {
    int i, j;
    int ia, ja, ib = 0, jb = 0, ic = 0, jc = 0;
    double best;

    // Grab three points to define a plane; first choose (0, 0) arbitrarily.
    ia = ja = 0;
    // Then the point farthest from pt a.
    best = VERY_NEGATIVE;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            if(i == ia &amp;&amp; j == ja) continue;

            double dist = (ctrl[i][j]).Minus(ctrl[ia][ja]).Magnitude();
            if(dist &gt; best) {
                best = dist;
                ib = i;
                jb = j;
            }
        }
    }
    // Then biggest magnitude of ab cross ac.
    best = VERY_NEGATIVE;
    for(i = 0; i &lt;= degm; i++) {
        for(j = 0; j &lt;= degn; j++) {
            if(i == ia &amp;&amp; j == ja) continue;
            if(i == ib &amp;&amp; j == jb) continue;

            @others
@language c
@tabwidth -4
</t>
<t tx="leo.20191228122652.1">@path ./src/srf/
//-----------------------------------------------------------------------------
// How to intersect two surfaces, to get some type of curve. This is either
// an exact special case (e.g., two planes to make a line), or a numerical
// thing.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "solvespace.h"

extern int FLAG;

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122652.10">bool SContour::BridgeToContour(SContour *sc,
                               SEdgeList *avoidEdges, List&lt;Vector&gt; *avoidPts)
{
    int i, j;

    // Start looking for a bridge on our new hole near its leftmost (min x)
    // point.
    int sco = 0;
    for(i = 0; i &lt; (sc-&gt;l.n - 1); i++) {
        if((sc-&gt;l[i].p).EqualsExactly(sc-&gt;xminPt)) {
            sco = i;
        }
    }

    // And start looking on our merged contour at whichever point is nearest
    // to the leftmost point of the new segment.
    int thiso = 0;
    double dmin = 1e10;
    for(i = 0; i &lt; l.n; i++) {
        Vector p = l[i].p;
        double d = (p.Minus(sc-&gt;xminPt)).MagSquared();
        if(d &lt; dmin) {
            dmin = d;
            thiso = i;
        }
    }

    int thisp, scp;

    Vector a, b, *f;

    // First check if the contours share a point; in that case we should
    // merge them there, without a bridge.
    for(i = 0; i &lt; l.n; i++) {
        thisp = WRAP(i+thiso, l.n);
        a = l[thisp].p;

        for(f = avoidPts-&gt;First(); f; f = avoidPts-&gt;NextAfter(f)) {
            if(f-&gt;Equals(a)) break;
        }
        if(f) continue;

        for(j = 0; j &lt; (sc-&gt;l.n - 1); j++) {
            scp = WRAP(j+sco, (sc-&gt;l.n - 1));
            b = sc-&gt;l[scp].p;

            if(a.Equals(b)) {
                goto haveEdge;
            }
        }
    }

    // If that fails, look for a bridge that does not intersect any edges.
    for(i = 0; i &lt; l.n; i++) {
        thisp = WRAP(i+thiso, l.n);
        a = l[thisp].p;

        for(f = avoidPts-&gt;First(); f; f = avoidPts-&gt;NextAfter(f)) {
            if(f-&gt;Equals(a)) break;
        }
        if(f) continue;

        for(j = 0; j &lt; (sc-&gt;l.n - 1); j++) {
            scp = WRAP(j+sco, (sc-&gt;l.n - 1));
            b = sc-&gt;l[scp].p;

            for(f = avoidPts-&gt;First(); f; f = avoidPts-&gt;NextAfter(f)) {
                if(f-&gt;Equals(b)) break;
            }
            if(f) continue;

            if(avoidEdges-&gt;AnyEdgeCrossings(a, b) &gt; 0) {
                // doesn't work, bridge crosses an existing edge
            } else {
                goto haveEdge;
            }
        }
    }

    // Tried all the possibilities, didn't find an edge
    return false;

haveEdge:
    SContour merged = {};
    for(i = 0; i &lt; l.n; i++) {
        merged.AddPoint(l[i].p);
        if(i == thisp) {
            // less than or equal; need to duplicate the join point
            for(j = 0; j &lt;= (sc-&gt;l.n - 1); j++) {
                int jp = WRAP(j + scp, (sc-&gt;l.n - 1));
                merged.AddPoint((sc-&gt;l[jp]).p);
            }
            // and likewise duplicate join point for the outer curve
            merged.AddPoint(l[i].p);
        }
    }

    // and future bridges mustn't cross our bridge, and it's tricky to get
    // things right if two bridges come from the same point
    avoidEdges-&gt;AddEdge(a, b);
    avoidPts-&gt;Add(&amp;a);
    avoidPts-&gt;Add(&amp;b);

    l.Clear();
    l = merged.l;
    return true;
}

</t>
<t tx="leo.20191228122652.11">bool SContour::IsEar(int bp, double scaledEps) const {
    @others
}

</t>
<t tx="leo.20191228122652.12">int ap = WRAP(bp-1, l.n),
    cp = WRAP(bp+1, l.n);

STriangle tr = {};
tr.a = l[ap].p;
tr.b = l[bp].p;
tr.c = l[cp].p;

if((tr.a).Equals(tr.c)) {
    // This is two coincident and anti-parallel edges. Zero-area, so
    // won't generate a real triangle, but we certainly can clip it.
    return true;
}

Vector n = Vector::From(0, 0, -1);
if((tr.Normal()).Dot(n) &lt; scaledEps) {
    // This vertex is reflex, or between two collinear edges; either way,
    // it's not an ear.
    return false;
}

// Accelerate with an axis-aligned bounding box test
Vector maxv = tr.a, minv = tr.a;
(tr.b).MakeMaxMin(&amp;maxv, &amp;minv);
(tr.c).MakeMaxMin(&amp;maxv, &amp;minv);

int i;
for(i = 0; i &lt; l.n; i++) {
    if(i == ap || i == bp || i == cp) continue;

    Vector p = l[i].p;
    if(p.OutsideAndNotOn(maxv, minv)) continue;

    // A point on the edge of the triangle is considered to be inside,
    // and therefore makes it a non-ear; but a point on the vertex is
    // "outside", since that's necessary to make bridges work.
    if(p.EqualsExactly(tr.a)) continue;
    if(p.EqualsExactly(tr.b)) continue;
    if(p.EqualsExactly(tr.c)) continue;

    if(tr.ContainsPointProjd(n, p)) {
        return false;
    }
}
return true;
</t>
<t tx="leo.20191228122652.13">void SContour::ClipEarInto(SMesh *m, int bp, double scaledEps) {
    @others
}

</t>
<t tx="leo.20191228122652.14">int ap = WRAP(bp-1, l.n),
    cp = WRAP(bp+1, l.n);

STriangle tr = {};
tr.a = l[ap].p;
tr.b = l[bp].p;
tr.c = l[cp].p;
if(tr.Normal().MagSquared() &lt; scaledEps*scaledEps) {
    // A vertex with more than two edges will cause us to generate
    // zero-area triangles, which must be culled.
} else {
    m-&gt;AddTriangle(&amp;tr);
}

// By deleting the point at bp, we may change the ear-ness of the points
// on either side.
l[ap].ear = EarType::UNKNOWN;
l[cp].ear = EarType::UNKNOWN;

l.ClearTags();
l[bp].tag = 1;
l.RemoveTagged();
</t>
<t tx="leo.20191228122652.15">void SContour::UvTriangulateInto(SMesh *m, SSurface *srf) {
    Vector tu, tv;
    srf-&gt;TangentsAt(0.5, 0.5, &amp;tu, &amp;tv);
    double s = sqrt(tu.MagSquared() + tv.MagSquared());
    // We would like to apply our tolerances in xyz; but that would be a lot
    // of work, so at least scale the epsilon semi-reasonably. That's
    // perfect for square planes, less perfect for anything else.
    double scaledEps = LENGTH_EPS / s;

    int i;
    // Clean the original contour by removing any zero-length edges.
    l.ClearTags();
    for(i = 1; i &lt; l.n; i++) {
       if((l[i].p).Equals(l[i-1].p)) {
            l[i].tag = 1;
        }
    }
    l.RemoveTagged();

    // Now calculate the ear-ness of each vertex
    for(i = 0; i &lt; l.n; i++) {
        (l[i]).ear = IsEar(i, scaledEps) ? EarType::EAR : EarType::NOT_EAR;
    }

    bool toggle = false;
    while(l.n &gt; 3) {
        // Some points may have changed ear-ness, so recalculate
        for(i = 0; i &lt; l.n; i++) {
            if(l[i].ear == EarType::UNKNOWN) {
                (l[i]).ear = IsEar(i, scaledEps) ?
                                        EarType::EAR : EarType::NOT_EAR;
            }
        }

        int bestEar = -1;
        double bestChordTol = VERY_POSITIVE;
        // Alternate the starting position so we generate strip-like
        // triangulations instead of fan-like
        toggle = !toggle;
        int offset = toggle ? -1 : 0;
        for(i = 0; i &lt; l.n; i++) {
            int ear = WRAP(i+offset, l.n);
            if(l[ear].ear == EarType::EAR) {
                if(srf-&gt;degm == 1 &amp;&amp; srf-&gt;degn == 1) {
                    // This is a plane; any ear is a good ear.
                    bestEar = ear;
                    break;
                }
                // If we are triangulating a curved surface, then try to
                // clip ears that have a small chord tolerance from the
                // surface.
                Vector prev = l[WRAP((i+offset-1), l.n)].p,
                       next = l[WRAP((i+offset+1), l.n)].p;
                double tol = srf-&gt;ChordToleranceForEdge(prev, next);
                if(tol &lt; bestChordTol - scaledEps) {
                    bestEar = ear;
                    bestChordTol = tol;
                }
                if(bestChordTol &lt; 0.1*SS.ChordTolMm()) {
                    break;
                }
            }
        }
        if(bestEar &lt; 0) {
            dbp("couldn't find an ear! fail");
            return;
        }
        ClipEarInto(m, bestEar, scaledEps);
    }

    ClipEarInto(m, 0, scaledEps); // add the last triangle
}

double SSurface::ChordToleranceForEdge(Vector a, Vector b) const {
    Vector as = PointAt(a.x, a.y), bs = PointAt(b.x, b.y);

    double worst = VERY_NEGATIVE;
    int i;
    for(i = 1; i &lt;= 3; i++) {
        Vector p  = a. Plus((b. Minus(a )).ScaledBy(i/4.0)),
               ps = as.Plus((bs.Minus(as)).ScaledBy(i/4.0));

        Vector pps = PointAt(p.x, p.y);
        worst = max(worst, (pps.Minus(ps)).MagSquared());
    }
    return sqrt(worst);
}

Vector SSurface::PointAtMaybeSwapped(double u, double v, bool swapped) const {
    if(swapped) {
        return PointAt(v, u);
    } else {
        return PointAt(u, v);
    }
}

</t>
<t tx="leo.20191228122652.16">void SSurface::MakeTriangulationGridInto(List&lt;double&gt; *l, double vs, double vf,
                                         bool swapped) const
{
    double worst = 0;

    // Try piecewise linearizing four curves, at u = 0, 1/3, 2/3, 1; choose
    // the worst chord tolerance of any of those.
    int i;
    for(i = 0; i &lt;= 3; i++) {
        double u = i/3.0;

        // This chord test should be identical to the one in SBezier::MakePwl
        // to make the piecewise linear edges line up with the grid more or
        // less.
        Vector ps = PointAtMaybeSwapped(u, vs, swapped),
               pf = PointAtMaybeSwapped(u, vf, swapped);

        double vm1 = (2*vs + vf) / 3,
    if((vf - vs) &lt; step || worst &lt; SS.ChordTolMm()) {
        l-&gt;Add(&amp;vf);
    } else {
        MakeTriangulationGridInto(l, vs, (vs+vf)/2, swapped);
        MakeTriangulationGridInto(l, (vs+vf)/2, vf, swapped);
    }
}

</t>
<t tx="leo.20191228122652.17">void SPolygon::UvGridTriangulateInto(SMesh *mesh, SSurface *srf) {
    SEdgeList orig = {};
    MakeEdgesInto(&amp;orig);

    SEdgeList holes = {};

    normal = Vector::From(0, 0, 1);
    FixContourDirections();

    // Build a rectangular grid, with horizontal and vertical lines in the
    // uv plane. The spacing of these lines is adaptive, so calculate that.
    List&lt;double&gt; li, lj;
    li = {};
    lj = {};
    double v = 0;
    li.Add(&amp;v);
    srf-&gt;MakeTriangulationGridInto(&amp;li, 0, 1, /*swapped=*/true);
    lj.Add(&amp;v);
    srf-&gt;MakeTriangulationGridInto(&amp;lj, 0, 1, /*swapped=*/false);

    // Now iterate over each quad in the grid. If it's outside the polygon,
    // or if it intersects the polygon, then we discard it. Otherwise we
    // generate two triangles in the mesh, and cut it out of our polygon.
    int i, j;
    for(i = 0; i &lt; (li.n - 1); i++) {
        for(j = 0; j &lt; (lj.n - 1); j++) {
            double us = li[i], uf = li[i+1],
               orig.AnyEdgeCrossings(d, a, NULL))
            {
                continue;
            }

            // There's no intersections, so it doesn't matter which point
            // we decide to test.
            if(!this-&gt;ContainsPoint(a)) {
                continue;
            }

            // Add the quad to our mesh
            STriangle tr = {};
            tr.a = a;
            tr.b = b;
            tr.c = c;
            mesh-&gt;AddTriangle(&amp;tr);
            tr.a = a;
            tr.b = c;
            tr.c = d;
            mesh-&gt;AddTriangle(&amp;tr);

            holes.AddEdge(a, b);
            holes.AddEdge(b, c);
            holes.AddEdge(c, d);
            holes.AddEdge(d, a);
        }
    }

    holes.CullExtraneousEdges();
    SPolygon hp = {};
    holes.AssemblePolygon(&amp;hp, NULL, /*keepDir=*/true);

    SContour *sc;
    for(sc = hp.l.First(); sc; sc = hp.l.NextAfter(sc)) {
        l.Add(sc);
    }

    orig.Clear();
    holes.Clear();
    li.Clear();
    lj.Clear();
    hp.l.Clear();

    UvTriangulateInto(mesh, srf);
}

</t>
<t tx="leo.20191228122652.18">void SPolygon::TriangulateInto(SMesh *m) const {
    Vector n = normal;
    if(n.Equals(Vector::From(0.0, 0.0, 0.0))) {
       n = ComputeNormal();
    }
    Vector u = n.Normal(0);
    Vector v = n.Normal(1);

    SPolygon p = {};
    this-&gt;InverseTransformInto(&amp;p, u, v, n);

    SSurface srf = SSurface::FromPlane(Vector::From(0.0, 0.0, 0.0),
                                       Vector::From(1.0, 0.0, 0.0),
                                       Vector::From(0.0, 1.0, 0.0));
    SMesh pm = {};
    p.UvTriangulateInto(&amp;pm, &amp;srf);
    for(STriangle st : pm.l) {
        st = st.Transform(u, v, n);
        m-&gt;AddTriangle(&amp;st);
    }

    p.Clear();
    pm.Clear();
}
</t>
<t tx="leo.20191228122652.2">void SSurface::AddExactIntersectionCurve(SBezier *sb, SSurface *srfB,
                                         SShell *agnstA, SShell *agnstB, SShell *into)
{
    SCurve sc = {};
    // Important to keep the order of (surfA, surfB) consistent; when we later
    // rewrite the identifiers, we rewrite surfA from A and surfB from B.
    sc.surfA = h;
    sc.surfB = srfB-&gt;h;
    sc.exact = *sb;
    sc.isExact = true;

    // Now we have to piecewise linearize the curve. If there's already an
    // identical curve in the shell, then follow that pwl exactly, otherwise
    // calculate from scratch.
    SCurve split, *existing = NULL, *se;
    SBezier sbrev = *sb;
    sbrev.Reverse();
    bool backwards = false;
    for(se = into-&gt;curve.First(); se; se = into-&gt;curve.NextAfter(se)) {
        if(se-&gt;isExact) {
            if(sb-&gt;Equals(&amp;(se-&gt;exact))) {
                existing = se;
                break;
            }
            if(sbrev.Equals(&amp;(se-&gt;exact))) {
                existing = se;
                backwards = true;
                break;
            }
        }
    }
    if(existing) {
        SCurvePt *v;
        for(v = existing-&gt;pts.First(); v; v = existing-&gt;pts.NextAfter(v)) {
            sc.pts.Add(v);
        }
        if(backwards) sc.pts.Reverse();
        split = sc;
        sc = {};
    } else {
        sb-&gt;MakePwlInto(&amp;(sc.pts));
        // and split the line where it intersects our existing surfaces
        split = sc.MakeCopySplitAgainst(agnstA, agnstB, this, srfB);
        sc.Clear();
    }

    // Test if the curve lies entirely outside one of the
    SCurvePt *scpt;
    bool withinA = false, withinB = false;
    for(scpt = split.pts.First(); scpt; scpt = split.pts.NextAfter(scpt)) {
        double tol = 0.01;
        Point2d puv;
        ClosestPointTo(scpt-&gt;p, &amp;puv);
        if(puv.x &gt; -tol &amp;&amp; puv.x &lt; 1 + tol &amp;&amp;
           puv.y &gt; -tol &amp;&amp; puv.y &lt; 1 + tol)
        {
            withinA = true;
        }
        srfB-&gt;ClosestPointTo(scpt-&gt;p, &amp;puv);
        if(puv.x &gt; -tol &amp;&amp; puv.x &lt; 1 + tol &amp;&amp;
           puv.y &gt; -tol &amp;&amp; puv.y &lt; 1 + tol)
        {
            withinB = true;
        }
        // Break out early, no sense wasting time if we already have the answer.
        if(withinA &amp;&amp; withinB) break;
    }
    if(!(withinA &amp;&amp; withinB)) {
        // Intersection curve lies entirely outside one of the surfaces, so
        // it's fake.
        split.Clear();
        return;
    }

#if 0
    if(sb-&gt;deg == 2) {
        dbp(" ");
        SCurvePt *prev = NULL, *v;
        dbp("split.pts.n = %d", split.pts.n);
        for(v = split.pts.First(); v; v = split.pts.NextAfter(v)) {
            if(prev) {
                Vector e = (prev-&gt;p).Minus(v-&gt;p).WithMagnitude(0);
                SS.nakedEdges.AddEdge((prev-&gt;p).Plus(e), (v-&gt;p).Minus(e));
            }
            prev = v;
        }
    }
#endif // 0
    ssassert(!(sb-&gt;Start()).Equals(sb-&gt;Finish()),
             "Unexpected zero-length edge");

    split.source = SCurve::Source::INTERSECTION;
    into-&gt;curve.AddAndAssignId(&amp;split);
}

</t>
<t tx="leo.20191228122652.3">void SSurface::IntersectAgainst(SSurface *b, SShell *agnstA, SShell *agnstB,
                                SShell *into)
{
    Vector amax, amin, bmax, bmin;
    GetAxisAlignedBounding(&amp;amax, &amp;amin);
    b-&gt;GetAxisAlignedBounding(&amp;bmax, &amp;bmin);

    if(Vector::BoundingBoxesDisjoint(amax, amin, bmax, bmin)) {
        // They cannot possibly intersect, no curves to generate
        return;
    }

    Vector alongt, alongb;
    SBezier oft, ofb;
    @others
}

//-----------------------------------------------------------------------------
// Are two surfaces coincident, with the same (or with opposite) normals?
// Currently handles planes only.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122652.4">bool isExtdt = this-&gt;IsExtrusion(&amp;oft, &amp;alongt),
     isExtdb =    b-&gt;IsExtrusion(&amp;ofb, &amp;alongb);

if(degm == 1 &amp;&amp; degn == 1 &amp;&amp; b-&gt;degm == 1 &amp;&amp; b-&gt;degn == 1) {
    // Line-line intersection; it's a plane or nothing.
    Vector na = NormalAt(0, 0).WithMagnitude(1),
           nb = b-&gt;NormalAt(0, 0).WithMagnitude(1);
    double da = na.Dot(PointAt(0, 0)),
    int i;
    double tmax = VERY_POSITIVE, tmin = VERY_NEGATIVE;
    for(i = 0; i &lt; 2; i++) {
        SSurface *s = (i == 0) ? this : b;
        Vector tu, tv;
        s-&gt;TangentsAt(0, 0, &amp;tu, &amp;tv);

        double up, vp, ud, vd;
        s-&gt;ClosestPointTo(p, &amp;up, &amp;vp);
        ud = (dl.Dot(tu)) / tu.MagSquared();
        vd = (dl.Dot(tv)) / tv.MagSquared();

        // so u = up + t*ud
        //    v = vp + t*vd
        if(ud &gt; LENGTH_EPS) {
            tmin = max(tmin, -up/ud);
            tmax = min(tmax, (1 - up)/ud);
        } else if(ud &lt; -LENGTH_EPS) {
            tmax = min(tmax, -up/ud);
            tmin = max(tmin, (1 - up)/ud);
        } else {
            if(up &lt; -LENGTH_EPS || up &gt; 1 + LENGTH_EPS) {
                // u is constant, and outside [0, 1]
                tmax = VERY_NEGATIVE;
            }
        }
        if(vd &gt; LENGTH_EPS) {
            tmin = max(tmin, -vp/vd);
            tmax = min(tmax, (1 - vp)/vd);
        } else if(vd &lt; -LENGTH_EPS) {
            tmax = min(tmax, -vp/vd);
            tmin = max(tmin, (1 - vp)/vd);
        } else {
            if(vp &lt; -LENGTH_EPS || vp &gt; 1 + LENGTH_EPS) {
                // v is constant, and outside [0, 1]
                tmax = VERY_NEGATIVE;
            }
        }
    }

    if(tmax &gt; tmin + LENGTH_EPS) {
        SBezier bezier = SBezier::From(p.Plus(dl.ScaledBy(tmin)),
                                       p.Plus(dl.ScaledBy(tmax)));
        AddExactIntersectionCurve(&amp;bezier, b, agnstA, agnstB, into);
    }
} else if((degm == 1 &amp;&amp; degn == 1 &amp;&amp; isExtdb) ||
          (b-&gt;degm == 1 &amp;&amp; b-&gt;degn == 1 &amp;&amp; isExtdt))
{
    // The intersection between a plane and a surface of extrusion
    SSurface *splane, *sext;
    if(degm == 1 &amp;&amp; degn == 1) {
        splane = this;
        sext = b;
    } else {
        splane = b;
        sext = this;
    }

    Vector n = splane-&gt;NormalAt(0, 0).WithMagnitude(1), along;
    double d = n.Dot(splane-&gt;PointAt(0, 0));
    SBezier bezier;
    (void)sext-&gt;IsExtrusion(&amp;bezier, &amp;along);

    if(fabs(n.Dot(along)) &lt; LENGTH_EPS) {
        // Direction of extrusion is parallel to plane; so intersection
        // is zero or more lines. Build a line within the plane, and
        // normal to the direction of extrusion, and intersect that line
        // against the surface; each intersection point corresponds to
        // a line.
        Vector pm, alu, p0, dp;
        // a point halfway along the extrusion
        pm = ((sext-&gt;ctrl[0][0]).Plus(sext-&gt;ctrl[0][1])).ScaledBy(0.5);
        alu = along.WithMagnitude(1);
        dp = (n.Cross(along)).WithMagnitude(1);
        // n, alu, and dp form an orthogonal csys; set n component to
        // place it on the plane, alu component to lie halfway along
        // extrusion, and dp component doesn't matter so zero
        p0 = n.ScaledBy(d).Plus(alu.ScaledBy(pm.Dot(alu)));

        List&lt;SInter&gt; inters = {};
        sext-&gt;AllPointsIntersecting(p0, p0.Plus(dp), &amp;inters,
            /*asSegment=*/false, /*trimmed=*/false, /*inclTangent=*/true);

        SInter *si;
        for(si = inters.First(); si; si = inters.NextAfter(si)) {
            Vector al = along.ScaledBy(0.5);
            SBezier bezier;
            bezier = SBezier::From((si-&gt;p).Minus(al), (si-&gt;p).Plus(al));
            AddExactIntersectionCurve(&amp;bezier, b, agnstA, agnstB, into);
        }

        inters.Clear();
    } else {
        // Direction of extrusion is not parallel to plane; so
        // intersection is projection of extruded curve into our plane.
        int i;
        for(i = 0; i &lt;= bezier.deg; i++) {
            Vector p0 = bezier.ctrl[i],
                   p1 = p0.Plus(along);

            bezier.ctrl[i] =
                Vector::AtIntersectionOfPlaneAndLine(n, d, p0, p1, NULL);
        }

        AddExactIntersectionCurve(&amp;bezier, b, agnstA, agnstB, into);
    }
} else if(isExtdt &amp;&amp; isExtdb &amp;&amp;
            sqrt(fabs(alongt.Dot(alongb))) &gt;
            sqrt(alongt.Magnitude() * alongb.Magnitude()) - LENGTH_EPS)
{
    // Two surfaces of extrusion along the same axis. So they might
    // intersect along some number of lines parallel to the axis.
    Vector axis = alongt.WithMagnitude(1);

    List&lt;SInter&gt; inters = {};
    List&lt;Vector&gt; lv = {};

    double a_axis0 = (   ctrl[0][0]).Dot(axis),
    if(fabs(ab_axis0 - ab_axis1) &lt; LENGTH_EPS) {
        // The line would be zero-length
        return;
    }

    Vector axis0 = axis.ScaledBy(ab_axis0),
           axis1 = axis.ScaledBy(ab_axis1),
           axisc = (axis0.Plus(axis1)).ScaledBy(0.5);

    oft.MakePwlInto(&amp;lv);

    int i;
    for(i = 0; i &lt; lv.n - 1; i++) {
        Vector pa = lv[i], pb = lv[i+1];
        pa = pa.Minus(axis.ScaledBy(pa.Dot(axis)));
        pb = pb.Minus(axis.ScaledBy(pb.Dot(axis)));
        pa = pa.Plus(axisc);
        pb = pb.Plus(axisc);

        b-&gt;AllPointsIntersecting(pa, pb, &amp;inters,
            /*asSegment=*/true,/*trimmed=*/false, /*inclTangent=*/false);
    }

    SInter *si;
    for(si = inters.First(); si; si = inters.NextAfter(si)) {
        Vector p = (si-&gt;p).Minus(axis.ScaledBy((si-&gt;p).Dot(axis)));
        double ub, vb;
        b-&gt;ClosestPointTo(p, &amp;ub, &amp;vb, /*mustConverge=*/true);
        SSurface plane;
        plane = SSurface::FromPlane(p, axis.Normal(0), axis.Normal(1));

        b-&gt;PointOnSurfaces(this, &amp;plane, &amp;ub, &amp;vb);

        p = b-&gt;PointAt(ub, vb);

        SBezier bezier;
        bezier = SBezier::From(p.Plus(axis0), p.Plus(axis1));
        AddExactIntersectionCurve(&amp;bezier, b, agnstA, agnstB, into);
    }

    inters.Clear();
    lv.Clear();
} else {
    // Try intersecting the surfaces numerically, by a marching algorithm.
    // First, we find all the intersections between a surface and the
    // boundary of the other surface.
    SPointList spl = {};
    int a;
    for(a = 0; a &lt; 2; a++) {
        SShell   *shA  = (a == 0) ? agnstA : agnstB;
        SSurface *srfA = (a == 0) ? this : b,
                 *srfB = (a == 0) ? b : this;

        SEdgeList el = {};
        srfA-&gt;MakeEdgesInto(shA, &amp;el, MakeAs::XYZ, NULL);

        SEdge *se;
        for(se = el.l.First(); se; se = el.l.NextAfter(se)) {
            List&lt;SInter&gt; lsi = {};

            srfB-&gt;AllPointsIntersecting(se-&gt;a, se-&gt;b, &amp;lsi,
                /*asSegment=*/true, /*trimmed=*/true, /*inclTangent=*/false);
            if(lsi.IsEmpty())
                continue;

            // Find the other surface that this curve trims.
            hSCurve hsc = { (uint32_t)se-&gt;auxA };
            SCurve *sc = shA-&gt;curve.FindById(hsc);
            hSSurface hother = (sc-&gt;surfA == srfA-&gt;h) ?
                                                sc-&gt;surfB : sc-&gt;surfA;
            SSurface *other = shA-&gt;surface.FindById(hother);

            SInter *si;
            for(si = lsi.First(); si; si = lsi.NextAfter(si)) {
                Vector p = si-&gt;p;
                double u, v;
                srfB-&gt;ClosestPointTo(p, &amp;u, &amp;v);
                srfB-&gt;PointOnSurfaces(srfA, other, &amp;u, &amp;v);
                p = srfB-&gt;PointAt(u, v);
                if(!spl.ContainsPoint(p)) {
                    SPoint sp;
                    sp.p = p;
                    // We also need the edge normal, so that we know in
                    // which direction to march.
                    srfA-&gt;ClosestPointTo(p, &amp;u, &amp;v);
                    Vector n = srfA-&gt;NormalAt(u, v);
                    sp.auxv = n.Cross((se-&gt;b).Minus(se-&gt;a));
                    sp.auxv = (sp.auxv).WithMagnitude(1);

                    spl.l.Add(&amp;sp);
                }
            }
            lsi.Clear();
        }

        el.Clear();
    }

    while(spl.l.n &gt;= 2) {
        SCurve sc = {};
        sc.surfA = h;
        sc.surfB = b-&gt;h;
        sc.isExact = false;
        sc.source = SCurve::Source::INTERSECTION;

        Vector start  = spl.l[0].p,
               startv = spl.l[0].auxv;
        spl.l.ClearTags();
        spl.l[0].tag = 1;
        spl.l.RemoveTagged();

        // Our chord tolerance is whatever the user specified
        double maxtol = SS.ChordTolMm();
        int maxsteps = max(300, SS.GetMaxSegments()*3);

        // The curve starts at our starting point.
        SCurvePt padd = {};
        padd.vertex = true;
        padd.p = start;
        sc.pts.Add(&amp;padd);

        Point2d pa, pb;
        Vector np, npc = Vector::From(0, 0, 0);
        bool fwd = false;
        // Better to start with a too-small step, so that we don't miss
        // features of the curve entirely.
        double tol, step = maxtol;
        for(a = 0; a &lt; maxsteps; a++) {
            ClosestPointTo(start, &amp;pa);
            b-&gt;ClosestPointTo(start, &amp;pb);

            Vector na =    NormalAt(pa).WithMagnitude(1),
                   nb = b-&gt;NormalAt(pb).WithMagnitude(1);

            if(a == 0) {
                Vector dp = nb.Cross(na);
                if(dp.Dot(startv) &lt; 0) {
                    // We want to march in the more inward direction.
                    fwd = true;
                } else {
                    fwd = false;
                }
            }

            int i;
            for(i = 0; i &lt; 20; i++) {
                Vector dp = nb.Cross(na);
                if(!fwd) dp = dp.ScaledBy(-1);
                dp = dp.WithMagnitude(step);

                np = start.Plus(dp);
                npc = ClosestPointOnThisAndSurface(b, np);
                tol = (npc.Minus(np)).Magnitude();

                if(tol &gt; maxtol*0.8) {
                    step *= 0.90;
                } else {
                    step /= 0.90;
                }

                if((tol &lt; maxtol) &amp;&amp; (tol &gt; maxtol/2)) {
                    // If we meet the chord tolerance test, and we're
                    // not too fine, then we break out.
                    break;
                }
            }

            SPoint *sp;
            for(sp = spl.l.First(); sp; sp = spl.l.NextAfter(sp)) {
                if((sp-&gt;p).OnLineSegment(start, npc, 2*SS.ChordTolMm())) {
                    sp-&gt;tag = 1;
                    a = maxsteps;
                    npc = sp-&gt;p;
                }
            }

            padd.p = npc;
            padd.vertex = (a == maxsteps);
            sc.pts.Add(&amp;padd);

            start = npc;
        }

        spl.l.RemoveTagged();

        // And now we split and insert the curve
        SCurve split = sc.MakeCopySplitAgainst(agnstA, agnstB, this, b);
        sc.Clear();
        into-&gt;curve.AddAndAssignId(&amp;split);
    }
    spl.Clear();
}
</t>
<t tx="leo.20191228122652.5">bool SSurface::CoincidentWith(SSurface *ss, bool sameNormal) const {
    if(degm != 1 || degn != 1) return false;
    if(ss-&gt;degm != 1 || ss-&gt;degn != 1) return false;

    Vector p = ctrl[0][0];
    Vector n = NormalAt(0, 0).WithMagnitude(1);
    double d = n.Dot(p);

    if(!ss-&gt;CoincidentWithPlane(n, d)) return false;

    Vector n2 = ss-&gt;NormalAt(0, 0);
    if(sameNormal) {
        if(n2.Dot(n) &lt; 0) return false;
    } else {
        if(n2.Dot(n) &gt; 0) return false;
    }

    return true;
}

</t>
<t tx="leo.20191228122652.6">bool SSurface::CoincidentWithPlane(Vector n, double d) const {
    if(degm != 1 || degn != 1) return false;
    if(fabs(n.Dot(ctrl[0][0]) - d) &gt; LENGTH_EPS) return false;
    if(fabs(n.Dot(ctrl[0][1]) - d) &gt; LENGTH_EPS) return false;
    if(fabs(n.Dot(ctrl[1][0]) - d) &gt; LENGTH_EPS) return false;
    if(fabs(n.Dot(ctrl[1][1]) - d) &gt; LENGTH_EPS) return false;

    return true;
}

//-----------------------------------------------------------------------------
// In our shell, find all surfaces that are coincident with the prototype
// surface (with same or opposite normal, as specified), and copy all of
// their trim polygons into el. The edges are returned in uv coordinates for
// the prototype surface.
//-----------------------------------------------------------------------------
</t>
<t tx="leo.20191228122652.7">void SShell::MakeCoincidentEdgesInto(SSurface *proto, bool sameNormal,
                                     SEdgeList *el, SShell *useCurvesFrom)
{
    SSurface *ss;
    for(ss = surface.First(); ss; ss = surface.NextAfter(ss)) {
        if(proto-&gt;CoincidentWith(ss, sameNormal)) {
            ss-&gt;MakeEdgesInto(this, el, SSurface::MakeAs::XYZ, useCurvesFrom);
        }
    }

    SEdge *se;
    for(se = el-&gt;l.First(); se; se = el-&gt;l.NextAfter(se)) {
        double ua, va, ub, vb;
        proto-&gt;ClosestPointTo(se-&gt;a, &amp;ua, &amp;va);
        proto-&gt;ClosestPointTo(se-&gt;b, &amp;ub, &amp;vb);

        if(sameNormal) {
            se-&gt;a = Vector::From(ua, va, 0);
            se-&gt;b = Vector::From(ub, vb, 0);
        } else {
            // Flip normal, so flip all edge directions
            se-&gt;b = Vector::From(ua, va, 0);
            se-&gt;a = Vector::From(ub, vb, 0);
        }
    }
}

</t>
<t tx="leo.20191228122652.8">@path ./src/srf/
//-----------------------------------------------------------------------------
// Triangulate a surface. If the surface is curved, then we first superimpose
// a grid of quads, with spacing to achieve our chord tolerance. We then
// proceed by ear-clipping; the resulting mesh should be watertight and not
// awful numerically, but has no special properties (Delaunay, etc.).
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#include "../solvespace.h"

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20191228122652.9">void SPolygon::UvTriangulateInto(SMesh *m, SSurface *srf) {
    if(l.n &lt;= 0) return;

    //int64_t in = GetMilliseconds();

    normal = Vector::From(0, 0, 1);

    while(l.n &gt; 0) {
        FixContourDirections();
        l.ClearTags();

        // Find a top-level contour, and start with that. Then build bridges
        // in order to merge all its islands into a single contour.
        SContour *top;
        for(top = l.First(); top; top = l.NextAfter(top)) {
            if(top-&gt;timesEnclosed == 0) {
                break;
            }
        }
        if(!top) {
            dbp("polygon has no top-level contours?");
            return;
        }

        // Start with the outer contour
        SContour merged = {};
        top-&gt;tag = 1;
        top-&gt;CopyInto(&amp;merged);
        merged.l.RemoveLast(1);

        // List all of the edges, for testing whether bridges work.
        SEdgeList el = {};
        top-&gt;MakeEdgesInto(&amp;el);
        List&lt;Vector&gt; vl = {};

        // And now find all of its holes. Note that we will also find any
        // outer contours that lie entirely within this contour, and any
        // holes for those contours. But that's okay, because we can merge
        // those too.
        SContour *sc;
        for(sc = l.First(); sc; sc = l.NextAfter(sc)) {
            if(sc-&gt;timesEnclosed != 1) continue;
            if(sc-&gt;l.n &lt; 2) continue;

            // Test the midpoint of an edge. Our polygon may not be self-
            // intersecting, but two contours may share a vertex; so a
            // vertex could be on the edge of another polygon, in which
            // case ContainsPointProjdToNormal returns indeterminate.
            Vector tp = sc-&gt;AnyEdgeMidpoint();
            if(top-&gt;ContainsPointProjdToNormal(normal, tp)) {
                sc-&gt;tag = 2;
                sc-&gt;MakeEdgesInto(&amp;el);
                sc-&gt;FindPointWithMinX();
            }
        }

//        dbp("finished finding holes: %d ms", (int)(GetMilliseconds() - in));
        for(;;) {
            double xmin = 1e10;
            SContour *scmin = NULL;

            for(sc = l.First(); sc; sc = l.NextAfter(sc)) {
                if(sc-&gt;tag != 2) continue;

                if(sc-&gt;xminPt.x &lt; xmin) {
                    xmin = sc-&gt;xminPt.x;
                    scmin = sc;
                }
            }
            if(!scmin) break;

            if(!merged.BridgeToContour(scmin, &amp;el, &amp;vl)) {
                dbp("couldn't merge our hole");
                return;
            }
//            dbp("   bridged to contour: %d ms", (int)(GetMilliseconds() - in));
            scmin-&gt;tag = 3;
        }
//        dbp("finished merging holes: %d ms", (int)(GetMilliseconds() - in));

        merged.UvTriangulateInto(m, srf);
//        dbp("finished ear clippping: %d ms", (int)(GetMilliseconds() - in));
        merged.l.Clear();
        el.Clear();
        vl.Clear();

        // Careful, need to free the points within the contours, and not just
        // the contours themselves. This was a tricky memory leak.
        for(sc = l.First(); sc; sc = l.NextAfter(sc)) {
            if(sc-&gt;tag) {
                sc-&gt;l.Clear();
            }
        }
        l.RemoveTagged();
    }
}

</t>
</tnodes>
</leo_file>
